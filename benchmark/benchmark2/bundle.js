(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";
exports.__esModule = true;
var Map_1 = require("../DataTypes/Map");
/**
 * A manager class for all of the AI in a scene.
 * Keeps a list of registered actors and handles AI generation for actors.
 */
var AIManager = /** @class */ (function () {
    function AIManager() {
        this.actors = new Array();
        this.registeredAI = new Map_1["default"]();
    }
    /**
     * Registers an actor with the AIManager
     * @param actor The actor to register
     */
    AIManager.prototype.registerActor = function (actor) {
        this.actors.push(actor);
    };
    AIManager.prototype.removeActor = function (actor) {
        var index = this.actors.indexOf(actor);
        if (index !== -1) {
            this.actors.splice(index, 1);
        }
    };
    /**
     * Registers an AI with the AIManager for use later on
     * @param name The name of the AI to register
     * @param constr The constructor for the AI
     */
    AIManager.prototype.registerAI = function (name, constr) {
        this.registeredAI.add(name, constr);
    };
    /**
     * Generates an AI instance from its name
     * @param name The name of the AI to add
     * @returns A new AI instance
     */
    AIManager.prototype.generateAI = function (name) {
        if (this.registeredAI.has(name)) {
            return new (this.registeredAI.get(name))();
        }
        else {
            throw "Cannot create AI with name ".concat(name, ", no AI with that name is registered");
        }
    };
    AIManager.prototype.update = function (deltaT) {
        // Run the ai for every active actor
        this.actors.forEach(function (actor) { if (actor.aiActive)
            actor.ai.update(deltaT); });
    };
    return AIManager;
}());
exports["default"] = AIManager;
},{"../DataTypes/Map":8}],2:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
exports.__esModule = true;
var StateMachine_1 = require("../DataTypes/State/StateMachine");
/**
 * A version of a @reference[StateMachine] that is configured to work as an AI controller for a @reference[GameNode]
 */
var StateMachineAI = /** @class */ (function (_super) {
    __extends(StateMachineAI, _super);
    function StateMachineAI() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    // @implemented
    StateMachineAI.prototype.initializeAI = function (owner, config) { };
    // @implemented
    StateMachineAI.prototype.destroy = function () {
        // Get rid of our reference to the owner
        delete this.owner;
        this.receiver.destroy();
    };
    // @implemented
    StateMachineAI.prototype.activate = function (options) { };
    return StateMachineAI;
}(StateMachine_1["default"]));
exports["default"] = StateMachineAI;
},{"../DataTypes/State/StateMachine":18}],3:[function(require,module,exports){
"use strict";
// @ignorePage
exports.__esModule = true;
/**
 * A placeholder function for No Operation. Does nothing
 */
var NullFunc = function () { };
exports["default"] = NullFunc;
},{}],4:[function(require,module,exports){
"use strict";
exports.__esModule = true;
/**
 * A linked-list for the edges in a @reference[Graph].
 */
var EdgeNode = /** @class */ (function () {
    /**
     * Creates a new EdgeNode
     * @param index The index of the node this edge connects to
     * @param weight The weight of this edge
     */
    function EdgeNode(index, weight) {
        this.y = index;
        this.next = null;
        this.weight = weight ? weight : 1;
    }
    return EdgeNode;
}());
exports["default"] = EdgeNode;
},{}],5:[function(require,module,exports){
"use strict";
exports.__esModule = true;
exports.MAX_V = void 0;
var EdgeNode_1 = require("./EdgeNode");
exports.MAX_V = 100;
/**
 * An implementation of a graph data structure using edge lists. Inspired by The Algorithm Design Manual.
 */
var Graph = /** @class */ (function () {
    /**
     * Constructs a new graph
     * @param directed Whether or not this graph is directed
     */
    function Graph(directed) {
        if (directed === void 0) { directed = false; }
        this.directed = directed;
        this.weighted = false;
        this.numVertices = 0;
        this.numEdges = 0;
        this.edges = new Array(exports.MAX_V);
        this.degree = new Array(exports.MAX_V);
    }
    /** Adds a node to this graph and returns the index of it
     * @returns The index of the new node
    */
    Graph.prototype.addNode = function () {
        this.numVertices++;
        return this.numVertices;
    };
    /** Adds an edge between node x and y, with an optional weight
     * @param x The index of the start of the edge
     * @param y The index of the end of the edge
     * @param weight The optional weight of the new edge
    */
    Graph.prototype.addEdge = function (x, y, weight) {
        var edge = new EdgeNode_1["default"](y, weight);
        if (this.edges[x]) {
            edge.next = this.edges[x];
        }
        this.edges[x] = edge;
        if (!this.directed) {
            edge = new EdgeNode_1["default"](x, weight);
            if (this.edges[y]) {
                edge.next = this.edges[y];
            }
            this.edges[y] = edge;
        }
        this.numEdges += 1;
    };
    /**
     * Checks whether or not an edge exists between two nodes.
     * This check is directional if this is a directed graph.
     * @param x The first node
     * @param y The second node
     * @returns true if an edge exists, false otherwise
     */
    Graph.prototype.edgeExists = function (x, y) {
        var edge = this.edges[x];
        while (edge !== null) {
            if (edge.y === y) {
                return true;
            }
            edge = edge.next;
        }
    };
    /**
     * Gets the edge list associated with node x
     * @param x The index of the node
     * @returns The head of a linked-list of edges
     */
    Graph.prototype.getEdges = function (x) {
        return this.edges[x];
    };
    /**
     * Gets the degree associated with node x
     * @param x The index of the node
     */
    Graph.prototype.getDegree = function (x) {
        return this.degree[x];
    };
    /**
     * Converts the specifed node into a string
     * @param index The index of the node to convert to a string
     * @returns The string representation of the node: "Node x"
     */
    Graph.prototype.nodeToString = function (index) {
        return "Node " + index;
    };
    /**
     * Converts the Graph into a string format
     * @returns The graph as a string
     */
    Graph.prototype.toString = function () {
        var retval = "";
        for (var i = 0; i < this.numVertices; i++) {
            var edge = this.edges[i];
            var edgeStr = "";
            while (edge !== undefined && edge !== null) {
                edgeStr += edge.y.toString();
                if (this.weighted) {
                    edgeStr += " (" + edge.weight + ")";
                }
                if (edge.next !== null) {
                    edgeStr += ", ";
                }
                edge = edge.next;
            }
            retval += this.nodeToString(i) + ": " + edgeStr + "\n";
        }
        return retval;
    };
    return Graph;
}());
exports["default"] = Graph;
},{"./EdgeNode":4}],6:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
exports.__esModule = true;
var Graph_1 = require("./Graph");
/**
 * An extension of Graph that has nodes with positions in 2D space.
 * This is a weighted graph (though not inherently directd)
*/
var PositionGraph = /** @class */ (function (_super) {
    __extends(PositionGraph, _super);
    /**
     * Createes a new PositionGraph
     * @param directed Whether or not this graph is directed
     */
    function PositionGraph(directed) {
        if (directed === void 0) { directed = false; }
        var _this = _super.call(this, directed) || this;
        _this.debugRender = function () {
            // for(let point of this.positions){
            // 	ctx.fillRect((point.x - origin.x - 4)*zoom, (point.y - origin.y - 4)*zoom, 8, 8);
            // }
        };
        _this.positions = new Array(Graph_1.MAX_V);
        return _this;
    }
    /**
     * Adds a positioned node to this graph
     * @param position The position of the node to add
     * @returns The index of the added node
     */
    PositionGraph.prototype.addPositionedNode = function (position) {
        this.positions[this.numVertices] = position;
        return this.addNode();
    };
    /**
     * Changes the position of a node.
     * Automatically adjusts the weights of the graph tied to this node.
     * As such, be warned that this function has an O(n + m) running time, and use it sparingly.
     * @param index The index of the node
     * @param position The new position of the node
     */
    PositionGraph.prototype.setNodePosition = function (index, position) {
        this.positions[index] = position;
        // Recalculate all weights associated with this index
        for (var i = 0; i < this.numEdges; i++) {
            var edge = this.edges[i];
            while (edge !== null) {
                // If this node is on either side of the edge, recalculate weight
                if (i === index || edge.y === index) {
                    edge.weight = this.positions[i].distanceTo(this.positions[edge.y]);
                }
                edge = edge.next;
            }
        }
    };
    /**
     * Gets the position of a node
     * @param index The index of the node
     * @returns The position of the node
     */
    PositionGraph.prototype.getNodePosition = function (index) {
        return this.positions[index];
    };
    /**
     * Adds an edge to this graph between node x and y.
     * Automatically calculates the weight of the edge as the distance between the nodes.
     * @param x The beginning of the edge
     * @param y The end of the edge
     */
    PositionGraph.prototype.addEdge = function (x, y) {
        if (!this.positions[x] || !this.positions[y]) {
            throw "Can't add edge to un-positioned node!";
        }
        // Weight is the distance between the nodes
        var weight = this.positions[x].distanceTo(this.positions[y]);
        _super.prototype.addEdge.call(this, x, y, weight);
    };
    // @override
    PositionGraph.prototype.nodeToString = function (index) {
        return "Node " + index + " - " + this.positions[index].toString();
    };
    return PositionGraph;
}(Graph_1["default"]));
exports["default"] = PositionGraph;
},{"./Graph":5}],7:[function(require,module,exports){
"use strict";
exports.__esModule = true;
exports.isRegion = void 0;
function isRegion(arg) {
    return arg && arg.size && arg.scale && arg.boundary;
}
exports.isRegion = isRegion;
},{}],8:[function(require,module,exports){
"use strict";
exports.__esModule = true;
/**
 * Associates strings with elements of type T
 */
var Map = /** @class */ (function () {
    /** Creates a new map */
    function Map() {
        this.map = {};
    }
    /**
     * Adds a value T stored at a key.
     * @param key The key of the item to be stored
     * @param value The item to be stored
     */
    Map.prototype.add = function (key, value) {
        this.map[key] = value;
    };
    /**
     * Get the value associated with a key.
     * @param key The key of the item
     * @returns The item at the key or undefined
     */
    Map.prototype.get = function (key) {
        return this.map[key];
    };
    /**
     * An alias of add. Sets the value stored at key to the new specified value
     * @param key The key of the item to be stored
     * @param value The item to be stored
     */
    Map.prototype.set = function (key, value) {
        this.add(key, value);
    };
    /**
     * Returns true if there is a value stored at the specified key, false otherwise.
     * @param key The key to check
     * @returns A boolean representing whether or not there is an item at the given key.
     */
    Map.prototype.has = function (key) {
        return this.map[key] !== undefined;
    };
    /**
     * Returns an array of all of the keys in this map.
     * @returns An array containing all keys in the map.
     */
    Map.prototype.keys = function () {
        return Object.keys(this.map);
    };
    // @implemented
    Map.prototype.forEach = function (func) {
        Object.keys(this.map).forEach(function (key) { return func(key); });
    };
    /**
     * Deletes an item associated with a key
     * @param key The key at which to delete an item
     */
    Map.prototype["delete"] = function (key) {
        delete this.map[key];
    };
    // @implemented
    Map.prototype.clear = function () {
        var _this = this;
        this.forEach(function (key) { return delete _this.map[key]; });
    };
    /**
     * Converts this map to a string representation.
     * @returns The string representation of this map.
     */
    Map.prototype.toString = function () {
        var _this = this;
        var str = "";
        this.forEach(function (key) { return str += key + " -> " + _this.get(key).toString() + "\n"; });
        return str;
    };
    return Map;
}());
exports["default"] = Map;
},{}],9:[function(require,module,exports){
"use strict";
exports.__esModule = true;
var Vec2_1 = require("./Vec2");
/** A 4x4 matrix0 */
var Mat4x4 = /** @class */ (function () {
    function Mat4x4() {
        this.mat = new Float32Array([
            0, 0, 0, 0,
            0, 0, 0, 0,
            0, 0, 0, 0,
            0, 0, 0, 0
        ]);
    }
    Object.defineProperty(Mat4x4, "IDENTITY", {
        // Static members
        get: function () {
            return new Mat4x4().identity();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Mat4x4, "ZERO", {
        get: function () {
            return new Mat4x4().zero();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Mat4x4.prototype, "_00", {
        // Accessors
        set: function (x) {
            this.mat[0] = x;
        },
        enumerable: false,
        configurable: true
    });
    Mat4x4.prototype.set = function (col, row, value) {
        if (col < 0 || col > 3 || row < 0 || row > 3) {
            throw "Error - index (".concat(col, ", ").concat(row, ") is out of bounds for Mat4x4");
        }
        this.mat[row * 4 + col] = value;
        return this;
    };
    Mat4x4.prototype.get = function (col, row) {
        return this.mat[row * 4 + col];
    };
    Mat4x4.prototype.setAll = function () {
        var items = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            items[_i] = arguments[_i];
        }
        this.mat.set(items);
        return this;
    };
    Mat4x4.prototype.identity = function () {
        return this.setAll(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    };
    Mat4x4.prototype.zero = function () {
        return this.setAll(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    };
    /**
     * Makes this Mat4x4 a rotation matrix of the specified number of radians ccw
     * @param zRadians The number of radians to rotate
     * @returns this Mat4x4
     */
    Mat4x4.prototype.rotate = function (zRadians) {
        return this.setAll(Math.cos(zRadians), -Math.sin(zRadians), 0, 0, Math.sin(zRadians), Math.cos(zRadians), 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    };
    /**
     * Turns this Mat4x4 into a translation matrix of the specified translation
     * @param translation The translation in x and y
     * @returns this Mat4x4
     */
    Mat4x4.prototype.translate = function (translation) {
        // If translation is a vec, get its array
        if (translation instanceof Vec2_1["default"]) {
            translation = translation.toArray();
        }
        return this.setAll(1, 0, 0, translation[0], 0, 1, 0, translation[1], 0, 0, 1, 0, 0, 0, 0, 1);
    };
    Mat4x4.prototype.scale = function (scale) {
        // Make sure scale is a float32Array
        if (scale instanceof Vec2_1["default"]) {
            scale = scale.toArray();
        }
        else if (!(scale instanceof Float32Array)) {
            scale = new Float32Array([scale, scale]);
        }
        return this.setAll(scale[0], 0, 0, 0, 0, scale[1], 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    };
    /**
     * Returns a new Mat4x4 that represents the right side multiplication THIS x OTHER
     * @param other The other Mat4x4 to multiply by
     * @returns a new Mat4x4 containing the product of these two Mat4x4s
     */
    Mat4x4.prototype.mult = function (other, out) {
        var _a;
        var temp = new Float32Array(16);
        for (var i = 0; i < 4; i++) {
            for (var j = 0; j < 4; j++) {
                var value = 0;
                for (var k = 0; k < 4; k++) {
                    value += this.get(k, i) * other.get(j, k);
                }
                temp[j * 4 + i] = value;
            }
        }
        if (out !== undefined) {
            return out.setAll.apply(out, temp);
        }
        else {
            return (_a = new Mat4x4()).setAll.apply(_a, temp);
        }
    };
    /**
     * Multiplies all given matricies in order. e.g. MULT(A, B, C) -> A*B*C
     * @param mats A list of Mat4x4s to multiply in order
     * @returns A new Mat4x4 holding the result of the operation
     */
    Mat4x4.MULT = function () {
        var mats = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            mats[_i] = arguments[_i];
        }
        // Create a new array
        var temp = Mat4x4.IDENTITY;
        // Multiply by every array in order, in place
        for (var i = 0; i < mats.length; i++) {
            temp.mult(mats[i], temp);
        }
        return temp;
    };
    Mat4x4.prototype.toArray = function () {
        return this.mat;
    };
    Mat4x4.prototype.toString = function () {
        return "|".concat(this.mat[0].toFixed(2), ", ").concat(this.mat[1].toFixed(2), ", ").concat(this.mat[2].toFixed(2), ", ").concat(this.mat[3].toFixed(2), "|\n") +
            "|".concat(this.mat[4].toFixed(2), ", ").concat(this.mat[5].toFixed(2), ", ").concat(this.mat[6].toFixed(2), ", ").concat(this.mat[7].toFixed(2), "|\n") +
            "|".concat(this.mat[8].toFixed(2), ", ").concat(this.mat[9].toFixed(2), ", ").concat(this.mat[10].toFixed(2), ", ").concat(this.mat[11].toFixed(2), "|\n") +
            "|".concat(this.mat[12].toFixed(2), ", ").concat(this.mat[13].toFixed(2), ", ").concat(this.mat[14].toFixed(2), ", ").concat(this.mat[15].toFixed(2), "|");
    };
    return Mat4x4;
}());
exports["default"] = Mat4x4;
},{"./Vec2":20}],10:[function(require,module,exports){
"use strict";
exports.__esModule = true;
/**
 * A class that contains the area of overlap of two colliding objects to allow for sorting by the physics system.
 */
var AreaCollision = /** @class */ (function () {
    /**
     * Creates a new AreaCollision object
     * @param area The area of the collision
     * @param collider The other collider
     */
    function AreaCollision(area, collider, other, type, tile) {
        this.area = area;
        this.collider = collider;
        this.other = other;
        this.type = type;
        this.tile = tile;
    }
    return AreaCollision;
}());
exports["default"] = AreaCollision;
},{}],11:[function(require,module,exports){
"use strict";
exports.__esModule = true;
var Vec2_1 = require("../Vec2");
/**
 * An object representing the data collected from a physics hit between two geometric objects.
 * Inspired by the helpful collision documentation @link(here)(https://noonat.github.io/intersect/).
 */
var Hit = /** @class */ (function () {
    function Hit() {
        /** The near times of the collision */
        this.nearTimes = Vec2_1["default"].ZERO;
        /** The position of the collision */
        this.pos = Vec2_1["default"].ZERO;
        /** The overlap distance of the hit */
        this.delta = Vec2_1["default"].ZERO;
        /** The normal vector of the hit */
        this.normal = Vec2_1["default"].ZERO;
    }
    return Hit;
}());
exports["default"] = Hit;
},{"../Vec2":20}],12:[function(require,module,exports){
"use strict";
exports.__esModule = true;
/**
 * A FIFO queue with elements of type T
 */
var Queue = /** @class */ (function () {
    /**
     * Constructs a new queue
     * @param maxElements The maximum size of the stack
     */
    function Queue(maxElements) {
        if (maxElements === void 0) { maxElements = 100; }
        this.MAX_ELEMENTS = maxElements;
        this.q = new Array(this.MAX_ELEMENTS);
        this.head = 0;
        this.tail = 0;
        this.size = 0;
    }
    /**
     * Adds an item to the back of the queue
     * @param item The item to add to the back of the queue
     */
    Queue.prototype.enqueue = function (item) {
        if ((this.tail + 1) % this.MAX_ELEMENTS === this.head) {
            throw new Error("Queue full - cannot add element");
        }
        this.size += 1;
        this.q[this.tail] = item;
        this.tail = (this.tail + 1) % this.MAX_ELEMENTS;
    };
    /**
     * Retrieves an item from the front of the queue
     * @returns The item at the front of the queue
     */
    Queue.prototype.dequeue = function () {
        if (this.head === this.tail) {
            throw new Error("Queue empty - cannot remove element");
        }
        this.size -= 1;
        var item = this.q[this.head];
        // Now delete the item
        delete this.q[this.head];
        this.head = (this.head + 1) % this.MAX_ELEMENTS;
        return item;
    };
    /**
     * Returns the item at the front of the queue, but does not remove it
     * @returns The item at the front of the queue
     */
    Queue.prototype.peekNext = function () {
        if (this.head === this.tail) {
            throw "Queue empty - cannot get element";
        }
        var item = this.q[this.head];
        return item;
    };
    /**
     * Returns true if the queue has items in it, false otherwise
     * @returns A boolean representing whether or not this queue has items
     */
    Queue.prototype.hasItems = function () {
        return this.head !== this.tail;
    };
    /**
     * Returns the number of elements in the queue.
     * @returns The size of the queue
     */
    Queue.prototype.getSize = function () {
        return this.size;
    };
    // @implemented
    Queue.prototype.clear = function () {
        var _this = this;
        this.forEach(function (item, index) { return delete _this.q[index]; });
        this.size = 0;
        this.head = this.tail;
    };
    // @implemented
    Queue.prototype.forEach = function (func) {
        var i = this.head;
        while (i !== this.tail) {
            func(this.q[i], i);
            i = (i + 1) % this.MAX_ELEMENTS;
        }
    };
    /**
     * Converts this queue into a string format
     * @returns A string representing this queue
     */
    Queue.prototype.toString = function () {
        var retval = "";
        this.forEach(function (item, index) {
            var str = item.toString();
            if (index !== 0) {
                str += " -> ";
            }
            retval = str + retval;
        });
        return "Top -> " + retval;
    };
    return Queue;
}());
exports["default"] = Queue;
},{}],13:[function(require,module,exports){
"use strict";
exports.__esModule = true;
/** A container for info about a webGL shader program */
var WebGLProgramType = /** @class */ (function () {
    function WebGLProgramType() {
    }
    /**
     * Deletes this shader program
     */
    WebGLProgramType.prototype["delete"] = function (gl) {
        // Clean up all aspects of this program
        if (this.program) {
            gl.deleteProgram(this.program);
        }
        if (this.vertexShader) {
            gl.deleteShader(this.vertexShader);
        }
        if (this.fragmentShader) {
            gl.deleteShader(this.fragmentShader);
        }
    };
    return WebGLProgramType;
}());
exports["default"] = WebGLProgramType;
},{}],14:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
exports.__esModule = true;
var Shape_1 = require("./Shape");
var Vec2_1 = require("../Vec2");
var MathUtils_1 = require("../../Utils/MathUtils");
var Circle_1 = require("./Circle");
var Hit_1 = require("../Physics/Hit");
/**
 * An Axis-Aligned Bounding Box. In other words, a rectangle that is always aligned to the x-y grid.
 * Inspired by the helpful collision documentation @link(here)(https://noonat.github.io/intersect/).
 */
var AABB = /** @class */ (function (_super) {
    __extends(AABB, _super);
    /**
     * Creates a new AABB
     * @param center The center of the AABB
     * @param halfSize The half size of the AABB - The distance from the center to an edge in x and y
     */
    function AABB(center, halfSize) {
        var _this = _super.call(this) || this;
        _this.center = center ? center : new Vec2_1["default"](0, 0);
        _this.halfSize = halfSize ? halfSize : new Vec2_1["default"](0, 0);
        return _this;
    }
    Object.defineProperty(AABB.prototype, "topLeft", {
        /** Returns a point representing the top left corner of the AABB */
        get: function () {
            return new Vec2_1["default"](this.left, this.top);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AABB.prototype, "topRight", {
        /** Returns a point representing the top right corner of the AABB */
        get: function () {
            return new Vec2_1["default"](this.right, this.top);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AABB.prototype, "bottomLeft", {
        /** Returns a point representing the bottom left corner of the AABB */
        get: function () {
            return new Vec2_1["default"](this.left, this.bottom);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AABB.prototype, "bottomRight", {
        /** Returns a point representing the bottom right corner of the AABB */
        get: function () {
            return new Vec2_1["default"](this.right, this.bottom);
        },
        enumerable: false,
        configurable: true
    });
    // @override
    AABB.prototype.getBoundingRect = function () {
        return this.clone();
    };
    // @override
    AABB.prototype.getBoundingCircle = function () {
        var r = Math.max(this.hw, this.hh);
        return new Circle_1["default"](this.center.clone(), r);
    };
    // @deprecated
    AABB.prototype.getHalfSize = function () {
        return this.halfSize;
    };
    // @deprecated
    AABB.prototype.setHalfSize = function (halfSize) {
        this.halfSize = halfSize;
    };
    // TODO - move these all to the Shape class
    /**
     * A simple boolean check of whether this AABB contains a point
     * @param point The point to check
     * @returns A boolean representing whether this AABB contains the specified point
     */
    AABB.prototype.containsPoint = function (point) {
        return point.x >= this.x - this.hw && point.x <= this.x + this.hw
            && point.y >= this.y - this.hh && point.y <= this.y + this.hh;
    };
    /**
     * A simple boolean check of whether this AABB contains a point
     * @param point The point to check
     * @returns A boolean representing whether this AABB contains the specified point
     */
    AABB.prototype.intersectPoint = function (point) {
        var dx = point.x - this.x;
        var px = this.hw - Math.abs(dx);
        if (px <= 0) {
            return false;
        }
        var dy = point.y - this.y;
        var py = this.hh - Math.abs(dy);
        if (py <= 0) {
            return false;
        }
        return true;
    };
    /**
     * A boolean check of whether this AABB contains a point with soft left and top boundaries.
     * In other words, if the top left is (0, 0), the point (0, 0) is not in the AABB
     * @param point The point to check
     * @returns A boolean representing whether this AABB contains the specified point
     */
    AABB.prototype.containsPointSoft = function (point) {
        return point.x > this.x - this.hw && point.x <= this.x + this.hw
            && point.y > this.y - this.hh && point.y <= this.y + this.hh;
    };
    /**
     * Returns the data from the intersection of this AABB with a line segment from a point in a direction
     * @param point The point that the line segment starts from
     * @param delta The direction and distance of the segment
     * @param padding Pads the AABB to make it wider for the intersection test
     * @returns The Hit object representing the intersection, or null if there was no intersection
     */
    AABB.prototype.intersectSegment = function (point, delta, padding) {
        var paddingX = padding ? padding.x : 0;
        var paddingY = padding ? padding.y : 0;
        var scaleX = 1 / delta.x;
        var scaleY = 1 / delta.y;
        var signX = MathUtils_1["default"].sign(scaleX);
        var signY = MathUtils_1["default"].sign(scaleY);
        var tnearx = scaleX * (this.x - signX * (this.hw + paddingX) - point.x);
        var tneary = scaleY * (this.y - signY * (this.hh + paddingY) - point.y);
        var tfarx = scaleX * (this.x + signX * (this.hw + paddingX) - point.x);
        var tfary = scaleY * (this.y + signY * (this.hh + paddingY) - point.y);
        if (tnearx > tfary || tneary > tfarx) {
            // We aren't colliding - we clear one axis before intersecting another
            return null;
        }
        var tnear = Math.max(tnearx, tneary);
        // Double check for NaNs
        if (tnearx !== tnearx) {
            tnear = tneary;
        }
        else if (tneary !== tneary) {
            tnear = tnearx;
        }
        var tfar = Math.min(tfarx, tfary);
        if (tnear === -Infinity) {
            return null;
        }
        if (tnear >= 1 || tfar <= 0) {
            return null;
        }
        // We are colliding
        var hit = new Hit_1["default"]();
        hit.time = MathUtils_1["default"].clamp01(tnear);
        hit.nearTimes.x = tnearx;
        hit.nearTimes.y = tneary;
        if (tnearx > tneary) {
            // We hit on the left or right size
            hit.normal.x = -signX;
            hit.normal.y = 0;
        }
        else if (Math.abs(tnearx - tneary) < 0.0001) {
            // We hit on the corner
            hit.normal.x = -signX;
            hit.normal.y = -signY;
            hit.normal.normalize();
        }
        else {
            // We hit on the top or bottom
            hit.normal.x = 0;
            hit.normal.y = -signY;
        }
        hit.delta.x = (1.0 - hit.time) * -delta.x;
        hit.delta.y = (1.0 - hit.time) * -delta.y;
        hit.pos.x = point.x + delta.x * hit.time;
        hit.pos.y = point.y + delta.y * hit.time;
        return hit;
    };
    // @override
    AABB.prototype.overlaps = function (other) {
        if (other instanceof AABB) {
            return this.overlapsAABB(other);
        }
        throw "Overlap not defined between these shapes.";
    };
    /**
     * A simple boolean check of whether this AABB overlaps another
     * @param other The other AABB to check against
     * @returns True if this AABB overlaps the other, false otherwise
     */
    AABB.prototype.overlapsAABB = function (other) {
        var dx = other.x - this.x;
        var px = this.hw + other.hw - Math.abs(dx);
        if (px <= 0) {
            return false;
        }
        var dy = other.y - this.y;
        var py = this.hh + other.hh - Math.abs(dy);
        if (py <= 0) {
            return false;
        }
        return true;
    };
    /**
     * Determines whether these AABBs are JUST touching - not overlapping.
     * Vec2.x is -1 if the other is to the left, 1 if to the right.
     * Likewise, Vec2.y is -1 if the other is on top, 1 if on bottom.
     * @param other The other AABB to check
     * @returns The collision sides stored in a Vec2 if the AABBs are touching, null otherwise
     */
    AABB.prototype.touchesAABB = function (other) {
        var dx = other.x - this.x;
        var px = this.hw + other.hw - Math.abs(dx);
        var dy = other.y - this.y;
        var py = this.hh + other.hh - Math.abs(dy);
        // If one axis is just touching and the other is overlapping, true
        if ((px === 0 && py >= 0) || (py === 0 && px >= 0)) {
            var ret = new Vec2_1["default"]();
            if (px === 0) {
                ret.x = other.x < this.x ? -1 : 1;
            }
            if (py === 0) {
                ret.y = other.y < this.y ? -1 : 1;
            }
            return ret;
        }
        else {
            return null;
        }
    };
    /**
     * Determines whether these AABBs are JUST touching - not overlapping.
     * Also, if they are only touching corners, they are considered not touching.
     * Vec2.x is -1 if the other is to the left, 1 if to the right.
     * Likewise, Vec2.y is -1 if the other is on top, 1 if on bottom.
     * @param other The other AABB to check
     * @returns The side of the touch, stored as a Vec2, or null if there is no touch
     */
    AABB.prototype.touchesAABBWithoutCorners = function (other) {
        var dx = other.x - this.x;
        var px = this.hw + other.hw - Math.abs(dx);
        var dy = other.y - this.y;
        var py = this.hh + other.hh - Math.abs(dy);
        // If one axis is touching, and the other is strictly overlapping
        if ((px === 0 && py > 0) || (py === 0 && px > 0)) {
            var ret = new Vec2_1["default"]();
            if (px === 0) {
                ret.x = other.x < this.x ? -1 : 1;
            }
            else {
                ret.y = other.y < this.y ? -1 : 1;
            }
            return ret;
        }
        else {
            return null;
        }
    };
    /**
     * Calculates the area of the overlap between this AABB and another
     * @param other The other AABB
     * @returns The area of the overlap between the AABBs
     */
    AABB.prototype.overlapArea = function (other) {
        var leftx = Math.max(this.x - this.hw, other.x - other.hw);
        var rightx = Math.min(this.x + this.hw, other.x + other.hw);
        var dx = rightx - leftx;
        var lefty = Math.max(this.y - this.hh, other.y - other.hh);
        var righty = Math.min(this.y + this.hh, other.y + other.hh);
        var dy = righty - lefty;
        if (dx < 0 || dy < 0)
            return 0;
        return dx * dy;
    };
    /**
     * Moves and resizes this rect from its current position to the position specified
     * @param velocity The movement of the rect from its position
     * @param fromPosition A position specified to be the starting point of sweeping
     * @param halfSize The halfSize of the sweeping rect
     */
    AABB.prototype.sweep = function (velocity, fromPosition, halfSize) {
        if (!fromPosition) {
            fromPosition = this.center;
        }
        if (!halfSize) {
            halfSize = this.halfSize;
        }
        var centerX = fromPosition.x + velocity.x / 2;
        var centerY = fromPosition.y + velocity.y / 2;
        var minX = Math.min(fromPosition.x - halfSize.x, fromPosition.x + velocity.x - halfSize.x);
        var minY = Math.min(fromPosition.y - halfSize.y, fromPosition.y + velocity.y - halfSize.y);
        this.center.set(centerX, centerY);
        this.halfSize.set(centerX - minX, centerY - minY);
    };
    // @override
    AABB.prototype.clone = function () {
        return new AABB(this.center.clone(), this.halfSize.clone());
    };
    /**
     * Converts this AABB to a string format
     * @returns (center: (x, y), halfSize: (x, y))
     */
    AABB.prototype.toString = function () {
        return "(center: " + this.center.toString() + ", half-size: " + this.halfSize.toString() + ")";
    };
    return AABB;
}(Shape_1["default"]));
exports["default"] = AABB;
},{"../../Utils/MathUtils":97,"../Physics/Hit":11,"../Vec2":20,"./Circle":15,"./Shape":16}],15:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
exports.__esModule = true;
var Vec2_1 = require("../Vec2");
var AABB_1 = require("./AABB");
var Shape_1 = require("./Shape");
/**
 * A Circle
 */
var Circle = /** @class */ (function (_super) {
    __extends(Circle, _super);
    /**
     * Creates a new Circle
     * @param center The center of the circle
     * @param radius The radius of the circle
     */
    function Circle(center, radius) {
        var _this = _super.call(this) || this;
        _this._center = center ? center : new Vec2_1["default"](0, 0);
        _this.radius = radius ? radius : 0;
        return _this;
    }
    Object.defineProperty(Circle.prototype, "center", {
        get: function () {
            return this._center;
        },
        set: function (center) {
            this._center = center;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Circle.prototype, "halfSize", {
        get: function () {
            return new Vec2_1["default"](this.radius, this.radius);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Circle.prototype, "r", {
        get: function () {
            return this.radius;
        },
        set: function (radius) {
            this.radius = radius;
        },
        enumerable: false,
        configurable: true
    });
    // @override
    /**
     * A simple boolean check of whether this AABB contains a point
     * @param point The point to check
     * @returns A boolean representing whether this AABB contains the specified point
     */
    Circle.prototype.containsPoint = function (point) {
        return this.center.distanceSqTo(point) <= this.radius * this.radius;
    };
    // @override
    Circle.prototype.getBoundingRect = function () {
        return new AABB_1["default"](this._center.clone(), new Vec2_1["default"](this.radius, this.radius));
    };
    // @override
    Circle.prototype.getBoundingCircle = function () {
        return this.clone();
    };
    // @override
    Circle.prototype.overlaps = function (other) {
        throw new Error("Method not implemented.");
    };
    // @override
    Circle.prototype.clone = function () {
        return new Circle(this._center.clone(), this.radius);
    };
    Circle.prototype.toString = function () {
        return "(center: " + this.center.toString() + ", radius: " + this.radius + ")";
    };
    return Circle;
}(Shape_1["default"]));
exports["default"] = Circle;
},{"../Vec2":20,"./AABB":14,"./Shape":16}],16:[function(require,module,exports){
"use strict";
exports.__esModule = true;
var Vec2_1 = require("../Vec2");
var AABB_1 = require("./AABB");
/**
 * An abstract Shape class that acts as an interface for better interactions with subclasses.
 */
var Shape = /** @class */ (function () {
    function Shape() {
    }
    Object.defineProperty(Shape.prototype, "x", {
        get: function () {
            return this.center.x;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Shape.prototype, "y", {
        get: function () {
            return this.center.y;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Shape.prototype, "hw", {
        get: function () {
            return this.halfSize.x;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Shape.prototype, "hh", {
        get: function () {
            return this.halfSize.y;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Shape.prototype, "top", {
        get: function () {
            return this.y - this.hh;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Shape.prototype, "bottom", {
        get: function () {
            return this.y + this.hh;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Shape.prototype, "left", {
        get: function () {
            return this.x - this.hw;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Shape.prototype, "right", {
        get: function () {
            return this.x + this.hw;
        },
        enumerable: false,
        configurable: true
    });
    Shape.getTimeOfCollision = function (A, velA, B, velB) {
        if (A instanceof AABB_1["default"] && B instanceof AABB_1["default"]) {
            return Shape.getTimeOfCollision_AABB_AABB(A, velA, B, velB);
        }
    };
    Shape.getTimeOfCollision_AABB_AABB = function (A, velA, B, velB) {
        var posSmaller = A.center;
        var posLarger = B.center;
        var sizeSmaller = A.halfSize;
        var sizeLarger = B.halfSize;
        var firstContact = new Vec2_1["default"](0, 0);
        var lastContact = new Vec2_1["default"](0, 0);
        var collidingX = false;
        var collidingY = false;
        // Sort by position
        if (posLarger.x < posSmaller.x) {
            // Swap, because smaller is further right than larger
            var temp = void 0;
            temp = sizeSmaller;
            sizeSmaller = sizeLarger;
            sizeLarger = temp;
            temp = posSmaller;
            posSmaller = posLarger;
            posLarger = temp;
            temp = velA;
            velA = velB;
            velB = temp;
        }
        // A is left, B is right
        firstContact.x = Infinity;
        lastContact.x = Infinity;
        if (posLarger.x - sizeLarger.x >= posSmaller.x + sizeSmaller.x) {
            // If we aren't currently colliding
            var relVel = velA.x - velB.x;
            if (relVel > 0) {
                // If they are moving towards each other
                firstContact.x = ((posLarger.x - sizeLarger.x) - (posSmaller.x + sizeSmaller.x)) / (relVel);
                lastContact.x = ((posLarger.x + sizeLarger.x) - (posSmaller.x - sizeSmaller.x)) / (relVel);
            }
        }
        else {
            collidingX = true;
        }
        if (posLarger.y < posSmaller.y) {
            // Swap, because smaller is further up than larger
            var temp = void 0;
            temp = sizeSmaller;
            sizeSmaller = sizeLarger;
            sizeLarger = temp;
            temp = posSmaller;
            posSmaller = posLarger;
            posLarger = temp;
            temp = velA;
            velA = velB;
            velB = temp;
        }
        // A is top, B is bottom
        firstContact.y = Infinity;
        lastContact.y = Infinity;
        if (posLarger.y - sizeLarger.y >= posSmaller.y + sizeSmaller.y) {
            // If we aren't currently colliding
            var relVel = velA.y - velB.y;
            if (relVel > 0) {
                // If they are moving towards each other
                firstContact.y = ((posLarger.y - sizeLarger.y) - (posSmaller.y + sizeSmaller.y)) / (relVel);
                lastContact.y = ((posLarger.y + sizeLarger.y) - (posSmaller.y - sizeSmaller.y)) / (relVel);
            }
        }
        else {
            collidingY = true;
        }
        return [firstContact, lastContact, collidingX, collidingY];
    };
    return Shape;
}());
exports["default"] = Shape;
},{"../Vec2":20,"./AABB":14}],17:[function(require,module,exports){
"use strict";
exports.__esModule = true;
/**
 * A LIFO stack with items of type T
 */
var Stack = /** @class */ (function () {
    /**
     * Constructs a new stack
     * @param maxElements The maximum size of the stack
     */
    function Stack(maxElements) {
        if (maxElements === void 0) { maxElements = 100; }
        this.MAX_ELEMENTS = maxElements;
        this.stack = new Array(this.MAX_ELEMENTS);
        this.head = -1;
    }
    /**
     * Adds an item to the top of the stack
     * @param item The new item to add to the stack
     */
    Stack.prototype.push = function (item) {
        if (this.head + 1 === this.MAX_ELEMENTS) {
            throw "Stack full - cannot add element";
        }
        this.head += 1;
        this.stack[this.head] = item;
    };
    /**
     * Removes an item from the top of the stack
     * @returns The item at the top of the stack
     */
    Stack.prototype.pop = function () {
        if (this.head === -1) {
            throw "Stack empty - cannot remove element";
        }
        this.head -= 1;
        return this.stack[this.head + 1];
    };
    /**
     * Returns the element currently at the top of the stack
     * @returns The item at the top of the stack
     */
    Stack.prototype.peek = function () {
        if (this.head === -1) {
            throw "Stack empty - cannot get element";
        }
        return this.stack[this.head];
    };
    /** Returns true if this stack is empty
     * @returns A boolean that represents whether or not the stack is empty
    */
    Stack.prototype.isEmpty = function () {
        return this.head === -1;
    };
    // @implemented
    Stack.prototype.clear = function () {
        var _this = this;
        this.forEach(function (item, index) { return delete _this.stack[index]; });
        this.head = -1;
    };
    /**
     * Returns the number of items currently in the stack
     * @returns The number of items in the stack
     */
    Stack.prototype.size = function () {
        return this.head + 1;
    };
    // @implemented
    Stack.prototype.forEach = function (func) {
        var i = 0;
        while (i <= this.head) {
            func(this.stack[i], i);
            i += 1;
        }
    };
    /**
     * Converts this stack into a string format
     * @returns A string representing this stack
     */
    Stack.prototype.toString = function () {
        var retval = "";
        this.forEach(function (item, index) {
            var str = item.toString();
            if (index !== 0) {
                str += " -> ";
            }
            retval = str + retval;
        });
        return "Top -> " + retval;
    };
    return Stack;
}());
exports["default"] = Stack;
},{}],18:[function(require,module,exports){
"use strict";
exports.__esModule = true;
var Stack_1 = require("../Stack");
var Map_1 = require("../Map");
var Receiver_1 = require("../../Events/Receiver");
var Emitter_1 = require("../../Events/Emitter");
/**
 * An implementation of a Push Down Automata State machine. States can also be hierarchical
 * for more flexibility, as described in @link(Game Programming Patterns)(https://gameprogrammingpatterns.com/state.html).
 */
var StateMachine = /** @class */ (function () {
    /**
     * Creates a new StateMachine
     */
    function StateMachine() {
        this.stack = new Stack_1["default"]();
        this.stateMap = new Map_1["default"]();
        this.receiver = new Receiver_1["default"]();
        this.emitter = new Emitter_1["default"]();
        this.emitEventOnStateChange = false;
    }
    /**
     * Sets the activity state of this state machine
     * @param flag True if you want to set this machine running, false otherwise
     */
    StateMachine.prototype.setActive = function (flag) {
        this.active = flag;
    };
    /**
     * Makes this state machine emit an event any time its state changes
     * @param stateChangeEventName The name of the event to emit
     */
    StateMachine.prototype.setEmitEventOnStateChange = function (stateChangeEventName) {
        this.emitEventOnStateChange = true;
        this.stateChangeEventName = stateChangeEventName;
    };
    /**
     * Stops this state machine from emitting events on state change.
     */
    StateMachine.prototype.cancelEmitEventOnStateChange = function () {
        this.emitEventOnStateChange = false;
    };
    /**
     * Initializes this state machine with an initial state and sets it running
     * @param initialState The name of initial state of the state machine
     */
    StateMachine.prototype.initialize = function (initialState, options) {
        this.stack.push(this.stateMap.get(initialState));
        this.currentState = this.stack.peek();
        this.currentState.onEnter(options);
        this.setActive(true);
    };
    /**
     * Adds a state to this state machine
     * @param stateName The name of the state to add
     * @param state The state to add
     */
    StateMachine.prototype.addState = function (stateName, state) {
        this.stateMap.add(stateName, state);
    };
    /**
     * Changes the state of this state machine to the provided string
     * @param state The string name of the state to change to
     */
    StateMachine.prototype.changeState = function (state) {
        // Exit the current state
        var options = this.currentState.onExit();
        // Make sure the correct state is at the top of the stack
        if (state === "previous") {
            // Pop the current state off the stack
            this.stack.pop();
        }
        else {
            // Retrieve the new state from the statemap and put it at the top of the stack
            this.stack.pop();
            this.stack.push(this.stateMap.get(state));
        }
        // Retreive the new state from the stack
        this.currentState = this.stack.peek();
        // Emit an event if turned on
        if (this.emitEventOnStateChange) {
            this.emitter.fireEvent(this.stateChangeEventName, { state: this.currentState });
        }
        // Enter the new state
        this.currentState.onEnter(options);
    };
    /**
     * Handles input. This happens at the very beginning of this state machine's update cycle.
     * @param event The game event to process
     */
    StateMachine.prototype.handleEvent = function (event) {
        if (this.active) {
            this.currentState.handleInput(event);
        }
    };
    // @implemented
    StateMachine.prototype.update = function (deltaT) {
        // Distribute events
        while (this.receiver.hasNextEvent()) {
            var event_1 = this.receiver.getNextEvent();
            this.handleEvent(event_1);
        }
        // Delegate the update to the current state
        this.currentState.update(deltaT);
    };
    return StateMachine;
}());
exports["default"] = StateMachine;
},{"../../Events/Emitter":23,"../../Events/Receiver":27,"../Map":8,"../Stack":17}],19:[function(require,module,exports){
"use strict";
exports.__esModule = true;
var ResourceManager_1 = require("../../ResourceManager/ResourceManager");
var Vec2_1 = require("../Vec2");
/**
 * The data representation of a Tileset for the game engine. This represents one image,
 * with a startIndex if required (as it is with Tiled using two images in one tilset).
 */
var Tileset = /** @class */ (function () {
    // TODO: Change this to be more general and work with other tileset formats
    function Tileset(tilesetData) {
        // Defer handling of the data to a helper class
        this.initFromTiledData(tilesetData);
    }
    /**
     * Initialize the tileset from the data from a Tiled json file
     * @param tiledData The parsed object from a Tiled json file
     */
    Tileset.prototype.initFromTiledData = function (tiledData) {
        this.numRows = tiledData.tilecount / tiledData.columns;
        this.numCols = tiledData.columns;
        this.startIndex = tiledData.firstgid;
        this.endIndex = this.startIndex + tiledData.tilecount - 1;
        this.tileSize = new Vec2_1["default"](tiledData.tilewidth, tiledData.tilewidth);
        this.imageKey = tiledData.image;
        this.imageSize = new Vec2_1["default"](tiledData.imagewidth, tiledData.imageheight);
    };
    /**
     * Gets the image key associated with this tilemap
     * @returns The image key of this tilemap
     */
    Tileset.prototype.getImageKey = function () {
        return this.imageKey;
    };
    /**
     * Returns a Vec2 containing the left and top offset from the image origin for this tile.
     * @param tileIndex The index of the tile from startIndex to endIndex of this tileset
     * @returns A Vec2 containing the offset for the specified tile.
     */
    Tileset.prototype.getImageOffsetForTile = function (tileIndex) {
        // Get the true index
        var index = tileIndex - this.startIndex;
        var row = Math.floor(index / this.numCols);
        var col = index % this.numCols;
        var width = this.tileSize.x;
        var height = this.tileSize.y;
        // Calculate the position to start a crop in the tileset image
        var left = col * width;
        var top = row * height;
        return new Vec2_1["default"](left, top);
    };
    /**
     * Gets the start index
     * @returns The start index
     */
    Tileset.prototype.getStartIndex = function () {
        return this.startIndex;
    };
    /**
     * Gets the tile set
     * @returns A Vec2 containing the tile size
     */
    Tileset.prototype.getTileSize = function () {
        return this.tileSize;
    };
    /**
     * Gets the number of rows in the tileset
     * @returns The number of rows
     */
    Tileset.prototype.getNumRows = function () {
        return this.numRows;
    };
    /**
     * Gets the number of columns in the tilset
     * @returns The number of columns
     */
    Tileset.prototype.getNumCols = function () {
        return this.numCols;
    };
    Tileset.prototype.getTileCount = function () {
        return this.endIndex - this.startIndex + 1;
    };
    /**
     * Checks whether or not this tilset contains the specified tile index. This is used for rendering.
     * @param tileIndex The index of the tile to check
     * @returns A boolean representing whether or not this tilset uses the specified index
     */
    Tileset.prototype.hasTile = function (tileIndex) {
        return tileIndex >= this.startIndex && tileIndex <= this.endIndex;
    };
    /**
     * Render a singular tile with index tileIndex from the tileset located at position dataIndex
     * @param ctx The rendering context
     * @param tileIndex The value of the tile to render
     * @param dataIndex The index of the tile in the data array
     * @param worldSize The size of the world
     * @param origin The viewport origin in the current layer
     * @param scale The scale of the tilemap
     */
    Tileset.prototype.renderTile = function (ctx, tileIndex, dataIndex, maxCols, origin, scale, zoom) {
        var image = ResourceManager_1["default"].getInstance().getImage(this.imageKey);
        // Get the true index
        var index = tileIndex - this.startIndex;
        var row = Math.floor(index / this.numCols);
        var col = index % this.numCols;
        var width = this.tileSize.x;
        var height = this.tileSize.y;
        // Calculate the position to start a crop in the tileset image
        var left = col * width;
        var top = row * height;
        // Calculate the position in the world to render the tile
        var x = Math.floor((dataIndex % maxCols) * width * scale.x);
        var y = Math.floor(Math.floor(dataIndex / maxCols) * height * scale.y);
        ctx.drawImage(image, left, top, width, height, Math.floor((x - origin.x) * zoom), Math.floor((y - origin.y) * zoom), Math.ceil(width * scale.x * zoom), Math.ceil(height * scale.y * zoom));
    };
    return Tileset;
}());
exports["default"] = Tileset;
},{"../../ResourceManager/ResourceManager":79,"../Vec2":20}],20:[function(require,module,exports){
"use strict";
exports.__esModule = true;
var MathUtils_1 = require("../Utils/MathUtils");
/**
 * A two-dimensional vector (x, y)
 */
var Vec2 = /** @class */ (function () {
    /**
     * Creates a new Vec2
     * @param x The x value of the vector
     * @param y The y value of the vector
     */
    function Vec2(x, y) {
        if (x === void 0) { x = 0; }
        if (y === void 0) { y = 0; }
        /**
         * When this vector changes its value, do something
         */
        this.onChange = function () { };
        this.vec = new Float32Array(2);
        this.vec[0] = x;
        this.vec[1] = y;
    }
    Object.defineProperty(Vec2.prototype, "x", {
        // Expose x and y with getters and setters
        get: function () {
            return this.vec[0];
        },
        set: function (x) {
            this.vec[0] = x;
            if (this.onChange) {
                this.onChange();
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Vec2.prototype, "y", {
        get: function () {
            return this.vec[1];
        },
        set: function (y) {
            this.vec[1] = y;
            if (this.onChange) {
                this.onChange();
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Vec2, "ZERO", {
        get: function () {
            return new Vec2(0, 0);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Vec2, "INF", {
        get: function () {
            return new Vec2(Infinity, Infinity);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Vec2, "UP", {
        get: function () {
            return new Vec2(0, -1);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Vec2, "DOWN", {
        get: function () {
            return new Vec2(0, 1);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Vec2, "LEFT", {
        get: function () {
            return new Vec2(-1, 0);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Vec2, "RIGHT", {
        get: function () {
            return new Vec2(1, 0);
        },
        enumerable: false,
        configurable: true
    });
    /**
     * The squared magnitude of the vector. This tends to be faster, so use it in situations where taking the
     * square root doesn't matter, like for comparing distances.
     * @returns The squared magnitude of the vector
     */
    Vec2.prototype.magSq = function () {
        return this.x * this.x + this.y * this.y;
    };
    /**
     * The magnitude of the vector.
     * @returns The magnitude of the vector.
     */
    Vec2.prototype.mag = function () {
        return Math.sqrt(this.magSq());
    };
    /**
     * Divdes x and y by the magnitude to obtain the unit vector in the direction of this vector.
     * @returns This vector as a unit vector.
     */
    Vec2.prototype.normalize = function () {
        if (this.x === 0 && this.y === 0)
            return this;
        var mag = this.mag();
        this.x /= mag;
        this.y /= mag;
        return this;
    };
    /**
     * Works like normalize(), but returns a new Vec2
     * @returns A new vector that is the unit vector for this one
     */
    Vec2.prototype.normalized = function () {
        if (this.isZero()) {
            return this;
        }
        var mag = this.mag();
        return new Vec2(this.x / mag, this.y / mag);
    };
    /**
     * Sets the x and y elements of this vector to zero.
     * @returns This vector, with x and y set to zero.
     */
    Vec2.prototype.zero = function () {
        return this.set(0, 0);
    };
    /**
     * Sets the vector's x and y based on the angle provided. Goes counter clockwise.
     * @param angle The angle in radians
     * @param radius The magnitude of the vector at the specified angle
     * @returns This vector.
     */
    Vec2.prototype.setToAngle = function (angle, radius) {
        if (radius === void 0) { radius = 1; }
        this.x = MathUtils_1["default"].floorToPlace(Math.cos(angle) * radius, 5);
        this.y = MathUtils_1["default"].floorToPlace(-Math.sin(angle) * radius, 5);
        return this;
    };
    /**
     * Returns a vector that point from this vector to another one
     * @param other The vector to point to
     * @returns A new Vec2 that points from this vector to the one provided
     */
    Vec2.prototype.vecTo = function (other) {
        return new Vec2(other.x - this.x, other.y - this.y);
    };
    /**
     * Returns a vector containing the direction from this vector to another
     * @param other The vector to point to
     * @returns A new Vec2 that points from this vector to the one provided. This new Vec2 will be a unit vector.
     */
    Vec2.prototype.dirTo = function (other) {
        return this.vecTo(other).normalize();
    };
    /**
     * Keeps the vector's direction, but sets its magnitude to be the provided magnitude
     * @param magnitude The magnitude the vector should be
     * @returns This vector with its magnitude set to the new magnitude
     */
    Vec2.prototype.scaleTo = function (magnitude) {
        return this.normalize().scale(magnitude);
    };
    /**
     * Scales x and y by the number provided, or if two number are provided, scales them individually.
     * @param factor The scaling factor for the vector, or for only the x-component if yFactor is provided
     * @param yFactor The scaling factor for the y-component of the vector
     * @returns This vector after scaling
     */
    Vec2.prototype.scale = function (factor, yFactor) {
        if (yFactor === void 0) { yFactor = null; }
        if (yFactor !== null) {
            this.x *= factor;
            this.y *= yFactor;
            return this;
        }
        this.x *= factor;
        this.y *= factor;
        return this;
    };
    /**
     * Returns a scaled version of this vector without modifying it.
     * @param factor The scaling factor for the vector, or for only the x-component if yFactor is provided
     * @param yFactor The scaling factor for the y-component of the vector
     * @returns A new vector that has the values of this vector after scaling
     */
    Vec2.prototype.scaled = function (factor, yFactor) {
        if (yFactor === void 0) { yFactor = null; }
        return this.clone().scale(factor, yFactor);
    };
    /**
     * Rotates the vector counter-clockwise by the angle amount specified
     * @param angle The angle to rotate by in radians
     * @returns This vector after rotation.
     */
    Vec2.prototype.rotateCCW = function (angle) {
        var cs = Math.cos(angle);
        var sn = Math.sin(angle);
        var tempX = this.x * cs - this.y * sn;
        var tempY = this.x * sn + this.y * cs;
        this.x = tempX;
        this.y = tempY;
        return this;
    };
    /**
     * Sets the vectors coordinates to be the ones provided
     * @param x The new x value for this vector
     * @param y The new y value for this vector
     * @returns This vector
     */
    Vec2.prototype.set = function (x, y) {
        this.x = x;
        this.y = y;
        return this;
    };
    /**
     * Copies the values of the other Vec2 into this one.
     * @param other The Vec2 to copy
     * @returns This vector with its values set to the vector provided
     */
    Vec2.prototype.copy = function (other) {
        return this.set(other.x, other.y);
    };
    /**
     * Adds this vector the another vector
     * @param other The Vec2 to add to this one
     * @returns This vector after adding the one provided
     */
    Vec2.prototype.add = function (other) {
        this.x += other.x;
        this.y += other.y;
        return this;
    };
    /**
     * Increments the fields of this vector. Both are incremented with a, if only a is provided.
     * @param a The first number to increment by
     * @param b The second number to increment by
     * @returnss This vector after incrementing
     */
    Vec2.prototype.inc = function (a, b) {
        if (b === undefined) {
            this.x += a;
            this.y += a;
        }
        else {
            this.x += a;
            this.y += b;
        }
        return this;
    };
    /**
     * Subtracts another vector from this vector
     * @param other The Vec2 to subtract from this one
     * @returns This vector after subtracting the one provided
     */
    Vec2.prototype.sub = function (other) {
        this.x -= other.x;
        this.y -= other.y;
        return this;
    };
    /**
     * Multiplies this vector with another vector element-wise. In other words, this.x *= other.x and this.y *= other.y
     * @param other The Vec2 to multiply this one by
     * @returns This vector after multiplying its components by this one
     */
    Vec2.prototype.mult = function (other) {
        this.x *= other.x;
        this.y *= other.y;
        return this;
    };
    /**
     * Divides this vector with another vector element-wise. In other words, this.x /= other.x and this.y /= other.y
     * @param other The vector to divide this one by
     * @returns This vector after division
     */
    Vec2.prototype.div = function (other) {
        if (other.x === 0 || other.y === 0)
            throw "Divide by zero error";
        this.x /= other.x;
        this.y /= other.y;
        return this;
    };
    /**
     * Does an element wise remainder operation on this vector. this.x %= other.x and this.y %= other.y
     * @param other The other vector
     * @returns this vector
     */
    Vec2.prototype.remainder = function (other) {
        this.x = this.x % other.x;
        this.y = this.y % other.y;
        return this;
    };
    /**
     * Returns the squared distance between this vector and another vector
     * @param other The vector to compute distance squared to
     * @returns The squared distance between this vector and the one provided
     */
    Vec2.prototype.distanceSqTo = function (other) {
        return (this.x - other.x) * (this.x - other.x) + (this.y - other.y) * (this.y - other.y);
    };
    /**
     * Returns the distance between this vector and another vector
     * @param other The vector to compute distance to
     * @returns The distance between this vector and the one provided
     */
    Vec2.prototype.distanceTo = function (other) {
        return Math.sqrt(this.distanceSqTo(other));
    };
    /**
     * Returns the dot product of this vector and another
     * @param other The vector to compute the dot product with
     * @returns The dot product of this vector and the one provided.
     */
    Vec2.prototype.dot = function (other) {
        return this.x * other.x + this.y * other.y;
    };
    /**
     * Returns the angle counter-clockwise in radians from this vector to another vector
     * @param other The vector to compute the angle to
     * @returns The angle, rotating CCW, from this vector to the other vector
     */
    Vec2.prototype.angleToCCW = function (other) {
        var dot = this.dot(other);
        var det = this.x * other.y - this.y * other.x;
        var angle = -Math.atan2(det, dot);
        if (angle < 0) {
            angle += 2 * Math.PI;
        }
        return angle;
    };
    /**
     * Returns a string representation of this vector rounded to 1 decimal point
     * @returns This vector as a string
     */
    Vec2.prototype.toString = function () {
        return this.toFixed();
    };
    /**
     * Returns a string representation of this vector rounded to the specified number of decimal points
     * @param numDecimalPoints The number of decimal points to create a string to
     * @returns This vector as a string
     */
    Vec2.prototype.toFixed = function (numDecimalPoints) {
        if (numDecimalPoints === void 0) { numDecimalPoints = 1; }
        return "(" + this.x.toFixed(numDecimalPoints) + ", " + this.y.toFixed(numDecimalPoints) + ")";
    };
    /**
     * Returns a new vector with the same coordinates as this one.
     * @returns A new Vec2 with the same values as this one
     */
    Vec2.prototype.clone = function () {
        return new Vec2(this.x, this.y);
    };
    /**
     * Returns true if this vector and other have the EXACT same x and y (not assured to be safe for floats)
     * @param other The vector to check against
     * @returns A boolean representing the equality of the two vectors
     */
    Vec2.prototype.strictEquals = function (other) {
        return this.x === other.x && this.y === other.y;
    };
    /**
     * Returns true if this vector and other have the same x and y
     * @param other The vector to check against
     * @returns A boolean representing the equality of the two vectors
     */
    Vec2.prototype.equals = function (other) {
        var xEq = Math.abs(this.x - other.x) < 0.0000001;
        var yEq = Math.abs(this.y - other.y) < 0.0000001;
        return xEq && yEq;
    };
    /**
     * Returns true if this vector is the zero vector exactly (not assured to be safe for floats).
     * @returns A boolean representing the equality of this vector and the zero vector
     */
    Vec2.prototype.strictIsZero = function () {
        return this.x === 0 && this.y === 0;
    };
    /**
     * Returns true if this x and y for this vector are both zero.
     * @returns A boolean representing the equality of this vector and the zero vector
     */
    Vec2.prototype.isZero = function () {
        return Math.abs(this.x) < 0.0000001 && Math.abs(this.y) < 0.0000001;
    };
    /**
     * Sets the function that is called whenever this vector is changed.
     * @param f The function to be called
     */
    Vec2.prototype.setOnChange = function (f) {
        this.onChange = f;
    };
    Vec2.prototype.toArray = function () {
        return this.vec;
    };
    /**
     * Performs linear interpolation between two vectors
     * @param a The first vector
     * @param b The second vector
     * @param t The time of the lerp, with 0 being vector A, and 1 being vector B
     * @returns A new Vec2 representing the lerp between vector a and b.
     */
    Vec2.lerp = function (a, b, t) {
        return new Vec2(MathUtils_1["default"].lerp(a.x, b.x, t), MathUtils_1["default"].lerp(a.y, b.y, t));
    };
    Vec2.ZERO_STATIC = new Vec2(0, 0);
    return Vec2;
}());
exports["default"] = Vec2;
},{"../Utils/MathUtils":97}],21:[function(require,module,exports){
"use strict";
exports.__esModule = true;
var Map_1 = require("../DataTypes/Map");
var Vec2_1 = require("../DataTypes/Vec2");
var Color_1 = require("../Utils/Color");
/**
 * A util class for rendering Debug messages to the canvas.
 */
var Debug = /** @class */ (function () {
    function Debug() {
    }
    /**
     * Add a message to display on the debug screen
     * @param id A unique ID for this message
     * @param messages The messages to print to the debug screen
     */
    Debug.log = function (id) {
        var messages = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            messages[_i - 1] = arguments[_i];
        }
        // let message = "";
        // for(let i = 0; i < messages.length; i++){
        // 	message += messages[i].toString();
        // }
        // Join all messages with spaces
        var message = messages.map(function (m) { return m.toString(); }).join(" ");
        this.logMessages.add(id, message);
    };
    /**
     * Deletes a a key from the log and stops it from keeping up space on the screen
     * @param id The id of the log item to clear
     */
    Debug.clearLogItem = function (id) {
        this.logMessages["delete"](id);
    };
    /**
     * Sets the list of nodes to render with the debugger
     * @param nodes The new list of nodes
     */
    Debug.setNodes = function (nodes) {
        this.nodes = nodes;
    };
    /**
     * Draws a box at the specified position
     * @param center The center of the box
     * @param halfSize The dimensions of the box
     * @param filled A boolean for whether or not the box is filled
     * @param color The color of the box to draw
     */
    Debug.drawBox = function (center, halfSize, filled, color) {
        var alpha = this.debugRenderingContext.globalAlpha;
        this.debugRenderingContext.globalAlpha = color.a;
        if (filled) {
            this.debugRenderingContext.fillStyle = color.toString();
            this.debugRenderingContext.fillRect(center.x - halfSize.x, center.y - halfSize.y, halfSize.x * 2, halfSize.y * 2);
        }
        else {
            var lineWidth = 2;
            this.debugRenderingContext.lineWidth = lineWidth;
            this.debugRenderingContext.strokeStyle = color.toString();
            this.debugRenderingContext.strokeRect(center.x - halfSize.x, center.y - halfSize.y, halfSize.x * 2, halfSize.y * 2);
        }
        this.debugRenderingContext.globalAlpha = alpha;
    };
    /**
     * Draws a circle at the specified position
     * @param center The center of the circle
     * @param radius The dimensions of the box
     * @param filled A boolean for whether or not the circle is filled
     * @param color The color of the circle
     */
    Debug.drawCircle = function (center, radius, filled, color) {
        var alpha = this.debugRenderingContext.globalAlpha;
        this.debugRenderingContext.globalAlpha = color.a;
        if (filled) {
            this.debugRenderingContext.fillStyle = color.toString();
            this.debugRenderingContext.beginPath();
            this.debugRenderingContext.arc(center.x, center.y, radius, 0, 2 * Math.PI);
            this.debugRenderingContext.closePath();
            this.debugRenderingContext.fill();
        }
        else {
            var lineWidth = 2;
            this.debugRenderingContext.lineWidth = lineWidth;
            this.debugRenderingContext.strokeStyle = color.toString();
            this.debugRenderingContext.beginPath();
            this.debugRenderingContext.arc(center.x, center.y, radius, 0, 2 * Math.PI);
            this.debugRenderingContext.closePath();
            this.debugRenderingContext.stroke();
        }
        this.debugRenderingContext.globalAlpha = alpha;
    };
    /**
     * Draws a ray at the specified position
     * @param from The starting position of the ray
     * @param to The ending position of the ray
     * @param color The color of the ray
     */
    Debug.drawRay = function (from, to, color) {
        this.debugRenderingContext.lineWidth = 2;
        this.debugRenderingContext.strokeStyle = color.toString();
        this.debugRenderingContext.beginPath();
        this.debugRenderingContext.moveTo(from.x, from.y);
        this.debugRenderingContext.lineTo(to.x, to.y);
        this.debugRenderingContext.closePath();
        this.debugRenderingContext.stroke();
    };
    /**
     * Draws a point at the specified position
     * @param pos The position of the point
     * @param color The color of the point
     */
    Debug.drawPoint = function (pos, color) {
        var pointSize = 6;
        this.debugRenderingContext.fillStyle = color.toString();
        this.debugRenderingContext.fillRect(pos.x - pointSize / 2, pos.y - pointSize / 2, pointSize, pointSize);
    };
    /**
     * Sets the default rendering color for text for the debugger
     * @param color The color to render the text
     */
    Debug.setDefaultTextColor = function (color) {
        this.defaultTextColor = color;
    };
    /**
     * Performs any necessary setup operations on the Debug canvas
     * @param canvas The debug canvas
     * @param width The desired width of the canvas
     * @param height The desired height of the canvas
     * @returns The rendering context extracted from the canvas
     */
    Debug.initializeDebugCanvas = function (canvas, width, height) {
        canvas.width = width;
        canvas.height = height;
        this.debugCanvasSize = new Vec2_1["default"](width, height);
        this.debugRenderingContext = canvas.getContext("2d");
        return this.debugRenderingContext;
    };
    /** Clears the debug canvas */
    Debug.clearCanvas = function () {
        this.debugRenderingContext.clearRect(0, 0, this.debugCanvasSize.x, this.debugCanvasSize.y);
    };
    /** Renders the text and nodes sent to the Debug system */
    Debug.render = function () {
        this.renderText();
        this.renderNodes();
    };
    /** Renders the text sent to the Debug canvas */
    Debug.renderText = function () {
        var _this = this;
        var y = 20;
        this.debugRenderingContext.font = "20px Arial";
        this.debugRenderingContext.fillStyle = this.defaultTextColor.toString();
        // Draw all of the text
        this.logMessages.forEach(function (key) {
            _this.debugRenderingContext.fillText(_this.logMessages.get(key), 10, y);
            y += 30;
        });
    };
    /** Renders the nodes registered with the debug canvas */
    Debug.renderNodes = function () {
        if (this.nodes) {
            this.nodes.forEach(function (node) {
                node.debugRender();
            });
        }
    };
    /** A map of log messages to display on the screen */
    Debug.logMessages = new Map_1["default"]();
    /** The rendering color for text */
    Debug.defaultTextColor = Color_1["default"].WHITE;
    return Debug;
}());
exports["default"] = Debug;
},{"../DataTypes/Map":8,"../DataTypes/Vec2":20,"../Utils/Color":94}],22:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
exports.__esModule = true;
var Color_1 = require("../Utils/Color");
// @ignorePage
var Stats = /** @class */ (function (_super) {
    __extends(Stats, _super);
    function Stats() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Stats.initStats = function () {
        var canvas = document.getElementById("stats-canvas");
        canvas.width = this.CANVAS_WIDTH;
        canvas.height = this.CANVAS_HEIGHT;
        this.ctx = canvas.getContext("2d");
        this.statsDiv = document.getElementById("stats-display");
        this.prevfps = new Array();
        this.prevClearTimes = new Array();
        this.SGClearTimes = new Array();
        this.avgSGClearTime = 0;
        this.prevFillTimes = new Array();
        this.SGFillTimes = new Array();
        this.avgSGFillTime = 0;
        this.prevUpdateTimes = new Array();
        this.SGUpdateTimes = new Array();
        this.avgSGUpdateTime = 0;
        this.prevQueryTimes = new Array();
        this.SGQueryTimes = new Array();
        this.avgSGQueryTime = 0;
        var clearTime = document.createElement("span");
        clearTime.setAttribute("id", "sgclear");
        var fillTime = document.createElement("span");
        fillTime.setAttribute("id", "sgfill");
        var updateTime = document.createElement("span");
        updateTime.setAttribute("id", "sgupdate");
        var queryTime = document.createElement("span");
        queryTime.setAttribute("id", "sgquery");
        var br1 = document.createElement("br");
        var br2 = document.createElement("br");
        var br3 = document.createElement("br");
        this.statsDiv.append(clearTime, br1, fillTime, br2, updateTime, br3, queryTime);
        this.graphChoices = document.getElementById("chart-option");
        var option1 = document.createElement("option");
        option1.value = "prevfps";
        option1.label = "FPS";
        var option2 = document.createElement("option");
        option2.value = "prevClearTimes";
        option2.label = "Clear Time";
        var option3 = document.createElement("option");
        option3.value = "prevFillTimes";
        option3.label = "Fill time";
        var option4 = document.createElement("option");
        option4.value = "prevUpdateTimes";
        option4.label = "Update time";
        var option5 = document.createElement("option");
        option5.value = "prevQueryTimes";
        option5.label = "Query Time";
        var optionAll = document.createElement("option");
        optionAll.value = "all";
        optionAll.label = "All";
        this.graphChoices.append(option1, option2, option3, option4, option5, optionAll);
    };
    Stats.updateFPS = function (fps) {
        this.prevfps.push(fps);
        if (this.prevfps.length > Stats.NUM_POINTS) {
            this.prevfps.shift();
        }
        if (this.SGClearTimes.length > 0) {
            this.prevClearTimes.push(this.avgSGClearTime);
            if (this.prevClearTimes.length > this.NUM_POINTS) {
                this.prevClearTimes.shift();
            }
        }
        if (this.SGFillTimes.length > 0) {
            this.prevFillTimes.push(this.avgSGFillTime);
            if (this.prevFillTimes.length > this.NUM_POINTS) {
                this.prevFillTimes.shift();
            }
        }
        if (this.SGUpdateTimes.length > 0) {
            this.prevUpdateTimes.push(this.avgSGUpdateTime);
            if (this.prevUpdateTimes.length > this.NUM_POINTS) {
                this.prevUpdateTimes.shift();
            }
        }
        if (this.SGQueryTimes.length > 0) {
            this.prevQueryTimes.push(this.avgSGQueryTime);
            if (this.prevQueryTimes.length > this.NUM_POINTS) {
                this.prevQueryTimes.shift();
            }
        }
        this.updateSGStats();
    };
    Stats.log = function (key, data) {
        if (key === "sgclear") {
            this.SGClearTimes.push(data);
            if (this.SGClearTimes.length > 100) {
                this.SGClearTimes.shift();
            }
        }
        else if (key === "sgfill") {
            this.SGFillTimes.push(data);
            if (this.SGFillTimes.length > 100) {
                this.SGFillTimes.shift();
            }
        }
        else if (key === "sgupdate") {
            this.SGUpdateTimes.push(data);
            if (this.SGUpdateTimes.length > 100) {
                this.SGUpdateTimes.shift();
            }
        }
        else if (key === "sgquery") {
            this.SGQueryTimes.push(data);
            if (this.SGQueryTimes.length > 1000) {
                this.SGQueryTimes.shift();
            }
        }
    };
    Stats.render = function () {
        // Display stats
        this.drawCharts();
    };
    Stats.drawCharts = function () {
        this.ctx.clearRect(0, 0, this.CANVAS_WIDTH, this.CANVAS_HEIGHT);
        var paramString = this.graphChoices.value;
        if (paramString === "prevfps" || paramString === "all") {
            var param = this.prevfps;
            var color = Color_1["default"].BLUE.toString();
            this.drawChart(param, color);
        }
        if (paramString === "prevClearTimes" || paramString === "all") {
            var param = this.prevClearTimes;
            var color = Color_1["default"].RED.toString();
            this.drawChart(param, color);
        }
        if (paramString === "prevFillTimes" || paramString === "all") {
            var param = this.prevFillTimes;
            var color = Color_1["default"].GREEN.toString();
            this.drawChart(param, color);
        }
        if (paramString === "prevUpdateTimes" || paramString === "all") {
            var param = this.prevUpdateTimes;
            var color = Color_1["default"].CYAN.toString();
            this.drawChart(param, color);
        }
        if (paramString === "prevQueryTimes" || paramString === "all") {
            var param = this.prevQueryTimes;
            var color = Color_1["default"].ORANGE.toString();
            this.drawChart(param, color);
        }
    };
    Stats.drawChart = function (param, color) {
        this.ctx.strokeStyle = Color_1["default"].BLACK.toString();
        this.ctx.beginPath();
        this.ctx.moveTo(10, 10);
        this.ctx.lineTo(10, this.CANVAS_HEIGHT - 10);
        this.ctx.closePath();
        this.ctx.stroke();
        this.ctx.beginPath();
        this.ctx.moveTo(10, this.CANVAS_HEIGHT - 10);
        this.ctx.lineTo(this.CANVAS_WIDTH - 10, this.CANVAS_HEIGHT - 10);
        this.ctx.closePath();
        this.ctx.stroke();
        var max = Math.max.apply(Math, param);
        var prevX = 10;
        var prevY = this.CANVAS_HEIGHT - 10 - param[0] / max * (this.CANVAS_HEIGHT - 20);
        this.ctx.strokeStyle = color;
        for (var i = 1; i < param.length; i++) {
            var fps = param[i];
            var x = 10 + i * (this.CANVAS_WIDTH - 20) / this.NUM_POINTS;
            var y = this.CANVAS_HEIGHT - 10 - fps / max * (this.CANVAS_HEIGHT - 20);
            this.ctx.beginPath();
            this.ctx.moveTo(prevX, prevY);
            this.ctx.lineTo(x, y);
            this.ctx.closePath();
            this.ctx.stroke();
            prevX = x;
            prevY = y;
        }
    };
    Stats.updateSGStats = function () {
        if (this.SGClearTimes.length > 0) {
            this.avgSGClearTime = this.SGClearTimes.reduce(function (acc, val) { return acc + val; }) / this.SGClearTimes.length;
        }
        if (this.SGFillTimes.length > 0) {
            this.avgSGFillTime = this.SGFillTimes.reduce(function (acc, val) { return acc + val; }) / this.SGFillTimes.length;
        }
        if (this.SGUpdateTimes.length > 0) {
            this.avgSGUpdateTime = this.SGUpdateTimes.reduce(function (acc, val) { return acc + val; }) / this.SGUpdateTimes.length;
        }
        if (this.SGQueryTimes.length > 0) {
            this.avgSGQueryTime = this.SGQueryTimes.reduce(function (acc, val) { return acc + val; }) / this.SGQueryTimes.length;
        }
        document.getElementById("sgclear").innerHTML = "Avg SG clear time: " + this.avgSGClearTime;
        document.getElementById("sgfill").innerHTML = "Avg SG fill time: " + this.avgSGFillTime;
        document.getElementById("sgupdate").innerHTML = "Avg SG update time: " + this.avgSGUpdateTime;
        document.getElementById("sgquery").innerHTML = "Avg SG query time: " + this.avgSGQueryTime;
    };
    Stats.NUM_POINTS = 60;
    Stats.CANVAS_WIDTH = 300;
    Stats.CANVAS_HEIGHT = 300;
    return Stats;
}(Object));
exports["default"] = Stats;
},{"../Utils/Color":94}],23:[function(require,module,exports){
"use strict";
exports.__esModule = true;
var EventQueue_1 = require("./EventQueue");
var GameEvent_1 = require("./GameEvent");
/**
 * An event emitter object other systems can use to hook into the EventQueue.
 * Provides an easy interface for firing off events.
 */
var Emitter = /** @class */ (function () {
    /** Creates a new Emitter */
    function Emitter() {
        this.eventQueue = EventQueue_1["default"].getInstance();
    }
    /**
     * Emit and event of type eventType with the data packet data
     * @param eventType The name of the event to fire off
     * @param data A @reference[Map] or record containing any data about the event
     */
    Emitter.prototype.fireEvent = function (eventType, data) {
        if (data === void 0) { data = null; }
        this.eventQueue.addEvent(new GameEvent_1["default"](eventType, data));
    };
    return Emitter;
}());
exports["default"] = Emitter;
},{"./EventQueue":24,"./GameEvent":25}],24:[function(require,module,exports){
"use strict";
exports.__esModule = true;
var Queue_1 = require("../DataTypes/Queue");
var Map_1 = require("../DataTypes/Map");
var GameEventType_1 = require("./GameEventType");
/**
 * The main event system of the game engine.
 * Events are sent to the EventQueue, which handles distribution to any systems that are listening for those events.
 * This allows for handling of input without having classes directly hook into javascript event handles,
 * and allows otherwise separate classes to communicate with each other cleanly, such as a Player object
 * requesting a sound be played by the audio system.
 *
 * The distribution of @reference[GameEvent]s happens as follows:
 *
 * Events are recieved throughout a frame and are queued up by the EventQueue.
 * At the beginning of the next frame, events are sent out to any receivers that are hooked into the event type.
 * @reference[Receiver]s are then free to process events as they see fit.
 *
 * Overall, the EventQueue can be considered as something similar to an email server,
 * and the @reference[Receiver]s can be considered as the client inboxes.
 *
 * See @link(Game Programming Patterns)(https://gameprogrammingpatterns.com/event-queue.html) for more discussion on EventQueues
 */
var EventQueue = /** @class */ (function () {
    function EventQueue() {
        this.MAX_SIZE = 100;
        this.q = new Queue_1["default"](this.MAX_SIZE);
        this.receivers = new Map_1["default"]();
    }
    /** Retrieves the instance of the Singleton EventQueue */
    EventQueue.getInstance = function () {
        if (this.instance === null) {
            this.instance = new EventQueue();
        }
        return this.instance;
    };
    /** Adds an event to the EventQueue.
     * This is exposed to the rest of the game engine through the @reference[Emitter] class */
    EventQueue.prototype.addEvent = function (event) {
        this.q.enqueue(event);
    };
    /**
     * Associates a receiver with a type of event. Every time this event appears in the future,
     * it will be given to the receiver (and any others watching that type).
     * This is exposed to the rest of the game engine through the @reference[Receiver] class
     * @param receiver The event receiver
     * @param type The type or types of events to subscribe to
     */
    EventQueue.prototype.subscribe = function (receiver, type) {
        if (type instanceof Array) {
            // If it is an array, subscribe to all event types
            for (var _i = 0, type_1 = type; _i < type_1.length; _i++) {
                var t = type_1[_i];
                this.addListener(receiver, t);
            }
        }
        else {
            this.addListener(receiver, type);
        }
    };
    /**
     * Unsubscribes the specified receiver from all events, or from whatever events are provided
     * @param receiver The receiver to unsubscribe
     * @param keys The events to unsubscribe from. If none are provided, unsubscribe from all
     */
    EventQueue.prototype.unsubscribe = function (receiver) {
        var _this = this;
        var events = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            events[_i - 1] = arguments[_i];
        }
        this.receivers.forEach(function (eventName) {
            // If keys were provided, only continue if this key is one of them
            if (events.length > 0 && events.indexOf(eventName) === -1)
                return;
            // Find the index of our receiver for this key
            var index = _this.receivers.get(eventName).indexOf(receiver);
            // If an index was found, remove the receiver
            if (index !== -1) {
                _this.receivers.get(eventName).splice(index, 1);
            }
        });
    };
    // Associate the receiver and the type
    EventQueue.prototype.addListener = function (receiver, type) {
        if (this.receivers.has(type)) {
            this.receivers.get(type).push(receiver);
        }
        else {
            this.receivers.add(type, [receiver]);
        }
    };
    EventQueue.prototype.update = function (deltaT) {
        while (this.q.hasItems()) {
            // Retrieve each event
            var event_1 = this.q.dequeue();
            // If a receiver has this event type, send it the event
            if (this.receivers.has(event_1.type)) {
                for (var _i = 0, _a = this.receivers.get(event_1.type); _i < _a.length; _i++) {
                    var receiver = _a[_i];
                    receiver.receive(event_1);
                }
            }
            // If a receiver is subscribed to all events, send it the event
            if (this.receivers.has(GameEventType_1.GameEventType.ALL)) {
                for (var _b = 0, _c = this.receivers.get(GameEventType_1.GameEventType.ALL); _b < _c.length; _b++) {
                    var receiver = _c[_b];
                    receiver.receive(event_1);
                }
            }
        }
    };
    EventQueue.instance = null;
    return EventQueue;
}());
exports["default"] = EventQueue;
},{"../DataTypes/Map":8,"../DataTypes/Queue":12,"./GameEventType":26}],25:[function(require,module,exports){
"use strict";
exports.__esModule = true;
var Map_1 = require("../DataTypes/Map");
/**
 * A representation of an in-game event that is passed through the @reference[EventQueue]
 */
var GameEvent = /** @class */ (function () {
    /**
     * Creates a new GameEvent.
     * This is handled implicitly through the @reference[Emitter] class
     * @param type The type of the GameEvent
     * @param data The data contained by the GameEvent
     */
    function GameEvent(type, data) {
        if (data === void 0) { data = null; }
        // Parse the game event data
        if (data === null) {
            this.data = new Map_1["default"]();
        }
        else if (!(data instanceof Map_1["default"])) {
            // data is a raw object, unpack
            this.data = new Map_1["default"]();
            for (var key in data) {
                this.data.add(key, data[key]);
            }
        }
        else {
            this.data = data;
        }
        this.type = type;
        this.time = Date.now();
    }
    /**
     * Checks the type of the GameEvent
     * @param type The type to check
     * @returns True if the GameEvent is the specified type, false otherwise.
     */
    GameEvent.prototype.isType = function (type) {
        return this.type === type;
    };
    /**
     * Returns this GameEvent as a string
     * @returns The string representation of the GameEvent
     */
    GameEvent.prototype.toString = function () {
        return this.type + ": @" + this.time;
    };
    return GameEvent;
}());
exports["default"] = GameEvent;
},{"../DataTypes/Map":8}],26:[function(require,module,exports){
"use strict";
// @ignorePage
exports.__esModule = true;
exports.GameEventType = void 0;
var GameEventType;
(function (GameEventType) {
    /**
     * Mouse Down event. Has data: {position: Vec2 - Mouse Position}
     */
    GameEventType["MOUSE_DOWN"] = "mouse_down";
    /**
     * Mouse Up event. Has data: {position: Vec2 - Mouse Position}
     */
    GameEventType["MOUSE_UP"] = "mouse_up";
    /**
     * Mouse Move event. Has data: {position: Vec2 - Mouse Position}
     */
    GameEventType["MOUSE_MOVE"] = "mouse_move";
    /**
     * Key Down event. Has data: {key: string - The key that is down}
     */
    GameEventType["KEY_DOWN"] = "key_down";
    /**
     * Key Up event. Has data: {key: string - The key that is up}
     */
    GameEventType["KEY_UP"] = "key_up";
    /**
     * Canvas Blur event. Has data: {}
     */
    GameEventType["CANVAS_BLUR"] = "canvas_blur";
    /**
     * Mouse wheel up event. Has data: {}
     */
    GameEventType["WHEEL_UP"] = "wheel_up";
    /**
     * Mouse wheel down event. Has data: {}
     */
    GameEventType["WHEEL_DOWN"] = "wheel_down";
    /**
     * Start Recording event. Has data: {}
     */
    GameEventType["START_RECORDING"] = "start_recording";
    /**
     * Stop Recording event. Has data: {}
     */
    GameEventType["STOP_RECORDING"] = "stop_recording";
    /**
     * Play Recording event. Has data: {}
     */
    GameEventType["PLAY_RECORDING"] = "play_recording";
    /**
     * Play Sound event. Has data: {key: string, loop: boolean, holdReference: boolean }
     */
    GameEventType["PLAY_SOUND"] = "play_sound";
    /**
     * Play Sound event. Has data: {key: string}
     */
    GameEventType["STOP_SOUND"] = "stop_sound";
    /**
     * Play Sound event. Has data: {key: string, loop: boolean, holdReference: boolean, channel: AudioChannelType }
     */
    GameEventType["PLAY_SFX"] = "play_sfx";
    /**
     * Play Sound event. Has data: {key: string, loop: boolean, holdReference: boolean }
     */
    GameEventType["PLAY_MUSIC"] = "play_music";
    /**
     * Mute audio channel event. Has data: {channel: AudioChannelType}
     */
    GameEventType["MUTE_CHANNEL"] = "mute_channel";
    /**
     * Unmute audio channel event. Has data: {channel: AudioChannelType}
     */
    GameEventType["UNMUTE_CHANNEL"] = "unmute_channel";
    /**
     * Encompasses all event types. Used for receivers only.
     */
    GameEventType["ALL"] = "all";
})(GameEventType = exports.GameEventType || (exports.GameEventType = {}));
},{}],27:[function(require,module,exports){
"use strict";
exports.__esModule = true;
var Queue_1 = require("../DataTypes/Queue");
var EventQueue_1 = require("./EventQueue");
/**
 * Receives subscribed events from the EventQueue.
 */
var Receiver = /** @class */ (function () {
    /** Creates a new Receiver */
    function Receiver() {
        this.MAX_SIZE = 100;
        this.q = new Queue_1["default"](this.MAX_SIZE);
    }
    Receiver.prototype.destroy = function () {
        EventQueue_1["default"].getInstance().unsubscribe(this);
    };
    /**
     * Adds these types of events to this receiver's queue every update.
     * @param eventTypes The types of events this receiver will be subscribed to
     */
    Receiver.prototype.subscribe = function (eventTypes) {
        EventQueue_1["default"].getInstance().subscribe(this, eventTypes);
        this.q.clear();
    };
    /**
     * Adds an event to the queue of this reciever. This is used by the @reference[EventQueue] to distribute events
     * @param event The event to receive
     */
    Receiver.prototype.receive = function (event) {
        try {
            this.q.enqueue(event);
        }
        catch (e) {
            console.warn("Receiver overflow for event " + event.toString());
            throw e;
        }
    };
    /**
     * Retrieves the next event from the receiver's queue
     * @returns The next GameEvent
     */
    Receiver.prototype.getNextEvent = function () {
        return this.q.dequeue();
    };
    /**
     * Looks at the next event in the receiver's queue, but doesn't remove it from the queue
     * @returns The next GameEvent
     */
    Receiver.prototype.peekNextEvent = function () {
        return this.q.peekNext();
    };
    /**
     * Returns true if the receiver has any events in its queue
     * @returns True if the receiver has another event, false otherwise
     */
    Receiver.prototype.hasNextEvent = function () {
        return this.q.hasItems();
    };
    /**
     * Ignore all events this frame
     */
    Receiver.prototype.ignoreEvents = function () {
        this.q.clear();
    };
    return Receiver;
}());
exports["default"] = Receiver;
},{"../DataTypes/Queue":12,"./EventQueue":24}],28:[function(require,module,exports){
"use strict";
exports.__esModule = true;
var Receiver_1 = require("../Events/Receiver");
var Map_1 = require("../DataTypes/Map");
var Vec2_1 = require("../DataTypes/Vec2");
var EventQueue_1 = require("../Events/EventQueue");
var GameEventType_1 = require("../Events/GameEventType");
/**
 * Receives input events from the @reference[EventQueue] and allows for easy access of information about input by other systems
 */
var Input = /** @class */ (function () {
    function Input() {
    }
    /**
     * Initializes the Input object
     * @param viewport A reference to the viewport of the game
     */
    Input.initialize = function (viewport, keyMap) {
        Input.viewport = viewport;
        Input.mousePressed = false;
        Input.mouseJustPressed = false;
        Input.receiver = new Receiver_1["default"]();
        Input.keyJustPressed = new Map_1["default"]();
        Input.keyPressed = new Map_1["default"]();
        Input.mousePosition = new Vec2_1["default"](0, 0);
        Input.mousePressPosition = new Vec2_1["default"](0, 0);
        Input.scrollDirection = 0;
        Input.justScrolled = false;
        Input.keysDisabled = false;
        Input.mouseDisabled = false;
        // Initialize the keymap
        Input.keyMap = new Map_1["default"]();
        // Add all keys to the keymap
        for (var entry in keyMap) {
            var name_1 = keyMap[entry].name;
            var keys = keyMap[entry].keys;
            Input.keyMap.add(name_1, keys);
        }
        Input.eventQueue = EventQueue_1["default"].getInstance();
        // Subscribe to all input events
        Input.eventQueue.subscribe(Input.receiver, [GameEventType_1.GameEventType.MOUSE_DOWN, GameEventType_1.GameEventType.MOUSE_UP, GameEventType_1.GameEventType.MOUSE_MOVE,
            GameEventType_1.GameEventType.KEY_DOWN, GameEventType_1.GameEventType.KEY_UP, GameEventType_1.GameEventType.CANVAS_BLUR, GameEventType_1.GameEventType.WHEEL_UP, GameEventType_1.GameEventType.WHEEL_DOWN]);
    };
    Input.update = function (deltaT) {
        // Reset the justPressed values to false
        Input.mouseJustPressed = false;
        Input.keyJustPressed.forEach(function (key) { return Input.keyJustPressed.set(key, false); });
        Input.justScrolled = false;
        Input.scrollDirection = 0;
        while (Input.receiver.hasNextEvent()) {
            var event_1 = Input.receiver.getNextEvent();
            // Handle each event type
            if (event_1.type === GameEventType_1.GameEventType.MOUSE_DOWN) {
                Input.mouseJustPressed = true;
                Input.mousePressed = true;
                Input.mousePressPosition = event_1.data.get("position");
                Input.mouseButtonPressed = event_1.data.get("button");
            }
            if (event_1.type === GameEventType_1.GameEventType.MOUSE_UP) {
                Input.mousePressed = false;
            }
            if (event_1.type === GameEventType_1.GameEventType.MOUSE_MOVE) {
                Input.mousePosition = event_1.data.get("position");
            }
            if (event_1.type === GameEventType_1.GameEventType.KEY_DOWN) {
                var key = event_1.data.get("key");
                // Handle space bar
                if (key === " ") {
                    key = "space";
                }
                if (!Input.keyPressed.get(key)) {
                    Input.keyJustPressed.set(key, true);
                    Input.keyPressed.set(key, true);
                }
            }
            if (event_1.type === GameEventType_1.GameEventType.KEY_UP) {
                var key = event_1.data.get("key");
                // Handle space bar
                if (key === " ") {
                    key = "space";
                }
                Input.keyPressed.set(key, false);
            }
            if (event_1.type === GameEventType_1.GameEventType.CANVAS_BLUR) {
                Input.clearKeyPresses();
            }
            if (event_1.type === GameEventType_1.GameEventType.WHEEL_UP) {
                Input.scrollDirection = -1;
                Input.justScrolled = true;
            }
            else if (event_1.type === GameEventType_1.GameEventType.WHEEL_DOWN) {
                Input.scrollDirection = 1;
                Input.justScrolled = true;
            }
        }
    };
    Input.clearKeyPresses = function () {
        Input.keyJustPressed.forEach(function (key) { return Input.keyJustPressed.set(key, false); });
        Input.keyPressed.forEach(function (key) { return Input.keyPressed.set(key, false); });
    };
    /**
     * Returns whether or not a key was newly pressed Input frame.
     * If the key is still pressed from last frame and wasn't re-pressed, Input will return false.
     * @param key The key
     * @returns True if the key was just pressed, false otherwise
     */
    Input.isKeyJustPressed = function (key) {
        if (Input.keysDisabled)
            return false;
        if (Input.keyJustPressed.has(key)) {
            return Input.keyJustPressed.get(key);
        }
        else {
            return false;
        }
    };
    /**
     * Returns an array of all of the keys that are newly pressed Input frame.
     * If a key is still pressed from last frame and wasn't re-pressed, it will not be in Input list.
     * @returns An array of all of the newly pressed keys.
     */
    Input.getKeysJustPressed = function () {
        if (Input.keysDisabled)
            return [];
        var keys = Array();
        Input.keyJustPressed.forEach(function (key) {
            if (Input.keyJustPressed.get(key)) {
                keys.push(key);
            }
        });
        return keys;
    };
    /**
     * Returns whether or not a key is being pressed.
     * @param key The key
     * @returns True if the key is currently pressed, false otherwise
     */
    Input.isKeyPressed = function (key) {
        if (Input.keysDisabled)
            return false;
        if (Input.keyPressed.has(key)) {
            return Input.keyPressed.get(key);
        }
        else {
            return false;
        }
    };
    /**
     * Changes the binding of an input name to keys
     * @param inputName The name of the input
     * @param keys The corresponding keys
     */
    Input.changeKeyBinding = function (inputName, keys) {
        Input.keyMap.set(inputName, keys);
    };
    /**
     * Clears all key bindings
     */
    Input.clearAllKeyBindings = function () {
        Input.keyMap.clear();
    };
    /**
     * Returns whether or not an input was just pressed this frame
     * @param inputName The name of the input
     * @returns True if the input was just pressed, false otherwise
     */
    Input.isJustPressed = function (inputName) {
        if (Input.keysDisabled)
            return false;
        if (Input.keyMap.has(inputName)) {
            var keys = Input.keyMap.get(inputName);
            var justPressed = false;
            for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
                var key = keys_1[_i];
                justPressed = justPressed || Input.isKeyJustPressed(key);
            }
            return justPressed;
        }
        else {
            return false;
        }
    };
    /**
     * Returns whether or not an input is currently pressed
     * @param inputName The name of the input
     * @returns True if the input is pressed, false otherwise
     */
    Input.isPressed = function (inputName) {
        if (Input.keysDisabled)
            return false;
        if (Input.keyMap.has(inputName)) {
            var keys = Input.keyMap.get(inputName);
            var pressed = false;
            for (var _i = 0, keys_2 = keys; _i < keys_2.length; _i++) {
                var key = keys_2[_i];
                pressed = pressed || Input.isKeyPressed(key);
            }
            return pressed;
        }
        else {
            return false;
        }
    };
    /**
     *
     * Returns whether or not the mouse was newly pressed Input frame.
     * @param mouseButton Optionally specify which mouse click you want to know was pressed.
     * 0 for left click, 1 for middle click, 2 for right click.
     * @returns True if the mouse was just pressed, false otherwise
     */
    Input.isMouseJustPressed = function (mouseButton) {
        if (mouseButton) {
            return Input.mouseJustPressed && !Input.mouseDisabled && mouseButton == this.mouseButtonPressed;
        }
        return Input.mouseJustPressed && !Input.mouseDisabled;
    };
    /**
     * Returns whether or not the mouse is currently pressed
     * @param mouseButton Optionally specify which mouse click you want to know was pressed.
     * 0 for left click, 1 for middle click, 2 for right click.
     * @returns True if the mouse is currently pressed, false otherwise
     */
    Input.isMousePressed = function (mouseButton) {
        if (mouseButton) {
            return Input.mousePressed && !Input.mouseDisabled && mouseButton == this.mouseButtonPressed;
        }
        return Input.mousePressed && !Input.mouseDisabled;
    };
    /**
     * Returns whether the user scrolled or not
     * @returns True if the user just scrolled Input frame, false otherwise
     */
    Input.didJustScroll = function () {
        return Input.justScrolled && !Input.mouseDisabled;
    };
    /**
     * Gets the direction of the scroll
     * @returns -1 if the user scrolled up, 1 if they scrolled down
     */
    Input.getScrollDirection = function () {
        return Input.scrollDirection;
    };
    /**
     * Gets the position of the player's mouse
     * @returns The mouse position stored as a Vec2
     */
    Input.getMousePosition = function () {
        return Input.mousePosition.scaled(1 / this.viewport.getZoomLevel());
    };
    /**
     * Gets the position of the player's mouse in the game world,
     * taking into consideration the scrolling of the viewport
     * @returns The mouse position stored as a Vec2
     */
    Input.getGlobalMousePosition = function () {
        return Input.mousePosition.clone().scale(1 / this.viewport.getZoomLevel()).add(Input.viewport.getOrigin());
    };
    /**
     * Gets the position of the last mouse press
     * @returns The mouse position stored as a Vec2
     */
    Input.getMousePressPosition = function () {
        return Input.mousePressPosition;
    };
    /**
     * Gets the position of the last mouse press in the game world,
     * taking into consideration the scrolling of the viewport
     * @returns The mouse position stored as a Vec2
     */
    Input.getGlobalMousePressPosition = function () {
        return Input.mousePressPosition.clone().add(Input.viewport.getOrigin());
    };
    /**
     * Disables all keypress and mouse click inputs
     */
    Input.disableInput = function () {
        Input.keysDisabled = true;
        Input.mouseDisabled = true;
    };
    /**
     * Enables all keypress and mouse click inputs
     */
    Input.enableInput = function () {
        Input.keysDisabled = false;
        Input.mouseDisabled = false;
    };
    return Input;
}());
exports["default"] = Input;
},{"../DataTypes/Map":8,"../DataTypes/Vec2":20,"../Events/EventQueue":24,"../Events/GameEventType":26,"../Events/Receiver":27}],29:[function(require,module,exports){
"use strict";
exports.__esModule = true;
var EventQueue_1 = require("../Events/EventQueue");
var Vec2_1 = require("../DataTypes/Vec2");
var GameEvent_1 = require("../Events/GameEvent");
var GameEventType_1 = require("../Events/GameEventType");
/**
 * Handles communication with the web browser to receive asynchronous events and send them to the @reference[EventQueue]
 */
var InputHandler = /** @class */ (function () {
    /**
     * Creates a new InputHandler
     * @param canvas The game canvas
     */
    function InputHandler(canvas) {
        var _this = this;
        this.handleMouseDown = function (event, canvas) {
            var pos = _this.getMousePosition(event, canvas);
            var button = event.button;
            var gameEvent = new GameEvent_1["default"](GameEventType_1.GameEventType.MOUSE_DOWN, { position: pos, button: button });
            _this.eventQueue.addEvent(gameEvent);
        };
        this.handleMouseUp = function (event, canvas) {
            var pos = _this.getMousePosition(event, canvas);
            var gameEvent = new GameEvent_1["default"](GameEventType_1.GameEventType.MOUSE_UP, { position: pos });
            _this.eventQueue.addEvent(gameEvent);
        };
        this.handleMouseMove = function (event, canvas) {
            var pos = _this.getMousePosition(event, canvas);
            var gameEvent = new GameEvent_1["default"](GameEventType_1.GameEventType.MOUSE_MOVE, { position: pos });
            _this.eventQueue.addEvent(gameEvent);
        };
        this.handleKeyDown = function (event) {
            var key = _this.getKey(event);
            var gameEvent = new GameEvent_1["default"](GameEventType_1.GameEventType.KEY_DOWN, { key: key });
            _this.eventQueue.addEvent(gameEvent);
        };
        this.handleKeyUp = function (event) {
            var key = _this.getKey(event);
            var gameEvent = new GameEvent_1["default"](GameEventType_1.GameEventType.KEY_UP, { key: key });
            _this.eventQueue.addEvent(gameEvent);
        };
        this.handleBlur = function (event) {
            var gameEvent = new GameEvent_1["default"](GameEventType_1.GameEventType.CANVAS_BLUR, {});
            _this.eventQueue.addEvent(gameEvent);
        };
        this.handleContextMenu = function (event) {
            event.preventDefault();
            event.stopPropagation();
        };
        this.handleWheel = function (event) {
            event.preventDefault();
            event.stopPropagation();
            var gameEvent;
            if (event.deltaY < 0) {
                gameEvent = new GameEvent_1["default"](GameEventType_1.GameEventType.WHEEL_UP, {});
            }
            else {
                gameEvent = new GameEvent_1["default"](GameEventType_1.GameEventType.WHEEL_DOWN, {});
            }
            _this.eventQueue.addEvent(gameEvent);
        };
        this.eventQueue = EventQueue_1["default"].getInstance();
        canvas.onmousedown = function (event) { return _this.handleMouseDown(event, canvas); };
        canvas.onmouseup = function (event) { return _this.handleMouseUp(event, canvas); };
        canvas.oncontextmenu = this.handleContextMenu;
        canvas.onmousemove = function (event) { return _this.handleMouseMove(event, canvas); };
        document.onkeydown = this.handleKeyDown;
        document.onkeyup = this.handleKeyUp;
        document.onblur = this.handleBlur;
        document.oncontextmenu = this.handleBlur;
        document.onwheel = this.handleWheel;
    }
    InputHandler.prototype.getKey = function (keyEvent) {
        return keyEvent.key.toLowerCase();
    };
    InputHandler.prototype.getMousePosition = function (mouseEvent, canvas) {
        var rect = canvas.getBoundingClientRect();
        var x = mouseEvent.clientX - rect.left;
        var y = mouseEvent.clientY - rect.top;
        return new Vec2_1["default"](x, y);
    };
    return InputHandler;
}());
exports["default"] = InputHandler;
},{"../DataTypes/Vec2":20,"../Events/EventQueue":24,"../Events/GameEvent":25,"../Events/GameEventType":26}],30:[function(require,module,exports){
"use strict";
exports.__esModule = true;
// @ignorePage
/**
 * Sets up the environment of the game engine
 */
var EnvironmentInitializer = /** @class */ (function () {
    function EnvironmentInitializer() {
    }
    EnvironmentInitializer.setup = function () {
        CanvasRenderingContext2D.prototype.roundedRect = function (x, y, w, h, r) {
            // Clamp the radius between 0 and the min of the width or height
            if (r < 0)
                r = 0;
            if (r > Math.min(w, h))
                r = Math.min(w, h);
            // Draw the rounded rect
            this.beginPath();
            // Top
            this.moveTo(x + r, y);
            this.lineTo(x + w - r, y);
            this.arcTo(x + w, y, x + w, y + r, r);
            // Right
            this.lineTo(x + w, y + h - r);
            this.arcTo(x + w, y + h, x + w - r, y + h, r);
            // Bottom
            this.lineTo(x + r, y + h);
            this.arcTo(x, y + h, x, y + h - r, r);
            // Left
            this.lineTo(x, y + r);
            this.arcTo(x, y, x + r, y, r);
            this.closePath();
        };
        CanvasRenderingContext2D.prototype.strokeRoundedRect = function (x, y, w, h, r) {
            this.roundedRect(x, y, w, h, r);
            this.stroke();
        };
        CanvasRenderingContext2D.prototype.fillRoundedRect = function (x, y, w, h, r) {
            this.roundedRect(x, y, w, h, r);
            this.fill();
        };
    };
    return EnvironmentInitializer;
}());
exports["default"] = EnvironmentInitializer;
},{}],31:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
exports.__esModule = true;
var GameLoop_1 = require("./GameLoop");
var Debug_1 = require("../Debug/Debug");
var Stats_1 = require("../Debug/Stats");
/**
 * A game loop with a fixed update time and a variable render time.
 * Every frame, the game updates until all time since the last frame has been processed.
 * If too much time has passed, such as if the last update was too slow,
 * or if the browser was put into the background, the loop will panic and discard time.
 * A render happens at the end of every frame. This happens as fast as possible unless specified.
 * A loop of this type allows for deterministic behavior - No matter what the frame rate is, the update should behave the same,
 * as it is occuring in a fixed interval.
 */
var FixedUpdateGameLoop = /** @class */ (function (_super) {
    __extends(FixedUpdateGameLoop, _super);
    function FixedUpdateGameLoop() {
        var _this = _super.call(this) || this;
        /**
         * The main loop of the game. Updates until the current time is reached. Renders once
         * @param timestamp The current time in ms
         */
        _this.doFrame = function (timestamp) {
            // If a pause was executed, stop doing the loop.
            if (_this.paused) {
                return;
            }
            // Request animation frame to prepare for another update or render
            window.requestAnimationFrame(function (t) { return _this.doFrame(t); });
            // If we are trying to render too soon, do nothing.
            if (timestamp < _this.lastFrameTime + _this.minFrameDelay) {
                return;
            }
            // A frame is actually happening
            _this.startFrame(timestamp);
            // Update while there is still time to make up. If we do too many update steps, panic and exit the loop.
            _this.numUpdateSteps = 0;
            var panic = false;
            while (_this.frameDelta >= _this.updateTimestep) {
                // Do an update
                _this._doUpdate(_this.updateTimestep / 1000);
                // Remove the update step time from the time we have to process
                _this.frameDelta -= _this.updateTimestep;
                // Increment steps and check if we've done too many
                _this.numUpdateSteps++;
                if (_this.numUpdateSteps > 100) {
                    panic = true;
                    break;
                }
            }
            // Updates are done, render
            _this._doRender();
            // Wrap up the frame
            _this.finishFrame(panic);
        };
        _this.maxUpdateFPS = 60;
        _this.updateTimestep = Math.floor(1000 / _this.maxUpdateFPS);
        _this.frameDelta = 0;
        _this.lastFrameTime = 0;
        _this.minFrameDelay = 0;
        _this.frame = 0;
        _this.fps = _this.maxUpdateFPS; // Initialize the fps to the max allowed fps
        _this.fpsUpdateInterval = 1000;
        _this.lastFpsUpdate = 0;
        _this.framesSinceLastFpsUpdate = 0;
        _this.started = false;
        _this.paused = false;
        _this.running = false;
        _this.numUpdateSteps = 0;
        return _this;
    }
    FixedUpdateGameLoop.prototype.getFPS = function () {
        return 0;
    };
    /**
     * Updates the frame count and sum of time for the framerate of the game
     * @param timestep The current time in ms
     */
    FixedUpdateGameLoop.prototype.updateFPS = function (timestamp) {
        this.fps = 0.9 * this.framesSinceLastFpsUpdate * 1000 / (timestamp - this.lastFpsUpdate) + (1 - 0.9) * this.fps;
        this.lastFpsUpdate = timestamp;
        this.framesSinceLastFpsUpdate = 0;
        Debug_1["default"].log("fps", "FPS: " + this.fps.toFixed(1));
        Stats_1["default"].updateFPS(this.fps);
    };
    /**
 * Changes the maximum allowed physics framerate of the game
 * @param initMax The max framerate
 */
    FixedUpdateGameLoop.prototype.setMaxUpdateFPS = function (initMax) {
        this.maxUpdateFPS = initMax;
        this.updateTimestep = Math.floor(1000 / this.maxUpdateFPS);
    };
    /**
     * Sets the maximum rendering framerate
     * @param maxFPS The max framerate
     */
    FixedUpdateGameLoop.prototype.setMaxFPS = function (maxFPS) {
        this.minFrameDelay = 1000 / maxFPS;
    };
    /**
     * This function is called when the game loop panics, i.e. it tries to process too much time in an entire frame.
     * This will reset the amount of time back to zero.
     * @returns The amount of time we are discarding from processing.
     */
    FixedUpdateGameLoop.prototype.resetFrameDelta = function () {
        var oldFrameDelta = this.frameDelta;
        this.frameDelta = 0;
        return oldFrameDelta;
    };
    /**
     * Starts up the game loop and calls the first requestAnimationFrame
     */
    FixedUpdateGameLoop.prototype.start = function () {
        var _this = this;
        if (!this.started) {
            this.started = true;
            window.requestAnimationFrame(function (timestamp) { return _this.doFirstFrame(timestamp); });
        }
    };
    FixedUpdateGameLoop.prototype.pause = function () {
        this.paused = true;
    };
    FixedUpdateGameLoop.prototype.resume = function () {
        this.paused = false;
    };
    /**
     * The first game frame - initializes the first frame time and begins the render
     * @param timestamp The current time in ms
     */
    FixedUpdateGameLoop.prototype.doFirstFrame = function (timestamp) {
        var _this = this;
        this.running = true;
        this._doRender();
        this.lastFrameTime = timestamp;
        this.lastFpsUpdate = timestamp;
        this.framesSinceLastFpsUpdate = 0;
        window.requestAnimationFrame(function (t) { return _this.doFrame(t); });
    };
    /**
     * Handles any processing that needs to be done at the start of the frame
     * @param timestamp The time of the frame in ms
     */
    FixedUpdateGameLoop.prototype.startFrame = function (timestamp) {
        // Update the amount of time we need our update to process
        this.frameDelta += timestamp - this.lastFrameTime;
        // Set the new time of the last frame
        this.lastFrameTime = timestamp;
        // Update the estimate of the framerate
        if (timestamp > this.lastFpsUpdate + this.fpsUpdateInterval) {
            this.updateFPS(timestamp);
        }
        // Increment the number of frames
        this.frame++;
        this.framesSinceLastFpsUpdate++;
    };
    /**
     * Wraps up the frame and handles the panic state if there is one
     * @param panic Whether or not the loop panicked
     */
    FixedUpdateGameLoop.prototype.finishFrame = function (panic) {
        if (panic) {
            var discardedTime = Math.round(this.resetFrameDelta());
            console.warn('Main loop panicked, probably because the browser tab was put in the background. Discarding ' + discardedTime + 'ms');
        }
    };
    return FixedUpdateGameLoop;
}(GameLoop_1["default"]));
exports["default"] = FixedUpdateGameLoop;
},{"../Debug/Debug":21,"../Debug/Stats":22,"./GameLoop":33}],32:[function(require,module,exports){
"use strict";
exports.__esModule = true;
var EventQueue_1 = require("../Events/EventQueue");
var Input_1 = require("../Input/Input");
var InputHandler_1 = require("../Input/InputHandler");
var Recorder_1 = require("../Playback/Recorder");
var Debug_1 = require("../Debug/Debug");
var ResourceManager_1 = require("../ResourceManager/ResourceManager");
var Viewport_1 = require("../SceneGraph/Viewport");
var SceneManager_1 = require("../Scene/SceneManager");
var AudioManager_1 = require("../Sound/AudioManager");
var Stats_1 = require("../Debug/Stats");
var CanvasRenderer_1 = require("../Rendering/CanvasRenderer");
var Color_1 = require("../Utils/Color");
var GameOptions_1 = require("./GameOptions");
var FixedUpdateGameLoop_1 = require("./FixedUpdateGameLoop");
var EnvironmentInitializer_1 = require("./EnvironmentInitializer");
var Vec2_1 = require("../DataTypes/Vec2");
var RegistryManager_1 = require("../Registry/RegistryManager");
var WebGLRenderer_1 = require("../Rendering/WebGLRenderer");
/**
 * The main loop of the game engine.
 * Handles the update order, and initializes all subsystems.
 * The Game manages the update cycle, and requests animation frames to render to the browser.
 */
var Game = /** @class */ (function () {
    /**
     * Creates a new Game
     * @param options The options for Game initialization
     */
    function Game(options) {
        // Before anything else, build the environment
        EnvironmentInitializer_1["default"].setup();
        // Typecast the config object to a GameConfig object
        this.gameOptions = GameOptions_1["default"].parse(options);
        this.showDebug = this.gameOptions.showDebug;
        this.showStats = this.gameOptions.showStats;
        // Create an instance of a game loop
        this.loop = new FixedUpdateGameLoop_1["default"]();
        // Get the game canvas and give it a background color
        this.GAME_CANVAS = document.getElementById("game-canvas");
        this.DEBUG_CANVAS = document.getElementById("debug-canvas");
        // Give the canvas a size and get the rendering context
        this.WIDTH = this.gameOptions.canvasSize.x;
        this.HEIGHT = this.gameOptions.canvasSize.y;
        // This step MUST happen before the resource manager does anything
        if (this.gameOptions.useWebGL) {
            this.renderingManager = new WebGLRenderer_1["default"]();
        }
        else {
            this.renderingManager = new CanvasRenderer_1["default"]();
        }
        this.initializeGameWindow();
        this.ctx = this.renderingManager.initializeCanvas(this.GAME_CANVAS, this.WIDTH, this.HEIGHT);
        this.clearColor = new Color_1["default"](this.gameOptions.clearColor.r, this.gameOptions.clearColor.g, this.gameOptions.clearColor.b);
        // Initialize debugging and stats
        Debug_1["default"].initializeDebugCanvas(this.DEBUG_CANVAS, this.WIDTH, this.HEIGHT);
        Stats_1["default"].initStats();
        if (this.gameOptions.showStats) {
            // Find the stats output and make it no longer hidden
            document.getElementById("stats").hidden = false;
        }
        // Size the viewport to the game canvas
        var canvasSize = new Vec2_1["default"](this.WIDTH, this.HEIGHT);
        this.viewport = new Viewport_1["default"](canvasSize, this.gameOptions.zoomLevel);
        // Initialize all necessary game subsystems
        this.eventQueue = EventQueue_1["default"].getInstance();
        this.inputHandler = new InputHandler_1["default"](this.GAME_CANVAS);
        Input_1["default"].initialize(this.viewport, this.gameOptions.inputs);
        this.recorder = new Recorder_1["default"]();
        this.resourceManager = ResourceManager_1["default"].getInstance();
        this.sceneManager = new SceneManager_1["default"](this.viewport, this.renderingManager);
        this.audioManager = AudioManager_1["default"].getInstance();
    }
    /**
     * Set up the game window that holds the canvases
     */
    Game.prototype.initializeGameWindow = function () {
        var gameWindow = document.getElementById("game-window");
        // Set the height of the game window
        gameWindow.style.width = this.WIDTH + "px";
        gameWindow.style.height = this.HEIGHT + "px";
    };
    /**
     * Retreives the SceneManager from the Game
     * @returns The SceneManager
     */
    Game.prototype.getSceneManager = function () {
        return this.sceneManager;
    };
    /**
     * Starts the game
     */
    Game.prototype.start = function (InitialScene, options) {
        var _this = this;
        // Set the update function of the loop
        this.loop.doUpdate = function (deltaT) { return _this.update(deltaT); };
        // Set the render function of the loop
        this.loop.doRender = function () { return _this.render(); };
        // Preload registry items
        RegistryManager_1["default"].preload();
        // Load the items with the resource manager
        this.resourceManager.loadResourcesFromQueue(function () {
            // When we're done loading, start the loop
            console.log("Finished Preload - loading first scene");
            _this.sceneManager.changeToScene(InitialScene, {}, options);
            _this.loop.start();
        });
    };
    /**
     * Updates all necessary subsystems of the game. Defers scene updates to the sceneManager
     * @param deltaT The time sine the last update
     */
    Game.prototype.update = function (deltaT) {
        try {
            // Handle all events that happened since the start of the last loop
            this.eventQueue.update(deltaT);
            // Update the input data structures so game objects can see the input
            Input_1["default"].update(deltaT);
            // Update the recording of the game
            this.recorder.update(deltaT);
            // Update all scenes
            this.sceneManager.update(deltaT);
            // Update all sounds
            this.audioManager.update(deltaT);
            // Load or unload any resources if needed
            this.resourceManager.update(deltaT);
        }
        catch (e) {
            this.loop.pause();
            console.warn("Uncaught Error in Update - Crashing gracefully");
            console.error(e);
        }
    };
    /**
     * Clears the canvas and defers scene rendering to the sceneManager. Renders the debug canvas
     */
    Game.prototype.render = function () {
        try {
            // Clear the canvases
            Debug_1["default"].clearCanvas();
            this.renderingManager.clear(this.clearColor);
            this.sceneManager.render();
            // Hacky debug mode
            if (Input_1["default"].isKeyJustPressed("g")) {
                this.showDebug = !this.showDebug;
            }
            // Debug render
            if (this.showDebug) {
                Debug_1["default"].render();
            }
            if (this.showStats) {
                Stats_1["default"].render();
            }
        }
        catch (e) {
            this.loop.pause();
            console.warn("Uncaught Error in Render - Crashing gracefully");
            console.error(e);
        }
    };
    return Game;
}());
exports["default"] = Game;
},{"../DataTypes/Vec2":20,"../Debug/Debug":21,"../Debug/Stats":22,"../Events/EventQueue":24,"../Input/Input":28,"../Input/InputHandler":29,"../Playback/Recorder":58,"../Registry/RegistryManager":61,"../Rendering/CanvasRenderer":67,"../Rendering/WebGLRenderer":72,"../ResourceManager/ResourceManager":79,"../Scene/SceneManager":90,"../SceneGraph/Viewport":82,"../Sound/AudioManager":92,"../Utils/Color":94,"./EnvironmentInitializer":30,"./FixedUpdateGameLoop":31,"./GameOptions":34}],33:[function(require,module,exports){
"use strict";
exports.__esModule = true;
var NullFunc_1 = require("../DataTypes/Functions/NullFunc");
/**
 * The main game loop of the game. Keeps track of fps and handles scheduling of updates and rendering.
 * This class is left abstract, so that a subclass can handle exactly how the loop is scheduled.
 * For an example of different types of game loop scheduling, check out @link(Game Programming Patterns)(https://gameprogrammingpatterns.com/game-loop.html)
 */
var GameLoop = /** @class */ (function () {
    function GameLoop() {
        /** The function to call when an update occurs */
        this._doUpdate = NullFunc_1["default"];
        /** The function to call when a render occurs */
        this._doRender = NullFunc_1["default"];
    }
    Object.defineProperty(GameLoop.prototype, "doUpdate", {
        set: function (update) {
            this._doUpdate = update;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GameLoop.prototype, "doRender", {
        set: function (render) {
            this._doRender = render;
        },
        enumerable: false,
        configurable: true
    });
    return GameLoop;
}());
exports["default"] = GameLoop;
},{"../DataTypes/Functions/NullFunc":3}],34:[function(require,module,exports){
"use strict";
// @ignorePage
exports.__esModule = true;
/** The options for initializing the @reference[GameLoop] */
var GameOptions = /** @class */ (function () {
    function GameOptions() {
    }
    /**
     * Parses the data in the raw options object
     * @param options The game options as a Record
     * @returns A version of the options converted to a GameOptions object
     */
    GameOptions.parse = function (options) {
        var gOpt = new GameOptions();
        gOpt.canvasSize = options.canvasSize ? options.canvasSize : { x: 800, y: 600 };
        gOpt.zoomLevel = options.zoomLevel ? options.zoomLevel : 1;
        gOpt.clearColor = options.clearColor ? options.clearColor : { r: 255, g: 255, b: 255 };
        gOpt.inputs = options.inputs ? options.inputs : [];
        gOpt.showDebug = !!options.showDebug;
        gOpt.showStats = !!options.showStats;
        gOpt.useWebGL = !!options.useWebGL;
        return gOpt;
    };
    return GameOptions;
}());
exports["default"] = GameOptions;
},{}],35:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
exports.__esModule = true;
var GameNode_1 = require("./GameNode");
var Vec2_1 = require("../DataTypes/Vec2");
var AABB_1 = require("../DataTypes/Shapes/AABB");
var Debug_1 = require("../Debug/Debug");
var Color_1 = require("../Utils/Color");
/**
 * The representation of an object in the game world that can be drawn to the screen
 */
var CanvasNode = /** @class */ (function (_super) {
    __extends(CanvasNode, _super);
    function CanvasNode() {
        var _this = _super.call(this) || this;
        /** A flag for whether or not the CanvasNode is visible */
        _this.visible = true;
        _this._size = new Vec2_1["default"](0, 0);
        _this._size.setOnChange(function () { return _this.sizeChanged(); });
        _this._scale = new Vec2_1["default"](1, 1);
        _this._scale.setOnChange(function () { return _this.scaleChanged(); });
        _this._boundary = new AABB_1["default"]();
        _this.updateBoundary();
        _this._hasCustomShader = false;
        return _this;
    }
    Object.defineProperty(CanvasNode.prototype, "alpha", {
        get: function () {
            return this._alpha;
        },
        set: function (a) {
            this._alpha = a;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CanvasNode.prototype, "size", {
        get: function () {
            return this._size;
        },
        set: function (size) {
            var _this = this;
            this._size = size;
            // Enter as a lambda to bind "this"
            this._size.setOnChange(function () { return _this.sizeChanged(); });
            this.sizeChanged();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CanvasNode.prototype, "scale", {
        get: function () {
            return this._scale;
        },
        set: function (scale) {
            var _this = this;
            this._scale = scale;
            // Enter as a lambda to bind "this"
            this._scale.setOnChange(function () { return _this.scaleChanged(); });
            this.scaleChanged();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CanvasNode.prototype, "scaleX", {
        set: function (value) {
            this.scale.x = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CanvasNode.prototype, "scaleY", {
        set: function (value) {
            this.scale.y = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CanvasNode.prototype, "hasCustomShader", {
        get: function () {
            return this._hasCustomShader;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CanvasNode.prototype, "customShaderKey", {
        get: function () {
            return this._customShaderKey;
        },
        enumerable: false,
        configurable: true
    });
    // @override
    CanvasNode.prototype.positionChanged = function () {
        _super.prototype.positionChanged.call(this);
        this.updateBoundary();
    };
    /** Called if the size vector is changed or replaced. */
    CanvasNode.prototype.sizeChanged = function () {
        this.updateBoundary();
    };
    /** Called if the scale vector is changed or replaced */
    CanvasNode.prototype.scaleChanged = function () {
        this.updateBoundary();
    };
    // @docIgnore
    /** Called if the position, size, or scale of the CanvasNode is changed. Updates the boundary. */
    CanvasNode.prototype.updateBoundary = function () {
        this._boundary.center.set(this.position.x, this.position.y);
        this._boundary.halfSize.set(this.size.x * this.scale.x / 2, this.size.y * this.scale.y / 2);
    };
    Object.defineProperty(CanvasNode.prototype, "boundary", {
        get: function () {
            return this._boundary;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CanvasNode.prototype, "sizeWithZoom", {
        get: function () {
            var zoom = this.scene.getViewScale();
            return this.boundary.halfSize.clone().scaled(zoom, zoom);
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Adds a custom shader to this CanvasNode
     * @param key The registry key of the ShaderType
     */
    CanvasNode.prototype.useCustomShader = function (key) {
        this._hasCustomShader = true;
        this._customShaderKey = key;
    };
    /**
     * Returns true if the point (x, y) is inside of this canvas object
     * @param x The x position of the point
     * @param y The y position of the point
     * @returns A flag representing whether or not this node contains the point.
     */
    CanvasNode.prototype.contains = function (x, y) {
        return this._boundary.containsPoint(new Vec2_1["default"](x, y));
    };
    // @implemented
    CanvasNode.prototype.debugRender = function () {
        Debug_1["default"].drawBox(this.relativePosition, this.sizeWithZoom, false, Color_1["default"].BLUE);
        _super.prototype.debugRender.call(this);
    };
    return CanvasNode;
}(GameNode_1["default"]));
exports["default"] = CanvasNode;
},{"../DataTypes/Shapes/AABB":14,"../DataTypes/Vec2":20,"../Debug/Debug":21,"../Utils/Color":94,"./GameNode":36}],36:[function(require,module,exports){
"use strict";
exports.__esModule = true;
exports.TweenableProperties = void 0;
var Vec2_1 = require("../DataTypes/Vec2");
var Receiver_1 = require("../Events/Receiver");
var Emitter_1 = require("../Events/Emitter");
var Region_1 = require("../DataTypes/Interfaces/Region");
var AABB_1 = require("../DataTypes/Shapes/AABB");
var TweenController_1 = require("../Rendering/Animations/TweenController");
var Debug_1 = require("../Debug/Debug");
var Color_1 = require("../Utils/Color");
var Circle_1 = require("../DataTypes/Shapes/Circle");
/**
 * The representation of an object in the game world.
 * To construct GameNodes, see the @reference[Scene] documentation.
 */
var GameNode = /** @class */ (function () {
    // Constructor docs are ignored, as the user should NOT create new GameNodes with a raw constructor
    function GameNode() {
        var _this = this;
        /*---------- PHYSICAL ----------*/
        this.hasPhysics = false;
        this.moving = false;
        this.frozen = false;
        this.onGround = false;
        this.onWall = false;
        this.onCeiling = false;
        this.active = false;
        this.isColliding = false;
        this.pathfinding = false;
        this._position = new Vec2_1["default"](0, 0);
        this._position.setOnChange(function () { return _this.positionChanged(); });
        this.receiver = new Receiver_1["default"]();
        this.emitter = new Emitter_1["default"]();
        this.tweens = new TweenController_1["default"](this);
        this.rotation = 0;
    }
    GameNode.prototype.destroy = function () {
        this.tweens.destroy();
        this.receiver.destroy();
        if (this.hasPhysics) {
            this.removePhysics();
        }
        if (this._ai) {
            this._ai.destroy();
            delete this._ai;
            this.scene.getAIManager().removeActor(this);
        }
        this.scene.remove(this);
        this.layer.removeNode(this);
    };
    Object.defineProperty(GameNode.prototype, "position", {
        /*---------- POSITIONED ----------*/
        get: function () {
            return this._position;
        },
        set: function (pos) {
            var _this = this;
            this._position = pos;
            this._position.setOnChange(function () { return _this.positionChanged(); });
            this.positionChanged();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GameNode.prototype, "relativePosition", {
        get: function () {
            return this.inRelativeCoordinates(this.position);
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Converts a point to coordinates relative to the zoom and origin of this node
     * @param point The point to conver
     * @returns A new Vec2 representing the point in relative coordinates
     */
    GameNode.prototype.inRelativeCoordinates = function (point) {
        var origin = this.scene.getViewTranslation(this);
        var zoom = this.scene.getViewScale();
        return point.clone().sub(origin).scale(zoom);
    };
    Object.defineProperty(GameNode.prototype, "id", {
        /*---------- UNIQUE ----------*/
        get: function () {
            return this._id;
        },
        set: function (id) {
            // id can only be set once
            if (this._id === undefined) {
                this._id = id;
            }
            else {
                throw "Attempted to assign id to object that already has id.";
            }
        },
        enumerable: false,
        configurable: true
    });
    /*---------- PHYSICAL ----------*/
    // @implemented
    /**
     * @param velocity The velocity with which to move the object.
     */
    GameNode.prototype.move = function (velocity) {
        if (this.frozen)
            return;
        this.moving = true;
        this._velocity = velocity;
    };
    ;
    GameNode.prototype.moveOnPath = function (speed, path) {
        if (this.frozen)
            return;
        this.path = path;
        var dir = path.getMoveDirection(this);
        this.moving = true;
        this.pathfinding = true;
        this._velocity = dir.scale(speed);
    };
    // @implemented
    /**
     * @param velocity The velocity with which the object will move.
     */
    GameNode.prototype.finishMove = function () {
        this.moving = false;
        this.position.add(this._velocity);
        if (this.pathfinding) {
            this.path.handlePathProgress(this);
            this.path = null;
            this.pathfinding = false;
        }
    };
    // @implemented
    /**
     * @param collisionShape The collider for this object. If this has a region (implements Region),
     * it will be used when no collision shape is specified (or if collision shape is null).
     * @param isCollidable Whether this is collidable or not. True by default.
     * @param isStatic Whether this is static or not. False by default
     */
    GameNode.prototype.addPhysics = function (collisionShape, colliderOffset, isCollidable, isStatic) {
        if (isCollidable === void 0) { isCollidable = true; }
        if (isStatic === void 0) { isStatic = false; }
        // Initialize the physics variables
        this.hasPhysics = true;
        this.moving = false;
        this.onGround = false;
        this.onWall = false;
        this.onCeiling = false;
        this.active = true;
        this.isCollidable = isCollidable;
        this.isStatic = isStatic;
        this.isTrigger = false;
        this.triggerMask = 0;
        this.triggerEnters = new Array(32);
        this.triggerExits = new Array(32);
        this._velocity = Vec2_1["default"].ZERO;
        this.sweptRect = new AABB_1["default"]();
        this.collidedWithTilemap = false;
        this.group = -1; // The default group, collides with everything
        // Set the collision shape if provided, or simply use the the region if there is one.
        if (collisionShape) {
            this.collisionShape = collisionShape;
            this.collisionShape.center = this.position;
        }
        else if ((0, Region_1.isRegion)(this)) {
            // If the gamenode has a region and no other is specified, use that
            this.collisionShape = this.boundary.clone();
        }
        else {
            throw "No collision shape specified for physics object.";
        }
        // If we were provided with a collider offset, set it. Otherwise there is no offset, so use the zero vector
        if (colliderOffset) {
            this.colliderOffset = colliderOffset;
        }
        else {
            this.colliderOffset = Vec2_1["default"].ZERO;
        }
        // Initialize the swept rect
        this.sweptRect = this.collisionShape.getBoundingRect();
        // Register the object with physics
        this.scene.getPhysicsManager().registerObject(this);
    };
    /** Removes this object from the physics system */
    GameNode.prototype.removePhysics = function () {
        // Remove this from the physics manager
        this.scene.getPhysicsManager().deregisterObject(this);
        // Nullify all physics fields
        this.hasPhysics = false;
        this.moving = false;
        this.onGround = false;
        this.onWall = false;
        this.onCeiling = false;
        this.active = false;
        this.isCollidable = false;
        this.isStatic = false;
        this.isTrigger = false;
        this.triggerMask = 0;
        this.triggerEnters = null;
        this.triggerExits = null;
        this._velocity = Vec2_1["default"].ZERO;
        this.sweptRect = null;
        this.collidedWithTilemap = false;
        this.group = -1;
        this.collisionShape = null;
        this.colliderOffset = Vec2_1["default"].ZERO;
        this.sweptRect = null;
    };
    /** Disables physics movement for this node */
    GameNode.prototype.freeze = function () {
        this.frozen = true;
    };
    /** Reenables physics movement for this node */
    GameNode.prototype.unfreeze = function () {
        this.frozen = false;
    };
    /** Prevents this object from participating in all collisions and triggers. It can still move. */
    GameNode.prototype.disablePhysics = function () {
        this.active = false;
    };
    /** Enables this object to participate in collisions and triggers. This is only necessary if disablePhysics was called */
    GameNode.prototype.enablePhysics = function () {
        this.active = true;
    };
    /**
     * Sets the collider for this GameNode
     * @param collider The new collider to use
     */
    GameNode.prototype.setCollisionShape = function (collider) {
        this.collisionShape = collider;
        this.collisionShape.center.copy(this.position);
    };
    // @implemented
    /**
     * Sets this object to be a trigger for a specific group
     * @param group The name of the group that activates the trigger
     * @param onEnter The name of the event to send when this trigger is activated
     * @param onExit The name of the event to send when this trigger stops being activated
     */
    GameNode.prototype.setTrigger = function (group, onEnter, onExit) {
        // Make this object a trigger
        this.isTrigger = true;
        // Get the number of the physics layer
        var layerNumber = this.scene.getPhysicsManager().getGroupNumber(group);
        if (layerNumber === 0) {
            console.warn("Trigger for GameNode ".concat(this.id, " not set - group \"").concat(group, "\" was not recognized by the physics manager."));
            return;
        }
        // Add this to the trigger mask
        this.triggerMask |= layerNumber;
        // Layer numbers are bits, so get which bit it is
        var index = Math.log2(layerNumber);
        // Set the event names
        this.triggerEnters[index] = onEnter;
        this.triggerExits[index] = onExit;
    };
    ;
    // @implemented
    /**
     * @param group The physics group this node should belong to
     */
    GameNode.prototype.setGroup = function (group) {
        this.scene.getPhysicsManager().setGroup(this, group);
    };
    // @implemened
    GameNode.prototype.getLastVelocity = function () {
        return this._velocity;
    };
    Object.defineProperty(GameNode.prototype, "ai", {
        /*---------- ACTOR ----------*/
        get: function () {
            return this._ai;
        },
        set: function (ai) {
            if (!this._ai) {
                // If we haven't been previously had an ai, register us with the ai manager
                this.scene.getAIManager().registerActor(this);
            }
            this._ai = ai;
            this.aiActive = true;
        },
        enumerable: false,
        configurable: true
    });
    // @implemented
    GameNode.prototype.addAI = function (ai, options, type) {
        if (!this._ai) {
            this.scene.getAIManager().registerActor(this);
        }
        if (typeof ai === "string") {
            this._ai = this.scene.getAIManager().generateAI(ai);
        }
        else {
            this._ai = new ai();
        }
        // Question, how much do we want different type of AI to be handled the same, i.e. should GoapAI and AI similar methods and signatures for the sake of unity
        this._ai.initializeAI(this, options);
        this.aiActive = true;
    };
    // @implemented
    GameNode.prototype.setAIActive = function (active, options) {
        this.aiActive = active;
        if (this.aiActive) {
            this.ai.activate(options);
        }
    };
    Object.defineProperty(GameNode.prototype, "positionX", {
        /*---------- TWEENABLE PROPERTIES ----------*/
        set: function (value) {
            this.position.x = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GameNode.prototype, "positionY", {
        set: function (value) {
            this.position.y = value;
        },
        enumerable: false,
        configurable: true
    });
    /*---------- GAME NODE ----------*/
    /**
     * Sets the scene for this object.
     * @param scene The scene this object belongs to.
     */
    GameNode.prototype.setScene = function (scene) {
        this.scene = scene;
    };
    /**
     * Gets the scene this object is in.
     * @returns The scene this object belongs to
    */
    GameNode.prototype.getScene = function () {
        return this.scene;
    };
    /**
     * Sets the layer of this object.
     * @param layer The layer this object will be on.
     */
    GameNode.prototype.setLayer = function (layer) {
        this.layer = layer;
    };
    /**
     * Returns the layer this object is on.
     * @returns This layer this object is on.
    */
    GameNode.prototype.getLayer = function () {
        return this.layer;
    };
    /** Called if the position vector is modified or replaced */
    GameNode.prototype.positionChanged = function () {
        if (this.collisionShape) {
            if (this.colliderOffset) {
                this.collisionShape.center = this.position.clone().add(this.colliderOffset);
            }
            else {
                this.collisionShape.center = this.position.clone();
            }
        }
    };
    ;
    /**
     * Updates this GameNode
     * @param deltaT The timestep of the update.
     */
    GameNode.prototype.update = function (deltaT) {
        // Defer event handling to AI.
        while (this.receiver.hasNextEvent()) {
            this._ai.handleEvent(this.receiver.getNextEvent());
        }
    };
    // @implemented
    GameNode.prototype.debugRender = function () {
        // Draw the position of this GameNode
        Debug_1["default"].drawPoint(this.relativePosition, Color_1["default"].BLUE);
        // If velocity is not zero, draw a vector for it
        if (this._velocity && !this._velocity.isZero()) {
            Debug_1["default"].drawRay(this.relativePosition, this._velocity.clone().scaleTo(20).add(this.relativePosition), Color_1["default"].BLUE);
        }
        // If this has a collider, draw it
        if (this.collisionShape) {
            var color = this.isColliding ? Color_1["default"].RED : Color_1["default"].GREEN;
            if (this.isTrigger) {
                color = Color_1["default"].MAGENTA;
            }
            color.a = 0.2;
            if (this.collisionShape instanceof AABB_1["default"]) {
                Debug_1["default"].drawBox(this.inRelativeCoordinates(this.collisionShape.center), this.collisionShape.halfSize.scaled(this.scene.getViewScale()), true, color);
            }
            else if (this.collisionShape instanceof Circle_1["default"]) {
                Debug_1["default"].drawCircle(this.inRelativeCoordinates(this.collisionShape.center), this.collisionShape.hw * this.scene.getViewScale(), true, color);
            }
        }
    };
    return GameNode;
}());
exports["default"] = GameNode;
var TweenableProperties;
(function (TweenableProperties) {
    TweenableProperties["posX"] = "positionX";
    TweenableProperties["posY"] = "positionY";
    TweenableProperties["scaleX"] = "scaleX";
    TweenableProperties["scaleY"] = "scaleY";
    TweenableProperties["rotation"] = "rotation";
    TweenableProperties["alpha"] = "alpha";
})(TweenableProperties = exports.TweenableProperties || (exports.TweenableProperties = {}));
},{"../DataTypes/Interfaces/Region":7,"../DataTypes/Shapes/AABB":14,"../DataTypes/Shapes/Circle":15,"../DataTypes/Vec2":20,"../Debug/Debug":21,"../Events/Emitter":23,"../Events/Receiver":27,"../Rendering/Animations/TweenController":65,"../Utils/Color":94}],37:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
exports.__esModule = true;
var CanvasNode_1 = require("./CanvasNode");
var Color_1 = require("../Utils/Color");
/**
 * The representation of a game object that doesn't rely on any resources to render - it is drawn to the screen by the canvas
 */
var Graphic = /** @class */ (function (_super) {
    __extends(Graphic, _super);
    function Graphic() {
        var _this = _super.call(this) || this;
        _this.color = Color_1["default"].RED;
        return _this;
    }
    Object.defineProperty(Graphic.prototype, "alpha", {
        get: function () {
            return this.color.a;
        },
        set: function (a) {
            this.color.a = a;
        },
        enumerable: false,
        configurable: true
    });
    // @deprecated
    /**
     * Sets the color of the Graphic. DEPRECATED
     * @param color The new color of the Graphic.
     */
    Graphic.prototype.setColor = function (color) {
        this.color = color;
    };
    Object.defineProperty(Graphic.prototype, "colorR", {
        get: function () {
            return this.color.r;
        },
        set: function (r) {
            this.color.r = r;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Graphic.prototype, "colorG", {
        get: function () {
            return this.color.g;
        },
        set: function (g) {
            this.color.g = g;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Graphic.prototype, "colorB", {
        get: function () {
            return this.color.b;
        },
        set: function (b) {
            this.color.b = b;
        },
        enumerable: false,
        configurable: true
    });
    return Graphic;
}(CanvasNode_1["default"]));
exports["default"] = Graphic;
},{"../Utils/Color":94,"./CanvasNode":35}],38:[function(require,module,exports){
"use strict";
exports.__esModule = true;
exports.GraphicType = void 0;
var GraphicType;
(function (GraphicType) {
    GraphicType["POINT"] = "POINT";
    GraphicType["RECT"] = "RECT";
    GraphicType["LINE"] = "LINE";
    GraphicType["PARTICLE"] = "PARTICLE";
})(GraphicType = exports.GraphicType || (exports.GraphicType = {}));
},{}],39:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
exports.__esModule = true;
var Graphic_1 = require("../Graphic");
var Line = /** @class */ (function (_super) {
    __extends(Line, _super);
    function Line(start, end) {
        var _this = _super.call(this) || this;
        _this.start = start;
        _this.end = end;
        _this.thickness = 2;
        // Does this really have a meaning for lines?
        _this.size.set(5, 5);
        return _this;
    }
    Object.defineProperty(Line.prototype, "start", {
        get: function () {
            return this.position;
        },
        set: function (pos) {
            this.position = pos;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Line.prototype, "end", {
        get: function () {
            return this._end;
        },
        set: function (pos) {
            this._end = pos;
        },
        enumerable: false,
        configurable: true
    });
    return Line;
}(Graphic_1["default"]));
exports["default"] = Line;
},{"../Graphic":37}],40:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
exports.__esModule = true;
var Point_1 = require("./Point");
/**
 * - Position X
- Velocity (speed and direction) X
- Color X
- Lifetime
- Age can be handled as lifetime
- Shape X
- Size X
- Transparency X
 */
var Particle = /** @class */ (function (_super) {
    __extends(Particle, _super);
    function Particle(position, size, mass) {
        var _this = 
        // Are we making this a circle?
        _super.call(this, position) || this;
        _this.inUse = false;
        _this.mass = mass;
        return _this;
    }
    Particle.prototype.setParticleActive = function (lifetime, position) {
        this.age = lifetime;
        this.inUse = true;
        this.visible = true;
        this.position = position;
    };
    Particle.prototype.decrementAge = function (decay) {
        this.age -= decay;
    };
    Particle.prototype.setParticleInactive = function () {
        this.inUse = false;
        this.visible = false;
    };
    Object.defineProperty(Particle.prototype, "velY", {
        get: function () {
            return this.vel.y;
        },
        set: function (y) {
            this.vel.y = y;
        },
        enumerable: false,
        configurable: true
    });
    return Particle;
}(Point_1["default"]));
exports["default"] = Particle;
},{"./Point":41}],41:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
exports.__esModule = true;
var Graphic_1 = require("../Graphic");
/** A basic point to be drawn on the screen. */
var Point = /** @class */ (function (_super) {
    __extends(Point, _super);
    function Point(position) {
        var _this = 
        // Are we making this a circle?
        _super.call(this) || this;
        _this.position = position;
        _this.size.set(5, 5);
        return _this;
    }
    return Point;
}(Graphic_1["default"]));
exports["default"] = Point;
},{"../Graphic":37}],42:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
exports.__esModule = true;
var Graphic_1 = require("../Graphic");
var Color_1 = require("../../Utils/Color");
/** A basic rectangle to be drawn on the screen. */
var Rect = /** @class */ (function (_super) {
    __extends(Rect, _super);
    function Rect(position, size) {
        var _this = _super.call(this) || this;
        _this.position = position;
        _this.size = size;
        _this.borderColor = Color_1["default"].TRANSPARENT;
        _this.borderWidth = 0;
        return _this;
    }
    /**
     * Sets the border color of this rectangle
     * @param color The border color
     */
    Rect.prototype.setBorderColor = function (color) {
        this.borderColor = color;
    };
    // @deprecated
    Rect.prototype.getBorderColor = function () {
        return this.borderColor;
    };
    /**
     * Sets the border width of this rectangle
     * @param width The width of the rectangle in pixels
     */
    Rect.prototype.setBorderWidth = function (width) {
        this.borderWidth = width;
    };
    Rect.prototype.getBorderWidth = function () {
        return this.borderWidth;
    };
    return Rect;
}(Graphic_1["default"]));
exports["default"] = Rect;
},{"../../Utils/Color":94,"../Graphic":37}],43:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
exports.__esModule = true;
var Sprite_1 = require("./Sprite");
var AnimationManager_1 = require("../../Rendering/Animations/AnimationManager");
var Vec2_1 = require("../../DataTypes/Vec2");
/** An sprite with specified animation frames. */
var AnimatedSprite = /** @class */ (function (_super) {
    __extends(AnimatedSprite, _super);
    function AnimatedSprite(spritesheet) {
        var _this = _super.call(this, spritesheet.name) || this;
        _this.numCols = spritesheet.columns;
        _this.numRows = spritesheet.rows;
        // Set the size of the sprite to the sprite size specified by the spritesheet
        _this.size.set(spritesheet.spriteWidth, spritesheet.spriteHeight);
        _this.animation = new AnimationManager_1["default"](_this);
        // Add the animations to the animated sprite
        for (var _i = 0, _a = spritesheet.animations; _i < _a.length; _i++) {
            var animation = _a[_i];
            _this.animation.add(animation.name, animation);
        }
        return _this;
    }
    Object.defineProperty(AnimatedSprite.prototype, "cols", {
        get: function () {
            return this.numCols;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AnimatedSprite.prototype, "rows", {
        get: function () {
            return this.numRows;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Gets the image offset for the current index of animation
     * @param index The index we're at in the animation
     * @returns A Vec2 containing the image offset
     */
    AnimatedSprite.prototype.getAnimationOffset = function (index) {
        return new Vec2_1["default"]((index % this.numCols) * this.size.x, Math.floor(index / this.numCols) * this.size.y);
    };
    return AnimatedSprite;
}(Sprite_1["default"]));
exports["default"] = AnimatedSprite;
},{"../../DataTypes/Vec2":20,"../../Rendering/Animations/AnimationManager":62,"./Sprite":44}],44:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
exports.__esModule = true;
var CanvasNode_1 = require("../CanvasNode");
var ResourceManager_1 = require("../../ResourceManager/ResourceManager");
var Vec2_1 = require("../../DataTypes/Vec2");
/**
 * The representation of a sprite - an in-game image
 */
var Sprite = /** @class */ (function (_super) {
    __extends(Sprite, _super);
    function Sprite(imageId) {
        var _this = _super.call(this) || this;
        _this.imageId = imageId;
        var image = ResourceManager_1["default"].getInstance().getImage(_this.imageId);
        _this.size = new Vec2_1["default"](image.width, image.height);
        _this.imageOffset = Vec2_1["default"].ZERO;
        _this.invertX = false;
        _this.invertY = false;
        return _this;
    }
    /**
     * Sets the offset of the sprite from (0, 0) in the image's coordinates
     * @param offset The offset of the sprite from (0, 0) in image coordinates
     */
    Sprite.prototype.setImageOffset = function (offset) {
        this.imageOffset = offset;
    };
    return Sprite;
}(CanvasNode_1["default"]));
exports["default"] = Sprite;
},{"../../DataTypes/Vec2":20,"../../ResourceManager/ResourceManager":79,"../CanvasNode":35}],45:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
exports.__esModule = true;
var Vec2_1 = require("../DataTypes/Vec2");
var CanvasNode_1 = require("./CanvasNode");
/**
 * The representation of a tilemap - this can consist of a combination of tilesets in one layer
 */
var Tilemap = /** @class */ (function (_super) {
    __extends(Tilemap, _super);
    // TODO: Make this no longer be specific to Tiled
    function Tilemap(tilemapData, layer, tilesets, scale) {
        var _this = _super.call(this) || this;
        _this.tilesets = tilesets;
        _this.tileSize = new Vec2_1["default"](0, 0);
        _this.name = layer.name;
        var tilecount = 0;
        for (var _i = 0, tilesets_1 = tilesets; _i < tilesets_1.length; _i++) {
            var tileset = tilesets_1[_i];
            tilecount += tileset.getTileCount() + 1;
        }
        _this.collisionMap = new Array(tilecount);
        for (var i = 0; i < _this.collisionMap.length; i++) {
            _this.collisionMap[i] = false;
        }
        // Defer parsing of the data to child classes - this allows for isometric vs. orthographic tilemaps and handling of Tiled data or other data
        _this.parseTilemapData(tilemapData, layer);
        _this.scale.set(scale.x, scale.y);
        return _this;
    }
    /**
     * Returns an array of the tilesets associated with this tilemap
     * @returns An array of all of the tilesets assocaited with this tilemap.
     */
    Tilemap.prototype.getTilesets = function () {
        return this.tilesets;
    };
    /**
     * Returns the size of tiles in this tilemap as they appear in the game world after scaling
     * @returns A vector containing the size of tiles in this tilemap as they appear in the game world after scaling.
     */
    Tilemap.prototype.getTileSize = function () {
        return this.tileSize.scaled(this.scale.x, this.scale.y);
    };
    /**
     * Gets the tile size taking zoom into account
     * @returns The tile size with zoom
    */
    Tilemap.prototype.getTileSizeWithZoom = function () {
        var zoom = this.scene.getViewScale();
        return this.getTileSize().scale(zoom);
    };
    /**
     * Adds this tilemap to the physics system
    */
    Tilemap.prototype.addPhysics = function () {
        this.hasPhysics = true;
        this.active = true;
        this.group = -1;
        this.scene.getPhysicsManager().registerTilemap(this);
    };
    return Tilemap;
}(CanvasNode_1["default"]));
exports["default"] = Tilemap;
},{"../DataTypes/Vec2":20,"./CanvasNode":35}],46:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
exports.__esModule = true;
var Tilemap_1 = require("../Tilemap");
var Vec2_1 = require("../../DataTypes/Vec2");
var Debug_1 = require("../../Debug/Debug");
var Color_1 = require("../../Utils/Color");
/**
 * The representation of an orthogonal tilemap - i.e. a top down or platformer tilemap
 */
var OrthogonalTilemap = /** @class */ (function (_super) {
    __extends(OrthogonalTilemap, _super);
    function OrthogonalTilemap() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    // @override
    OrthogonalTilemap.prototype.parseTilemapData = function (tilemapData, layer) {
        // The size of the tilemap in local space
        this.numCols = tilemapData.width;
        this.numRows = tilemapData.height;
        // The size of tiles
        this.tileSize.set(tilemapData.tilewidth, tilemapData.tileheight);
        // The size of the tilemap on the canvas
        this.size.set(this.numCols * this.tileSize.x, this.numRows * this.tileSize.y);
        this.position.copy(this.size.scaled(0.5));
        this.data = layer.data;
        this.visible = layer.visible;
        // Whether the tilemap is collidable or not
        this.isCollidable = false;
        if (layer.properties) {
            for (var _i = 0, _a = layer.properties; _i < _a.length; _i++) {
                var item = _a[_i];
                if (item.name === "Collidable") {
                    this.isCollidable = item.value;
                    // Set all tiles besides "empty: 0" to be collidable
                    for (var i = 1; i < this.collisionMap.length; i++) {
                        this.collisionMap[i] = true;
                    }
                }
            }
        }
    };
    /**
     * Gets the dimensions of the tilemap
     * @returns A Vec2 containing the number of columns and the number of rows in the tilemap.
     */
    OrthogonalTilemap.prototype.getDimensions = function () {
        return new Vec2_1["default"](this.numCols, this.numRows);
    };
    /**
     * Gets the data value of the tile at the specified world position
     * @param worldCoords The coordinates in world space
     * @returns The data value of the tile
     */
    OrthogonalTilemap.prototype.getTileAtWorldPosition = function (worldCoords) {
        var localCoords = this.getColRowAt(worldCoords);
        return this.getTileAtRowCol(localCoords);
    };
    /**
     * Get the tile at the specified row and column
     * @param rowCol The coordinates in tilemap space
     * @returns The data value of the tile
     */
    OrthogonalTilemap.prototype.getTileAtRowCol = function (rowCol) {
        if (rowCol.x < 0 || rowCol.x >= this.numCols || rowCol.y < 0 || rowCol.y >= this.numRows) {
            return -1;
        }
        return this.data[rowCol.y * this.numCols + rowCol.x];
    };
    /**
     * Gets the world position of the tile at the specified index
     * @param index The index of the tile
     * @returns A Vec2 containing the world position of the tile
     */
    OrthogonalTilemap.prototype.getTileWorldPosition = function (index) {
        // Get the local position
        var col = index % this.numCols;
        var row = Math.floor(index / this.numCols);
        // Get the world position
        var x = col * this.tileSize.x;
        var y = row * this.tileSize.y;
        return new Vec2_1["default"](x, y);
    };
    /**
     * Gets the data value of the tile at the specified index
     * @param index The index of the tile
     * @returns The data value of the tile
     */
    OrthogonalTilemap.prototype.getTile = function (index) {
        return this.data[index];
    };
    // @override
    OrthogonalTilemap.prototype.setTile = function (index, type) {
        this.data[index] = type;
    };
    /**
     * Sets the tile at the specified row and column
     * @param rowCol The position of the tile in tilemap space
     * @param type The new data value of the tile
     */
    OrthogonalTilemap.prototype.setTileAtRowCol = function (rowCol, type) {
        var index = rowCol.y * this.numCols + rowCol.x;
        this.setTile(index, type);
    };
    /**
     * Returns true if the tile at the specified row and column of the tilemap is collidable
     * @param indexOrCol The index of the tile or the column it is in
     * @param row The row the tile is in
     * @returns A flag representing whether or not the tile is collidable.
     */
    OrthogonalTilemap.prototype.isTileCollidable = function (indexOrCol, row) {
        // The value of the tile
        var tile = 0;
        if (row) {
            // We have a column and a row
            tile = this.getTileAtRowCol(new Vec2_1["default"](indexOrCol, row));
            if (tile < 0) {
                return false;
            }
        }
        else {
            if (indexOrCol < 0 || indexOrCol >= this.data.length) {
                // Tiles that don't exist aren't collidable
                return false;
            }
            // We have an index
            tile = this.getTile(indexOrCol);
        }
        return this.collisionMap[tile];
    };
    /**
     * Takes in world coordinates and returns the row and column of the tile at that position
     * @param worldCoords The coordinates of the potential tile in world space
     * @returns A Vec2 containing the coordinates of the potential tile in tilemap space
     */
    OrthogonalTilemap.prototype.getColRowAt = function (worldCoords) {
        var col = Math.floor(worldCoords.x / this.tileSize.x / this.scale.x);
        var row = Math.floor(worldCoords.y / this.tileSize.y / this.scale.y);
        return new Vec2_1["default"](col, row);
    };
    // @override
    OrthogonalTilemap.prototype.update = function (deltaT) { };
    // @override
    OrthogonalTilemap.prototype.debugRender = function () {
        // Half of the tile size
        var zoomedHalfTileSize = this.getTileSizeWithZoom().scaled(0.5);
        var halfTileSize = this.getTileSize().scaled(0.5);
        // The center of the top left tile
        var topLeft = this.position.clone().sub(this.size.scaled(0.5));
        // A vec to store the center
        var center = Vec2_1["default"].ZERO;
        for (var col = 0; col < this.numCols; col++) {
            // Calculate the x-position
            center.x = topLeft.x + col * 2 * halfTileSize.x + halfTileSize.x;
            for (var row = 0; row < this.numRows; row++) {
                if (this.isCollidable && this.isTileCollidable(col, row)) {
                    // Calculate the y-position
                    center.y = topLeft.y + row * 2 * halfTileSize.y + halfTileSize.y;
                    // Draw a box for this tile
                    Debug_1["default"].drawBox(this.inRelativeCoordinates(center), zoomedHalfTileSize, false, Color_1["default"].BLUE);
                }
            }
        }
    };
    return OrthogonalTilemap;
}(Tilemap_1["default"]));
exports["default"] = OrthogonalTilemap;
},{"../../DataTypes/Vec2":20,"../../Debug/Debug":21,"../../Utils/Color":94,"../Tilemap":45}],47:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
exports.__esModule = true;
var CanvasNode_1 = require("./CanvasNode");
var Color_1 = require("../Utils/Color");
var Vec2_1 = require("../DataTypes/Vec2");
var Input_1 = require("../Input/Input");
/**
 * The representation of a UIElement - the parent class of things like buttons
 */
var UIElement = /** @class */ (function (_super) {
    __extends(UIElement, _super);
    function UIElement(position) {
        var _this = _super.call(this) || this;
        _this.position = position;
        _this.backgroundColor = new Color_1["default"](0, 0, 0, 0);
        _this.borderColor = new Color_1["default"](0, 0, 0, 0);
        _this.borderRadius = 5;
        _this.borderWidth = 1;
        _this.padding = Vec2_1["default"].ZERO;
        _this.onClick = null;
        _this.onClickEventId = null;
        _this.onRelease = null;
        _this.onReleaseEventId = null;
        _this.onEnter = null;
        _this.onEnterEventId = null;
        _this.onLeave = null;
        _this.onLeaveEventId = null;
        _this.isClicked = false;
        _this.isEntered = false;
        return _this;
    }
    // @deprecated
    UIElement.prototype.setBackgroundColor = function (color) {
        this.backgroundColor = color;
    };
    // @deprecated
    UIElement.prototype.setPadding = function (padding) {
        this.padding.copy(padding);
    };
    UIElement.prototype.update = function (deltaT) {
        _super.prototype.update.call(this, deltaT);
        // See of this object was just clicked
        if (Input_1["default"].isMouseJustPressed()) {
            var clickPos = Input_1["default"].getMousePressPosition();
            if (this.contains(clickPos.x, clickPos.y) && this.visible && !this.layer.isHidden()) {
                this.isClicked = true;
                if (this.onClick !== null) {
                    this.onClick();
                }
                if (this.onClickEventId !== null) {
                    var data = {};
                    this.emitter.fireEvent(this.onClickEventId, data);
                }
            }
        }
        // If the mouse wasn't just pressed, then we definitely weren't clicked
        if (!Input_1["default"].isMousePressed()) {
            if (this.isClicked) {
                this.isClicked = false;
            }
        }
        // Check if the mouse is hovering over this element
        var mousePos = Input_1["default"].getMousePosition();
        if (mousePos && this.contains(mousePos.x, mousePos.y)) {
            this.isEntered = true;
            if (this.onEnter !== null) {
                this.onEnter();
            }
            if (this.onEnterEventId !== null) {
                var data = {};
                this.emitter.fireEvent(this.onEnterEventId, data);
            }
        }
        else if (this.isEntered) {
            this.isEntered = false;
            if (this.onLeave !== null) {
                this.onLeave();
            }
            if (this.onLeaveEventId !== null) {
                var data = {};
                this.emitter.fireEvent(this.onLeaveEventId, data);
            }
        }
        else if (this.isClicked) {
            // If mouse is dragged off of element while down, it is not clicked anymore
            this.isClicked = false;
        }
    };
    /**
     * Overridable method for calculating background color - useful for elements that want to be colored on different after certain events
     * @returns The background color of the UIElement
     */
    UIElement.prototype.calculateBackgroundColor = function () {
        return this.backgroundColor;
    };
    /**
     * Overridable method for calculating border color - useful for elements that want to be colored on different after certain events
     * @returns The border color of the UIElement
     */
    UIElement.prototype.calculateBorderColor = function () {
        return this.borderColor;
    };
    return UIElement;
}(CanvasNode_1["default"]));
exports["default"] = UIElement;
},{"../DataTypes/Vec2":20,"../Input/Input":28,"../Utils/Color":94,"./CanvasNode":35}],48:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
exports.__esModule = true;
var Label_1 = require("./Label");
var Color_1 = require("../../Utils/Color");
/** A clickable button UIElement */
var Button = /** @class */ (function (_super) {
    __extends(Button, _super);
    function Button(position, text) {
        var _this = _super.call(this, position, text) || this;
        _this.backgroundColor = new Color_1["default"](150, 75, 203);
        _this.borderColor = new Color_1["default"](41, 46, 30);
        _this.textColor = new Color_1["default"](255, 255, 255);
        return _this;
    }
    // @override
    Button.prototype.calculateBackgroundColor = function () {
        // Change the background color if clicked or hovered
        if (this.isEntered && !this.isClicked) {
            return this.backgroundColor.lighten();
        }
        else if (this.isClicked) {
            return this.backgroundColor.darken();
        }
        else {
            return this.backgroundColor;
        }
    };
    Button.prototype.clone = function (orig, onClickEventId) {
        this.backgroundColor = orig.backgroundColor;
        this.borderColor = orig.borderColor;
        this.textColor = orig.textColor;
        this.size = orig.size;
        this.borderWidth = orig.borderWidth;
        this.onClickEventId = onClickEventId;
    };
    return Button;
}(Label_1["default"]));
exports["default"] = Button;
},{"../../Utils/Color":94,"./Label":49}],49:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
exports.__esModule = true;
exports.HAlign = exports.VAlign = void 0;
var Vec2_1 = require("../../DataTypes/Vec2");
var Color_1 = require("../../Utils/Color");
var UIElement_1 = require("../UIElement");
/** A basic text-containing label */
var Label = /** @class */ (function (_super) {
    __extends(Label, _super);
    function Label(position, text) {
        var _this = _super.call(this, position) || this;
        _this.text = text;
        _this.textColor = new Color_1["default"](0, 0, 0, 1);
        _this.font = "Arial";
        _this.fontSize = 30;
        _this.hAlign = "center";
        _this.vAlign = "center";
        _this.sizeAssigned = false;
        return _this;
    }
    // @deprecated
    Label.prototype.setText = function (text) {
        this.text = text;
    };
    // @deprecated
    Label.prototype.setTextColor = function (color) {
        this.textColor = color;
    };
    /**
     * Gets a string containg the font details for rendering
     * @returns A string containing the font details
     */
    Label.prototype.getFontString = function () {
        return this.fontSize + "px " + this.font;
    };
    /**
     * Overridable method for calculating text color - useful for elements that want to be colored on different after certain events
     * @returns a string containg the text color
     */
    Label.prototype.calculateTextColor = function () {
        return this.textColor.toStringRGBA();
    };
    /**
     * Uses the canvas to calculate the width of the text
     * @param ctx The rendering context
     * @returns A number representing the rendered text width
     */
    Label.prototype.calculateTextWidth = function (ctx) {
        ctx.font = this.fontSize + "px " + this.font;
        return ctx.measureText(this.text).width;
    };
    Label.prototype.setHAlign = function (align) {
        this.hAlign = align;
    };
    Label.prototype.setVAlign = function (align) {
        this.vAlign = align;
    };
    /**
     * Calculate the offset of the text - this is used for rendering text with different alignments
     * @param ctx The rendering context
     * @returns The offset of the text in a Vec2
     */
    Label.prototype.calculateTextOffset = function (ctx) {
        var textWidth = this.calculateTextWidth(ctx);
        var offset = new Vec2_1["default"](0, 0);
        var hDiff = this.size.x - textWidth;
        if (this.hAlign === HAlign.CENTER) {
            offset.x = hDiff / 2;
        }
        else if (this.hAlign === HAlign.RIGHT) {
            offset.x = hDiff;
        }
        if (this.vAlign === VAlign.TOP) {
            ctx.textBaseline = "top";
            offset.y = 0;
        }
        else if (this.vAlign === VAlign.BOTTOM) {
            ctx.textBaseline = "bottom";
            offset.y = this.size.y;
        }
        else {
            ctx.textBaseline = "middle";
            offset.y = this.size.y / 2;
        }
        return offset;
    };
    Label.prototype.sizeChanged = function () {
        _super.prototype.sizeChanged.call(this);
        this.sizeAssigned = true;
    };
    /**
     * Automatically sizes the element to the text within it
     * @param ctx The rendering context
     */
    Label.prototype.autoSize = function (ctx) {
        var width = this.calculateTextWidth(ctx);
        var height = this.fontSize;
        this.size.set(width + this.padding.x * 2, height + this.padding.y * 2);
        this.sizeAssigned = true;
    };
    /**
     * Initially assigns a size to the UIElement if none is provided
     * @param ctx The rendering context
     */
    Label.prototype.handleInitialSizing = function (ctx) {
        if (!this.sizeAssigned) {
            this.autoSize(ctx);
        }
    };
    /** On the next render, size this element to it's current text using its current font size */
    Label.prototype.sizeToText = function () {
        this.sizeAssigned = false;
    };
    Object.defineProperty(Label.prototype, "textAlpha", {
        get: function () {
            return this.textColor.a;
        },
        set: function (a) {
            this.textColor.a = a;
        },
        enumerable: false,
        configurable: true
    });
    return Label;
}(UIElement_1["default"]));
exports["default"] = Label;
var VAlign;
(function (VAlign) {
    VAlign["TOP"] = "top";
    VAlign["CENTER"] = "center";
    VAlign["BOTTOM"] = "bottom";
})(VAlign = exports.VAlign || (exports.VAlign = {}));
var HAlign;
(function (HAlign) {
    HAlign["LEFT"] = "left";
    HAlign["CENTER"] = "center";
    HAlign["RIGHT"] = "right";
})(HAlign = exports.HAlign || (exports.HAlign = {}));
},{"../../DataTypes/Vec2":20,"../../Utils/Color":94,"../UIElement":47}],50:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
exports.__esModule = true;
var Vec2_1 = require("../../DataTypes/Vec2");
var Input_1 = require("../../Input/Input");
var Color_1 = require("../../Utils/Color");
var MathUtils_1 = require("../../Utils/MathUtils");
var UIElement_1 = require("../UIElement");
/** A slider UIElement */
var Slider = /** @class */ (function (_super) {
    __extends(Slider, _super);
    function Slider(position, initValue) {
        var _this = _super.call(this, position) || this;
        _this.value = initValue;
        _this.nibColor = Color_1["default"].RED;
        _this.sliderColor = Color_1["default"].BLACK;
        _this.backgroundColor = Color_1["default"].TRANSPARENT;
        _this.borderColor = Color_1["default"].TRANSPARENT;
        _this.nibSize = new Vec2_1["default"](10, 20);
        // Set a default size
        _this.size.set(200, 20);
        return _this;
    }
    /**
     * Retrieves the value of the slider
     * @returns The value of the slider
     */
    Slider.prototype.getValue = function () {
        return this.value;
    };
    /** A method called in response to the value changing */
    Slider.prototype.valueChanged = function () {
        if (this.onValueChange) {
            this.onValueChange(this.value);
        }
        if (this.onValueChangeEventId) {
            this.emitter.fireEvent(this.onValueChangeEventId, { target: this, value: this.value });
        }
    };
    Slider.prototype.update = function (deltaT) {
        _super.prototype.update.call(this, deltaT);
        if (this.isClicked) {
            var val = MathUtils_1["default"].invLerp(this.position.x - this.size.x / 2, this.position.x + this.size.x / 2, Input_1["default"].getMousePosition().x);
            this.value = MathUtils_1["default"].clamp01(val);
            this.valueChanged();
        }
    };
    return Slider;
}(UIElement_1["default"]));
exports["default"] = Slider;
},{"../../DataTypes/Vec2":20,"../../Input/Input":28,"../../Utils/Color":94,"../../Utils/MathUtils":97,"../UIElement":47}],51:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
exports.__esModule = true;
var Color_1 = require("../../Utils/Color");
var Label_1 = require("./Label");
var Input_1 = require("../../Input/Input");
/** A text input UIElement */
var TextInput = /** @class */ (function (_super) {
    __extends(TextInput, _super);
    function TextInput(position) {
        var _this = _super.call(this, position, "") || this;
        _this.focused = false;
        _this.cursorCounter = 0;
        // Give a default size to the x only
        _this.size.set(200, _this.fontSize);
        _this.hAlign = "left";
        _this.borderColor = Color_1["default"].BLACK;
        _this.backgroundColor = Color_1["default"].WHITE;
        return _this;
    }
    TextInput.prototype.update = function (deltaT) {
        _super.prototype.update.call(this, deltaT);
        if (Input_1["default"].isMouseJustPressed()) {
            var clickPos = Input_1["default"].getMousePressPosition();
            if (this.contains(clickPos.x, clickPos.y)) {
                this.focused = true;
                this.cursorCounter = 30;
            }
            else {
                this.focused = false;
            }
        }
        if (this.focused) {
            var keys = Input_1["default"].getKeysJustPressed();
            var nums = "1234567890";
            var specialChars = "`~!@#$%^&*()-_=+[{]}\\|;:'\",<.>/?";
            var letters = "qwertyuiopasdfghjklzxcvbnm";
            var mask_1 = nums + specialChars + letters;
            keys = keys.filter(function (key) { return mask_1.includes(key); });
            var shiftPressed = Input_1["default"].isKeyPressed("shift");
            var backspacePressed = Input_1["default"].isKeyJustPressed("backspace");
            var spacePressed = Input_1["default"].isKeyJustPressed("space");
            if (backspacePressed) {
                this.text = this.text.substring(0, this.text.length - 1);
            }
            else if (spacePressed) {
                this.text += " ";
            }
            else if (keys.length > 0) {
                if (shiftPressed) {
                    this.text += keys[0].toUpperCase();
                }
                else {
                    this.text += keys[0];
                }
            }
        }
    };
    return TextInput;
}(Label_1["default"]));
exports["default"] = TextInput;
},{"../../Input/Input":28,"../../Utils/Color":94,"./Label":49}],52:[function(require,module,exports){
"use strict";
exports.__esModule = true;
exports.UIElementType = void 0;
var UIElementType;
(function (UIElementType) {
    UIElementType["BUTTON"] = "BUTTON";
    UIElementType["LABEL"] = "LABEL";
    UIElementType["SLIDER"] = "SLIDER";
    UIElementType["TEXT_INPUT"] = "TEXTINPUT";
})(UIElementType = exports.UIElementType || (exports.UIElementType = {}));
},{}],53:[function(require,module,exports){
"use strict";
exports.__esModule = true;
var Map_1 = require("../DataTypes/Map");
/**
 * The manager class for navigation.
 * Handles all navigable entities, such and allows them to be accessed by outside systems by requesting a path
 * from one position to another.
 */
var NavigationManager = /** @class */ (function () {
    function NavigationManager() {
        this.navigableEntities = new Map_1["default"]();
    }
    /**
     * Adds a navigable entity to the NavigationManager
     * @param navName The name of the navigable entitry
     * @param nav The actual Navigable instance
     */
    NavigationManager.prototype.addNavigableEntity = function (navName, nav) {
        this.navigableEntities.add(navName, nav);
    };
    /**
     * Gets a path frome one point to another using a specified Navigable object
     * @param navName The name of the registered Navigable object
     * @param fromPosition The starting position of navigation
     * @param toPosition The ending position of Navigation
     * @param direct If true, go direct from fromPosition to toPosition, don't use NavMesh
     * @returns A NavigationPath containing the route to take over the Navigable entity to get between the provided positions.
     */
    NavigationManager.prototype.getPath = function (navName, fromPosition, toPosition, direct) {
        var nav = this.navigableEntities.get(navName);
        return nav.getNavigationPath(fromPosition.clone(), toPosition.clone(), direct);
    };
    return NavigationManager;
}());
exports["default"] = NavigationManager;
},{"../DataTypes/Map":8}],54:[function(require,module,exports){
"use strict";
exports.__esModule = true;
var Vec2_1 = require("../DataTypes/Vec2");
/**
 * A path that AIs can follow. Uses finishMove() in Physical to determine progress on the route
 */
var NavigationPath = /** @class */ (function () {
    /**
     * Constructs a new NavigationPath
     * @param path The path of nodes to take
     */
    function NavigationPath(path) {
        this.path = path;
        this.currentMoveDirection = Vec2_1["default"].ZERO;
        this.distanceThreshold = 4;
    }
    /**
     * Returns the status of navigation along this NavigationPath
     * @returns True if the node has reached the end of the path, false otherwise
     */
    NavigationPath.prototype.isDone = function () {
        return this.path.isEmpty();
    };
    /**
     * Gets the movement direction in the current position along the path
     * @param node The node to move along the path
     * @returns The movement direction as a Vec2
     */
    NavigationPath.prototype.getMoveDirection = function (node) {
        // Return direction to next point in the nav
        return node.position.dirTo(this.path.peek());
    };
    /**
     * Updates this NavigationPath to the current state of the GameNode
     * @param node The node moving along the path
     */
    NavigationPath.prototype.handlePathProgress = function (node) {
        if (node.position.distanceSqTo(this.path.peek()) < this.distanceThreshold * this.distanceThreshold) {
            // We've reached our node, move on to the next destination
            this.path.pop();
        }
    };
    NavigationPath.prototype.toString = function () {
        return this.path.toString();
    };
    return NavigationPath;
}());
exports["default"] = NavigationPath;
},{"../DataTypes/Vec2":20}],55:[function(require,module,exports){
"use strict";
exports.__esModule = true;
var Stack_1 = require("../DataTypes/Stack");
var GraphUtils_1 = require("../Utils/GraphUtils");
var NavigationPath_1 = require("./NavigationPath");
/**
 * An implementation of a Navmesh. Navmeshes are graphs in the game world along which nodes can move.
 */
var Navmesh = /** @class */ (function () {
    /**
     * Creates a new Navmesh from the points in the speecified graph
     * @param graph The graph to construct a navmesh from
     */
    function Navmesh(graph) {
        this.graph = graph;
    }
    // @implemented
    Navmesh.prototype.getNavigationPath = function (fromPosition, toPosition, direct) {
        var start = this.getClosestNode(fromPosition);
        var end = this.getClosestNode(toPosition);
        var pathStack = new Stack_1["default"](this.graph.numVertices);
        // Push the final position and the final position in the graph
        pathStack.push(toPosition.clone());
        if (direct) {
            return new NavigationPath_1["default"](pathStack);
        }
        pathStack.push(this.graph.positions[end]);
        var parent = GraphUtils_1["default"].djikstra(this.graph, start);
        // Add all parents along the path
        var i = end;
        while (parent[i] !== -1) {
            pathStack.push(this.graph.positions[parent[i]]);
            i = parent[i];
        }
        return new NavigationPath_1["default"](pathStack);
    };
    /**
     * Gets the closest node in this Navmesh to the specified position
     * @param position The position to query
     * @returns The index of the closest node in the Navmesh to the position
     */
    Navmesh.prototype.getClosestNode = function (position) {
        var n = this.graph.numVertices;
        var i = 1;
        var index = 0;
        var dist = position.distanceSqTo(this.graph.positions[0]);
        while (i < n) {
            var d = position.distanceSqTo(this.graph.positions[i]);
            if (d < dist) {
                dist = d;
                index = i;
            }
            i++;
        }
        return index;
    };
    return Navmesh;
}());
exports["default"] = Navmesh;
},{"../DataTypes/Stack":17,"../Utils/GraphUtils":96,"./NavigationPath":54}],56:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
exports.__esModule = true;
var PhysicsManager_1 = require("./PhysicsManager");
var Vec2_1 = require("../DataTypes/Vec2");
var AABB_1 = require("../DataTypes/Shapes/AABB");
var OrthogonalTilemap_1 = require("../Nodes/Tilemaps/OrthogonalTilemap");
var AreaCollision_1 = require("../DataTypes/Physics/AreaCollision");
/**
 * ALGORITHM:
 * 	In an effort to keep things simple and working effectively, each dynamic node will resolve its
 * 	collisions considering the rest of the world as static.
 *
 * 	Collision detecting will happen first. This can be considered a broad phase, but it is not especially
 * 	efficient, as it does not need to be for this game engine. Every dynamic node is checked against every
 * 	other node for collision area. If collision area is non-zero (meaning the current node sweeps into another),
 * 	it is added to a list of hits.
 *
 * 	INITIALIZATION:
 * 		- Physics constants are reset
 * 		- Swept shapes are recalculated. If a node isn't moving, it is skipped.
 *
 * 	COLLISION DETECTION:
 * 		- For a node, collision area will be calculated using the swept AABB of the node against every other AABB in a static state
 * 		- These collisions will be sorted by area in descending order
 *
 * 	COLLISION RESOLUTION:
 * 		- For each hit, time of collision is calculated using a swept line through the AABB of the static node expanded
 * 			with minkowski sums (discretely, but the concept is there)
 * 		- The collision is resolved based on the near time of the collision (from method of separated axes)
 * 			- X is resolved by near x, Y by near y.
 * 			- There is some fudging to allow for sliding along walls of separate colliders. Sorting by area also helps with this.
 * 			- Corner to corner collisions are resolve to favor x-movement. This is in consideration of platformers, to give
 * 				the player some help with jumps
 *
 * 	Pros:
 * 		- Everything happens with a consistent time. There is a distinct before and after for each resolution.
 * 		- No back-tracking needs to be done. Once we resolve a node, it is definitively resolved.
 *
 * 	Cons:
 * 		- Nodes that are processed early have movement priority over other nodes. This can lead to some undesirable interactions.
 */
var BasicPhysicsManager = /** @class */ (function (_super) {
    __extends(BasicPhysicsManager, _super);
    function BasicPhysicsManager(options) {
        var _this = _super.call(this) || this;
        _this.staticNodes = new Array();
        _this.dynamicNodes = new Array();
        _this.tilemaps = new Array();
        _this.collisionMasks = new Array(32);
        // Parse options
        _this.parseOptions(options);
        return _this;
    }
    /**
     * Parses the options for constructing the physics manager
     * @param options A record of options
     */
    BasicPhysicsManager.prototype.parseOptions = function (options) {
        if (options.groupNames !== undefined && options.collisions !== undefined) {
            for (var i = 0; i < options.groupNames.length; i++) {
                var group = options.groupNames[i];
                // Register the group name and number
                this.groupNames[i] = group;
                this.groupMap.set(group, 1 << i);
                var collisionMask = 0;
                for (var j = 0; j < options.collisions[i].length; j++) {
                    if (options.collisions[i][j]) {
                        collisionMask |= 1 << j;
                    }
                }
                this.collisionMasks[i] = collisionMask;
            }
        }
    };
    // @override
    BasicPhysicsManager.prototype.registerObject = function (node) {
        if (node.isStatic) {
            // Static and not collidable
            this.staticNodes.push(node);
        }
        else {
            // Dynamic and not collidable
            this.dynamicNodes.push(node);
        }
    };
    // @override
    BasicPhysicsManager.prototype.deregisterObject = function (node) {
        if (node.isStatic) {
            // Remove the node from the static list
            var index = this.staticNodes.indexOf(node);
            this.staticNodes.splice(index, 1);
        }
        else {
            // Remove the node from the dynamic list
            var index = this.dynamicNodes.indexOf(node);
            this.dynamicNodes.splice(index, 1);
        }
    };
    // @override
    BasicPhysicsManager.prototype.registerTilemap = function (tilemap) {
        this.tilemaps.push(tilemap);
    };
    // @override
    BasicPhysicsManager.prototype.deregisterTilemap = function (tilemap) {
        var index = this.tilemaps.indexOf(tilemap);
        this.tilemaps.splice(index, 1);
    };
    // @override
    BasicPhysicsManager.prototype.update = function (deltaT) {
        for (var _i = 0, _a = this.dynamicNodes; _i < _a.length; _i++) {
            var node = _a[_i];
            /*---------- INITIALIZATION PHASE ----------*/
            // Clear frame dependent boolean values for each node
            node.onGround = false;
            node.onCeiling = false;
            node.onWall = false;
            node.collidedWithTilemap = false;
            node.isColliding = false;
            // If this node is not active, don't process it
            if (!node.active) {
                continue;
            }
            // Update the swept shapes of each node
            if (node.moving) {
                // If moving, reflect that in the swept shape
                node.sweptRect.sweep(node._velocity, node.collisionShape.center, node.collisionShape.halfSize);
            }
            else {
                // If our node isn't moving, don't bother to check it (other nodes will detect if they run into it)
                node._velocity.zero();
                continue;
            }
            /*---------- DETECTION PHASE ----------*/
            // Gather a set of overlaps
            var overlaps = new Array();
            var groupIndex = node.group === -1 ? -1 : Math.log2(node.group);
            // First, check this node against every static node (order doesn't actually matter here, since we sort anyways)
            for (var _b = 0, _c = this.staticNodes; _b < _c.length; _b++) {
                var other = _c[_b];
                // Ignore inactive nodes
                if (!other.active)
                    continue;
                var collider = other.collisionShape.getBoundingRect();
                var area = node.sweptRect.overlapArea(collider);
                if (area > 0) {
                    // We had a collision
                    overlaps.push(new AreaCollision_1["default"](area, collider, other, "GameNode", null));
                }
            }
            // Then, check it against every dynamic node
            for (var _d = 0, _e = this.dynamicNodes; _d < _e.length; _d++) {
                var other = _e[_d];
                // Ignore ourselves
                if (node === other)
                    continue;
                // Ignore inactive nodes
                if (!other.active)
                    continue;
                var collider = other.collisionShape.getBoundingRect();
                var area = node.sweptRect.overlapArea(collider);
                if (area > 0) {
                    // We had a collision
                    overlaps.push(new AreaCollision_1["default"](area, collider, other, "GameNode", null));
                }
            }
            // Lastly, gather a set of AABBs from the tilemap.
            // This step involves the most extra work, so it is abstracted into a method
            for (var _f = 0, _g = this.tilemaps; _f < _g.length; _f++) {
                var tilemap = _g[_f];
                // Ignore inactive tilemaps
                if (!tilemap.active)
                    continue;
                if (tilemap instanceof OrthogonalTilemap_1["default"]) {
                    this.collideWithOrthogonalTilemap(node, tilemap, overlaps);
                }
            }
            // Sort the overlaps by area
            overlaps = overlaps.sort(function (a, b) { return b.area - a.area; });
            // Keep track of hits to use later
            var hits = [];
            /*---------- RESOLUTION PHASE ----------*/
            // For every overlap, determine if we need to collide with it and when
            for (var _h = 0, overlaps_1 = overlaps; _h < overlaps_1.length; _h++) {
                var overlap = overlaps_1[_h];
                // Ignore nodes we don't interact with
                if (groupIndex !== -1 && overlap.other.group !== -1 && ((this.collisionMasks[groupIndex] & overlap.other.group) === 0))
                    continue;
                // Do a swept line test on the static AABB with this AABB size as padding (this is basically using a minkowski sum!)
                // Start the sweep at the position of this node with a delta of _velocity
                var point = node.collisionShape.center;
                var delta = node._velocity;
                var padding = node.collisionShape.halfSize;
                var otherAABB = overlap.collider;
                var hit = otherAABB.intersectSegment(node.collisionShape.center, node._velocity, node.collisionShape.halfSize);
                overlap.hit = hit;
                if (hit !== null) {
                    hits.push(hit);
                    // We got a hit, resolve with the time inside of the hit
                    var tnearx = hit.nearTimes.x;
                    var tneary = hit.nearTimes.y;
                    // Allow edge clipping (edge overlaps don't count, only area overlaps)
                    // Importantly don't allow both cases to be true. Then we clip through corners. Favor x to help players land jumps
                    if (tnearx < 1.0 && (point.y === otherAABB.top - padding.y || point.y === otherAABB.bottom + padding.y) && delta.x !== 0) {
                        tnearx = 1.0;
                    }
                    else if (tneary < 1.0 && (point.x === otherAABB.left - padding.x || point.x === otherAABB.right + padding.x) && delta.y !== 0) {
                        tneary = 1.0;
                    }
                    if (hit.nearTimes.x >= 0 && hit.nearTimes.x < 1) {
                        // Any tilemap objects that made it here are collidable
                        if (overlap.type === "Tilemap" || overlap.other.isCollidable) {
                            node._velocity.x = node._velocity.x * tnearx;
                            node.isColliding = true;
                        }
                    }
                    if (hit.nearTimes.y >= 0 && hit.nearTimes.y < 1) {
                        // Any tilemap objects that made it here are collidable
                        if (overlap.type === "Tilemap" || overlap.other.isCollidable) {
                            node._velocity.y = node._velocity.y * tneary;
                            node.isColliding = true;
                        }
                    }
                }
            }
            /*---------- INFORMATION/TRIGGER PHASE ----------*/
            // Check if we ended up on the ground, ceiling or wall
            // Also check for triggers
            for (var _j = 0, overlaps_2 = overlaps; _j < overlaps_2.length; _j++) {
                var overlap = overlaps_2[_j];
                // Check for a trigger. If we care about the trigger, react
                if (overlap.other.isTrigger && (overlap.other.triggerMask & node.group)) {
                    // Get the bit that this group is represented by
                    var index = Math.floor(Math.log2(node.group));
                    // Extract the triggerEnter event name
                    this.emitter.fireEvent(overlap.other.triggerEnters[index], {
                        node: node.id,
                        other: overlap.other.id
                    });
                }
                // Ignore collision sides for nodes we don't interact with
                if (groupIndex !== -1 && overlap.other.group !== -1 && ((this.collisionMasks[groupIndex] & overlap.other.group) === 0))
                    continue;
                // Only check for direction if the overlap was collidable
                if (overlap.type === "Tilemap" || overlap.other.isCollidable) {
                    var collisionSide = overlap.collider.touchesAABBWithoutCorners(node.collisionShape.getBoundingRect());
                    if (collisionSide !== null) {
                        // If we touch, not including corner cases, check the collision normal
                        if (overlap.hit !== null) {
                            // If we hit a tilemap, keep track of it
                            if (overlap.type == "Tilemap") {
                                node.collidedWithTilemap = true;
                            }
                            if (collisionSide.y === -1) {
                                // Node is on top of overlap, so onGround
                                node.onGround = true;
                            }
                            else if (collisionSide.y === 1) {
                                // Node is on bottom of overlap, so onCeiling
                                node.onCeiling = true;
                            }
                            else {
                                // Node wasn't touching on y, so it is touching on x
                                node.onWall = true;
                            }
                        }
                    }
                }
            }
            // Resolve the collision with the node, and move it
            node.finishMove();
        }
    };
    /**
     * Handles a collision between this node and an orthogonal tilemap
     * @param node The node
     * @param tilemap The tilemap the node may be colliding with
     * @param overlaps The list of overlaps
     */
    BasicPhysicsManager.prototype.collideWithOrthogonalTilemap = function (node, tilemap, overlaps) {
        // Get the min and max x and y coordinates of the moving node
        var min = new Vec2_1["default"](node.sweptRect.left, node.sweptRect.top);
        var max = new Vec2_1["default"](node.sweptRect.right, node.sweptRect.bottom);
        // Convert the min/max x/y to the min and max row/col in the tilemap array
        var minIndex = tilemap.getColRowAt(min);
        var maxIndex = tilemap.getColRowAt(max);
        var tileSize = tilemap.getTileSize();
        // Loop over all possible tiles (which isn't many in the scope of the velocity per frame)
        for (var col = minIndex.x; col <= maxIndex.x; col++) {
            for (var row = minIndex.y; row <= maxIndex.y; row++) {
                if (tilemap.isTileCollidable(col, row)) {
                    // Get the position of this tile
                    var tilePos = new Vec2_1["default"](col * tileSize.x + tileSize.x / 2, row * tileSize.y + tileSize.y / 2);
                    // Create a new collider for this tile
                    var collider = new AABB_1["default"](tilePos, tileSize.scaled(1 / 2));
                    // Calculate collision area between the node and the tile
                    var area = node.sweptRect.overlapArea(collider);
                    if (area > 0) {
                        // We had a collision
                        overlaps.push(new AreaCollision_1["default"](area, collider, tilemap, "Tilemap", new Vec2_1["default"](col, row)));
                    }
                }
            }
        }
    };
    return BasicPhysicsManager;
}(PhysicsManager_1["default"]));
exports["default"] = BasicPhysicsManager;
},{"../DataTypes/Physics/AreaCollision":10,"../DataTypes/Shapes/AABB":14,"../DataTypes/Vec2":20,"../Nodes/Tilemaps/OrthogonalTilemap":46,"./PhysicsManager":57}],57:[function(require,module,exports){
"use strict";
exports.__esModule = true;
var Receiver_1 = require("../Events/Receiver");
var Emitter_1 = require("../Events/Emitter");
var Map_1 = require("../DataTypes/Map");
/**
 * An abstract physics manager.
 * This class exposes functions for subclasses to implement that should allow for a working physics system to be created.
 */
var PhysicsManager = /** @class */ (function () {
    function PhysicsManager() {
        this.receiver = new Receiver_1["default"]();
        this.emitter = new Emitter_1["default"]();
        // The creation and implementation of layers is deferred to the subclass
        this.groupMap = new Map_1["default"]();
        this.groupNames = new Array();
    }
    PhysicsManager.prototype.destroy = function () {
        this.receiver.destroy();
    };
    /**
     * Sets the physics layer of the GameNode
     * @param node The GameNode
     * @param group The group that the GameNode should be on
     */
    PhysicsManager.prototype.setGroup = function (node, group) {
        node.group = this.groupMap.get(group);
    };
    /**
     * Retrieves the layer number associated with the provided name
     * @param layer The name of the layer
     * @returns The layer number, or 0 if there is not a layer with that name registered
     */
    PhysicsManager.prototype.getGroupNumber = function (group) {
        if (this.groupMap.has(group)) {
            return this.groupMap.get(group);
        }
        else {
            return 0;
        }
    };
    /**
     * Gets all group names associated with the number provided
     * @param groups A mask of groups
     * @returns All groups contained in the mask
     */
    PhysicsManager.prototype.getGroupNames = function (groups) {
        if (groups === -1) {
            return [PhysicsManager.DEFAULT_GROUP];
        }
        else {
            var g = 1;
            var names = [];
            for (var i = 0; i < 32; i++) {
                if (g & groups) {
                    // This group is in the groups number
                    names.push(this.groupNames[i]);
                }
                // Shift the bit over
                g = g << 1;
            }
        }
    };
    /** The default group name */
    PhysicsManager.DEFAULT_GROUP = "Default";
    return PhysicsManager;
}());
exports["default"] = PhysicsManager;
},{"../DataTypes/Map":8,"../Events/Emitter":23,"../Events/Receiver":27}],58:[function(require,module,exports){
"use strict";
exports.__esModule = true;
var Queue_1 = require("../DataTypes/Queue");
var Receiver_1 = require("../Events/Receiver");
var EventQueue_1 = require("../Events/EventQueue");
var GameEventType_1 = require("../Events/GameEventType");
// @ignorePage
var Recorder = /** @class */ (function () {
    function Recorder() {
        this.receiver = new Receiver_1["default"]();
        this.log = new Queue_1["default"](1000);
        this.recording = false;
        this.playing = false;
        this.frame = 0;
        this.eventQueue = EventQueue_1["default"].getInstance();
        this.eventQueue.subscribe(this.receiver, "all");
    }
    Recorder.prototype.update = function (deltaT) {
        if (this.recording) {
            this.frame += 1;
        }
        if (this.playing) {
            // If playing, ignore events, just feed the record to the event queue
            this.receiver.ignoreEvents();
            /*
                While there is a next item, and while it should occur in this frame,
                send the event. i.e., while current_frame * current_delta_t is greater
                than recorded_frame * recorded_delta_t
            */
            while (this.log.hasItems()
                && this.log.peekNext().frame * this.log.peekNext().delta < this.frame * deltaT) {
                var event_1 = this.log.dequeue().event;
                console.log(event_1);
                this.eventQueue.addEvent(event_1);
            }
            if (!this.log.hasItems()) {
                this.playing = false;
            }
            this.frame += 1;
        }
        else {
            // If not playing, handle events
            while (this.receiver.hasNextEvent()) {
                var event_2 = this.receiver.getNextEvent();
                if (event_2.type === GameEventType_1.GameEventType.STOP_RECORDING) {
                    this.recording = false;
                }
                if (this.recording) {
                    this.log.enqueue(new LogItem(this.frame, deltaT, event_2));
                }
                if (event_2.type === GameEventType_1.GameEventType.START_RECORDING) {
                    this.log.clear();
                    this.recording = true;
                    this.frame = 0;
                }
                if (event_2.type === GameEventType_1.GameEventType.PLAY_RECORDING) {
                    this.frame = 0;
                    this.recording = false;
                    this.playing = true;
                }
            }
        }
    };
    return Recorder;
}());
exports["default"] = Recorder;
var LogItem = /** @class */ (function () {
    function LogItem(frame, deltaT, event) {
        this.frame = frame;
        this.delta = deltaT;
        this.event = event;
    }
    return LogItem;
}());
},{"../DataTypes/Queue":12,"../Events/EventQueue":24,"../Events/GameEventType":26,"../Events/Receiver":27}],59:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
exports.__esModule = true;
var Map_1 = require("../../DataTypes/Map");
/** */
var Registry = /** @class */ (function (_super) {
    __extends(Registry, _super);
    function Registry() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return Registry;
}(Map_1["default"]));
exports["default"] = Registry;
},{"../../DataTypes/Map":8}],60:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
exports.__esModule = true;
var LabelShaderType_1 = require("../../Rendering/WebGLRendering/ShaderTypes/LabelShaderType");
var PointShaderType_1 = require("../../Rendering/WebGLRendering/ShaderTypes/PointShaderType");
var RectShaderType_1 = require("../../Rendering/WebGLRendering/ShaderTypes/RectShaderType");
var SpriteShaderType_1 = require("../../Rendering/WebGLRendering/ShaderTypes/SpriteShaderType");
var ResourceManager_1 = require("../../ResourceManager/ResourceManager");
var Registry_1 = require("./Registry");
/**
 * A registry that handles shaders
 */
var ShaderRegistry = /** @class */ (function (_super) {
    __extends(ShaderRegistry, _super);
    function ShaderRegistry() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.registryItems = new Array();
        return _this;
    }
    /**
     * Preloads all built-in shaders
     */
    ShaderRegistry.prototype.preload = function () {
        // Get the resourceManager and queue all built-in shaders for preloading
        var rm = ResourceManager_1["default"].getInstance();
        // Queue a load for the point shader
        this.registerAndPreloadItem(ShaderRegistry.POINT_SHADER, PointShaderType_1["default"], "builtin/shaders/point.vshader", "builtin/shaders/point.fshader");
        // Queue a load for the rect shader
        this.registerAndPreloadItem(ShaderRegistry.RECT_SHADER, RectShaderType_1["default"], "builtin/shaders/rect.vshader", "builtin/shaders/rect.fshader");
        // Queue a load for the sprite shader
        this.registerAndPreloadItem(ShaderRegistry.SPRITE_SHADER, SpriteShaderType_1["default"], "builtin/shaders/sprite.vshader", "builtin/shaders/sprite.fshader");
        // Queue a load for the label shader
        this.registerAndPreloadItem(ShaderRegistry.LABEL_SHADER, LabelShaderType_1["default"], "builtin/shaders/label.vshader", "builtin/shaders/label.fshader");
        // Queue a load for any preloaded items
        for (var _i = 0, _a = this.registryItems; _i < _a.length; _i++) {
            var item = _a[_i];
            var shader = new item.constr(item.key);
            shader.initBufferObject();
            this.add(item.key, shader);
            // Load if desired
            if (item.preload !== undefined) {
                rm.shader(item.key, item.preload.vshaderLocation, item.preload.fshaderLocation);
            }
        }
    };
    /**
     * Registers a shader in the registry and loads it before the game begins
     * @param key The key you wish to assign to the shader
     * @param constr The constructor of the ShaderType
     * @param vshaderLocation The location of the vertex shader
     * @param fshaderLocation the location of the fragment shader
     */
    ShaderRegistry.prototype.registerAndPreloadItem = function (key, constr, vshaderLocation, fshaderLocation) {
        var shaderPreload = new ShaderPreload();
        shaderPreload.vshaderLocation = vshaderLocation;
        shaderPreload.fshaderLocation = fshaderLocation;
        var registryItem = new ShaderRegistryItem();
        registryItem.key = key;
        registryItem.constr = constr;
        registryItem.preload = shaderPreload;
        this.registryItems.push(registryItem);
    };
    /**
     * Registers a shader in the registry. NOTE: If you use this, you MUST load the shader before use.
     * If you wish to preload the shader, use registerAndPreloadItem()
     * @param key The key you wish to assign to the shader
     * @param constr The constructor of the ShaderType
     */
    ShaderRegistry.prototype.registerItem = function (key, constr) {
        var registryItem = new ShaderRegistryItem();
        registryItem.key = key;
        registryItem.constr = constr;
        this.registryItems.push(registryItem);
    };
    // Shader names
    ShaderRegistry.POINT_SHADER = "point";
    ShaderRegistry.RECT_SHADER = "rect";
    ShaderRegistry.SPRITE_SHADER = "sprite";
    ShaderRegistry.LABEL_SHADER = "label";
    return ShaderRegistry;
}(Registry_1["default"]));
exports["default"] = ShaderRegistry;
var ShaderRegistryItem = /** @class */ (function () {
    function ShaderRegistryItem() {
    }
    return ShaderRegistryItem;
}());
var ShaderPreload = /** @class */ (function () {
    function ShaderPreload() {
    }
    return ShaderPreload;
}());
},{"../../Rendering/WebGLRendering/ShaderTypes/LabelShaderType":74,"../../Rendering/WebGLRendering/ShaderTypes/PointShaderType":75,"../../Rendering/WebGLRendering/ShaderTypes/RectShaderType":77,"../../Rendering/WebGLRendering/ShaderTypes/SpriteShaderType":78,"../../ResourceManager/ResourceManager":79,"./Registry":59}],61:[function(require,module,exports){
"use strict";
exports.__esModule = true;
var Map_1 = require("../DataTypes/Map");
var ShaderRegistry_1 = require("./Registries/ShaderRegistry");
/**
 * The Registry is the system's way of converting classes and types into string
 * representations for use elsewhere in the application.
 * It allows classes to be accessed without explicitly using constructors in code,
 * and for resources to be loaded at Game creation time.
 */
var RegistryManager = /** @class */ (function () {
    function RegistryManager() {
    }
    RegistryManager.preload = function () {
        var _this = this;
        this.shaders.preload();
        this.registries.forEach(function (key) { return _this.registries.get(key).preload(); });
    };
    RegistryManager.addCustomRegistry = function (name, registry) {
        this.registries.add(name, registry);
    };
    RegistryManager.getRegistry = function (key) {
        return this.registries.get(key);
    };
    RegistryManager.shaders = new ShaderRegistry_1["default"]();
    /** Additional custom registries to add to the registry manager */
    RegistryManager.registries = new Map_1["default"]();
    return RegistryManager;
}());
exports["default"] = RegistryManager;
},{"../DataTypes/Map":8,"./Registries/ShaderRegistry":60}],62:[function(require,module,exports){
"use strict";
exports.__esModule = true;
var Map_1 = require("../../DataTypes/Map");
var Emitter_1 = require("../../Events/Emitter");
var AnimationTypes_1 = require("./AnimationTypes");
/**
 * An animation manager class for an animated CanvasNode.
 * This class keeps track of the possible animations, as well as the current animation state,
 * and abstracts all interactions with playing, pausing, and stopping animations as well as
 * creating new animations from the CanvasNode.
 */
var AnimationManager = /** @class */ (function () {
    /**
     * Creates a new AnimationManager
     * @param owner The owner of the AnimationManager
     */
    function AnimationManager(owner) {
        this.owner = owner;
        this.animationState = AnimationTypes_1.AnimationState.STOPPED;
        this.currentAnimation = "";
        this.currentFrame = 0;
        this.frameProgress = 0;
        this.loop = false;
        this.animations = new Map_1["default"]();
        this.onEndEvent = null;
        this.emitter = new Emitter_1["default"]();
    }
    /**
     * Add an animation to this sprite
     * @param key The unique key of the animation
     * @param animation The animation data
     */
    AnimationManager.prototype.add = function (key, animation) {
        this.animations.add(key, animation);
    };
    /**
     * Gets the index specified by the current animation and current frame
     * @returns The index in the current animation
     */
    AnimationManager.prototype.getIndex = function () {
        if (this.animations.has(this.currentAnimation)) {
            return this.animations.get(this.currentAnimation).frames[this.currentFrame].index;
        }
        else {
            // No current animation, warn the user
            console.warn("Animation index was requested, but the current animation: ".concat(this.currentAnimation, " was invalid"));
            return 0;
        }
    };
    /**
     * Determines whether the specified animation is currently playing
     * @param key The key of the animation to check
     * @returns true if the specified animation is playing, false otherwise
     */
    AnimationManager.prototype.isPlaying = function (key) {
        return this.currentAnimation === key && this.animationState === AnimationTypes_1.AnimationState.PLAYING;
    };
    /**
     * Retrieves the current animation index and advances the animation frame
     * @returns The index of the animation frame
     */
    AnimationManager.prototype.getIndexAndAdvanceAnimation = function () {
        // If we aren't playing, we won't be advancing the animation
        if (!(this.animationState === AnimationTypes_1.AnimationState.PLAYING)) {
            return this.getIndex();
        }
        if (this.animations.has(this.currentAnimation)) {
            var currentAnimation = this.animations.get(this.currentAnimation);
            var index = currentAnimation.frames[this.currentFrame].index;
            // Advance the animation
            this.frameProgress += 1;
            if (this.frameProgress >= currentAnimation.frames[this.currentFrame].duration) {
                // We have been on this frame for its whole duration, go to the next one
                this.frameProgress = 0;
                this.currentFrame += 1;
                if (this.currentFrame >= currentAnimation.frames.length) {
                    // We have reached the end of this animation
                    if (this.loop) {
                        this.currentFrame = 0;
                        this.frameProgress = 0;
                    }
                    else {
                        this.endCurrentAnimation();
                    }
                }
            }
            // Return the current index
            return index;
        }
        else {
            // No current animation, can't advance. Warn the user
            console.warn("Animation index and advance was requested, but the current animation (".concat(this.currentAnimation, ") in node with id: ").concat(this.owner.id, " was invalid"));
            return 0;
        }
    };
    /** Ends the current animation and fires any necessary events, as well as starting any new animations */
    AnimationManager.prototype.endCurrentAnimation = function () {
        this.currentFrame = 0;
        this.animationState = AnimationTypes_1.AnimationState.STOPPED;
        if (this.onEndEvent !== null) {
            this.emitter.fireEvent(this.onEndEvent, { owner: this.owner.id, animation: this.currentAnimation });
        }
        // If there is a pending animation, play it
        if (this.pendingAnimation !== null) {
            this.play(this.pendingAnimation, this.pendingLoop, this.pendingOnEnd);
        }
    };
    /**
     * Plays the specified animation. Does not restart it if it is already playing
     * @param animation The name of the animation to play
     * @param loop Whether or not to loop the animation. False by default
     * @param onEnd The name of an event to send when this animation naturally stops playing. This only matters if loop is false.
     */
    AnimationManager.prototype.playIfNotAlready = function (animation, loop, onEnd) {
        if (this.currentAnimation !== animation) {
            this.play(animation, loop, onEnd);
        }
    };
    /**
     * Plays the specified animation
     * @param animation The name of the animation to play
     * @param loop Whether or not to loop the animation. False by default
     * @param onEnd The name of an event to send when this animation naturally stops playing. This only matters if loop is false.
     */
    AnimationManager.prototype.play = function (animation, loop, onEnd) {
        this.currentAnimation = animation;
        this.currentFrame = 0;
        this.frameProgress = 0;
        this.animationState = AnimationTypes_1.AnimationState.PLAYING;
        // If loop arg was provided, use that
        if (loop !== undefined) {
            this.loop = loop;
        }
        else {
            // Otherwise, use what the json file specified
            this.loop = this.animations.get(animation).repeat;
        }
        if (onEnd !== undefined) {
            this.onEndEvent = onEnd;
        }
        else {
            this.onEndEvent = null;
        }
        // Reset pending animation
        this.pendingAnimation = null;
    };
    /**
     * Queues a single animation to be played after the current one. Does NOT stack.
     * Queueing additional animations past 1 will just replace the queued animation
     * @param animation The animation to queue
     * @param loop Whether or not the loop the queued animation
     * @param onEnd The event to fire when the queued animation ends
     */
    AnimationManager.prototype.queue = function (animation, loop, onEnd) {
        if (loop === void 0) { loop = false; }
        this.pendingAnimation = animation;
        this.pendingLoop = loop;
        if (onEnd !== undefined) {
            this.pendingOnEnd = onEnd;
        }
        else {
            this.pendingOnEnd = null;
        }
    };
    /** Pauses the current animation */
    AnimationManager.prototype.pause = function () {
        this.animationState = AnimationTypes_1.AnimationState.PAUSED;
    };
    /** Resumes the current animation if possible */
    AnimationManager.prototype.resume = function () {
        if (this.animationState === AnimationTypes_1.AnimationState.PAUSED) {
            this.animationState = AnimationTypes_1.AnimationState.PLAYING;
        }
    };
    /** Stops the current animation. The animation cannot be resumed after this. */
    AnimationManager.prototype.stop = function () {
        this.animationState = AnimationTypes_1.AnimationState.STOPPED;
    };
    return AnimationManager;
}());
exports["default"] = AnimationManager;
},{"../../DataTypes/Map":8,"../../Events/Emitter":23,"./AnimationTypes":63}],63:[function(require,module,exports){
"use strict";
exports.__esModule = true;
exports.TweenData = exports.TweenEffect = exports.AnimationData = exports.AnimationState = void 0;
// @ignorePage
var AnimationState;
(function (AnimationState) {
    AnimationState[AnimationState["STOPPED"] = 0] = "STOPPED";
    AnimationState[AnimationState["PAUSED"] = 1] = "PAUSED";
    AnimationState[AnimationState["PLAYING"] = 2] = "PLAYING";
})(AnimationState = exports.AnimationState || (exports.AnimationState = {}));
var AnimationData = /** @class */ (function () {
    function AnimationData() {
        this.repeat = false;
    }
    return AnimationData;
}());
exports.AnimationData = AnimationData;
var TweenEffect = /** @class */ (function () {
    function TweenEffect() {
    }
    return TweenEffect;
}());
exports.TweenEffect = TweenEffect;
var TweenData = /** @class */ (function () {
    function TweenData() {
    }
    return TweenData;
}());
exports.TweenData = TweenData;
},{}],64:[function(require,module,exports){
"use strict";
exports.__esModule = true;
var ParticleSystemManager = /** @class */ (function () {
    function ParticleSystemManager() {
        this.particleSystems = new Array();
    }
    ParticleSystemManager.getInstance = function () {
        if (ParticleSystemManager.instance === null) {
            ParticleSystemManager.instance = new ParticleSystemManager();
        }
        return ParticleSystemManager.instance;
    };
    ParticleSystemManager.prototype.registerParticleSystem = function (system) {
        this.particleSystems.push(system);
    };
    ParticleSystemManager.prototype.deregisterParticleSystem = function (system) {
        var index = this.particleSystems.indexOf(system);
        this.particleSystems.splice(index, 1);
    };
    ParticleSystemManager.prototype.clearParticleSystems = function () {
        this.particleSystems = new Array();
    };
    ParticleSystemManager.prototype.update = function (deltaT) {
        for (var _i = 0, _a = this.particleSystems; _i < _a.length; _i++) {
            var particleSystem = _a[_i];
            particleSystem.update(deltaT);
        }
    };
    ParticleSystemManager.instance = null;
    return ParticleSystemManager;
}());
exports["default"] = ParticleSystemManager;
},{}],65:[function(require,module,exports){
"use strict";
exports.__esModule = true;
var Map_1 = require("../../DataTypes/Map");
var AnimationTypes_1 = require("./AnimationTypes");
var EaseFunctions_1 = require("../../Utils/EaseFunctions");
var MathUtils_1 = require("../../Utils/MathUtils");
var TweenManager_1 = require("./TweenManager");
var Emitter_1 = require("../../Events/Emitter");
/**
 * A manager for the tweens of a GameNode.
 * Tweens are short animations played by interpolating between two properties using an easing function.
 * For a good visual representation of easing functions, check out @link(https://easings.net/)(https://easings.net/).
 * Multiple tween can be played at the same time, as long as they don't change the same property.
 * This allows for some interesting polishes or animations that may be very difficult to do with sprite work alone
 * - especially pixel art (such as rotations or scaling).
 */
var TweenController = /** @class */ (function () {
    /**
     * Creates a new TweenController
     * @param owner The owner of the TweenController
     */
    function TweenController(owner) {
        this.owner = owner;
        this.tweens = new Map_1["default"]();
        this.emitter = new Emitter_1["default"]();
        // Give ourselves to the TweenManager
        TweenManager_1["default"].getInstance().registerTweenController(this);
    }
    /**
     * Destroys this TweenController
     */
    TweenController.prototype.destroy = function () {
        // Only the gamenode and the tween manager should have a reference to this
        delete this.owner.tweens;
        TweenManager_1["default"].getInstance().deregisterTweenController(this);
    };
    /**
     * Add a tween to this game node
     * @param key The name of the tween
     * @param tween The data of the tween
     */
    TweenController.prototype.add = function (key, tween) {
        var typedTween = tween;
        // Initialize members that we need (and the user didn't provide)
        typedTween.progress = 0;
        typedTween.elapsedTime = 0;
        typedTween.animationState = AnimationTypes_1.AnimationState.STOPPED;
        this.tweens.add(key, typedTween);
    };
    /**
     * Play a tween with a certain name
     * @param key The name of the tween to play
     * @param loop Whether or not the tween should loop
     */
    TweenController.prototype.play = function (key, loop) {
        if (this.tweens.has(key)) {
            var tween = this.tweens.get(key);
            // Set loop if needed
            if (loop !== undefined) {
                tween.loop = loop;
            }
            // Set the initial values
            for (var _i = 0, _a = tween.effects; _i < _a.length; _i++) {
                var effect = _a[_i];
                if (effect.resetOnComplete) {
                    effect.initialValue = this.owner[effect.property];
                }
            }
            // Start the tween running
            tween.animationState = AnimationTypes_1.AnimationState.PLAYING;
            tween.elapsedTime = 0;
            tween.progress = 0;
            tween.reversing = false;
        }
        else {
            console.warn("Tried to play tween \"".concat(key, "\" on node with id ").concat(this.owner.id, ", but no such tween exists"));
        }
    };
    /**
     * Pauses a playing tween. Does not affect tweens that are stopped.
     * @param key The name of the tween to pause.
     */
    TweenController.prototype.pause = function (key) {
        if (this.tweens.has(key)) {
            this.tweens.get(key).animationState = AnimationTypes_1.AnimationState.PAUSED;
        }
    };
    /**
     * Resumes a paused tween.
     * @param key The name of the tween to resume
     */
    TweenController.prototype.resume = function (key) {
        if (this.tweens.has(key)) {
            var tween = this.tweens.get(key);
            if (tween.animationState === AnimationTypes_1.AnimationState.PAUSED)
                tween.animationState = AnimationTypes_1.AnimationState.PLAYING;
        }
    };
    /**
     * Stops a currently playing tween
     * @param key The key of the tween
     */
    TweenController.prototype.stop = function (key) {
        if (this.tweens.has(key)) {
            var tween = this.tweens.get(key);
            tween.animationState = AnimationTypes_1.AnimationState.STOPPED;
            // Return to the initial values
            for (var _i = 0, _a = tween.effects; _i < _a.length; _i++) {
                var effect = _a[_i];
                if (effect.resetOnComplete) {
                    this.owner[effect.property] = effect.initialValue;
                }
            }
        }
    };
    /**
     * The natural stop of a currently playing tween
     * @param key The key of the tween
     */
    TweenController.prototype.end = function (key) {
        this.stop(key);
        if (this.tweens.has(key)) {
            // Get the tween
            var tween = this.tweens.get(key);
            // If it has an onEnd, send an event
            if (tween.onEnd) {
                this.emitter.fireEvent(tween.onEnd, { key: key, node: this.owner.id });
            }
        }
    };
    /**
     * Stops all currently playing tweens
     */
    TweenController.prototype.stopAll = function () {
        var _this = this;
        this.tweens.forEach(function (key) { return _this.stop(key); });
    };
    TweenController.prototype.update = function (deltaT) {
        var _this = this;
        this.tweens.forEach(function (key) {
            var tween = _this.tweens.get(key);
            if (tween.animationState === AnimationTypes_1.AnimationState.PLAYING) {
                // Update the progress of the tween
                tween.elapsedTime += deltaT * 1000;
                // If we're past the startDelay, do the tween
                if (tween.elapsedTime >= tween.startDelay) {
                    if (!tween.reversing && tween.elapsedTime >= tween.startDelay + tween.duration) {
                        // If we're over time, stop the tween, loop, or reverse
                        if (tween.reverseOnComplete) {
                            // If we're over time and can reverse, do so
                            tween.reversing = true;
                        }
                        else if (tween.loop) {
                            // If we can't reverse and can loop, do so
                            tween.elapsedTime -= tween.duration;
                        }
                        else {
                            // We aren't looping and can't reverse, so stop
                            _this.end(key);
                        }
                    }
                    // Check for the end of reversing
                    if (tween.reversing && tween.elapsedTime >= tween.startDelay + 2 * tween.duration) {
                        if (tween.loop) {
                            tween.reversing = false;
                            tween.elapsedTime -= 2 * tween.duration;
                        }
                        else {
                            _this.end(key);
                        }
                    }
                    // Update the progress, make sure it is between 0 and 1. Errors from this should never be large
                    if (tween.reversing) {
                        tween.progress = MathUtils_1["default"].clamp01((2 * tween.duration - (tween.elapsedTime - tween.startDelay)) / tween.duration);
                    }
                    else {
                        tween.progress = MathUtils_1["default"].clamp01((tween.elapsedTime - tween.startDelay) / tween.duration);
                    }
                    for (var _i = 0, _a = tween.effects; _i < _a.length; _i++) {
                        var effect = _a[_i];
                        // Get the value from the ease function that corresponds to our progress
                        var ease = EaseFunctions_1["default"][effect.ease](tween.progress);
                        // Use the value to lerp the property
                        var value = MathUtils_1["default"].lerp(effect.start, effect.end, ease);
                        // Assign the value of the property
                        _this.owner[effect.property] = value;
                    }
                }
            }
        });
    };
    return TweenController;
}());
exports["default"] = TweenController;
},{"../../DataTypes/Map":8,"../../Events/Emitter":23,"../../Utils/EaseFunctions":95,"../../Utils/MathUtils":97,"./AnimationTypes":63,"./TweenManager":66}],66:[function(require,module,exports){
"use strict";
exports.__esModule = true;
var TweenManager = /** @class */ (function () {
    function TweenManager() {
        this.tweenControllers = new Array();
    }
    TweenManager.getInstance = function () {
        if (TweenManager.instance === null) {
            TweenManager.instance = new TweenManager();
        }
        return TweenManager.instance;
    };
    TweenManager.prototype.registerTweenController = function (controller) {
        this.tweenControllers.push(controller);
    };
    TweenManager.prototype.deregisterTweenController = function (controller) {
        var index = this.tweenControllers.indexOf(controller);
        this.tweenControllers.splice(index, 1);
    };
    TweenManager.prototype.clearTweenControllers = function () {
        this.tweenControllers = new Array();
    };
    TweenManager.prototype.update = function (deltaT) {
        for (var _i = 0, _a = this.tweenControllers; _i < _a.length; _i++) {
            var tweenController = _a[_i];
            tweenController.update(deltaT);
        }
    };
    TweenManager.instance = null;
    return TweenManager;
}());
exports["default"] = TweenManager;
},{}],67:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
exports.__esModule = true;
var Graphic_1 = require("../Nodes/Graphic");
var Point_1 = require("../Nodes/Graphics/Point");
var Rect_1 = require("../Nodes/Graphics/Rect");
var Sprite_1 = require("../Nodes/Sprites/Sprite");
var OrthogonalTilemap_1 = require("../Nodes/Tilemaps/OrthogonalTilemap");
var UIElement_1 = require("../Nodes/UIElement");
var GraphicRenderer_1 = require("./CanvasRendering/GraphicRenderer");
var RenderingManager_1 = require("./RenderingManager");
var TilemapRenderer_1 = require("./CanvasRendering/TilemapRenderer");
var UIElementRenderer_1 = require("./CanvasRendering/UIElementRenderer");
var Label_1 = require("../Nodes/UIElements/Label");
var Button_1 = require("../Nodes/UIElements/Button");
var Slider_1 = require("../Nodes/UIElements/Slider");
var TextInput_1 = require("../Nodes/UIElements/TextInput");
var AnimatedSprite_1 = require("../Nodes/Sprites/AnimatedSprite");
var Vec2_1 = require("../DataTypes/Vec2");
var Line_1 = require("../Nodes/Graphics/Line");
var Debug_1 = require("../Debug/Debug");
/**
 * An implementation of the RenderingManager class using CanvasRenderingContext2D.
 */
var CanvasRenderer = /** @class */ (function (_super) {
    __extends(CanvasRenderer, _super);
    function CanvasRenderer() {
        return _super.call(this) || this;
    }
    // @override
    CanvasRenderer.prototype.setScene = function (scene) {
        this.scene = scene;
        this.graphicRenderer.setScene(scene);
        this.tilemapRenderer.setScene(scene);
        this.uiElementRenderer.setScene(scene);
    };
    // @override
    CanvasRenderer.prototype.initializeCanvas = function (canvas, width, height) {
        canvas.width = width;
        canvas.height = height;
        this.worldSize = new Vec2_1["default"](width, height);
        this.ctx = canvas.getContext("2d");
        this.graphicRenderer = new GraphicRenderer_1["default"](this.ctx);
        this.tilemapRenderer = new TilemapRenderer_1["default"](this.ctx);
        this.uiElementRenderer = new UIElementRenderer_1["default"](this.ctx);
        // For crisp pixel art
        this.ctx.imageSmoothingEnabled = false;
        return this.ctx;
    };
    // @override
    CanvasRenderer.prototype.render = function (visibleSet, tilemaps, uiLayers) {
        var _this = this;
        // Sort by depth, then by visible set by y-value
        visibleSet.sort(function (a, b) {
            if (a.getLayer().getDepth() === b.getLayer().getDepth()) {
                return (a.boundary.bottom) - (b.boundary.bottom);
            }
            else {
                return a.getLayer().getDepth() - b.getLayer().getDepth();
            }
        });
        var tilemapIndex = 0;
        var tilemapLength = tilemaps.length;
        var visibleSetIndex = 0;
        var visibleSetLength = visibleSet.length;
        while (tilemapIndex < tilemapLength || visibleSetIndex < visibleSetLength) {
            // Check conditions where we've already reached the edge of one list
            if (tilemapIndex >= tilemapLength) {
                // Only render the remaining visible set
                var node = visibleSet[visibleSetIndex++];
                if (node.visible) {
                    this.renderNode(node);
                }
                continue;
            }
            if (visibleSetIndex >= visibleSetLength) {
                // Only render tilemaps
                this.renderTilemap(tilemaps[tilemapIndex++]);
                continue;
            }
            // Render whichever is further down
            if (tilemaps[tilemapIndex].getLayer().getDepth() <= visibleSet[visibleSetIndex].getLayer().getDepth()) {
                this.renderTilemap(tilemaps[tilemapIndex++]);
            }
            else {
                var node = visibleSet[visibleSetIndex++];
                if (node.visible) {
                    this.renderNode(node);
                }
            }
        }
        // Render the uiLayers on top of everything else
        var sortedUILayers = new Array();
        uiLayers.forEach(function (key) { return sortedUILayers.push(uiLayers.get(key)); });
        sortedUILayers = sortedUILayers.sort(function (ui1, ui2) { return ui1.getDepth() - ui2.getDepth(); });
        sortedUILayers.forEach(function (uiLayer) {
            if (!uiLayer.isHidden())
                uiLayer.getItems().forEach(function (node) {
                    if (node.visible) {
                        _this.renderNode(node);
                    }
                });
        });
    };
    /**
     * Renders a specified CanvasNode
     * @param node The CanvasNode to render
     */
    CanvasRenderer.prototype.renderNode = function (node) {
        // Calculate the origin of the viewport according to this sprite
        this.origin = this.scene.getViewTranslation(node);
        // Get the zoom level of the scene
        this.zoom = this.scene.getViewScale();
        // Move the canvas to the position of the node and rotate
        var xScale = 1;
        var yScale = 1;
        if (node instanceof Sprite_1["default"]) {
            xScale = node.invertX ? -1 : 1;
            yScale = node.invertY ? -1 : 1;
        }
        this.ctx.setTransform(xScale, 0, 0, yScale, (node.position.x - this.origin.x) * this.zoom, (node.position.y - this.origin.y) * this.zoom);
        this.ctx.rotate(-node.rotation);
        var globalAlpha = this.ctx.globalAlpha;
        if (node instanceof Rect_1["default"]) {
            Debug_1["default"].log("node" + node.id, "Node" + node.id + " Alpha: " + node.alpha);
        }
        this.ctx.globalAlpha = node.alpha;
        if (node instanceof AnimatedSprite_1["default"]) {
            this.renderAnimatedSprite(node);
        }
        else if (node instanceof Sprite_1["default"]) {
            this.renderSprite(node);
        }
        else if (node instanceof Graphic_1["default"]) {
            this.renderGraphic(node);
        }
        else if (node instanceof UIElement_1["default"]) {
            this.renderUIElement(node);
        }
        this.ctx.globalAlpha = globalAlpha;
        this.ctx.setTransform(1, 0, 0, 1, 0, 0);
    };
    // @override
    CanvasRenderer.prototype.renderSprite = function (sprite) {
        // Get the image from the resource manager
        var image = this.resourceManager.getImage(sprite.imageId);
        /*
            Coordinates in the space of the image:
                image crop start -> x, y
                image crop size  -> w, h
            Coordinates in the space of the world
                image draw start -> x, y
                image draw size  -> w, h
        */
        this.ctx.drawImage(image, sprite.imageOffset.x, sprite.imageOffset.y, sprite.size.x, sprite.size.y, (-sprite.size.x * sprite.scale.x / 2) * this.zoom, (-sprite.size.y * sprite.scale.y / 2) * this.zoom, sprite.size.x * sprite.scale.x * this.zoom, sprite.size.y * sprite.scale.y * this.zoom);
    };
    // @override
    CanvasRenderer.prototype.renderAnimatedSprite = function (sprite) {
        // Get the image from the resource manager
        var image = this.resourceManager.getImage(sprite.imageId);
        var animationIndex = sprite.animation.getIndexAndAdvanceAnimation();
        var animationOffset = sprite.getAnimationOffset(animationIndex);
        /*
            Coordinates in the space of the image:
                image crop start -> x, y
                image crop size  -> w, h
            Coordinates in the space of the world (given we moved)
                image draw start -> -w/2, -h/2
                image draw size  -> w, h
        */
        this.ctx.drawImage(image, sprite.imageOffset.x + animationOffset.x, sprite.imageOffset.y + animationOffset.y, sprite.size.x, sprite.size.y, (-sprite.size.x * sprite.scale.x / 2) * this.zoom, (-sprite.size.y * sprite.scale.y / 2) * this.zoom, sprite.size.x * sprite.scale.x * this.zoom, sprite.size.y * sprite.scale.y * this.zoom);
    };
    // @override
    CanvasRenderer.prototype.renderGraphic = function (graphic) {
        if (graphic instanceof Point_1["default"]) {
            this.graphicRenderer.renderPoint(graphic, this.zoom);
        }
        else if (graphic instanceof Line_1["default"]) {
            this.graphicRenderer.renderLine(graphic, this.origin, this.zoom);
        }
        else if (graphic instanceof Rect_1["default"]) {
            this.graphicRenderer.renderRect(graphic, this.zoom);
        }
    };
    // @override
    CanvasRenderer.prototype.renderTilemap = function (tilemap) {
        if (tilemap instanceof OrthogonalTilemap_1["default"]) {
            this.tilemapRenderer.renderOrthogonalTilemap(tilemap);
        }
    };
    // @override
    CanvasRenderer.prototype.renderUIElement = function (uiElement) {
        if (uiElement instanceof Label_1["default"]) {
            this.uiElementRenderer.renderLabel(uiElement);
        }
        else if (uiElement instanceof Button_1["default"]) {
            this.uiElementRenderer.renderButton(uiElement);
        }
        else if (uiElement instanceof Slider_1["default"]) {
            this.uiElementRenderer.renderSlider(uiElement);
        }
        else if (uiElement instanceof TextInput_1["default"]) {
            this.uiElementRenderer.renderTextInput(uiElement);
        }
    };
    CanvasRenderer.prototype.clear = function (clearColor) {
        this.ctx.clearRect(0, 0, this.worldSize.x, this.worldSize.y);
        this.ctx.fillStyle = clearColor.toString();
        this.ctx.fillRect(0, 0, this.worldSize.x, this.worldSize.y);
    };
    return CanvasRenderer;
}(RenderingManager_1["default"]));
exports["default"] = CanvasRenderer;
},{"../DataTypes/Vec2":20,"../Debug/Debug":21,"../Nodes/Graphic":37,"../Nodes/Graphics/Line":39,"../Nodes/Graphics/Point":41,"../Nodes/Graphics/Rect":42,"../Nodes/Sprites/AnimatedSprite":43,"../Nodes/Sprites/Sprite":44,"../Nodes/Tilemaps/OrthogonalTilemap":46,"../Nodes/UIElement":47,"../Nodes/UIElements/Button":48,"../Nodes/UIElements/Label":49,"../Nodes/UIElements/Slider":50,"../Nodes/UIElements/TextInput":51,"./CanvasRendering/GraphicRenderer":68,"./CanvasRendering/TilemapRenderer":69,"./CanvasRendering/UIElementRenderer":70,"./RenderingManager":71}],68:[function(require,module,exports){
"use strict";
exports.__esModule = true;
var ResourceManager_1 = require("../../ResourceManager/ResourceManager");
/**
 * A utility class to help the @reference[CanvasRenderer] render @reference[Graphic]s
 */
var GraphicRenderer = /** @class */ (function () {
    function GraphicRenderer(ctx) {
        this.resourceManager = ResourceManager_1["default"].getInstance();
        this.ctx = ctx;
    }
    /**
     * Sets the scene of this GraphicRenderer
     * @param scene The current scene
     */
    GraphicRenderer.prototype.setScene = function (scene) {
        this.scene = scene;
    };
    /**
     * Renders a point
     * @param point The point to render
     * @param zoom The zoom level
     */
    GraphicRenderer.prototype.renderPoint = function (point, zoom) {
        this.ctx.fillStyle = point.color.toStringRGBA();
        this.ctx.fillRect((-point.size.x / 2) * zoom, (-point.size.y / 2) * zoom, point.size.x * zoom, point.size.y * zoom);
    };
    GraphicRenderer.prototype.renderLine = function (line, origin, zoom) {
        this.ctx.strokeStyle = line.color.toStringRGBA();
        this.ctx.lineWidth = line.thickness;
        this.ctx.beginPath();
        this.ctx.moveTo(0, 0);
        this.ctx.lineTo((line.end.x - line.start.x) * zoom, (line.end.y - line.start.y) * zoom);
        this.ctx.closePath();
        this.ctx.stroke();
    };
    /**
     * Renders a rect
     * @param rect The rect to render
     * @param zoom The zoom level
     */
    GraphicRenderer.prototype.renderRect = function (rect, zoom) {
        // Draw the interior of the rect
        if (rect.color.a !== 0) {
            this.ctx.fillStyle = rect.color.toStringRGB();
            this.ctx.fillRect((-rect.size.x / 2) * zoom, (-rect.size.y / 2) * zoom, rect.size.x * zoom, rect.size.y * zoom);
        }
        // Draw the border of the rect if it isn't transparent
        if (rect.borderColor.a !== 0) {
            this.ctx.strokeStyle = rect.getBorderColor().toStringRGB();
            this.ctx.lineWidth = rect.getBorderWidth();
            this.ctx.strokeRect((-rect.size.x / 2) * zoom, (-rect.size.y / 2) * zoom, rect.size.x * zoom, rect.size.y * zoom);
        }
    };
    return GraphicRenderer;
}());
exports["default"] = GraphicRenderer;
},{"../../ResourceManager/ResourceManager":79}],69:[function(require,module,exports){
"use strict";
exports.__esModule = true;
var ResourceManager_1 = require("../../ResourceManager/ResourceManager");
var Vec2_1 = require("../../DataTypes/Vec2");
/**
 * A utility class for the @reference[CanvasRenderer] to render @reference[Tilemap]s
 */
var TilemapRenderer = /** @class */ (function () {
    function TilemapRenderer(ctx) {
        this.resourceManager = ResourceManager_1["default"].getInstance();
        this.ctx = ctx;
    }
    /**
     * Sets the scene of this TilemapRenderer
     * @param scene The current scene
     */
    TilemapRenderer.prototype.setScene = function (scene) {
        this.scene = scene;
    };
    /**
     * Renders an orthogonal tilemap
     * @param tilemap The tilemap to render
     */
    TilemapRenderer.prototype.renderOrthogonalTilemap = function (tilemap) {
        var previousAlpha = this.ctx.globalAlpha;
        this.ctx.globalAlpha = tilemap.getLayer().getAlpha();
        var origin = this.scene.getViewTranslation(tilemap);
        var size = this.scene.getViewport().getHalfSize();
        var zoom = this.scene.getViewScale();
        var bottomRight = origin.clone().add(size.scaled(2 * zoom));
        if (tilemap.visible) {
            var minColRow = tilemap.getColRowAt(origin);
            var maxColRow = tilemap.getColRowAt(bottomRight);
            for (var x = minColRow.x; x <= maxColRow.x; x++) {
                for (var y = minColRow.y; y <= maxColRow.y; y++) {
                    // Get the tile at this position
                    var tile = tilemap.getTileAtRowCol(new Vec2_1["default"](x, y));
                    // Extract the rot/flip parameters if there are any
                    var mask = (0xE << 28);
                    var rotFlip = ((mask & tile) >> 28) & 0xF;
                    tile = tile & ~mask;
                    // Find the tileset that owns this tile index and render
                    for (var _i = 0, _a = tilemap.getTilesets(); _i < _a.length; _i++) {
                        var tileset = _a[_i];
                        if (tileset.hasTile(tile)) {
                            this.renderTile(tileset, tile, x, y, origin, tilemap.scale, zoom, rotFlip);
                        }
                    }
                }
            }
        }
        this.ctx.globalAlpha = previousAlpha;
    };
    /**
     * Renders a tile
     * @param tileset The tileset this tile belongs to
     * @param tileIndex The index of the tile
     * @param tilemapRow The row of the tile in the tilemap
     * @param tilemapCol The column of the tile in the tilemap
     * @param origin The origin of the viewport
     * @param scale The scale of the tilemap
     * @param zoom The zoom level of the viewport
     */
    TilemapRenderer.prototype.renderTile = function (tileset, tileIndex, tilemapRow, tilemapCol, origin, scale, zoom, rotFlip) {
        var image = this.resourceManager.getImage(tileset.getImageKey());
        // Get the true index
        var index = tileIndex - tileset.getStartIndex();
        // Get the row and col of the tile in image space
        var row = Math.floor(index / tileset.getNumCols());
        var col = index % tileset.getNumCols();
        var width = tileset.getTileSize().x;
        var height = tileset.getTileSize().y;
        // Calculate the position to start a crop in the tileset image
        var left = col * width;
        var top = row * height;
        // Calculate the position in the world to render the tile
        var x = Math.floor(tilemapRow * width * scale.x);
        var y = Math.floor(tilemapCol * height * scale.y);
        var worldX = Math.floor((x - origin.x) * zoom);
        var worldY = Math.floor((y - origin.y) * zoom);
        var worldWidth = Math.ceil(width * scale.x * zoom);
        var worldHeight = Math.ceil(height * scale.y * zoom);
        if (rotFlip !== 0) {
            var scaleX = 1;
            var scaleY = 1;
            var shearX = 0;
            var shearY = 0;
            // Flip on the x-axis
            if (rotFlip & 8) {
                scaleX = -1;
            }
            // Flip on the y-axis
            if (rotFlip & 4) {
                scaleY = -1;
            }
            // Flip over the line y=x
            if (rotFlip & 2) {
                shearX = scaleY;
                shearY = scaleX;
                scaleX = 0;
                scaleY = 0;
            }
            this.ctx.setTransform(scaleX, shearX, shearY, scaleY, worldX + worldWidth / 2, worldY + worldHeight / 2);
            // Render the tile
            this.ctx.drawImage(image, left, top, width, height, -worldWidth / 2, -worldHeight / 2, worldWidth, worldHeight);
            if (rotFlip !== 0) {
                this.ctx.setTransform(1, 0, 0, 1, 0, 0);
            }
        }
        else {
            // No rotations, don't do the calculations, just render the tile
            // Render the tile
            this.ctx.drawImage(image, left, top, width, height, worldX, worldY, worldWidth, worldHeight);
        }
    };
    return TilemapRenderer;
}());
exports["default"] = TilemapRenderer;
},{"../../DataTypes/Vec2":20,"../../ResourceManager/ResourceManager":79}],70:[function(require,module,exports){
"use strict";
exports.__esModule = true;
var Vec2_1 = require("../../DataTypes/Vec2");
var ResourceManager_1 = require("../../ResourceManager/ResourceManager");
var MathUtils_1 = require("../../Utils/MathUtils");
/**
 * A utility class to help the @reference[CanvasRenderer] render @reference[UIElement]s
 */
var UIElementRenderer = /** @class */ (function () {
    function UIElementRenderer(ctx) {
        this.resourceManager = ResourceManager_1["default"].getInstance();
        this.ctx = ctx;
    }
    /**
     * Sets the scene of this UIElementRenderer
     * @param scene The current scene
     */
    UIElementRenderer.prototype.setScene = function (scene) {
        this.scene = scene;
    };
    /**
     * Renders a label
     * @param label The label to render
     */
    UIElementRenderer.prototype.renderLabel = function (label) {
        // If the size is unassigned (by the user or automatically) assign it
        label.handleInitialSizing(this.ctx);
        // Grab the global alpha so we can adjust it for this render
        var previousAlpha = this.ctx.globalAlpha;
        // Get the font and text position in label
        this.ctx.font = label.getFontString();
        var offset = label.calculateTextOffset(this.ctx);
        // Stroke and fill a rounded rect and give it text
        this.ctx.globalAlpha = label.backgroundColor.a;
        this.ctx.fillStyle = label.calculateBackgroundColor().toStringRGBA();
        this.ctx.fillRoundedRect(-label.size.x / 2, -label.size.y / 2, label.size.x, label.size.y, label.borderRadius);
        this.ctx.strokeStyle = label.calculateBorderColor().toStringRGBA();
        this.ctx.globalAlpha = label.borderColor.a;
        this.ctx.lineWidth = label.borderWidth;
        this.ctx.strokeRoundedRect(-label.size.x / 2, -label.size.y / 2, label.size.x, label.size.y, label.borderRadius);
        this.ctx.fillStyle = label.calculateTextColor();
        this.ctx.globalAlpha = label.textColor.a;
        this.ctx.fillText(label.text, offset.x - label.size.x / 2, offset.y - label.size.y / 2);
        this.ctx.globalAlpha = previousAlpha;
    };
    /**
     * Renders a button
     * @param button The button to render
     */
    UIElementRenderer.prototype.renderButton = function (button) {
        this.renderLabel(button);
    };
    /**
     * Renders a slider
     * @param slider The slider to render
     */
    UIElementRenderer.prototype.renderSlider = function (slider) {
        // Grab the global alpha so we can adjust it for this render
        var previousAlpha = this.ctx.globalAlpha;
        this.ctx.globalAlpha = slider.getLayer().getAlpha();
        // Calcualate the slider size
        var sliderSize = new Vec2_1["default"](slider.size.x, 2);
        // Draw the slider
        this.ctx.fillStyle = slider.sliderColor.toString();
        this.ctx.fillRoundedRect(-sliderSize.x / 2, -sliderSize.y / 2, sliderSize.x, sliderSize.y, slider.borderRadius);
        // Calculate the nib size and position
        var x = MathUtils_1["default"].lerp(-slider.size.x / 2, slider.size.x / 2, slider.getValue());
        // Draw the nib
        this.ctx.fillStyle = slider.nibColor.toString();
        this.ctx.fillRoundedRect(x - slider.nibSize.x / 2, -slider.nibSize.y / 2, slider.nibSize.x, slider.nibSize.y, slider.borderRadius);
        // Reset the alpha
        this.ctx.globalAlpha = previousAlpha;
    };
    /**
     * Renders a textInput
     * @param textInput The textInput to render
     */
    UIElementRenderer.prototype.renderTextInput = function (textInput) {
        // Show a cursor sometimes
        if (textInput.focused && textInput.cursorCounter % 60 > 30) {
            textInput.text += "|";
        }
        this.renderLabel(textInput);
        if (textInput.focused) {
            if (textInput.cursorCounter % 60 > 30) {
                textInput.text = textInput.text.substring(0, textInput.text.length - 1);
            }
            textInput.cursorCounter += 1;
            if (textInput.cursorCounter >= 60) {
                textInput.cursorCounter = 0;
            }
        }
    };
    return UIElementRenderer;
}());
exports["default"] = UIElementRenderer;
},{"../../DataTypes/Vec2":20,"../../ResourceManager/ResourceManager":79,"../../Utils/MathUtils":97}],71:[function(require,module,exports){
"use strict";
exports.__esModule = true;
var ResourceManager_1 = require("../ResourceManager/ResourceManager");
/**
 * An abstract framework to put all rendering in once place in the application
 */
var RenderingManager = /** @class */ (function () {
    function RenderingManager() {
        this.resourceManager = ResourceManager_1["default"].getInstance();
    }
    /**
     * Sets the scene currently being rendered
     * @param scene The current Scene
     */
    RenderingManager.prototype.setScene = function (scene) {
        this.scene = scene;
    };
    return RenderingManager;
}());
exports["default"] = RenderingManager;
},{"../ResourceManager/ResourceManager":79}],72:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
exports.__esModule = true;
var Vec2_1 = require("../DataTypes/Vec2");
var Graphic_1 = require("../Nodes/Graphic");
var Point_1 = require("../Nodes/Graphics/Point");
var Rect_1 = require("../Nodes/Graphics/Rect");
var AnimatedSprite_1 = require("../Nodes/Sprites/AnimatedSprite");
var Sprite_1 = require("../Nodes/Sprites/Sprite");
var UIElement_1 = require("../Nodes/UIElement");
var Label_1 = require("../Nodes/UIElements/Label");
var ShaderRegistry_1 = require("../Registry/Registries/ShaderRegistry");
var RegistryManager_1 = require("../Registry/RegistryManager");
var ResourceManager_1 = require("../ResourceManager/ResourceManager");
var ParallaxLayer_1 = require("../Scene/Layers/ParallaxLayer");
var RenderingManager_1 = require("./RenderingManager");
var WebGLRenderer = /** @class */ (function (_super) {
    __extends(WebGLRenderer, _super);
    function WebGLRenderer() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    WebGLRenderer.prototype.initializeCanvas = function (canvas, width, height) {
        canvas.width = width;
        canvas.height = height;
        this.worldSize = Vec2_1["default"].ZERO;
        this.worldSize.x = width;
        this.worldSize.y = height;
        // Get the WebGL context
        this.gl = canvas.getContext("webgl");
        this.gl.viewport(0, 0, canvas.width, canvas.height);
        this.gl.disable(this.gl.DEPTH_TEST);
        this.gl.enable(this.gl.BLEND);
        this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);
        this.gl.enable(this.gl.CULL_FACE);
        // Tell the resource manager we're using WebGL
        ResourceManager_1["default"].getInstance().useWebGL(true, this.gl);
        // Show the text canvas and get its context
        var textCanvas = document.getElementById("text-canvas");
        textCanvas.hidden = false;
        this.textCtx = textCanvas.getContext("2d");
        // Size the text canvas to be the same as the game canvas
        textCanvas.height = height;
        textCanvas.width = width;
        return this.gl;
    };
    WebGLRenderer.prototype.render = function (visibleSet, tilemaps, uiLayers) {
        var _this = this;
        for (var _i = 0, visibleSet_1 = visibleSet; _i < visibleSet_1.length; _i++) {
            var node = visibleSet_1[_i];
            this.renderNode(node);
        }
        uiLayers.forEach(function (key) {
            if (!uiLayers.get(key).isHidden())
                uiLayers.get(key).getItems().forEach(function (node) { return _this.renderNode(node); });
        });
    };
    WebGLRenderer.prototype.clear = function (color) {
        this.gl.clearColor(color.r, color.g, color.b, color.a);
        this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
        this.textCtx.clearRect(0, 0, this.worldSize.x, this.worldSize.y);
    };
    WebGLRenderer.prototype.renderNode = function (node) {
        // Calculate the origin of the viewport according to this sprite
        this.origin = this.scene.getViewTranslation(node);
        // Get the zoom level of the scene
        this.zoom = this.scene.getViewScale();
        if (node.hasCustomShader) {
            // If the node has a custom shader, render using that
            this.renderCustom(node);
        }
        else if (node instanceof Graphic_1["default"]) {
            this.renderGraphic(node);
        }
        else if (node instanceof Sprite_1["default"]) {
            if (node instanceof AnimatedSprite_1["default"]) {
                this.renderAnimatedSprite(node);
            }
            else {
                this.renderSprite(node);
            }
        }
        else if (node instanceof UIElement_1["default"]) {
            this.renderUIElement(node);
        }
    };
    WebGLRenderer.prototype.renderSprite = function (sprite) {
        var shader = RegistryManager_1["default"].shaders.get(ShaderRegistry_1["default"].SPRITE_SHADER);
        var options = this.addOptions(shader.getOptions(sprite), sprite);
        shader.render(this.gl, options);
    };
    WebGLRenderer.prototype.renderAnimatedSprite = function (sprite) {
        var shader = RegistryManager_1["default"].shaders.get(ShaderRegistry_1["default"].SPRITE_SHADER);
        var options = this.addOptions(shader.getOptions(sprite), sprite);
        shader.render(this.gl, options);
    };
    WebGLRenderer.prototype.renderGraphic = function (graphic) {
        if (graphic instanceof Point_1["default"]) {
            var shader = RegistryManager_1["default"].shaders.get(ShaderRegistry_1["default"].POINT_SHADER);
            var options = this.addOptions(shader.getOptions(graphic), graphic);
            shader.render(this.gl, options);
        }
        else if (graphic instanceof Rect_1["default"]) {
            var shader = RegistryManager_1["default"].shaders.get(ShaderRegistry_1["default"].RECT_SHADER);
            var options = this.addOptions(shader.getOptions(graphic), graphic);
            shader.render(this.gl, options);
        }
    };
    WebGLRenderer.prototype.renderTilemap = function (tilemap) {
        throw new Error("Method not implemented.");
    };
    WebGLRenderer.prototype.renderUIElement = function (uiElement) {
        if (uiElement instanceof Label_1["default"]) {
            var shader = RegistryManager_1["default"].shaders.get(ShaderRegistry_1["default"].LABEL_SHADER);
            var options = this.addOptions(shader.getOptions(uiElement), uiElement);
            shader.render(this.gl, options);
            this.textCtx.setTransform(1, 0, 0, 1, (uiElement.position.x - this.origin.x) * this.zoom, (uiElement.position.y - this.origin.y) * this.zoom);
            this.textCtx.rotate(-uiElement.rotation);
            var globalAlpha = this.textCtx.globalAlpha;
            this.textCtx.globalAlpha = uiElement.alpha;
            // Render text
            this.textCtx.font = uiElement.getFontString();
            var offset = uiElement.calculateTextOffset(this.textCtx);
            this.textCtx.fillStyle = uiElement.calculateTextColor();
            this.textCtx.globalAlpha = uiElement.textColor.a;
            this.textCtx.fillText(uiElement.text, offset.x - uiElement.size.x / 2, offset.y - uiElement.size.y / 2);
            this.textCtx.globalAlpha = globalAlpha;
            this.textCtx.setTransform(1, 0, 0, 1, 0, 0);
        }
    };
    WebGLRenderer.prototype.renderCustom = function (node) {
        var shader = RegistryManager_1["default"].shaders.get(node.customShaderKey);
        var options = this.addOptions(shader.getOptions(node), node);
        shader.render(this.gl, options);
    };
    WebGLRenderer.prototype.addOptions = function (options, node) {
        // Give the shader access to the world size
        options.worldSize = this.worldSize;
        // Adjust the origin position to the parallax
        var layer = node.getLayer();
        var parallax = new Vec2_1["default"](1, 1);
        if (layer instanceof ParallaxLayer_1["default"]) {
            parallax = layer.parallax;
        }
        options.origin = this.origin.clone().mult(parallax);
        return options;
    };
    return WebGLRenderer;
}(RenderingManager_1["default"]));
exports["default"] = WebGLRenderer;
},{"../DataTypes/Vec2":20,"../Nodes/Graphic":37,"../Nodes/Graphics/Point":41,"../Nodes/Graphics/Rect":42,"../Nodes/Sprites/AnimatedSprite":43,"../Nodes/Sprites/Sprite":44,"../Nodes/UIElement":47,"../Nodes/UIElements/Label":49,"../Registry/Registries/ShaderRegistry":60,"../Registry/RegistryManager":61,"../ResourceManager/ResourceManager":79,"../Scene/Layers/ParallaxLayer":87,"./RenderingManager":71}],73:[function(require,module,exports){
"use strict";
exports.__esModule = true;
var ResourceManager_1 = require("../../ResourceManager/ResourceManager");
/**
 * A wrapper class for WebGL shaders.
 * This class is a singleton, and there is only one for each shader type.
 * All objects that use this shader type will refer to and modify this same type.
 */
var ShaderType = /** @class */ (function () {
    function ShaderType(programKey) {
        this.programKey = programKey;
        this.resourceManager = ResourceManager_1["default"].getInstance();
    }
    /**
     * Extracts the options from the CanvasNode and gives them to the render function
     * @param node The node to get options from
     * @returns An object containing the options that should be passed to the render function
     */
    ShaderType.prototype.getOptions = function (node) { return {}; };
    return ShaderType;
}());
exports["default"] = ShaderType;
},{"../../ResourceManager/ResourceManager":79}],74:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
exports.__esModule = true;
var Mat4x4_1 = require("../../../DataTypes/Mat4x4");
var Vec2_1 = require("../../../DataTypes/Vec2");
var ResourceManager_1 = require("../../../ResourceManager/ResourceManager");
var QuadShaderType_1 = require("./QuadShaderType");
/** */
var LabelShaderType = /** @class */ (function (_super) {
    __extends(LabelShaderType, _super);
    function LabelShaderType(programKey) {
        var _this = _super.call(this, programKey) || this;
        _this.resourceManager = ResourceManager_1["default"].getInstance();
        return _this;
    }
    LabelShaderType.prototype.initBufferObject = function () {
        this.bufferObjectKey = "label";
        this.resourceManager.createBuffer(this.bufferObjectKey);
    };
    LabelShaderType.prototype.render = function (gl, options) {
        var backgroundColor = options.backgroundColor.toWebGL();
        var borderColor = options.borderColor.toWebGL();
        var program = this.resourceManager.getShaderProgram(this.programKey);
        var buffer = this.resourceManager.getBuffer(this.bufferObjectKey);
        gl.useProgram(program);
        var vertexData = this.getVertices(options.size.x, options.size.y);
        var FSIZE = vertexData.BYTES_PER_ELEMENT;
        // Bind the buffer
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertexData, gl.STATIC_DRAW);
        // Attributes
        var a_Position = gl.getAttribLocation(program, "a_Position");
        gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, 2 * FSIZE, 0 * FSIZE);
        gl.enableVertexAttribArray(a_Position);
        // Uniforms
        var u_BackgroundColor = gl.getUniformLocation(program, "u_BackgroundColor");
        gl.uniform4fv(u_BackgroundColor, backgroundColor);
        var u_BorderColor = gl.getUniformLocation(program, "u_BorderColor");
        gl.uniform4fv(u_BorderColor, borderColor);
        var u_MaxSize = gl.getUniformLocation(program, "u_MaxSize");
        gl.uniform2f(u_MaxSize, -vertexData[0], vertexData[1]);
        // Get transformation matrix
        // We want a square for our rendering space, so get the maximum dimension of our quad
        var maxDimension = Math.max(options.size.x, options.size.y);
        var u_BorderWidth = gl.getUniformLocation(program, "u_BorderWidth");
        gl.uniform1f(u_BorderWidth, options.borderWidth / maxDimension);
        var u_BorderRadius = gl.getUniformLocation(program, "u_BorderRadius");
        gl.uniform1f(u_BorderRadius, options.borderRadius / maxDimension);
        // The size of the rendering space will be a square with this maximum dimension
        var size = new Vec2_1["default"](maxDimension, maxDimension).scale(2 / options.worldSize.x, 2 / options.worldSize.y);
        // Center our translations around (0, 0)
        var translateX = (options.position.x - options.origin.x - options.worldSize.x / 2) / maxDimension;
        var translateY = -(options.position.y - options.origin.y - options.worldSize.y / 2) / maxDimension;
        // Create our transformation matrix
        this.translation.translate(new Float32Array([translateX, translateY]));
        this.scale.scale(size);
        this.rotation.rotate(options.rotation);
        var transformation = Mat4x4_1["default"].MULT(this.translation, this.scale, this.rotation);
        // Pass the translation matrix to our shader
        var u_Transform = gl.getUniformLocation(program, "u_Transform");
        gl.uniformMatrix4fv(u_Transform, false, transformation.toArray());
        // Draw the quad
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    };
    /**
     * The rendering space always has to be a square, so make sure its square w.r.t to the largest dimension
     * @param w The width of the quad in pixels
     * @param h The height of the quad in pixels
     * @returns An array of the vertices of the quad
     */
    LabelShaderType.prototype.getVertices = function (w, h) {
        var x, y;
        if (h > w) {
            y = 0.5;
            x = w / (2 * h);
        }
        else {
            x = 0.5;
            y = h / (2 * w);
        }
        return new Float32Array([
            -x, y,
            -x, -y,
            x, y,
            x, -y
        ]);
    };
    LabelShaderType.prototype.getOptions = function (rect) {
        var options = {
            position: rect.position,
            backgroundColor: rect.calculateBackgroundColor(),
            borderColor: rect.calculateBorderColor(),
            borderWidth: rect.borderWidth,
            borderRadius: rect.borderRadius,
            size: rect.size,
            rotation: rect.rotation
        };
        return options;
    };
    return LabelShaderType;
}(QuadShaderType_1["default"]));
exports["default"] = LabelShaderType;
},{"../../../DataTypes/Mat4x4":9,"../../../DataTypes/Vec2":20,"../../../ResourceManager/ResourceManager":79,"./QuadShaderType":76}],75:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
exports.__esModule = true;
var RenderingUtils_1 = require("../../../Utils/RenderingUtils");
var ShaderType_1 = require("../ShaderType");
var PointShaderType = /** @class */ (function (_super) {
    __extends(PointShaderType, _super);
    function PointShaderType(programKey) {
        return _super.call(this, programKey) || this;
    }
    PointShaderType.prototype.initBufferObject = function () {
        this.bufferObjectKey = "point";
        this.resourceManager.createBuffer(this.bufferObjectKey);
    };
    PointShaderType.prototype.render = function (gl, options) {
        var position = RenderingUtils_1["default"].toWebGLCoords(options.position, options.origin, options.worldSize);
        var color = RenderingUtils_1["default"].toWebGLColor(options.color);
        var program = this.resourceManager.getShaderProgram(this.programKey);
        var buffer = this.resourceManager.getBuffer(this.bufferObjectKey);
        gl.useProgram(program);
        var vertexData = position;
        var FSIZE = vertexData.BYTES_PER_ELEMENT;
        // Bind the buffer
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertexData, gl.STATIC_DRAW);
        // Attributes
        var a_Position = gl.getAttribLocation(program, "a_Position");
        gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, 2 * FSIZE, 0 * FSIZE);
        gl.enableVertexAttribArray(a_Position);
        // Uniforms
        var u_Color = gl.getUniformLocation(program, "u_Color");
        gl.uniform4fv(u_Color, color);
        var u_PointSize = gl.getUniformLocation(program, "u_PointSize");
        gl.uniform1f(u_PointSize, options.pointSize);
        gl.drawArrays(gl.POINTS, 0, 1);
    };
    PointShaderType.prototype.getOptions = function (point) {
        var options = {
            position: point.position,
            color: point.color,
            pointSize: point.size
        };
        return options;
    };
    return PointShaderType;
}(ShaderType_1["default"]));
exports["default"] = PointShaderType;
},{"../../../Utils/RenderingUtils":98,"../ShaderType":73}],76:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
exports.__esModule = true;
var Mat4x4_1 = require("../../../DataTypes/Mat4x4");
var ShaderType_1 = require("../ShaderType");
/** Represents any WebGL objects that have a quad mesh (i.e. a rectangular game object composed of only two triangles) */
var QuadShaderType = /** @class */ (function (_super) {
    __extends(QuadShaderType, _super);
    function QuadShaderType(programKey) {
        var _this = _super.call(this, programKey) || this;
        _this.scale = Mat4x4_1["default"].IDENTITY;
        _this.rotation = Mat4x4_1["default"].IDENTITY;
        _this.translation = Mat4x4_1["default"].IDENTITY;
        return _this;
    }
    return QuadShaderType;
}(ShaderType_1["default"]));
exports["default"] = QuadShaderType;
},{"../../../DataTypes/Mat4x4":9,"../ShaderType":73}],77:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
exports.__esModule = true;
var Mat4x4_1 = require("../../../DataTypes/Mat4x4");
var Vec2_1 = require("../../../DataTypes/Vec2");
var ResourceManager_1 = require("../../../ResourceManager/ResourceManager");
var QuadShaderType_1 = require("./QuadShaderType");
/** */
var RectShaderType = /** @class */ (function (_super) {
    __extends(RectShaderType, _super);
    function RectShaderType(programKey) {
        var _this = _super.call(this, programKey) || this;
        _this.resourceManager = ResourceManager_1["default"].getInstance();
        return _this;
    }
    RectShaderType.prototype.initBufferObject = function () {
        this.bufferObjectKey = "rect";
        this.resourceManager.createBuffer(this.bufferObjectKey);
    };
    RectShaderType.prototype.render = function (gl, options) {
        var color = options.color.toWebGL();
        var program = this.resourceManager.getShaderProgram(this.programKey);
        var buffer = this.resourceManager.getBuffer(this.bufferObjectKey);
        gl.useProgram(program);
        var vertexData = this.getVertices(options.size.x, options.size.y);
        var FSIZE = vertexData.BYTES_PER_ELEMENT;
        // Bind the buffer
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertexData, gl.STATIC_DRAW);
        // Attributes
        var a_Position = gl.getAttribLocation(program, "a_Position");
        gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, 2 * FSIZE, 0 * FSIZE);
        gl.enableVertexAttribArray(a_Position);
        // Uniforms
        var u_Color = gl.getUniformLocation(program, "u_Color");
        gl.uniform4fv(u_Color, color);
        // Get transformation matrix
        // We want a square for our rendering space, so get the maximum dimension of our quad
        var maxDimension = Math.max(options.size.x, options.size.y);
        // The size of the rendering space will be a square with this maximum dimension
        var size = new Vec2_1["default"](maxDimension, maxDimension).scale(2 / options.worldSize.x, 2 / options.worldSize.y);
        // Center our translations around (0, 0)
        var translateX = (options.position.x - options.origin.x - options.worldSize.x / 2) / maxDimension;
        var translateY = -(options.position.y - options.origin.y - options.worldSize.y / 2) / maxDimension;
        // Create our transformation matrix
        this.translation.translate(new Float32Array([translateX, translateY]));
        this.scale.scale(size);
        this.rotation.rotate(options.rotation);
        var transformation = Mat4x4_1["default"].MULT(this.translation, this.scale, this.rotation);
        // Pass the translation matrix to our shader
        var u_Transform = gl.getUniformLocation(program, "u_Transform");
        gl.uniformMatrix4fv(u_Transform, false, transformation.toArray());
        // Draw the quad
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    };
    /*
        So as it turns out, WebGL has an issue with non-square quads.
        It doesn't like when you don't have a 1-1 scale, and rotations are entirely messed up if this is not the case.
        To solve this, I used the scale of the LARGEST dimension of the quad to make a square, then adjusted the vertex coordinates inside of that.
        A diagram of the solution follows.

        There is a bounding square for the quad with dimensions hxh (in this case, since height is the largest dimension).
        The offset in the vertical direction is therefore 0.5, as it is normally.
        However, the offset in the horizontal direction is not so straightforward, but isn't conceptually hard.
        All we really have to do is a range change from [0, height/2] to [0, 0.5], where our value is t = width/2, and 0 <= t <= height/2.

        So now we have our rect, in a space scaled with respect to the largest dimension.
        Rotations work as you would expect, even for long rectangles.

                    0.5
            __ __ __ __ __ __ __
            |	|88888888888|	|
            |	|88888888888|	|
            |	|88888888888|	|
        -0.5|_ _|88888888888|_ _|0.5
            |	|88888888888|	|
            |	|88888888888|	|
            |	|88888888888|	|
            |___|88888888888|___|
                    -0.5

        The getVertices function below does as described, and converts the range
    */
    /**
     * The rendering space always has to be a square, so make sure its square w.r.t to the largest dimension
     * @param w The width of the quad in pixels
     * @param h The height of the quad in pixels
     * @returns An array of the vertices of the quad
     */
    RectShaderType.prototype.getVertices = function (w, h) {
        var x, y;
        if (h > w) {
            y = 0.5;
            x = w / (2 * h);
        }
        else {
            x = 0.5;
            y = h / (2 * w);
        }
        return new Float32Array([
            -x, y,
            -x, -y,
            x, y,
            x, -y
        ]);
    };
    RectShaderType.prototype.getOptions = function (rect) {
        var options = {
            position: rect.position,
            color: rect.color,
            size: rect.size,
            rotation: rect.rotation
        };
        return options;
    };
    return RectShaderType;
}(QuadShaderType_1["default"]));
exports["default"] = RectShaderType;
},{"../../../DataTypes/Mat4x4":9,"../../../DataTypes/Vec2":20,"../../../ResourceManager/ResourceManager":79,"./QuadShaderType":76}],78:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
exports.__esModule = true;
var Mat4x4_1 = require("../../../DataTypes/Mat4x4");
var Vec2_1 = require("../../../DataTypes/Vec2");
var AnimatedSprite_1 = require("../../../Nodes/Sprites/AnimatedSprite");
var ResourceManager_1 = require("../../../ResourceManager/ResourceManager");
var QuadShaderType_1 = require("./QuadShaderType");
/** A shader for sprites and animated sprites */
var SpriteShaderType = /** @class */ (function (_super) {
    __extends(SpriteShaderType, _super);
    function SpriteShaderType(programKey) {
        var _this = _super.call(this, programKey) || this;
        _this.resourceManager = ResourceManager_1["default"].getInstance();
        return _this;
    }
    SpriteShaderType.prototype.initBufferObject = function () {
        this.bufferObjectKey = "sprite";
        this.resourceManager.createBuffer(this.bufferObjectKey);
    };
    SpriteShaderType.prototype.render = function (gl, options) {
        var program = this.resourceManager.getShaderProgram(this.programKey);
        var buffer = this.resourceManager.getBuffer(this.bufferObjectKey);
        var texture = this.resourceManager.getTexture(options.imageKey);
        gl.useProgram(program);
        var vertexData = this.getVertices(options.size.x, options.size.y, options.scale);
        var FSIZE = vertexData.BYTES_PER_ELEMENT;
        // Bind the buffer
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertexData, gl.STATIC_DRAW);
        // Attributes
        var a_Position = gl.getAttribLocation(program, "a_Position");
        gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, 4 * FSIZE, 0 * FSIZE);
        gl.enableVertexAttribArray(a_Position);
        var a_TexCoord = gl.getAttribLocation(program, "a_TexCoord");
        gl.vertexAttribPointer(a_TexCoord, 2, gl.FLOAT, false, 4 * FSIZE, 2 * FSIZE);
        gl.enableVertexAttribArray(a_TexCoord);
        // Uniforms
        // Get transformation matrix
        // We want a square for our rendering space, so get the maximum dimension of our quad
        var maxDimension = Math.max(options.size.x, options.size.y);
        // The size of the rendering space will be a square with this maximum dimension
        var size = new Vec2_1["default"](maxDimension, maxDimension).scale(2 / options.worldSize.x, 2 / options.worldSize.y);
        // Center our translations around (0, 0)
        var translateX = (options.position.x - options.origin.x - options.worldSize.x / 2) / maxDimension;
        var translateY = -(options.position.y - options.origin.y - options.worldSize.y / 2) / maxDimension;
        // Create our transformation matrix
        this.translation.translate(new Float32Array([translateX, translateY]));
        this.scale.scale(size);
        this.rotation.rotate(options.rotation);
        var transformation = Mat4x4_1["default"].MULT(this.translation, this.scale, this.rotation);
        // Pass the translation matrix to our shader
        var u_Transform = gl.getUniformLocation(program, "u_Transform");
        gl.uniformMatrix4fv(u_Transform, false, transformation.toArray());
        // Set up our sampler with our assigned texture unit
        var u_Sampler = gl.getUniformLocation(program, "u_Sampler");
        gl.uniform1i(u_Sampler, texture);
        // Pass in texShift
        var u_texShift = gl.getUniformLocation(program, "u_texShift");
        gl.uniform2fv(u_texShift, options.texShift);
        // Pass in texScale
        var u_texScale = gl.getUniformLocation(program, "u_texScale");
        gl.uniform2fv(u_texScale, options.texScale);
        // Draw the quad
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    };
    /**
     * The rendering space always has to be a square, so make sure its square w.r.t to the largest dimension
     * @param w The width of the quad in pixels
     * @param h The height of the quad in pixels
     * @returns An array of the vertices of the quad
     */
    SpriteShaderType.prototype.getVertices = function (w, h, scale) {
        var x, y;
        if (h > w) {
            y = 0.5;
            x = w / (2 * h);
        }
        else {
            x = 0.5;
            y = h / (2 * w);
        }
        // Scale the rendering space if needed
        x *= scale[0];
        y *= scale[1];
        return new Float32Array([
            -x, y, 0.0, 0.0,
            -x, -y, 0.0, 1.0,
            x, y, 1.0, 0.0,
            x, -y, 1.0, 1.0
        ]);
    };
    SpriteShaderType.prototype.getOptions = function (sprite) {
        var texShift;
        var texScale;
        if (sprite instanceof AnimatedSprite_1["default"]) {
            var animationIndex = sprite.animation.getIndexAndAdvanceAnimation();
            var offset = sprite.getAnimationOffset(animationIndex);
            texShift = new Float32Array([offset.x / (sprite.cols * sprite.size.x), offset.y / (sprite.rows * sprite.size.y)]);
            texScale = new Float32Array([1 / (sprite.cols), 1 / (sprite.rows)]);
        }
        else {
            texShift = new Float32Array([0, 0]);
            texScale = new Float32Array([1, 1]);
        }
        var options = {
            position: sprite.position,
            rotation: sprite.rotation,
            size: sprite.size,
            scale: sprite.scale.toArray(),
            imageKey: sprite.imageId,
            texShift: texShift,
            texScale: texScale
        };
        return options;
    };
    return SpriteShaderType;
}(QuadShaderType_1["default"]));
exports["default"] = SpriteShaderType;
},{"../../../DataTypes/Mat4x4":9,"../../../DataTypes/Vec2":20,"../../../Nodes/Sprites/AnimatedSprite":43,"../../../ResourceManager/ResourceManager":79,"./QuadShaderType":76}],79:[function(require,module,exports){
"use strict";
exports.__esModule = true;
var Map_1 = require("../DataTypes/Map");
var Queue_1 = require("../DataTypes/Queue");
var StringUtils_1 = require("../Utils/StringUtils");
var AudioManager_1 = require("../Sound/AudioManager");
var WebGLProgramType_1 = require("../DataTypes/Rendering/WebGLProgramType");
/**
 * The resource manager for the game engine.
 * The resource manager interfaces with the loadable assets of a game such as images, data files,
 * and sounds, which are all found in the dist folder.
 * This class controls loading and updates the @reference[Scene] with the loading progress, so that the scene does
 * not start before all necessary assets are loaded.
 */
var ResourceManager = /** @class */ (function () {
    function ResourceManager() {
        this.loading = false;
        this.justLoaded = false;
        this.loadonly_imagesLoaded = 0;
        this.loadonly_imagesToLoad = 0;
        this.loadonly_imageLoadingQueue = new Queue_1["default"]();
        this.images = new Map_1["default"]();
        this.loadonly_spritesheetsLoaded = 0;
        this.loadonly_spritesheetsToLoad = 0;
        this.loadonly_spritesheetLoadingQueue = new Queue_1["default"]();
        this.spritesheets = new Map_1["default"]();
        this.loadonly_tilemapsLoaded = 0;
        this.loadonly_tilemapsToLoad = 0;
        this.loadonly_tilemapLoadingQueue = new Queue_1["default"]();
        this.tilemaps = new Map_1["default"]();
        this.loadonly_audioLoaded = 0;
        this.loadonly_audioToLoad = 0;
        this.loadonly_audioLoadingQueue = new Queue_1["default"]();
        this.audioBuffers = new Map_1["default"]();
        this.loadonly_jsonLoaded = 0;
        this.loadonly_jsonToLoad = 0;
        this.loadonly_jsonLoadingQueue = new Queue_1["default"]();
        this.jsonObjects = new Map_1["default"]();
        this.loadonly_gl_ShaderProgramsLoaded = 0;
        this.loadonly_gl_ShaderProgramsToLoad = 0;
        this.loadonly_gl_ShaderLoadingQueue = new Queue_1["default"]();
        this.gl_ShaderPrograms = new Map_1["default"]();
        this.gl_Textures = new Map_1["default"]();
        this.gl_NextTextureID = 0;
        this.gl_Buffers = new Map_1["default"]();
        this.resourcesToUnload = new Array();
        this.resourcesToKeep = new Array();
    }
    ;
    /* ######################################## SINGLETON ########################################*/
    /**
     * Returns the current instance of this class or a new instance if none exist
     * @returns The resource manager
     */
    ResourceManager.getInstance = function () {
        if (!this.instance) {
            this.instance = new ResourceManager();
        }
        return this.instance;
    };
    /* ######################################## PUBLIC FUNCTION ########################################*/
    /**
     * Activates or deactivates the use of WebGL
     * @param flag True if WebGL should be used, false otherwise
     * @param gl The instance of the graphics context, if applicable
     */
    ResourceManager.prototype.useWebGL = function (flag, gl) {
        this.gl_WebGLActive = flag;
        if (this.gl_WebGLActive) {
            this.gl = gl;
        }
    };
    /**
     * Loads an image from file
     * @param key The key to associate the loaded image with
     * @param path The path to the image to load
     */
    ResourceManager.prototype.image = function (key, path) {
        this.loadonly_imageLoadingQueue.enqueue({ key: key, path: path });
    };
    /**
     * Tells the resource manager to keep this resource
     * @param key The key of the resource
     */
    ResourceManager.prototype.keepImage = function (key) {
        this.keepResource(key, ResourceType.IMAGE);
    };
    /**
     * Retrieves a loaded image
     * @param key The key of the loaded image
     * @returns The image element associated with this key
     */
    ResourceManager.prototype.getImage = function (key) {
        var image = this.images.get(key);
        if (image === undefined) {
            throw "There is no image associated with key \"".concat(key, "\"");
        }
        return image;
    };
    /**
     * Loads a spritesheet from file
     * @param key The key to associate the loaded spritesheet with
     * @param path The path to the spritesheet to load
     */
    ResourceManager.prototype.spritesheet = function (key, path) {
        this.loadonly_spritesheetLoadingQueue.enqueue({ key: key, path: path });
    };
    /**
     * Tells the resource manager to keep this resource
     * @param key The key of the resource
     */
    ResourceManager.prototype.keepSpritesheet = function (key) {
        this.keepResource(key, ResourceType.SPRITESHEET);
    };
    /**
     * Retrieves a loaded spritesheet
     * @param key The key of the spritesheet to load
     * @returns The loaded Spritesheet
     */
    ResourceManager.prototype.getSpritesheet = function (key) {
        return this.spritesheets.get(key);
    };
    /**
     * Loads an audio file
     * @param key The key to associate with the loaded audio file
     * @param path The path to the audio file to load
     */
    ResourceManager.prototype.audio = function (key, path) {
        this.loadonly_audioLoadingQueue.enqueue({ key: key, path: path });
    };
    /**
     * Tells the resource manager to keep this resource
     * @param key The key of the resource
     */
    ResourceManager.prototype.keepAudio = function (key) {
        this.keepResource(key, ResourceType.AUDIO);
    };
    /**
     * Retrieves a loaded audio file
     * @param key The key of the audio file to load
     * @returns The AudioBuffer created from the loaded audio fle
     */
    ResourceManager.prototype.getAudio = function (key) {
        return this.audioBuffers.get(key);
    };
    /**
     * Load a tilemap from a json file. Automatically loads related images
     * @param key The key to associate with the loaded tilemap
     * @param path The path to the tilemap to load
     */
    ResourceManager.prototype.tilemap = function (key, path) {
        this.loadonly_tilemapLoadingQueue.enqueue({ key: key, path: path });
    };
    /**
     * Tells the resource manager to keep this resource
     * @param key The key of the resource
     */
    ResourceManager.prototype.keepTilemap = function (key) {
        this.keepResource(key, ResourceType.TILEMAP);
    };
    /**
     * Retreives a loaded tilemap
     * @param key The key of the loaded tilemap
     * @returns The tilemap data associated with the key
     */
    ResourceManager.prototype.getTilemap = function (key) {
        return this.tilemaps.get(key);
    };
    /**
     * Loads an object from a json file.
     * @param key The key to associate with the loaded object
     * @param path The path to the json file to load
     */
    ResourceManager.prototype.object = function (key, path) {
        this.loadonly_jsonLoadingQueue.enqueue({ key: key, path: path });
    };
    /**
     * Tells the resource manager to keep this resource
     * @param key The key of the resource
     */
    ResourceManager.prototype.keepObject = function (key) {
        this.keepResource(key, ResourceType.JSON);
    };
    /**
     * Retreives a loaded object
     * @param key The key of the loaded object
     * @returns The object data associated with the key
     */
    ResourceManager.prototype.getObject = function (key) {
        return this.jsonObjects.get(key);
    };
    /* ######################################## LOAD FUNCTION ########################################*/
    /**
     * Loads all resources currently in the queue
     * @param callback The function to cal when the resources are finished loading
     */
    ResourceManager.prototype.loadResourcesFromQueue = function (callback) {
        var _this = this;
        this.loadonly_typesToLoad = 5;
        this.loading = true;
        // Load everything in the queues. Tilemaps have to come before images because they will add new images to the queue
        this.loadTilemapsFromQueue(function () {
            console.log("Loaded Tilemaps");
            _this.loadSpritesheetsFromQueue(function () {
                console.log("Loaded Spritesheets");
                _this.loadImagesFromQueue(function () {
                    console.log("Loaded Images");
                    _this.loadAudioFromQueue(function () {
                        console.log("Loaded Audio");
                        _this.loadObjectsFromQueue(function () {
                            console.log("Loaded Objects");
                            if (_this.gl_WebGLActive) {
                                _this.gl_LoadShadersFromQueue(function () {
                                    console.log("Loaded Shaders");
                                    _this.finishLoading(callback);
                                });
                            }
                            else {
                                _this.finishLoading(callback);
                            }
                        });
                    });
                });
            });
        });
    };
    ResourceManager.prototype.finishLoading = function (callback) {
        // Done loading
        this.loading = false;
        this.justLoaded = true;
        callback();
    };
    /* ######################################## UNLOAD FUNCTION ########################################*/
    ResourceManager.prototype.keepResource = function (key, type) {
        var _a;
        console.log("Keep resource...");
        for (var i = 0; i < this.resourcesToUnload.length; i++) {
            var resource = this.resourcesToUnload[i];
            if (resource.key === key && resource.resourceType === type) {
                console.log("Found resource " + key + " of type " + type + ". Keeping.");
                var resourceToMove = this.resourcesToUnload.splice(i, 1);
                (_a = this.resourcesToKeep).push.apply(_a, resourceToMove);
                return;
            }
        }
    };
    /**
     * Deletes references to all resources in the resource manager
     */
    ResourceManager.prototype.unloadAllResources = function () {
        this.loading = false;
        this.justLoaded = false;
        for (var _i = 0, _a = this.resourcesToUnload; _i < _a.length; _i++) {
            var resource = _a[_i];
            // Unload the resource
            this.unloadResource(resource);
        }
    };
    ResourceManager.prototype.unloadResource = function (resource) {
        // Delete the resource itself
        switch (resource.resourceType) {
            case ResourceType.IMAGE:
                this.images["delete"](resource.key);
                if (this.gl_WebGLActive) {
                    this.gl_Textures["delete"](resource.key);
                }
                break;
            case ResourceType.TILEMAP:
                this.tilemaps["delete"](resource.key);
                break;
            case ResourceType.SPRITESHEET:
                this.spritesheets["delete"](resource.key);
                break;
            case ResourceType.AUDIO:
                this.audioBuffers["delete"](resource.key);
                break;
            case ResourceType.JSON:
                this.jsonObjects["delete"](resource.key);
                break;
            /*case ResourceType.SHADER:
                this.gl_ShaderPrograms.get(resource.key).delete(this.gl);
                this.gl_ShaderPrograms.delete(resource.key);
                break;*/
        }
        // Delete any dependencies
        for (var _i = 0, _a = resource.dependencies; _i < _a.length; _i++) {
            var dependency = _a[_i];
            this.unloadResource(dependency);
        }
    };
    /* ######################################## WORK FUNCTIONS ########################################*/
    /**
     * Loads all tilemaps currently in the tilemap loading queue
     * @param onFinishLoading The function to call when loading is complete
     */
    ResourceManager.prototype.loadTilemapsFromQueue = function (onFinishLoading) {
        this.loadonly_tilemapsToLoad = this.loadonly_tilemapLoadingQueue.getSize();
        this.loadonly_tilemapsLoaded = 0;
        // If no items to load, we're finished
        if (this.loadonly_tilemapsToLoad === 0) {
            onFinishLoading();
            return;
        }
        while (this.loadonly_tilemapLoadingQueue.hasItems()) {
            var tilemap = this.loadonly_tilemapLoadingQueue.dequeue();
            this.loadTilemap(tilemap.key, tilemap.path, onFinishLoading);
        }
    };
    /**
     * Loads a singular tilemap
     * @param key The key of the tilemap
     * @param pathToTilemapJSON The path to the tilemap JSON file
     * @param callbackIfLast The function to call if this is the last tilemap to load
     */
    ResourceManager.prototype.loadTilemap = function (key, pathToTilemapJSON, callbackIfLast) {
        var _this = this;
        this.loadTextFile(pathToTilemapJSON, function (fileText) {
            var tilemapObject = JSON.parse(fileText);
            // We can parse the object later - it's much faster than loading
            _this.tilemaps.add(key, tilemapObject);
            var resource = new ResourceReference(key, ResourceType.TILEMAP);
            // Grab the tileset images we need to load and add them to the imageloading queue
            for (var _i = 0, _a = tilemapObject.tilesets; _i < _a.length; _i++) {
                var tileset = _a[_i];
                if (tileset.image) {
                    var key_1 = tileset.image;
                    var path = StringUtils_1["default"].getPathFromFilePath(pathToTilemapJSON) + key_1;
                    _this.loadonly_imageLoadingQueue.enqueue({ key: key_1, path: path, isDependency: true });
                    // Add this image as a dependency to the tilemap
                    resource.addDependency(new ResourceReference(key_1, ResourceType.IMAGE));
                }
                else if (tileset.tiles) {
                    for (var _b = 0, _c = tileset.tiles; _b < _c.length; _b++) {
                        var tile = _c[_b];
                        var key_2 = tile.image;
                        var path = StringUtils_1["default"].getPathFromFilePath(pathToTilemapJSON) + key_2;
                        _this.loadonly_imageLoadingQueue.enqueue({ key: key_2, path: path, isDependency: true });
                        // Add this image as a dependency to the tilemap
                        resource.addDependency(new ResourceReference(key_2, ResourceType.IMAGE));
                    }
                }
            }
            // Add the resource reference to the list of resource to unload
            _this.resourcesToUnload.push(resource);
            // Finish loading
            _this.finishLoadingTilemap(callbackIfLast);
        });
    };
    /**
     * Finish loading a tilemap. Calls the callback function if this is the last tilemap being loaded
     * @param callback The function to call if this is the last tilemap to load
     */
    ResourceManager.prototype.finishLoadingTilemap = function (callback) {
        this.loadonly_tilemapsLoaded += 1;
        if (this.loadonly_tilemapsLoaded === this.loadonly_tilemapsToLoad) {
            // We're done loading tilemaps
            callback();
        }
    };
    /**
     * Loads all spritesheets currently in the spritesheet loading queue
     * @param onFinishLoading The function to call when the spritesheets are done loading
     */
    ResourceManager.prototype.loadSpritesheetsFromQueue = function (onFinishLoading) {
        this.loadonly_spritesheetsToLoad = this.loadonly_spritesheetLoadingQueue.getSize();
        this.loadonly_spritesheetsLoaded = 0;
        // If no items to load, we're finished
        if (this.loadonly_spritesheetsToLoad === 0) {
            onFinishLoading();
            return;
        }
        while (this.loadonly_spritesheetLoadingQueue.hasItems()) {
            var spritesheet = this.loadonly_spritesheetLoadingQueue.dequeue();
            this.loadSpritesheet(spritesheet.key, spritesheet.path, onFinishLoading);
        }
    };
    /**
     * Loads a singular spritesheet
     * @param key The key of the spritesheet to load
     * @param pathToSpritesheetJSON The path to the spritesheet JSON file
     * @param callbackIfLast The function to call if this is the last spritesheet
     */
    ResourceManager.prototype.loadSpritesheet = function (key, pathToSpritesheetJSON, callbackIfLast) {
        var _this = this;
        this.loadTextFile(pathToSpritesheetJSON, function (fileText) {
            var spritesheet = JSON.parse(fileText);
            // We can parse the object later - it's much faster than loading
            _this.spritesheets.add(key, spritesheet);
            var resource = new ResourceReference(key, ResourceType.SPRITESHEET);
            // Grab the image we need to load and add it to the imageloading queue
            var path = StringUtils_1["default"].getPathFromFilePath(pathToSpritesheetJSON) + spritesheet.spriteSheetImage;
            _this.loadonly_imageLoadingQueue.enqueue({ key: spritesheet.name, path: path, isDependency: true });
            resource.addDependency(new ResourceReference(spritesheet.name, ResourceType.IMAGE));
            _this.resourcesToUnload.push(resource);
            // Finish loading
            _this.finishLoadingSpritesheet(callbackIfLast);
        });
    };
    /**
     * Finish loading a spritesheet. Calls the callback function if this is the last spritesheet being loaded
     * @param callback The function to call if this is the last spritesheet to load
     */
    ResourceManager.prototype.finishLoadingSpritesheet = function (callback) {
        this.loadonly_spritesheetsLoaded += 1;
        if (this.loadonly_spritesheetsLoaded === this.loadonly_spritesheetsToLoad) {
            // We're done loading spritesheets
            callback();
        }
    };
    /**
     * Loads all images currently in the image loading queue
     * @param onFinishLoading The function to call when there are no more images to load
     */
    ResourceManager.prototype.loadImagesFromQueue = function (onFinishLoading) {
        this.loadonly_imagesToLoad = this.loadonly_imageLoadingQueue.getSize();
        this.loadonly_imagesLoaded = 0;
        // If no items to load, we're finished
        if (this.loadonly_imagesToLoad === 0) {
            onFinishLoading();
            return;
        }
        while (this.loadonly_imageLoadingQueue.hasItems()) {
            var image = this.loadonly_imageLoadingQueue.dequeue();
            this.loadImage(image.key, image.path, image.isDependency, onFinishLoading);
        }
    };
    /**
     * Loads a singular image
     * @param key The key of the image to load
     * @param path The path to the image to load
     * @param callbackIfLast The function to call if this is the last image
     */
    ResourceManager.prototype.loadImage = function (key, path, isDependency, callbackIfLast) {
        var _this = this;
        var image = new Image();
        image.onload = function () {
            // Add to loaded images
            _this.images.add(key, image);
            // If not a dependency, push it to the unload list. Otherwise it's managed by something else
            if (!isDependency) {
                _this.resourcesToUnload.push(new ResourceReference(key, ResourceType.IMAGE));
            }
            // If WebGL is active, create a texture
            if (_this.gl_WebGLActive) {
                _this.createWebGLTexture(key, image);
            }
            // Finish image load
            _this.finishLoadingImage(callbackIfLast);
        };
        image.src = path;
    };
    /**
     * Finish loading an image. If this is the last image, it calls the callback function
     * @param callback The function to call if this is the last image
     */
    ResourceManager.prototype.finishLoadingImage = function (callback) {
        this.loadonly_imagesLoaded += 1;
        if (this.loadonly_imagesLoaded === this.loadonly_imagesToLoad) {
            // We're done loading images
            callback();
        }
    };
    /**
     * Loads all audio currently in the tilemap loading queue
     * @param onFinishLoading The function to call when tilemaps are done loading
     */
    ResourceManager.prototype.loadAudioFromQueue = function (onFinishLoading) {
        this.loadonly_audioToLoad = this.loadonly_audioLoadingQueue.getSize();
        this.loadonly_audioLoaded = 0;
        // If no items to load, we're finished
        if (this.loadonly_audioToLoad === 0) {
            onFinishLoading();
            return;
        }
        while (this.loadonly_audioLoadingQueue.hasItems()) {
            var audio = this.loadonly_audioLoadingQueue.dequeue();
            this.loadAudio(audio.key, audio.path, onFinishLoading);
        }
    };
    /**
     * Load a singular audio file
     * @param key The key to the audio file to load
     * @param path The path to the audio file to load
     * @param callbackIfLast The function to call if this is the last audio file to load
     */
    ResourceManager.prototype.loadAudio = function (key, path, callbackIfLast) {
        var _this = this;
        var audioCtx = AudioManager_1["default"].getInstance().getAudioContext();
        var request = new XMLHttpRequest();
        request.open('GET', path, true);
        request.responseType = 'arraybuffer';
        request.onload = function () {
            audioCtx.decodeAudioData(request.response, function (buffer) {
                // Add to list of audio buffers
                _this.audioBuffers.add(key, buffer);
                _this.resourcesToUnload.push(new ResourceReference(key, ResourceType.AUDIO));
                // Finish loading sound
                _this.finishLoadingAudio(callbackIfLast);
            }, function (error) {
                throw "Error loading sound";
            });
        };
        request.send();
    };
    /**
     * Finish loading an audio file. Calls the callback functon if this is the last audio sample being loaded.
     * @param callback The function to call if this is the last audio file to load
     */
    ResourceManager.prototype.finishLoadingAudio = function (callback) {
        this.loadonly_audioLoaded += 1;
        if (this.loadonly_audioLoaded === this.loadonly_audioToLoad) {
            // We're done loading audio
            callback();
        }
    };
    /**
     * Loads all objects currently in the object loading queue
     * @param onFinishLoading The function to call when there are no more objects to load
     */
    ResourceManager.prototype.loadObjectsFromQueue = function (onFinishLoading) {
        this.loadonly_jsonToLoad = this.loadonly_jsonLoadingQueue.getSize();
        this.loadonly_jsonLoaded = 0;
        // If no items to load, we're finished
        if (this.loadonly_jsonToLoad === 0) {
            onFinishLoading();
            return;
        }
        while (this.loadonly_jsonLoadingQueue.hasItems()) {
            var obj = this.loadonly_jsonLoadingQueue.dequeue();
            this.loadObject(obj.key, obj.path, onFinishLoading);
        }
    };
    /**
     * Loads a singular object
     * @param key The key of the object to load
     * @param path The path to the object to load
     * @param callbackIfLast The function to call if this is the last object
     */
    ResourceManager.prototype.loadObject = function (key, path, callbackIfLast) {
        var _this = this;
        this.loadTextFile(path, function (fileText) {
            var obj = JSON.parse(fileText);
            _this.jsonObjects.add(key, obj);
            _this.resourcesToUnload.push(new ResourceReference(key, ResourceType.JSON));
            _this.finishLoadingObject(callbackIfLast);
        });
    };
    /**
     * Finish loading an object. If this is the last object, it calls the callback function
     * @param callback The function to call if this is the last object
     */
    ResourceManager.prototype.finishLoadingObject = function (callback) {
        this.loadonly_jsonLoaded += 1;
        if (this.loadonly_jsonLoaded === this.loadonly_jsonToLoad) {
            // We're done loading objects
            callback();
        }
    };
    /* ########## WEBGL SPECIFIC FUNCTIONS ########## */
    ResourceManager.prototype.getTexture = function (key) {
        return this.gl_Textures.get(key);
    };
    ResourceManager.prototype.getShaderProgram = function (key) {
        return this.gl_ShaderPrograms.get(key).program;
    };
    ResourceManager.prototype.getBuffer = function (key) {
        return this.gl_Buffers.get(key);
    };
    ResourceManager.prototype.createWebGLTexture = function (imageKey, image) {
        // Get the texture ID
        var textureID = this.getTextureID(this.gl_NextTextureID);
        // Create the texture
        var texture = this.gl.createTexture();
        // Set up the texture
        // Enable texture0
        this.gl.activeTexture(textureID);
        // Bind our texture to texture 0
        this.gl.bindTexture(this.gl.TEXTURE_2D, texture);
        // Set the texture parameters
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
        // Set the texture image
        this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, image);
        // Add the texture to our map with the same key as the image
        this.gl_Textures.add(imageKey, this.gl_NextTextureID);
        // Increment the key
        this.gl_NextTextureID += 1;
    };
    ResourceManager.prototype.getTextureID = function (id) {
        // Start with 9 cases - this can be expanded if needed, but for the best performance,
        // Textures should be stitched into an atlas
        switch (id) {
            case 0: return this.gl.TEXTURE0;
            case 1: return this.gl.TEXTURE1;
            case 2: return this.gl.TEXTURE2;
            case 3: return this.gl.TEXTURE3;
            case 4: return this.gl.TEXTURE4;
            case 5: return this.gl.TEXTURE5;
            case 6: return this.gl.TEXTURE6;
            case 7: return this.gl.TEXTURE7;
            case 8: return this.gl.TEXTURE8;
            default: return this.gl.TEXTURE9;
        }
    };
    ResourceManager.prototype.createBuffer = function (key) {
        if (this.gl_WebGLActive) {
            var buffer = this.gl.createBuffer();
            this.gl_Buffers.add(key, buffer);
        }
    };
    /**
     * Enqueues loading of a new shader program
     * @param key The key of the shader program
     * @param vShaderFilepath
     * @param fShaderFilepath
     */
    ResourceManager.prototype.shader = function (key, vShaderFilepath, fShaderFilepath) {
        var splitPath = vShaderFilepath.split(".");
        var end = splitPath[splitPath.length - 1];
        if (end !== "vshader") {
            throw "".concat(vShaderFilepath, " is not a valid vertex shader - must end in \".vshader");
        }
        splitPath = fShaderFilepath.split(".");
        end = splitPath[splitPath.length - 1];
        if (end !== "fshader") {
            throw "".concat(fShaderFilepath, " is not a valid vertex shader - must end in \".fshader");
        }
        var paths = new KeyPath_Shader();
        paths.key = key;
        paths.vpath = vShaderFilepath;
        paths.fpath = fShaderFilepath;
        this.loadonly_gl_ShaderLoadingQueue.enqueue(paths);
    };
    /**
     * Tells the resource manager to keep this resource
     * @param key The key of the resource
     */
    ResourceManager.prototype.keepShader = function (key) {
        this.keepResource(key, ResourceType.IMAGE);
    };
    ResourceManager.prototype.gl_LoadShadersFromQueue = function (onFinishLoading) {
        this.loadonly_gl_ShaderProgramsToLoad = this.loadonly_gl_ShaderLoadingQueue.getSize();
        this.loadonly_gl_ShaderProgramsLoaded = 0;
        // If webGL isn'active or there are no items to load, we're finished
        if (!this.gl_WebGLActive || this.loadonly_gl_ShaderProgramsToLoad === 0) {
            onFinishLoading();
            return;
        }
        while (this.loadonly_gl_ShaderLoadingQueue.hasItems()) {
            var shader = this.loadonly_gl_ShaderLoadingQueue.dequeue();
            this.gl_LoadShader(shader.key, shader.vpath, shader.fpath, onFinishLoading);
        }
    };
    ResourceManager.prototype.gl_LoadShader = function (key, vpath, fpath, callbackIfLast) {
        var _this = this;
        this.loadTextFile(vpath, function (vFileText) {
            var vShader = vFileText;
            _this.loadTextFile(fpath, function (fFileText) {
                var fShader = fFileText;
                // Extract the program and shaders
                var _a = _this.createShaderProgram(vShader, fShader), shaderProgram = _a[0], vertexShader = _a[1], fragmentShader = _a[2];
                // Create a wrapper type
                var programWrapper = new WebGLProgramType_1["default"]();
                programWrapper.program = shaderProgram;
                programWrapper.vertexShader = vertexShader;
                programWrapper.fragmentShader = fragmentShader;
                // Add to our map
                _this.gl_ShaderPrograms.add(key, programWrapper);
                _this.resourcesToUnload.push(new ResourceReference(key, ResourceType.SHADER));
                // Finish loading
                _this.gl_FinishLoadingShader(callbackIfLast);
            });
        });
    };
    ResourceManager.prototype.gl_FinishLoadingShader = function (callback) {
        this.loadonly_gl_ShaderProgramsLoaded += 1;
        if (this.loadonly_gl_ShaderProgramsLoaded === this.loadonly_gl_ShaderProgramsToLoad) {
            // We're done loading shaders
            callback();
        }
    };
    ResourceManager.prototype.createShaderProgram = function (vShaderSource, fShaderSource) {
        var vertexShader = this.loadVertexShader(vShaderSource);
        var fragmentShader = this.loadFragmentShader(fShaderSource);
        if (vertexShader === null || fragmentShader === null) {
            // We had a problem intializing - error
            return null;
        }
        // Create a shader program
        var program = this.gl.createProgram();
        if (!program) {
            // Error creating
            console.warn("Failed to create program");
            return null;
        }
        // Attach our vertex and fragment shader
        this.gl.attachShader(program, vertexShader);
        this.gl.attachShader(program, fragmentShader);
        // Link
        this.gl.linkProgram(program);
        if (!this.gl.getProgramParameter(program, this.gl.LINK_STATUS)) {
            // Error linking
            var error = this.gl.getProgramInfoLog(program);
            console.warn("Failed to link program: " + error);
            // Clean up
            this.gl.deleteProgram(program);
            this.gl.deleteShader(vertexShader);
            this.gl.deleteShader(fragmentShader);
            return null;
        }
        // We successfully create a program
        return [program, vertexShader, fragmentShader];
    };
    ResourceManager.prototype.loadVertexShader = function (shaderSource) {
        // Create a new vertex shader
        return this.loadShader(this.gl.VERTEX_SHADER, shaderSource);
    };
    ResourceManager.prototype.loadFragmentShader = function (shaderSource) {
        // Create a new fragment shader
        return this.loadShader(this.gl.FRAGMENT_SHADER, shaderSource);
    };
    ResourceManager.prototype.loadShader = function (type, shaderSource) {
        var shader = this.gl.createShader(type);
        // If we couldn't create the shader, error
        if (shader === null) {
            console.warn("Unable to create shader");
            return null;
        }
        // Add the source to the shader and compile
        this.gl.shaderSource(shader, shaderSource);
        this.gl.compileShader(shader);
        // Make sure there were no errors during this process
        if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
            // Not compiled - error
            var error = this.gl.getShaderInfoLog(shader);
            console.warn("Failed to compile shader: " + error);
            // Clean up
            this.gl.deleteShader(shader);
            return null;
        }
        // Sucess, so return the shader
        return shader;
    };
    /* ########## GENERAL LOADING FUNCTIONS ########## */
    ResourceManager.prototype.loadTextFile = function (textFilePath, callback) {
        var xobj = new XMLHttpRequest();
        xobj.overrideMimeType("application/json");
        xobj.open('GET', textFilePath, true);
        xobj.onreadystatechange = function () {
            if ((xobj.readyState == 4) && (xobj.status == 200)) {
                callback(xobj.responseText);
            }
        };
        xobj.send(null);
    };
    /* ########## LOADING BAR INFO ########## */
    ResourceManager.prototype.getLoadPercent = function () {
        return (this.loadonly_tilemapsLoaded / this.loadonly_tilemapsToLoad
            + this.loadonly_spritesheetsLoaded / this.loadonly_spritesheetsToLoad
            + this.loadonly_imagesLoaded / this.loadonly_imagesToLoad
            + this.loadonly_audioLoaded / this.loadonly_audioToLoad)
            / this.loadonly_typesToLoad;
    };
    ResourceManager.prototype.update = function (deltaT) {
        if (this.loading) {
            if (this.onLoadProgress) {
                this.onLoadProgress(this.getLoadPercent());
            }
        }
        else if (this.justLoaded) {
            this.justLoaded = false;
            if (this.onLoadComplete) {
                this.onLoadComplete();
            }
        }
    };
    return ResourceManager;
}());
exports["default"] = ResourceManager;
/**
 * A class representing a reference to a resource.
 * This is used for the exemption list to assure assets and their dependencies don't get
 * destroyed if they are still needed.
 */
var ResourceReference = /** @class */ (function () {
    function ResourceReference(key, resourceType) {
        this.key = key;
        this.resourceType = resourceType;
        this.dependencies = new Array();
    }
    ResourceReference.prototype.addDependency = function (resource) {
        this.dependencies.push(resource);
    };
    return ResourceReference;
}());
var ResourceType;
(function (ResourceType) {
    ResourceType["IMAGE"] = "IMAGE";
    ResourceType["TILEMAP"] = "TILEMAP";
    ResourceType["SPRITESHEET"] = "SPRITESHEET";
    ResourceType["AUDIO"] = "AUDIO";
    ResourceType["JSON"] = "JSON";
    ResourceType["SHADER"] = "SHADER";
})(ResourceType || (ResourceType = {}));
/**
 * A pair representing a key and the path of the resource to load
 */
var KeyPathPair = /** @class */ (function () {
    function KeyPathPair() {
        this.isDependency = false;
    }
    return KeyPathPair;
}());
var KeyPath_Shader = /** @class */ (function () {
    function KeyPath_Shader() {
    }
    return KeyPath_Shader;
}());
},{"../DataTypes/Map":8,"../DataTypes/Queue":12,"../DataTypes/Rendering/WebGLProgramType":13,"../Sound/AudioManager":92,"../Utils/StringUtils":99}],80:[function(require,module,exports){
"use strict";
exports.__esModule = true;
var Vec2_1 = require("../DataTypes/Vec2");
/**
 * An abstract interface of a SceneGraph.
 * Exposes methods for use by other code, but leaves the implementation up to the subclasses.
 * The SceneGraph manages the positions of all GameNodes, and can easily prune a visible set for rendering.
 */
var SceneGraph = /** @class */ (function () {
    /**
     * Creates a new SceneGraph
     * @param viewport The viewport
     * @param scene The Scene this SceneGraph belongs to
     */
    function SceneGraph(viewport, scene) {
        this.viewport = viewport;
        this.scene = scene;
        this.nodeMap = new Array();
        this.idCounter = 0;
    }
    /**
     * Add a node to the SceneGraph
     * @param node The CanvasNode to add to the SceneGraph
     * @returns The SceneGraph ID of this newly added CanvasNode
     */
    SceneGraph.prototype.addNode = function (node) {
        this.nodeMap[node.id] = node;
        this.addNodeSpecific(node, this.idCounter);
        this.idCounter += 1;
        return this.idCounter - 1;
    };
    ;
    /**
     * Removes a node from the SceneGraph
     * @param node The node to remove
     */
    SceneGraph.prototype.removeNode = function (node) {
        // Find and remove node in O(n)
        this.nodeMap[node.id] = undefined;
        this.removeNodeSpecific(node, node.id);
    };
    ;
    /**
     * Get a specific node using its id
     * @param id The id of the CanvasNode to retrieve
     * @returns The node with this ID
     */
    SceneGraph.prototype.getNode = function (id) {
        return this.nodeMap[id];
    };
    /**
     * Returns the nodes at specific coordinates
     * @param vecOrX The x-coordinate of the position, or the coordinates in a Vec2
     * @param y The y-coordinate of the position
     * @returns An array of nodes found at the position provided
     */
    SceneGraph.prototype.getNodesAt = function (vecOrX, y) {
        if (y === void 0) { y = null; }
        if (vecOrX instanceof Vec2_1["default"]) {
            return this.getNodesAtCoords(vecOrX.x, vecOrX.y);
        }
        else {
            return this.getNodesAtCoords(vecOrX, y);
        }
    };
    /**
     * Returns all nodes in the SceneGraph
     * @returns An Array containing all nodes in the SceneGraph
     */
    SceneGraph.prototype.getAllNodes = function () {
        var arr = new Array();
        for (var i = 0; i < this.nodeMap.length; i++) {
            if (this.nodeMap[i] !== undefined) {
                arr.push(this.nodeMap[i]);
            }
        }
        return arr;
    };
    return SceneGraph;
}());
exports["default"] = SceneGraph;
},{"../DataTypes/Vec2":20}],81:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
exports.__esModule = true;
var SceneGraph_1 = require("./SceneGraph");
var Stats_1 = require("../Debug/Stats");
/**
 * An implementation of a SceneGraph that simply stored CanvasNodes in an array.
 */
var SceneGraphArray = /** @class */ (function (_super) {
    __extends(SceneGraphArray, _super);
    /**
     * Creates a new SceneGraphArray
     * @param viewport The Viewport
     * @param scene The Scene this SceneGraph belongs to
     */
    function SceneGraphArray(viewport, scene) {
        var _this = _super.call(this, viewport, scene) || this;
        _this.nodeList = new Array();
        return _this;
    }
    // @override
    SceneGraphArray.prototype.addNodeSpecific = function (node, id) {
        this.nodeList.push(node);
    };
    // @override
    SceneGraphArray.prototype.removeNodeSpecific = function (node, id) {
        var index = this.nodeList.indexOf(node);
        if (index > -1) {
            this.nodeList.splice(index, 1);
        }
    };
    // @override
    SceneGraphArray.prototype.getNodesAtCoords = function (x, y) {
        var results = [];
        for (var _i = 0, _a = this.nodeList; _i < _a.length; _i++) {
            var node = _a[_i];
            if (node.contains(x, y)) {
                results.push(node);
            }
        }
        return results;
    };
    // @override
    SceneGraphArray.prototype.getNodesInRegion = function (boundary) {
        var t0 = performance.now();
        var results = [];
        for (var _i = 0, _a = this.nodeList; _i < _a.length; _i++) {
            var node = _a[_i];
            if (boundary.overlaps(node.boundary)) {
                results.push(node);
            }
        }
        var t1 = performance.now();
        Stats_1["default"].log("sgquery", (t1 - t0));
        return results;
    };
    SceneGraphArray.prototype.update = function (deltaT) {
        var t0 = performance.now();
        for (var _i = 0, _a = this.nodeList; _i < _a.length; _i++) {
            var node = _a[_i];
            if (!node.getLayer().isPaused()) {
                node.update(deltaT);
            }
        }
        var t1 = performance.now();
        Stats_1["default"].log("sgupdate", (t1 - t0));
    };
    SceneGraphArray.prototype.render = function (ctx) { };
    // @override
    SceneGraphArray.prototype.getVisibleSet = function () {
        var visibleSet = new Array();
        for (var _i = 0, _a = this.nodeList; _i < _a.length; _i++) {
            var node = _a[_i];
            if (!node.getLayer().isHidden() && node.visible && this.viewport.includes(node)) {
                visibleSet.push(node);
            }
        }
        return visibleSet;
    };
    return SceneGraphArray;
}(SceneGraph_1["default"]));
exports["default"] = SceneGraphArray;
},{"../Debug/Stats":22,"./SceneGraph":80}],82:[function(require,module,exports){
"use strict";
exports.__esModule = true;
var Vec2_1 = require("../DataTypes/Vec2");
var MathUtils_1 = require("../Utils/MathUtils");
var Queue_1 = require("../DataTypes/Queue");
var AABB_1 = require("../DataTypes/Shapes/AABB");
var Input_1 = require("../Input/Input");
var ParallaxLayer_1 = require("../Scene/Layers/ParallaxLayer");
var UILayer_1 = require("../Scene/Layers/UILayer");
/**
 * The viewport of the game. Corresponds to the visible window displayed in the browser.
 * The viewport keeps track of its position in the game world, and can act as a camera to follow objects.
 */
var Viewport = /** @class */ (function () {
    function Viewport(canvasSize, zoomLevel) {
        /** The amount that is zoomed in or out. */
        this.ZOOM_FACTOR = 1.2;
        this.view = new AABB_1["default"](Vec2_1["default"].ZERO, Vec2_1["default"].ZERO);
        this.boundary = new AABB_1["default"](Vec2_1["default"].ZERO, Vec2_1["default"].ZERO);
        this.lastPositions = new Queue_1["default"]();
        this.smoothingFactor = 10;
        this.scrollZoomEnabled = false;
        this.canvasSize = Vec2_1["default"].ZERO;
        this.focus = Vec2_1["default"].ZERO;
        // Set the size of the canvas
        this.setCanvasSize(canvasSize);
        // Set the size of the viewport
        this.setSize(canvasSize);
        this.setZoomLevel(zoomLevel);
        // Set the center (and make the viewport stay there)
        this.setCenter(this.view.halfSize.clone());
        this.setFocus(this.view.halfSize.clone());
    }
    /** Enables the viewport to zoom in and out */
    Viewport.prototype.enableZoom = function () {
        this.scrollZoomEnabled = true;
    };
    /**
     * Returns the position of the viewport
     * @returns The center of the viewport as a Vec2
     */
    Viewport.prototype.getCenter = function () {
        return this.view.center;
    };
    /**
     * Returns a new Vec2 with the origin of the viewport
     * @returns The top left cornder of the Vieport as a Vec2
     */
    Viewport.prototype.getOrigin = function () {
        return new Vec2_1["default"](this.view.left, this.view.top);
    };
    /**
     * Returns the region visible to this viewport
     * @returns The AABB containing the region visible to the viewport
     */
    Viewport.prototype.getView = function () {
        return this.view;
    };
    /**
     * Set the position of the viewport
     * @param vecOrX The new position or the x-coordinate of the new position
     * @param y The y-coordinate of the new position
     */
    Viewport.prototype.setCenter = function (vecOrX, y) {
        if (y === void 0) { y = null; }
        var pos;
        if (vecOrX instanceof Vec2_1["default"]) {
            pos = vecOrX;
        }
        else {
            pos = new Vec2_1["default"](vecOrX, y);
        }
        this.view.center = pos;
    };
    /**
     * Returns the size of the viewport as a Vec2
     * @returns The half-size of the viewport as a Vec2
     */
    Viewport.prototype.getHalfSize = function () {
        return this.view.getHalfSize();
    };
    /**
     * Sets the size of the viewport
     * @param vecOrX The new width of the viewport or the new size as a Vec2
     * @param y The new height of the viewport
     */
    Viewport.prototype.setSize = function (vecOrX, y) {
        if (y === void 0) { y = null; }
        if (vecOrX instanceof Vec2_1["default"]) {
            this.view.setHalfSize(vecOrX.scaled(1 / 2));
        }
        else {
            this.view.setHalfSize(new Vec2_1["default"](vecOrX / 2, y / 2));
        }
    };
    /**
     * Sets the half-size of the viewport
     * @param vecOrX The new half-width of the viewport or the new half-size as a Vec2
     * @param y The new height of the viewport
     */
    Viewport.prototype.setHalfSize = function (vecOrX, y) {
        if (y === void 0) { y = null; }
        if (vecOrX instanceof Vec2_1["default"]) {
            this.view.setHalfSize(vecOrX.clone());
        }
        else {
            this.view.setHalfSize(new Vec2_1["default"](vecOrX, y));
        }
    };
    /**
     * Updates the viewport with the size of the current Canvas
     * @param vecOrX The width of the canvas, or the canvas size as a Vec2
     * @param y The height of the canvas
     */
    Viewport.prototype.setCanvasSize = function (vecOrX, y) {
        if (y === void 0) { y = null; }
        if (vecOrX instanceof Vec2_1["default"]) {
            this.canvasSize = vecOrX.clone();
        }
        else {
            this.canvasSize = new Vec2_1["default"](vecOrX, y);
        }
    };
    /**
     * Sets the zoom level of the viewport
     * @param zoom The zoom level
     */
    Viewport.prototype.setZoomLevel = function (zoom) {
        this.view.halfSize.copy(this.canvasSize.scaled(1 / zoom / 2));
    };
    /**
     * Gets the zoom level of the viewport
     * @returns The zoom level
     */
    Viewport.prototype.getZoomLevel = function () {
        return this.canvasSize.x / this.view.hw / 2;
    };
    /**
     * Sets the smoothing factor for the viewport movement.
     * @param smoothingFactor The smoothing factor for the viewport
     */
    Viewport.prototype.setSmoothingFactor = function (smoothingFactor) {
        if (smoothingFactor < 1)
            smoothingFactor = 1;
        this.smoothingFactor = smoothingFactor;
    };
    /**
     * Tells the viewport to focus on a point. Overidden by "following".
     * @param focus The point the  viewport should focus on
     */
    Viewport.prototype.setFocus = function (focus) {
        this.focus.copy(focus);
    };
    /**
     * Returns true if the CanvasNode is inside of the viewport
     * @param node The node to check
     * @returns True if the node is currently visible in the viewport, false if not
     */
    Viewport.prototype.includes = function (node) {
        var parallax = node.getLayer() instanceof ParallaxLayer_1["default"] || node.getLayer() instanceof UILayer_1["default"] ? node.getLayer().parallax : new Vec2_1["default"](1, 1);
        var center = this.view.center.clone();
        this.view.center.mult(parallax);
        var overlaps = this.view.overlaps(node.boundary);
        this.view.center = center;
        return overlaps;
    };
    // TODO: Put some error handling on this for trying to make the bounds too small for the viewport
    // TODO: This should probably be done automatically, or should consider the aspect ratio or something
    /**
     * Sets the bounds of the viewport
     * @param lowerX The left edge of the viewport
     * @param lowerY The top edge of the viewport
     * @param upperX The right edge of the viewport
     * @param upperY The bottom edge of the viewport
     */
    Viewport.prototype.setBounds = function (lowerX, lowerY, upperX, upperY) {
        var hwidth = (upperX - lowerX) / 2;
        var hheight = (upperY - lowerY) / 2;
        var x = lowerX + hwidth;
        var y = lowerY + hheight;
        this.boundary.center.set(x, y);
        this.boundary.halfSize.set(hwidth, hheight);
    };
    /**
     * Make the viewport follow the specified GameNode
     * @param node The GameNode to follow
     */
    Viewport.prototype.follow = function (node) {
        this.following = node;
    };
    Viewport.prototype.updateView = function () {
        if (this.lastPositions.getSize() > this.smoothingFactor) {
            this.lastPositions.dequeue();
        }
        // Get the average of the last 10 positions
        var pos = Vec2_1["default"].ZERO;
        this.lastPositions.forEach(function (position) { return pos.add(position); });
        pos.scale(1 / this.lastPositions.getSize());
        // Set this position either to the object or to its bounds
        pos.x = MathUtils_1["default"].clamp(pos.x, this.boundary.left + this.view.hw, this.boundary.right - this.view.hw);
        pos.y = MathUtils_1["default"].clamp(pos.y, this.boundary.top + this.view.hh, this.boundary.bottom - this.view.hh);
        // Assure there are no lines in the tilemap
        pos.x = Math.floor(pos.x);
        pos.y = Math.floor(pos.y);
        this.view.center.copy(pos);
    };
    Viewport.prototype.update = function (deltaT) {
        // If zoom is enabled
        if (this.scrollZoomEnabled) {
            if (Input_1["default"].didJustScroll()) {
                var currentSize = this.view.getHalfSize().clone();
                if (Input_1["default"].getScrollDirection() < 0) {
                    // Zoom in
                    currentSize.scale(1 / this.ZOOM_FACTOR);
                }
                else {
                    // Zoom out
                    currentSize.scale(this.ZOOM_FACTOR);
                }
                if (currentSize.x > this.boundary.hw) {
                    var factor = this.boundary.hw / currentSize.x;
                    currentSize.x = this.boundary.hw;
                    currentSize.y *= factor;
                }
                if (currentSize.y > this.boundary.hh) {
                    var factor = this.boundary.hh / currentSize.y;
                    currentSize.y = this.boundary.hh;
                    currentSize.x *= factor;
                }
                this.view.setHalfSize(currentSize);
            }
        }
        // If viewport is following an object
        if (this.following) {
            // Update our list of previous positions
            this.lastPositions.enqueue(this.following.position.clone());
        }
        else {
            this.lastPositions.enqueue(this.focus);
        }
        this.updateView();
    };
    return Viewport;
}());
exports["default"] = Viewport;
},{"../DataTypes/Queue":12,"../DataTypes/Shapes/AABB":14,"../DataTypes/Vec2":20,"../Input/Input":28,"../Scene/Layers/ParallaxLayer":87,"../Scene/Layers/UILayer":88,"../Utils/MathUtils":97}],83:[function(require,module,exports){
"use strict";
exports.__esModule = true;
var Sprite_1 = require("../../Nodes/Sprites/Sprite");
var AnimatedSprite_1 = require("../../Nodes/Sprites/AnimatedSprite");
var GraphicTypes_1 = require("../../Nodes/Graphics/GraphicTypes");
var UIElementTypes_1 = require("../../Nodes/UIElements/UIElementTypes");
var Point_1 = require("../../Nodes/Graphics/Point");
var Vec2_1 = require("../../DataTypes/Vec2");
var Button_1 = require("../../Nodes/UIElements/Button");
var Label_1 = require("../../Nodes/UIElements/Label");
var Slider_1 = require("../../Nodes/UIElements/Slider");
var TextInput_1 = require("../../Nodes/UIElements/TextInput");
var Rect_1 = require("../../Nodes/Graphics/Rect");
var ResourceManager_1 = require("../../ResourceManager/ResourceManager");
var Line_1 = require("../../Nodes/Graphics/Line");
var Particle_1 = require("../../Nodes/Graphics/Particle");
// @ignorePage
/**
 * A factory that abstracts adding @reference[CanvasNode]s to the @reference[Scene].
 * Access methods in this factory through Scene.add.[methodName]().
 */
var CanvasNodeFactory = /** @class */ (function () {
    function CanvasNodeFactory() {
        var _this = this;
        /**
         * Adds an instance of a UIElement to the current scene - i.e. any class that extends UIElement
         * @param type The type of UIElement to add
         * @param layerName The layer to add the UIElement to
         * @param options Any additional arguments to feed to the constructor
         * @returns A new UIElement
         */
        this.addUIElement = function (type, layerName, options) {
            // Get the layer
            var layer = _this.scene.getLayer(layerName);
            var instance;
            switch (type) {
                case UIElementTypes_1.UIElementType.BUTTON:
                    instance = _this.buildButton(options);
                    break;
                case UIElementTypes_1.UIElementType.LABEL:
                    instance = _this.buildLabel(options);
                    break;
                case UIElementTypes_1.UIElementType.SLIDER:
                    instance = _this.buildSlider(options);
                    break;
                case UIElementTypes_1.UIElementType.TEXT_INPUT:
                    instance = _this.buildTextInput(options);
                    break;
                default:
                    throw "UIElementType '".concat(type, "' does not exist, or is registered incorrectly.");
            }
            instance.setScene(_this.scene);
            instance.id = _this.scene.generateId();
            _this.scene.getSceneGraph().addNode(instance);
            // Add instance to layer
            layer.addNode(instance);
            return instance;
        };
        /**
         * Adds a sprite to the current scene
         * @param key The key of the image the sprite will represent
         * @param layerName The layer on which to add the sprite
         * @returns A new Sprite
         */
        this.addSprite = function (key, layerName) {
            var layer = _this.scene.getLayer(layerName);
            var instance = new Sprite_1["default"](key);
            // Add instance to scene
            instance.setScene(_this.scene);
            instance.id = _this.scene.generateId();
            if (!(_this.scene.isParallaxLayer(layerName) || _this.scene.isUILayer(layerName))) {
                _this.scene.getSceneGraph().addNode(instance);
            }
            // Add instance to layer
            layer.addNode(instance);
            return instance;
        };
        /**
         * Adds an AnimatedSprite to the current scene
         * @param key The key of the image the sprite will represent
         * @param layerName The layer on which to add the sprite
         * @returns A new AnimatedSprite
         */
        this.addAnimatedSprite = function (key, layerName) {
            var layer = _this.scene.getLayer(layerName);
            var spritesheet = _this.resourceManager.getSpritesheet(key);
            var instance = new AnimatedSprite_1["default"](spritesheet);
            // Add instance fo scene
            instance.setScene(_this.scene);
            instance.id = _this.scene.generateId();
            if (!(_this.scene.isParallaxLayer(layerName) || _this.scene.isUILayer(layerName))) {
                _this.scene.getSceneGraph().addNode(instance);
            }
            // Add instance to layer
            layer.addNode(instance);
            return instance;
        };
        /**
         * Adds a new graphic element to the current Scene
         * @param type The type of graphic to add
         * @param layerName The layer on which to add the graphic
         * @param options Any additional arguments to send to the graphic constructor
         * @returns A new Graphic
         */
        this.addGraphic = function (type, layerName, options) {
            // Get the layer
            var layer = _this.scene.getLayer(layerName);
            var instance;
            switch (type) {
                case GraphicTypes_1.GraphicType.POINT:
                    instance = _this.buildPoint(options);
                    break;
                case GraphicTypes_1.GraphicType.LINE:
                    instance = _this.buildLine(options);
                    break;
                case GraphicTypes_1.GraphicType.RECT:
                    instance = _this.buildRect(options);
                    break;
                case GraphicTypes_1.GraphicType.PARTICLE:
                    instance = _this.buildParticle(options);
                    break;
                default:
                    throw "GraphicType '".concat(type, "' does not exist, or is registered incorrectly.");
            }
            // Add instance to scene
            instance.setScene(_this.scene);
            instance.id = _this.scene.generateId();
            if (!(_this.scene.isParallaxLayer(layerName) || _this.scene.isUILayer(layerName))) {
                _this.scene.getSceneGraph().addNode(instance);
            }
            // Add instance to layer
            layer.addNode(instance);
            return instance;
        };
    }
    CanvasNodeFactory.prototype.init = function (scene) {
        this.scene = scene;
        this.resourceManager = ResourceManager_1["default"].getInstance();
    };
    /* ---------- BUILDERS ---------- */
    CanvasNodeFactory.prototype.buildButton = function (options) {
        this.checkIfPropExists("Button", options, "position", Vec2_1["default"], "Vec2");
        this.checkIfPropExists("Button", options, "text", "string");
        return new Button_1["default"](options.position, options.text);
    };
    CanvasNodeFactory.prototype.buildLabel = function (options) {
        this.checkIfPropExists("Label", options, "position", Vec2_1["default"], "Vec2");
        this.checkIfPropExists("Label", options, "text", "string");
        return new Label_1["default"](options.position, options.text);
    };
    CanvasNodeFactory.prototype.buildSlider = function (options) {
        this.checkIfPropExists("Slider", options, "position", Vec2_1["default"], "Vec2");
        var initValue = 0;
        if (options.value !== undefined) {
            initValue = options.value;
        }
        return new Slider_1["default"](options.position, initValue);
    };
    CanvasNodeFactory.prototype.buildTextInput = function (options) {
        this.checkIfPropExists("TextInput", options, "position", Vec2_1["default"], "Vec2");
        return new TextInput_1["default"](options.position);
    };
    CanvasNodeFactory.prototype.buildPoint = function (options) {
        this.checkIfPropExists("Point", options, "position", Vec2_1["default"], "Vec2");
        return new Point_1["default"](options.position);
    };
    CanvasNodeFactory.prototype.buildParticle = function (options) {
        this.checkIfPropExists("Particle", options, "position", Vec2_1["default"], "Vec2");
        this.checkIfPropExists("Particle", options, "size", Vec2_1["default"], "Vec2");
        this.checkIfPropExists("Particle", options, "mass", "number", "number");
        //Changed for testing
        return new Particle_1["default"](options.position, options.size, options.mass);
    };
    CanvasNodeFactory.prototype.buildLine = function (options) {
        this.checkIfPropExists("Line", options, "start", Vec2_1["default"], "Vec2");
        this.checkIfPropExists("Line", options, "end", Vec2_1["default"], "Vec2");
        return new Line_1["default"](options.start, options.end);
    };
    CanvasNodeFactory.prototype.buildRect = function (options) {
        this.checkIfPropExists("Rect", options, "position", Vec2_1["default"], "Vec2");
        this.checkIfPropExists("Rect", options, "size", Vec2_1["default"], "Vec2");
        return new Rect_1["default"](options.position, options.size);
    };
    /* ---------- ERROR HANDLING ---------- */
    CanvasNodeFactory.prototype.checkIfPropExists = function (objectName, options, prop, type, typeName) {
        if (!options || options[prop] === undefined) {
            // Check that the options object has the property
            throw "".concat(objectName, " object requires argument ").concat(prop, " of type ").concat(typeName, ", but none was provided.");
        }
        else {
            // Check that the property has the correct type
            if ((typeof type) === "string") {
                if (!(typeof options[prop] === type)) {
                    throw "".concat(objectName, " object requires argument ").concat(prop, " of type ").concat(type, ", but provided ").concat(prop, " was not of type ").concat(type, ".");
                }
            }
            else if (type instanceof Function) {
                // If type is a constructor, check against that
                if (!(options[prop] instanceof type)) {
                    throw "".concat(objectName, " object requires argument ").concat(prop, " of type ").concat(typeName, ", but provided ").concat(prop, " was not of type ").concat(typeName, ".");
                }
            }
            else {
                throw "".concat(objectName, " object requires argument ").concat(prop, " of type ").concat(typeName, ", but provided ").concat(prop, " was not of type ").concat(typeName, ".");
            }
        }
    };
    return CanvasNodeFactory;
}());
exports["default"] = CanvasNodeFactory;
},{"../../DataTypes/Vec2":20,"../../Nodes/Graphics/GraphicTypes":38,"../../Nodes/Graphics/Line":39,"../../Nodes/Graphics/Particle":40,"../../Nodes/Graphics/Point":41,"../../Nodes/Graphics/Rect":42,"../../Nodes/Sprites/AnimatedSprite":43,"../../Nodes/Sprites/Sprite":44,"../../Nodes/UIElements/Button":48,"../../Nodes/UIElements/Label":49,"../../Nodes/UIElements/Slider":50,"../../Nodes/UIElements/TextInput":51,"../../Nodes/UIElements/UIElementTypes":52,"../../ResourceManager/ResourceManager":79}],84:[function(require,module,exports){
"use strict";
exports.__esModule = true;
var CanvasNodeFactory_1 = require("./CanvasNodeFactory");
var TilemapFactory_1 = require("./TilemapFactory");
/**
 * The manager of all factories used for adding @reference[GameNode]s to the @reference[Scene].
 */
var FactoryManager = /** @class */ (function () {
    function FactoryManager(scene, tilemaps) {
        // Constructors are called here to allow assignment of their functions to functions in this class
        this.canvasNodeFactory = new CanvasNodeFactory_1["default"]();
        this.tilemapFactory = new TilemapFactory_1["default"]();
        this.canvasNodeFactory.init(scene);
        this.tilemapFactory.init(scene, tilemaps);
    }
    // Expose all of the factories through the factory manager
    /**
     * Adds an instance of a UIElement to the current scene - i.e. any class that extends UIElement
     * @param type The type of UIElement to add
     * @param layerName The layer to add the UIElement to
     * @param options Any additional arguments to feed to the constructor
     * @returns A new UIElement
     */
    FactoryManager.prototype.uiElement = function (type, layerName, options) {
        return this.canvasNodeFactory.addUIElement(type, layerName, options);
    };
    /**
     * Adds a sprite to the current scene
     * @param key The key of the image the sprite will represent
     * @param layerName The layer on which to add the sprite
     * @returns A new Sprite
     */
    FactoryManager.prototype.sprite = function (key, layerName) {
        return this.canvasNodeFactory.addSprite(key, layerName);
    };
    /**
     * Adds an AnimatedSprite to the current scene
     * @param key The key of the image the sprite will represent
     * @param layerName The layer on which to add the sprite
     * @returns A new AnimatedSprite
     */
    FactoryManager.prototype.animatedSprite = function (key, layerName) {
        return this.canvasNodeFactory.addAnimatedSprite(key, layerName);
    };
    /**
     * Adds a new graphic element to the current Scene
     * @param type The type of graphic to add
     * @param layerName The layer on which to add the graphic
     * @param options Any additional arguments to send to the graphic constructor
     * @returns A new Graphic
     */
    FactoryManager.prototype.graphic = function (type, layerName, options) {
        return this.canvasNodeFactory.addGraphic(type, layerName, options);
    };
    /**
     * Adds a tilemap to the scene
     * @param key The key of the loaded tilemap to load
     * @param constr The constructor of the desired tilemap
     * @param args Additional arguments to send to the tilemap constructor
     * @returns An array of Layers, each of which contains a layer of the tilemap as its own Tilemap instance.
     */
    FactoryManager.prototype.tilemap = function (key, scale) {
        return this.tilemapFactory.add(key, scale);
    };
    return FactoryManager;
}());
exports["default"] = FactoryManager;
},{"./CanvasNodeFactory":83,"./TilemapFactory":85}],85:[function(require,module,exports){
"use strict";
exports.__esModule = true;
var ResourceManager_1 = require("../../ResourceManager/ResourceManager");
var OrthogonalTilemap_1 = require("../../Nodes/Tilemaps/OrthogonalTilemap");
var Tileset_1 = require("../../DataTypes/Tilesets/Tileset");
var Vec2_1 = require("../../DataTypes/Vec2");
var PositionGraph_1 = require("../../DataTypes/Graphs/PositionGraph");
var Navmesh_1 = require("../../Pathfinding/Navmesh");
// @ignorePage
/**
 * A factory that abstracts adding @reference[Tilemap]s to the @reference[Scene].
 * Access methods in this factory through Scene.add.[methodName]().
 */
var TilemapFactory = /** @class */ (function () {
    function TilemapFactory() {
        var _this = this;
        // TODO - This is specifically catered to Tiled tilemaps right now. In the future,
        // it would be good to have a "parseTilemap" function that would convert the tilemap
        // data into a standard format. This could allow for support from other programs
        // or the development of an internal level builder tool
        /**
         * Adds a tilemap to the scene
         * @param key The key of the loaded tilemap to load
         * @param constr The constructor of the desired tilemap
         * @param args Additional arguments to send to the tilemap constructor
         * @returns An array of Layers, each of which contains a layer of the tilemap as its own Tilemap instance.
         */
        this.add = function (key, scale) {
            if (scale === void 0) { scale = new Vec2_1["default"](1, 1); }
            // Get Tilemap Data
            var tilemapData = _this.resourceManager.getTilemap(key);
            // Set the constructor for this tilemap to either be orthographic or isometric
            var constr;
            if (tilemapData.orientation === "orthographic") {
                constr = OrthogonalTilemap_1["default"];
            }
            else {
                // No isometric tilemap support right now, so Orthographic tilemap
                constr = OrthogonalTilemap_1["default"];
            }
            // Initialize the return value array
            var sceneLayers = new Array();
            // Create all of the tilesets for this tilemap
            var tilesets = new Array();
            var collectionTiles = new Array();
            var _loop_1 = function (tileset) {
                if (tileset.image) {
                    // If this is a standard tileset and not a collection, create a tileset for it.
                    // TODO - We are ignoring collection tilesets for now. This is likely not a great idea in practice,
                    // as theoretically someone could want to use one for a standard tilemap. We are assuming for now
                    // that we only want to use them for object layers
                    tilesets.push(new Tileset_1["default"](tileset));
                }
                else {
                    tileset.tiles.forEach(function (tile) { return tile.id += tileset.firstgid; });
                    collectionTiles.push.apply(collectionTiles, tileset.tiles);
                }
            };
            for (var _i = 0, _a = tilemapData.tilesets; _i < _a.length; _i++) {
                var tileset = _a[_i];
                _loop_1(tileset);
            }
            // Loop over the layers of the tilemap and create tiledlayers or object layers
            for (var _b = 0, _c = tilemapData.layers; _b < _c.length; _b++) {
                var layer = _c[_b];
                var sceneLayer = void 0;
                var isParallaxLayer = false;
                var depth = 0;
                if (layer.properties) {
                    for (var _d = 0, _e = layer.properties; _d < _e.length; _d++) {
                        var prop = _e[_d];
                        if (prop.name === "Parallax") {
                            isParallaxLayer = prop.value;
                        }
                        else if (prop.name === "Depth") {
                            depth = prop.value;
                        }
                    }
                }
                if (isParallaxLayer) {
                    sceneLayer = _this.scene.addParallaxLayer(layer.name, new Vec2_1["default"](1, 1), depth);
                }
                else {
                    sceneLayer = _this.scene.addLayer(layer.name, depth);
                }
                if (layer.type === "tilelayer") {
                    // Create a new tilemap object for the layer
                    var tilemap = new constr(tilemapData, layer, tilesets, scale);
                    tilemap.id = _this.scene.generateId();
                    tilemap.setScene(_this.scene);
                    // Add tilemap to scene
                    _this.tilemaps.push(tilemap);
                    sceneLayer.addNode(tilemap);
                    // Register tilemap with physics if it's collidable
                    if (tilemap.isCollidable) {
                        tilemap.addPhysics();
                        if (layer.properties) {
                            for (var _f = 0, _g = layer.properties; _f < _g.length; _f++) {
                                var item = _g[_f];
                                if (item.name === "Group") {
                                    tilemap.setGroup(item.value);
                                }
                            }
                        }
                    }
                }
                else {
                    var isNavmeshPoints = false;
                    var navmeshName = void 0;
                    var edges = void 0;
                    if (layer.properties) {
                        for (var _h = 0, _j = layer.properties; _h < _j.length; _h++) {
                            var prop = _j[_h];
                            if (prop.name === "NavmeshPoints") {
                                isNavmeshPoints = true;
                            }
                            else if (prop.name === "name") {
                                navmeshName = prop.value;
                            }
                            else if (prop.name === "edges") {
                                edges = prop.value;
                            }
                        }
                    }
                    if (isNavmeshPoints) {
                        var g = new PositionGraph_1["default"]();
                        for (var _k = 0, _l = layer.objects; _k < _l.length; _k++) {
                            var obj = _l[_k];
                            g.addPositionedNode(new Vec2_1["default"](obj.x, obj.y));
                        }
                        for (var _m = 0, edges_1 = edges; _m < edges_1.length; _m++) {
                            var edge = edges_1[_m];
                            g.addEdge(edge.from, edge.to);
                        }
                        _this.scene.getNavigationManager().addNavigableEntity(navmeshName, new Navmesh_1["default"](g));
                        continue;
                    }
                    // Layer is an object layer, so add each object as a sprite to a new layer
                    for (var _o = 0, _p = layer.objects; _o < _p.length; _o++) {
                        var obj = _p[_o];
                        // Check if obj is collidable
                        var hasPhysics = false;
                        var isCollidable = false;
                        var isTrigger = false;
                        var onEnter = null;
                        var onExit = null;
                        var triggerGroup = null;
                        var group = "";
                        if (obj.properties) {
                            for (var _q = 0, _r = obj.properties; _q < _r.length; _q++) {
                                var prop = _r[_q];
                                if (prop.name === "HasPhysics") {
                                    hasPhysics = prop.value;
                                }
                                else if (prop.name === "Collidable") {
                                    isCollidable = prop.value;
                                }
                                else if (prop.name === "Group") {
                                    group = prop.value;
                                }
                                else if (prop.name === "IsTrigger") {
                                    isTrigger = prop.value;
                                }
                                else if (prop.name === "TriggerGroup") {
                                    triggerGroup = prop.value;
                                }
                                else if (prop.name === "TriggerOnEnter") {
                                    onEnter = prop.value;
                                }
                                else if (prop.name === "TriggerOnExit") {
                                    onExit = prop.value;
                                }
                            }
                        }
                        var sprite = void 0;
                        // Check if obj is a tile from a tileset
                        for (var _s = 0, tilesets_1 = tilesets; _s < tilesets_1.length; _s++) {
                            var tileset = tilesets_1[_s];
                            if (tileset.hasTile(obj.gid)) {
                                // The object is a tile from this set
                                var imageKey = tileset.getImageKey();
                                var offset = tileset.getImageOffsetForTile(obj.gid);
                                sprite = _this.scene.add.sprite(imageKey, layer.name);
                                var size = tileset.getTileSize().clone();
                                sprite.position.set((obj.x + size.x / 2) * scale.x, (obj.y - size.y / 2) * scale.y);
                                sprite.setImageOffset(offset);
                                sprite.size.copy(size);
                                sprite.scale.set(scale.x, scale.y);
                            }
                        }
                        // Not in a tileset, must correspond to a collection
                        if (!sprite) {
                            for (var _t = 0, collectionTiles_1 = collectionTiles; _t < collectionTiles_1.length; _t++) {
                                var tile = collectionTiles_1[_t];
                                if (obj.gid === tile.id) {
                                    var imageKey = tile.image;
                                    sprite = _this.scene.add.sprite(imageKey, layer.name);
                                    sprite.position.set((obj.x + tile.imagewidth / 2) * scale.x, (obj.y - tile.imageheight / 2) * scale.y);
                                    sprite.scale.set(scale.x, scale.y);
                                }
                            }
                        }
                        // Now we have sprite. Associate it with our physics object if there is one
                        if (hasPhysics) {
                            // Make the sprite a static physics object
                            sprite.addPhysics(sprite.boundary.clone(), Vec2_1["default"].ZERO, isCollidable, true);
                            sprite.setGroup(group);
                            if (isTrigger && triggerGroup !== null) {
                                sprite.setTrigger(triggerGroup, onEnter, onExit);
                            }
                        }
                    }
                }
                // Update the return value
                sceneLayers.push(sceneLayer);
            }
            return sceneLayers;
        };
    }
    TilemapFactory.prototype.init = function (scene, tilemaps) {
        this.scene = scene;
        this.tilemaps = tilemaps;
        this.resourceManager = ResourceManager_1["default"].getInstance();
    };
    return TilemapFactory;
}());
exports["default"] = TilemapFactory;
},{"../../DataTypes/Graphs/PositionGraph":6,"../../DataTypes/Tilesets/Tileset":19,"../../DataTypes/Vec2":20,"../../Nodes/Tilemaps/OrthogonalTilemap":46,"../../Pathfinding/Navmesh":55,"../../ResourceManager/ResourceManager":79}],86:[function(require,module,exports){
"use strict";
exports.__esModule = true;
var MathUtils_1 = require("../Utils/MathUtils");
/**
 * A layer in the scene. Layers are used for sorting @reference[GameNode]s by depth.
 */
var Layer = /** @class */ (function () {
    /**
     * Creates a new layer. To do this in a game, use the addLayer() method in @refrence[Scene]
     * @param scene The scene to add the layer to
     * @param name The name of the layer
     */
    function Layer(scene, name) {
        this.scene = scene;
        this.name = name;
        this.paused = false;
        this.hidden = false;
        this.alpha = 1;
        this.items = new Array();
        this.ySort = false;
        this.depth = 0;
    }
    /**
     * Retreives the name of the layer
     * @returns The name of the layer
     */
    Layer.prototype.getName = function () {
        return this.name;
    };
    /**
     * Pauses/Unpauses the layer. Affects all elements in this layer
     * @param pauseValue True if the layer should be paused, false if not
     */
    Layer.prototype.setPaused = function (pauseValue) {
        this.paused = pauseValue;
    };
    /**
     * Returns whether or not the layer is paused
     */
    Layer.prototype.isPaused = function () {
        return this.paused;
    };
    /**
     * Sets the opacity of the layer
     * @param alpha The new opacity value in the range [0, 1]
     */
    Layer.prototype.setAlpha = function (alpha) {
        this.alpha = MathUtils_1["default"].clamp(alpha, 0, 1);
    };
    /**
     * Gets the opacity of the layer
     * @returns The opacity
     */
    Layer.prototype.getAlpha = function () {
        return this.alpha;
    };
    /**
     * Sets the layer's hidden value. If hidden, a layer will not be rendered, but will still update
     * @param hidden The hidden value of the layer
     */
    Layer.prototype.setHidden = function (hidden) {
        this.hidden = hidden;
    };
    /**
     * Returns the hideen value of the lyaer
     * @returns True if the scene is hidden, false otherwise
     */
    Layer.prototype.isHidden = function () {
        return this.hidden;
    };
    /** Pauses this scene and hides it */
    Layer.prototype.disable = function () {
        this.paused = true;
        this.hidden = true;
    };
    /** Unpauses this layer and makes it visible */
    Layer.prototype.enable = function () {
        this.paused = false;
        this.hidden = false;
    };
    /**
     * Sets whether or not the scene will ySort automatically.
     * ySorting means that CanvasNodes on this layer will have their depth sorted depending on their y-value.
     * This means that if an object is "higher" in the scene, it will sort behind objects that are "lower".
     * This is useful for 3/4 view games, or similar situations, where you sometimes want to be in front of objects,
     * and other times want to be behind the same objects.
     * @param ySort True if ySorting should be active, false if not
     */
    Layer.prototype.setYSort = function (ySort) {
        this.ySort = ySort;
    };
    /**
     * Gets the ySort status of the scene
     * @returns True if ySorting is occurring, false otherwise
     */
    Layer.prototype.getYSort = function () {
        return this.ySort;
    };
    /**
     * Sets the depth of the layer compared to other layers. A larger number means the layer will be closer to the screen.
     * @param depth The depth of the layer.
     */
    Layer.prototype.setDepth = function (depth) {
        this.depth = depth;
    };
    /**
     * Retrieves the depth of the layer.
     * @returns The depth
     */
    Layer.prototype.getDepth = function () {
        return this.depth;
    };
    /**
     * Adds a node to this layer
     * @param node The node to add to this layer.
     */
    Layer.prototype.addNode = function (node) {
        this.items.push(node);
        node.setLayer(this);
    };
    /**
     * Removes a node from this layer
     * @param node The node to remove
     * @returns true if the node was removed, false otherwise
     */
    Layer.prototype.removeNode = function (node) {
        // Find and remove the node
        var index = this.items.indexOf(node);
        if (index !== -1) {
            this.items.splice(index, 1);
            node.setLayer(undefined);
        }
    };
    /**
     * Retreives all GameNodes from this layer
     * @returns an Array that contains all of the GameNodes in this layer.
     */
    Layer.prototype.getItems = function () {
        return this.items;
    };
    return Layer;
}());
exports["default"] = Layer;
},{"../Utils/MathUtils":97}],87:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
exports.__esModule = true;
var Layer_1 = require("../Layer");
/**
 * An extension of a Layer that has a parallax value.
 */
var ParallaxLayer = /** @class */ (function (_super) {
    __extends(ParallaxLayer, _super);
    /**
     * Creates a new ParallaxLayer.
     * Use addParallaxLayer() in @reference[Scene] to add a layer of this type to your game.
     * @param scene The Scene to add this ParallaxLayer to
     * @param name The name of the ParallaxLayer
     * @param parallax The parallax level
     */
    function ParallaxLayer(scene, name, parallax) {
        var _this = _super.call(this, scene, name) || this;
        _this.parallax = parallax;
        return _this;
    }
    return ParallaxLayer;
}(Layer_1["default"]));
exports["default"] = ParallaxLayer;
},{"../Layer":86}],88:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
exports.__esModule = true;
var Vec2_1 = require("../../DataTypes/Vec2");
var ParallaxLayer_1 = require("./ParallaxLayer");
/**
 * A Layer strictly to be used for managing UIElements.
 * This is intended to be a Layer that always stays in the same place,
 * and thus renders things like a HUD or an inventory without taking into consideration the \reference[Viewport] scroll.
 */
var UILayer = /** @class */ (function (_super) {
    __extends(UILayer, _super);
    /**
     * Creates a new UILayer.
     * Use addUILayer() in @reference[Scene] to add a layer of this type to your game.
     * @param scene The Scene to add this UILayer to
     * @param name The name of the UILayer
     */
    function UILayer(scene, name) {
        return _super.call(this, scene, name, Vec2_1["default"].ZERO) || this;
    }
    return UILayer;
}(ParallaxLayer_1["default"]));
exports["default"] = UILayer;
},{"../../DataTypes/Vec2":20,"./ParallaxLayer":87}],89:[function(require,module,exports){
"use strict";
exports.__esModule = true;
var Layer_1 = require("./Layer");
var Vec2_1 = require("../DataTypes/Vec2");
var BasicPhysicsManager_1 = require("../Physics/BasicPhysicsManager");
var SceneGraphArray_1 = require("../SceneGraph/SceneGraphArray");
var FactoryManager_1 = require("./Factories/FactoryManager");
var ResourceManager_1 = require("../ResourceManager/ResourceManager");
var Receiver_1 = require("../Events/Receiver");
var Emitter_1 = require("../Events/Emitter");
var NavigationManager_1 = require("../Pathfinding/NavigationManager");
var AIManager_1 = require("../AI/AIManager");
var Map_1 = require("../DataTypes/Map");
var ParallaxLayer_1 = require("./Layers/ParallaxLayer");
var UILayer_1 = require("./Layers/UILayer");
var CanvasNode_1 = require("../Nodes/CanvasNode");
var SceneOptions_1 = require("./SceneOptions");
var Debug_1 = require("../Debug/Debug");
var TimerManager_1 = require("../Timing/TimerManager");
var TweenManager_1 = require("../Rendering/Animations/TweenManager");
var ParticleSystemManager_1 = require("../Rendering/Animations/ParticleSystemManager");
/**
 * Scenes are the main container in the game engine.
 * Your main scene is the current level or menu of the game, and will contain all of the GameNodes needed.
 * Scenes provide an easy way to load assets, add assets to the game world, and unload assets,
 * and have lifecycle methods exposed for these functions.
 */
var Scene = /** @class */ (function () {
    /**
     * Creates a new Scene. To add a new Scene in your game, use changeToScene() in @reference[SceneManager]
     * @param viewport The viewport of the game
     * @param sceneManager The SceneManager that owns this Scene
     * @param renderingManager The RenderingManager that will handle this Scene's rendering
     * @param game The instance of the Game
     * @param options The options for Scene initialization
     */
    function Scene(viewport, sceneManager, renderingManager, options) {
        this.sceneOptions = SceneOptions_1["default"].parse(options === undefined ? {} : options);
        this.worldSize = new Vec2_1["default"](500, 500);
        this.viewport = viewport;
        this.viewport.setBounds(0, 0, 2560, 1280);
        this.running = false;
        this.sceneManager = sceneManager;
        this.receiver = new Receiver_1["default"]();
        this.emitter = new Emitter_1["default"]();
        this.tilemaps = new Array();
        this.sceneGraph = new SceneGraphArray_1["default"](this.viewport, this);
        this.layers = new Map_1["default"]();
        this.uiLayers = new Map_1["default"]();
        this.parallaxLayers = new Map_1["default"]();
        this.physicsManager = new BasicPhysicsManager_1["default"](this.sceneOptions.physics);
        this.navManager = new NavigationManager_1["default"]();
        this.aiManager = new AIManager_1["default"]();
        this.renderingManager = renderingManager;
        this.add = new FactoryManager_1["default"](this, this.tilemaps);
        this.load = ResourceManager_1["default"].getInstance();
        this.resourceManager = this.load;
        // Get the timer manager and clear any existing timers
        TimerManager_1["default"].getInstance().clearTimers();
    }
    /** A lifecycle method that gets called immediately after a new scene is created, before anything else. */
    Scene.prototype.initScene = function (init) { };
    /** A lifecycle method that gets called when a new scene is created. Load all files you wish to access in the scene here. */
    Scene.prototype.loadScene = function () { };
    /** A lifecycle method called strictly after loadScene(). Create any game objects you wish to use in the scene here. */
    Scene.prototype.startScene = function () { };
    /**
     * A lifecycle method called every frame of the game. This is where you can dynamically do things like add in new enemies
     * @param delta The time this frame represents
     */
    Scene.prototype.updateScene = function (deltaT) { };
    /** A lifecycle method that gets called on scene destruction. Specify which files you no longer need for garbage collection. */
    Scene.prototype.unloadScene = function () { };
    Scene.prototype.update = function (deltaT) {
        this.updateScene(deltaT);
        // Do time updates
        TimerManager_1["default"].getInstance().update(deltaT);
        // Do all AI updates
        this.aiManager.update(deltaT);
        // Update all physics objects
        this.physicsManager.update(deltaT);
        // Update all canvas objects
        this.sceneGraph.update(deltaT);
        // Update all tilemaps
        this.tilemaps.forEach(function (tilemap) {
            if (!tilemap.getLayer().isPaused()) {
                tilemap.update(deltaT);
            }
        });
        // Update all tweens
        TweenManager_1["default"].getInstance().update(deltaT);
        // Update all particle systems
        ParticleSystemManager_1["default"].getInstance().update(deltaT);
        // Update viewport
        this.viewport.update(deltaT);
    };
    /**
     * Collects renderable sets and coordinates with the RenderingManager to draw the Scene
     */
    Scene.prototype.render = function () {
        var _this = this;
        // Get the visible set of nodes
        var visibleSet = this.sceneGraph.getVisibleSet();
        // Add parallax layer items to the visible set (we're rendering them all for now)
        this.parallaxLayers.forEach(function (key) {
            var pLayer = _this.parallaxLayers.get(key);
            for (var _i = 0, _a = pLayer.getItems(); _i < _a.length; _i++) {
                var node = _a[_i];
                if (node instanceof CanvasNode_1["default"]) {
                    visibleSet.push(node);
                }
            }
        });
        // Send the visible set, tilemaps, and uiLayers to the renderer
        this.renderingManager.render(visibleSet, this.tilemaps, this.uiLayers);
        var nodes = this.sceneGraph.getAllNodes();
        this.tilemaps.forEach(function (tilemap) { return tilemap.visible ? nodes.push(tilemap) : 0; });
        Debug_1["default"].setNodes(nodes);
    };
    /**
     * Sets the scene as running or not
     * @param running True if the Scene should be running, false if not
     */
    Scene.prototype.setRunning = function (running) {
        this.running = running;
    };
    /**
     * Returns whether or not the Scene is running
     * @returns True if the scene is running, false otherwise
     */
    Scene.prototype.isRunning = function () {
        return this.running;
    };
    /**
     * Removes a node from this Scene
     * @param node The node to remove
     */
    Scene.prototype.remove = function (node) {
        // Remove from the scene graph
        if (node instanceof CanvasNode_1["default"]) {
            this.sceneGraph.removeNode(node);
        }
    };
    /** Destroys this scene and all nodes in it */
    Scene.prototype.destroy = function () {
        for (var _i = 0, _a = this.sceneGraph.getAllNodes(); _i < _a.length; _i++) {
            var node = _a[_i];
            node.destroy();
        }
        for (var _b = 0, _c = this.tilemaps; _b < _c.length; _b++) {
            var tilemap = _c[_b];
            tilemap.destroy();
        }
        this.receiver.destroy();
        delete this.sceneGraph;
        delete this.physicsManager;
        delete this.navManager;
        delete this.aiManager;
        delete this.receiver;
    };
    /**
     * Adds a new layer to the scene and returns it
     * @param name The name of the new layer
     * @param depth The depth of the layer
     * @returns The newly created Layer
     */
    Scene.prototype.addLayer = function (name, depth) {
        if (this.layers.has(name) || this.parallaxLayers.has(name) || this.uiLayers.has(name)) {
            throw "Layer with name ".concat(name, " already exists");
        }
        var layer = new Layer_1["default"](this, name);
        this.layers.add(name, layer);
        if (depth) {
            layer.setDepth(depth);
        }
        return layer;
    };
    /**
     * Adds a new parallax layer to this scene and returns it
     * @param name The name of the parallax layer
     * @param parallax The parallax level
     * @param depth The depth of the layer
     * @returns The newly created ParallaxLayer
     */
    Scene.prototype.addParallaxLayer = function (name, parallax, depth) {
        if (this.layers.has(name) || this.parallaxLayers.has(name) || this.uiLayers.has(name)) {
            throw "Layer with name ".concat(name, " already exists");
        }
        var layer = new ParallaxLayer_1["default"](this, name, parallax);
        this.parallaxLayers.add(name, layer);
        if (depth) {
            layer.setDepth(depth);
        }
        return layer;
    };
    /**
     * Adds a new UILayer to the scene
     * @param name The name of the new UIlayer
     * @returns The newly created UILayer
     */
    Scene.prototype.addUILayer = function (name) {
        if (this.layers.has(name) || this.parallaxLayers.has(name) || this.uiLayers.has(name)) {
            throw "Layer with name ".concat(name, " already exists");
        }
        var layer = new UILayer_1["default"](this, name);
        this.uiLayers.add(name, layer);
        return layer;
    };
    /**
     * Gets a layer from the scene by name if it exists.
     * This can be a Layer or any of its subclasses
     * @param name The name of the layer
     * @returns The Layer found with that name
     */
    Scene.prototype.getLayer = function (name) {
        if (this.layers.has(name)) {
            return this.layers.get(name);
        }
        else if (this.parallaxLayers.has(name)) {
            return this.parallaxLayers.get(name);
        }
        else if (this.uiLayers.has(name)) {
            return this.uiLayers.get(name);
        }
        else {
            throw "Requested layer ".concat(name, " does not exist.");
        }
    };
    /**
     * Returns true if this layer is a ParallaxLayer
     * @param name The name of the layer
     * @returns True if this layer is a ParallaxLayer
     */
    Scene.prototype.isParallaxLayer = function (name) {
        return this.parallaxLayers.has(name);
    };
    /**
     * Returns true if this layer is a UILayer
     * @param name The name of the layer
     * @returns True if this layer is ParallaxLayer
     */
    Scene.prototype.isUILayer = function (name) {
        return this.uiLayers.has(name);
    };
    /**
     * Returns the translation of this node with respect to camera space (due to the viewport moving).
     * This value is affected by the parallax level of the @reference[Layer] the node is on.
     * @param node The node to check the viewport with respect to
     * @returns A Vec2 containing the translation of viewport with respect to this node.
     */
    Scene.prototype.getViewTranslation = function (node) {
        var layer = node.getLayer();
        if (layer instanceof ParallaxLayer_1["default"] || layer instanceof UILayer_1["default"]) {
            return this.viewport.getOrigin().mult(layer.parallax);
        }
        else {
            return this.viewport.getOrigin();
        }
    };
    /**
     * Returns the scale level of the view
     * @returns The zoom level of the viewport
    */
    Scene.prototype.getViewScale = function () {
        return this.viewport.getZoomLevel();
    };
    /**
     * Returns the Viewport associated with this scene
     * @returns The current Viewport
     */
    Scene.prototype.getViewport = function () {
        return this.viewport;
    };
    /**
     * Gets the world size of this Scene
     * @returns The world size in a Vec2
     */
    Scene.prototype.getWorldSize = function () {
        return this.worldSize;
    };
    /**
     * Gets the SceneGraph associated with this Scene
     * @returns The SceneGraph
     */
    Scene.prototype.getSceneGraph = function () {
        return this.sceneGraph;
    };
    /**
     * Gets the PhysicsManager associated with this Scene
     * @returns The PhysicsManager
     */
    Scene.prototype.getPhysicsManager = function () {
        return this.physicsManager;
    };
    /**
     * Gets the NavigationManager associated with this Scene
     * @returns The NavigationManager
     */
    Scene.prototype.getNavigationManager = function () {
        return this.navManager;
    };
    /**
     * Gets the AIManager associated with this Scene
     * @returns The AIManager
     */
    Scene.prototype.getAIManager = function () {
        return this.aiManager;
    };
    /**
     * Generates an ID for a GameNode
     * @returns The new ID
     */
    Scene.prototype.generateId = function () {
        return this.sceneManager.generateId();
    };
    /**
     * Retrieves a Tilemap in this Scene
     * @param name The name of the Tilemap
     * @returns The Tilemap, if one this name exists, otherwise null
     */
    Scene.prototype.getTilemap = function (name) {
        for (var _i = 0, _a = this.tilemaps; _i < _a.length; _i++) {
            var tilemap = _a[_i];
            if (tilemap.name === name) {
                return tilemap;
            }
        }
        return null;
    };
    return Scene;
}());
exports["default"] = Scene;
},{"../AI/AIManager":1,"../DataTypes/Map":8,"../DataTypes/Vec2":20,"../Debug/Debug":21,"../Events/Emitter":23,"../Events/Receiver":27,"../Nodes/CanvasNode":35,"../Pathfinding/NavigationManager":53,"../Physics/BasicPhysicsManager":56,"../Rendering/Animations/ParticleSystemManager":64,"../Rendering/Animations/TweenManager":66,"../ResourceManager/ResourceManager":79,"../SceneGraph/SceneGraphArray":81,"../Timing/TimerManager":93,"./Factories/FactoryManager":84,"./Layer":86,"./Layers/ParallaxLayer":87,"./Layers/UILayer":88,"./SceneOptions":91}],90:[function(require,module,exports){
"use strict";
exports.__esModule = true;
var ResourceManager_1 = require("../ResourceManager/ResourceManager");
/**
 * The SceneManager acts as an interface to create Scenes, and handles the lifecycle methods of Scenes.
 * It gives Scenes access to information they need from the @reference[Game] class while keeping a layer of separation.
 */
var SceneManager = /** @class */ (function () {
    /**
     * Creates a new SceneManager
     * @param viewport The Viewport of the game
     * @param game The Game instance
     * @param renderingManager The RenderingManager of the game
     */
    function SceneManager(viewport, renderingManager) {
        this.resourceManager = ResourceManager_1["default"].getInstance();
        this.viewport = viewport;
        this.renderingManager = renderingManager;
        this.idCounter = 0;
        this.pendingScene = null;
    }
    /**
     * Add a scene as the main scene.
     * Use this method if you've created a subclass of Scene, and you want to add it as the main Scene.
     * @param constr The constructor of the scene to add
     * @param init An object to pass to the init function of the new scene
     */
    SceneManager.prototype.changeToScene = function (constr, init, options) {
        console.log("Creating the new scene - change is pending until next update");
        this.pendingScene = new constr(this.viewport, this, this.renderingManager, options);
        this.pendingSceneInit = init;
    };
    SceneManager.prototype.doSceneChange = function () {
        var _this = this;
        console.log("Performing scene change");
        this.viewport.setCenter(this.viewport.getHalfSize().x, this.viewport.getHalfSize().y);
        if (this.currentScene) {
            console.log("Unloading old scene");
            this.currentScene.unloadScene();
            console.log("Destroying old scene");
            this.currentScene.destroy();
        }
        console.log("Unloading old resources...");
        this.resourceManager.unloadAllResources();
        // Make the pending scene the current one
        this.currentScene = this.pendingScene;
        // Make the pending scene null
        this.pendingScene = null;
        // Init the scene
        this.currentScene.initScene(this.pendingSceneInit);
        // Enqueue all scene asset loads
        this.currentScene.loadScene();
        // Load all assets
        console.log("Starting Scene Load");
        this.resourceManager.loadResourcesFromQueue(function () {
            console.log("Starting Scene");
            _this.currentScene.startScene();
            _this.currentScene.setRunning(true);
        });
        this.renderingManager.setScene(this.currentScene);
    };
    /**
     * Generates a unique ID
     * @returns A new ID
     */
    SceneManager.prototype.generateId = function () {
        return this.idCounter++;
    };
    /**
     * Renders the current Scene
     */
    SceneManager.prototype.render = function () {
        if (this.currentScene) {
            this.currentScene.render();
        }
    };
    /**
     * Updates the current Scene
     * @param deltaT The timestep of the Scene
     */
    SceneManager.prototype.update = function (deltaT) {
        if (this.pendingScene !== null) {
            this.doSceneChange();
        }
        if (this.currentScene && this.currentScene.isRunning()) {
            this.currentScene.update(deltaT);
        }
    };
    return SceneManager;
}());
exports["default"] = SceneManager;
},{"../ResourceManager/ResourceManager":79}],91:[function(require,module,exports){
"use strict";
exports.__esModule = true;
// @ignorePage
/**
 * The options to give a @reference[Scene] for initialization
 */
var SceneOptions = /** @class */ (function () {
    function SceneOptions() {
    }
    SceneOptions.parse = function (options) {
        var sOpt = new SceneOptions();
        if (options.physics === undefined) {
            sOpt.physics = { groups: undefined, collisions: undefined };
        }
        else {
            sOpt.physics = options.physics;
        }
        return sOpt;
    };
    return SceneOptions;
}());
exports["default"] = SceneOptions;
},{}],92:[function(require,module,exports){
"use strict";
exports.__esModule = true;
exports.MAX_AUDIO_CHANNELS = exports.AudioChannelType = void 0;
var Map_1 = require("../DataTypes/Map");
var Receiver_1 = require("../Events/Receiver");
var ResourceManager_1 = require("../ResourceManager/ResourceManager");
var GameEventType_1 = require("../Events/GameEventType");
/**
 * Manages any sounds or music needed for the game.
 * Through the EventQueue, exposes interface to play sounds so GameNodes can activate sounds without
 * needing direct references to the audio system
 */
var AudioManager = /** @class */ (function () {
    function AudioManager() {
        this.initAudio();
        this.receiver = new Receiver_1["default"]();
        this.receiver.subscribe([
            GameEventType_1.GameEventType.PLAY_SOUND,
            GameEventType_1.GameEventType.STOP_SOUND,
            GameEventType_1.GameEventType.PLAY_MUSIC,
            GameEventType_1.GameEventType.PLAY_SFX,
            GameEventType_1.GameEventType.MUTE_CHANNEL,
            GameEventType_1.GameEventType.UNMUTE_CHANNEL
        ]);
        this.currentSounds = new Map_1["default"]();
        this.gainNodes = new Array(exports.MAX_AUDIO_CHANNELS);
        this.initGainNodes();
    }
    /**
     * Get the instance of the AudioManager class or create a new one if none exists
     * @returns The AudioManager
     */
    AudioManager.getInstance = function () {
        if (!this.instance) {
            this.instance = new AudioManager();
        }
        return this.instance;
    };
    /**
     * Initializes the webAudio context
     */
    AudioManager.prototype.initAudio = function () {
        try {
            window.AudioContext = window.AudioContext; // || window.webkitAudioContext; 
            this.audioCtx = new AudioContext();
            console.log('Web Audio API successfully loaded');
        }
        catch (e) {
            console.warn('Web Audio API is not supported in this browser');
        }
    };
    AudioManager.prototype.initGainNodes = function () {
        for (var i = 0; i < exports.MAX_AUDIO_CHANNELS; i++) {
            this.gainNodes[i] = this.audioCtx.createGain();
        }
    };
    /**
     * Returns the current audio context
     * @returns The AudioContext
     */
    AudioManager.prototype.getAudioContext = function () {
        return this.audioCtx;
    };
    /*
        According to the MDN, create a new sound for every call:

        An AudioBufferSourceNode can only be played once; after each call to start(), you have to create a new node
        if you want to play the same sound again. Fortunately, these nodes are very inexpensive to create, and the
        actual AudioBuffers can be reused for multiple plays of the sound. Indeed, you can use these nodes in a
        "fire and forget" manner: create the node, call start() to begin playing the sound, and don't even bother to
        hold a reference to it. It will automatically be garbage-collected at an appropriate time, which won't be
        until sometime after the sound has finished playing.
    */
    /**
     * Creates a new sound from the key of a loaded audio file
     * @param key The key of the loaded audio file to create a new sound for
     * @returns The newly created AudioBuffer
     */
    AudioManager.prototype.createSound = function (key, holdReference, channel, options) {
        // Get audio buffer
        var buffer = ResourceManager_1["default"].getInstance().getAudio(key);
        // Create a sound source
        var source = this.audioCtx.createBufferSource();
        // Tell the source which sound to play
        source.buffer = buffer;
        // Add any additional nodes
        var nodes = [source];
        // Do any additional nodes here?
        // Of course, there aren't any supported yet...
        // Add the gain node for this channel
        nodes.push(this.gainNodes[channel]);
        // Connect any nodes along the path
        for (var i = 1; i < nodes.length; i++) {
            nodes[i - 1].connect(nodes[i]);
        }
        // Connect the source to the context's destination
        nodes[nodes.length - 1].connect(this.audioCtx.destination);
        return source;
    };
    /**
     * Play the sound specified by the key
     * @param key The key of the sound to play
     * @param loop A boolean for whether or not to loop the sound
     * @param holdReference A boolean for whether or not we want to hold on to a reference of the audio node. This is good for playing music on a loop that will eventually need to be stopped.
     */
    AudioManager.prototype.playSound = function (key, loop, holdReference, channel, options) {
        var sound = this.createSound(key, holdReference, channel, options);
        if (loop) {
            sound.loop = true;
        }
        // Add a reference of the new sound to a map. This will allow us to stop a looping or long sound at a later time
        if (holdReference) {
            this.currentSounds.add(key, sound);
        }
        sound.start();
    };
    /**
     * Stop the sound specified by the key
     */
    AudioManager.prototype.stopSound = function (key) {
        var sound = this.currentSounds.get(key);
        if (sound) {
            sound.stop();
            this.currentSounds["delete"](key);
        }
    };
    AudioManager.prototype.muteChannel = function (channel) {
        this.gainNodes[channel].gain.setValueAtTime(0, this.audioCtx.currentTime);
    };
    AudioManager.prototype.unmuteChannel = function (channel) {
        this.gainNodes[channel].gain.setValueAtTime(1, this.audioCtx.currentTime);
    };
    /**
     * Sets the volume of a channel using the GainNode for that channel. For more
     * information on GainNodes, see https://developer.mozilla.org/en-US/docs/Web/API/GainNode
     * @param channel The audio channel to set the volume for
     * @param volume The volume of the channel. 0 is muted. Values below zero will be set to zero.
     */
    AudioManager.setVolume = function (channel, volume) {
        if (volume < 0) {
            volume = 0;
        }
        var am = AudioManager.getInstance();
        am.gainNodes[channel].gain.setValueAtTime(volume, am.audioCtx.currentTime);
    };
    /**
     * Returns the GainNode for this channel.
     * Learn more about GainNodes here https://developer.mozilla.org/en-US/docs/Web/API/GainNode
     * DON'T USE THIS UNLESS YOU KNOW WHAT YOU'RE DOING
     * @param channel The channel
     * @returns The GainNode for the specified channel
     */
    AudioManager.prototype.getChannelGainNode = function (channel) {
        return this.gainNodes[channel];
    };
    AudioManager.prototype.update = function (deltaT) {
        // Play each audio clip requested
        // TODO - Add logic to merge sounds if there are multiple of the same key
        while (this.receiver.hasNextEvent()) {
            var event_1 = this.receiver.getNextEvent();
            if (event_1.type === GameEventType_1.GameEventType.PLAY_SOUND || event_1.type === GameEventType_1.GameEventType.PLAY_MUSIC || event_1.type === GameEventType_1.GameEventType.PLAY_SFX) {
                var soundKey = event_1.data.get("key");
                var loop = event_1.data.get("loop");
                var holdReference = event_1.data.get("holdReference");
                var channel = AudioChannelType.DEFAULT;
                if (event_1.type === GameEventType_1.GameEventType.PLAY_MUSIC) {
                    channel = AudioChannelType.MUSIC;
                }
                else if (GameEventType_1.GameEventType.PLAY_SFX) {
                    channel = AudioChannelType.SFX;
                }
                else if (event_1.data.has("channel")) {
                    channel = event_1.data.get("channel");
                }
                this.playSound(soundKey, loop, holdReference, channel, event_1.data);
            }
            if (event_1.type === GameEventType_1.GameEventType.STOP_SOUND) {
                var soundKey = event_1.data.get("key");
                this.stopSound(soundKey);
            }
            if (event_1.type === GameEventType_1.GameEventType.MUTE_CHANNEL) {
                this.muteChannel(event_1.data.get("channel"));
            }
            if (event_1.type === GameEventType_1.GameEventType.UNMUTE_CHANNEL) {
                this.unmuteChannel(event_1.data.get("channel"));
            }
        }
    };
    return AudioManager;
}());
exports["default"] = AudioManager;
var AudioChannelType;
(function (AudioChannelType) {
    AudioChannelType[AudioChannelType["DEFAULT"] = 0] = "DEFAULT";
    AudioChannelType[AudioChannelType["SFX"] = 1] = "SFX";
    AudioChannelType[AudioChannelType["MUSIC"] = 2] = "MUSIC";
    AudioChannelType[AudioChannelType["CUSTOM_1"] = 3] = "CUSTOM_1";
    AudioChannelType[AudioChannelType["CUSTOM_2"] = 4] = "CUSTOM_2";
    AudioChannelType[AudioChannelType["CUSTOM_3"] = 5] = "CUSTOM_3";
    AudioChannelType[AudioChannelType["CUSTOM_4"] = 6] = "CUSTOM_4";
    AudioChannelType[AudioChannelType["CUSTOM_5"] = 7] = "CUSTOM_5";
    AudioChannelType[AudioChannelType["CUSTOM_6"] = 8] = "CUSTOM_6";
    AudioChannelType[AudioChannelType["CUSTOM_7"] = 9] = "CUSTOM_7";
    AudioChannelType[AudioChannelType["CUSTOM_8"] = 10] = "CUSTOM_8";
    AudioChannelType[AudioChannelType["CUSTOM_9"] = 11] = "CUSTOM_9";
})(AudioChannelType = exports.AudioChannelType || (exports.AudioChannelType = {}));
exports.MAX_AUDIO_CHANNELS = 12;
},{"../DataTypes/Map":8,"../Events/GameEventType":26,"../Events/Receiver":27,"../ResourceManager/ResourceManager":79}],93:[function(require,module,exports){
"use strict";
exports.__esModule = true;
var TimerManager = /** @class */ (function () {
    function TimerManager() {
        this.timers = new Array();
    }
    TimerManager.getInstance = function () {
        if (!this.instance) {
            this.instance = new TimerManager();
        }
        return this.instance;
    };
    TimerManager.prototype.addTimer = function (timer) {
        this.timers.push(timer);
    };
    TimerManager.prototype.clearTimers = function () {
        this.timers = new Array();
    };
    TimerManager.prototype.update = function (deltaT) {
        this.timers.forEach(function (timer) { return timer.update(deltaT); });
    };
    return TimerManager;
}());
exports["default"] = TimerManager;
},{}],94:[function(require,module,exports){
"use strict";
exports.__esModule = true;
var MathUtils_1 = require("./MathUtils");
// TODO: This should be moved to the datatypes folder
/**
 * A Color util class that keeps track of colors like a vector, but can be converted into a string format
 */
var Color = /** @class */ (function () {
    /**
     * Creates a new color
     * @param r Red
     * @param g Green
     * @param b Blue
     * @param a Alpha
     */
    function Color(r, g, b, a) {
        if (r === void 0) { r = 0; }
        if (g === void 0) { g = 0; }
        if (b === void 0) { b = 0; }
        if (a === void 0) { a = 1; }
        this.r = r;
        this.g = g;
        this.b = b;
        this.a = a;
    }
    Object.defineProperty(Color, "TRANSPARENT", {
        /**
         * Transparent color
         * @returns rgba(0, 0, 0, 0)
         */
        get: function () {
            return new Color(0, 0, 0, 0);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Color, "RED", {
        /**
         * Red color
         * @returns rgb(255, 0, 0)
         */
        get: function () {
            return new Color(255, 0, 0, 1);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Color, "GREEN", {
        /**
         * Green color
         * @returns rgb(0, 255, 0)
         */
        get: function () {
            return new Color(0, 255, 0, 1);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Color, "BLUE", {
        /**
         * Blue color
         * @returns rgb(0, 0, 255)
         */
        get: function () {
            return new Color(0, 0, 255, 1);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Color, "YELLOW", {
        /**
         * Yellow color
         * @returns rgb(255, 255, 0)
         */
        get: function () {
            return new Color(255, 255, 0, 1);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Color, "MAGENTA", {
        /**
         * Magenta color
         * @returns rgb(255, 0, 255)
         */
        get: function () {
            return new Color(255, 0, 255, 1);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Color, "CYAN", {
        /**
         * Cyan color
         * @returns rgb(0, 255, 255)
         */
        get: function () {
            return new Color(0, 255, 255, 1);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Color, "WHITE", {
        /**
         * White color
         * @returns rgb(255, 255, 255)
         */
        get: function () {
            return new Color(255, 255, 255, 1);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Color, "BLACK", {
        /**
         * Black color
         * @returns rgb(0, 0, 0)
         */
        get: function () {
            return new Color(0, 0, 0, 1);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Color, "ORANGE", {
        /**
         * Orange color
         * @returns rgb(255, 100, 0)
         */
        get: function () {
            return new Color(255, 100, 0, 1);
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Sets the color to the values provided
     * @param r Red
     * @param g Green
     * @param b Blue
     * @param a Alpha
     */
    Color.prototype.set = function (r, g, b, a) {
        if (a === void 0) { a = 1; }
        this.r = r;
        this.g = g;
        this.b = b;
        this.a = a;
    };
    /**
     * Returns a new color slightly lighter than the current color
     * @returns A new lighter Color
     */
    Color.prototype.lighten = function () {
        return new Color(MathUtils_1["default"].clamp(this.r + 40, 0, 255), MathUtils_1["default"].clamp(this.g + 40, 0, 255), MathUtils_1["default"].clamp(this.b + 40, 0, 255), MathUtils_1["default"].clamp(this.a + 10, 0, 255));
    };
    /**
     * Returns a new color slightly darker than the current color
     * @returns A new darker Color
     */
    Color.prototype.darken = function () {
        return new Color(MathUtils_1["default"].clamp(this.r - 40, 0, 255), MathUtils_1["default"].clamp(this.g - 40, 0, 255), MathUtils_1["default"].clamp(this.b - 40, 0, 255), MathUtils_1["default"].clamp(this.a + 10, 0, 255));
    };
    /**
     * Returns this color as an array
     * @returns [r, g, b, a]
     */
    Color.prototype.toArray = function () {
        return [this.r, this.g, this.b, this.a];
    };
    /**
     * Returns the color as a string of the form #RRGGBB
     * @returns #RRGGBB
     */
    Color.prototype.toString = function () {
        return "#" + MathUtils_1["default"].toHex(this.r, 2) + MathUtils_1["default"].toHex(this.g, 2) + MathUtils_1["default"].toHex(this.b, 2);
    };
    /**
     * Returns the color as a string of the form rgb(r, g, b)
     * @returns rgb(r, g, b)
     */
    Color.prototype.toStringRGB = function () {
        return "rgb(" + this.r.toString() + ", " + this.g.toString() + ", " + this.b.toString() + ")";
    };
    /**
     * Returns the color as a string of the form rgba(r, g, b, a)
     * @returns rgba(r, g, b, a)
     */
    Color.prototype.toStringRGBA = function () {
        if (this.a === 0) {
            return this.toStringRGB();
        }
        return "rgba(" + this.r.toString() + ", " + this.g.toString() + ", " + this.b.toString() + ", " + this.a.toString() + ")";
    };
    /**
     * Turns this color into a float32Array and changes color range to [0.0, 1.0]
     * @returns a Float32Array containing the color
     */
    Color.prototype.toWebGL = function () {
        return new Float32Array([
            this.r / 255,
            this.g / 255,
            this.b / 255,
            this.a
        ]);
    };
    Color.fromStringHex = function (str) {
        var i = 0;
        if (str.charAt(0) == "#")
            i += 1;
        var r = MathUtils_1["default"].fromHex(str.substring(i, i + 2));
        var g = MathUtils_1["default"].fromHex(str.substring(i + 2, i + 4));
        var b = MathUtils_1["default"].fromHex(str.substring(i + 4, i + 6));
        return new Color(r, g, b);
    };
    return Color;
}());
exports["default"] = Color;
},{"./MathUtils":97}],95:[function(require,module,exports){
"use strict";
// @ignorePage
exports.__esModule = true;
exports.EaseFunctionType = void 0;
var EaseFunctions = /** @class */ (function () {
    function EaseFunctions() {
    }
    EaseFunctions.easeInOutSine = function (x) {
        return -(Math.cos(Math.PI * x) - 1) / 2;
    };
    EaseFunctions.easeOutInSine = function (x) {
        return x < 0.5 ? -Math.cos(Math.PI * (x + 0.5)) / 2 : -Math.cos(Math.PI * (x - 0.5)) / 2 + 1;
    };
    EaseFunctions.easeOutSine = function (x) {
        return Math.sin((x * Math.PI) / 2);
    };
    EaseFunctions.easeInSine = function (x) {
        return 1 - Math.cos((x * Math.PI) / 2);
    };
    EaseFunctions.easeInOutQuint = function (x) {
        return x < 0.5 ? 16 * x * x * x * x * x : 1 - Math.pow(-2 * x + 2, 5) / 2;
    };
    EaseFunctions.easeInOutQuad = function (x) {
        return x < 0.5 ? 2 * x * x : 1 - Math.pow(-2 * x + 2, 2) / 2;
    };
    EaseFunctions.easeOutInQuad = function (x) {
        return x < 0.5 ? this.easeOutIn_OutPow(x, 2) : this.easeOutIn_InPow(x, 2);
    };
    EaseFunctions.easeOutIn_OutPow = function (x, pow) {
        return 0.5 - Math.pow(-2 * x + 1, pow) / 2;
    };
    EaseFunctions.easeOutIn_InPow = function (x, pow) {
        return 0.5 + Math.pow(2 * x - 1, pow) / 2;
    };
    return EaseFunctions;
}());
exports["default"] = EaseFunctions;
var EaseFunctionType;
(function (EaseFunctionType) {
    // SINE
    EaseFunctionType["IN_OUT_SINE"] = "easeInOutSine";
    EaseFunctionType["OUT_IN_SINE"] = "easeOutInSine";
    EaseFunctionType["IN_SINE"] = "easeInSine";
    EaseFunctionType["OUT_SINE"] = "easeOutSine";
    // QUAD
    EaseFunctionType["IN_OUT_QUAD"] = "easeInOutQuad";
    EaseFunctionType["OUT_IN_QUAD"] = "easeOutInQuad";
    // QUINT
    EaseFunctionType["IN_OUT_QUINT"] = "easeInOutQuint";
})(EaseFunctionType = exports.EaseFunctionType || (exports.EaseFunctionType = {}));
},{}],96:[function(require,module,exports){
"use strict";
exports.__esModule = true;
/** A class to provides some utility functions for graphs */
var GraphUtils = /** @class */ (function () {
    function GraphUtils() {
    }
    /**
     * An implementation of Djikstra's shortest path algorithm based on the one described in The Algorithm Design Manual.
     * @param g The graph
     * @param start The number to start the shortest path from
     * @returns An array containing the parent of each node of the Graph in the shortest path.
     */
    GraphUtils.djikstra = function (g, start) {
        var i; // Counter
        var p; // Pointer to edgenode
        var inTree = new Array(g.numVertices);
        var distance = new Array(g.numVertices);
        var parent = new Array(g.numVertices);
        var v; // Current vertex to process
        var w; // Candidate for next vertex
        var weight; // Edge weight
        var dist; // Best current distance from start
        for (i = 0; i < g.numVertices; i++) {
            inTree[i] = false;
            distance[i] = Infinity;
            parent[i] = -1;
        }
        distance[start] = 0;
        v = start;
        while (!inTree[v]) {
            inTree[v] = true;
            p = g.edges[v];
            while (p !== null) {
                w = p.y;
                weight = p.weight;
                if (distance[w] > distance[v] + weight) {
                    distance[w] = distance[v] + weight;
                    parent[w] = v;
                }
                p = p.next;
            }
            v = 0;
            dist = Infinity;
            for (i = 0; i <= g.numVertices; i++) {
                if (!inTree[i] && dist > distance[i]) {
                    dist = distance;
                    v = i;
                }
            }
        }
        return parent;
    };
    return GraphUtils;
}());
exports["default"] = GraphUtils;
},{}],97:[function(require,module,exports){
"use strict";
exports.__esModule = true;
/** A class containing some utility functions for math operations */
var MathUtils = /** @class */ (function () {
    function MathUtils() {
    }
    /**
     * Returns the sign of the value provided
     * @param x The value to extract the sign from
     * @returns -1 if the number is less than 0, 1 otherwise
     */
    MathUtils.sign = function (x) {
        return x < 0 ? -1 : 1;
    };
    /**
     * Returns whether or not x is between a and b
     * @param a The min bound
     * @param b The max bound
     * @param x The value to check
     * @param exclusive Whether or not a and b are exclusive bounds
     * @returns True if x is between a and b, false otherwise
     */
    MathUtils.between = function (a, b, x, exclusive) {
        if (exclusive) {
            return (a < x) && (x < b);
        }
        else {
            return (a <= x) && (x <= b);
        }
    };
    /**
     * Clamps the value x to the range [min, max], rounding up or down if needed
     * @param x The value to be clamped
     * @param min The min of the range
     * @param max The max of the range
     * @returns x, if it is between min and max, or min/max if it exceeds their bounds
     */
    MathUtils.clamp = function (x, min, max) {
        if (x < min)
            return min;
        if (x > max)
            return max;
        return x;
    };
    /**
     * Clamps the value x to the range between 0 and 1
     * @param x The value to be clamped
     * @returns x, if it is between 0 and 1, or 0/1 if it exceeds their bounds
     */
    MathUtils.clamp01 = function (x) {
        return MathUtils.clamp(x, 0, 1);
    };
    /**
     * Clamps the lower end of the value of x to the range to min
     * @param x The value to be clamped
     * @param min The minimum allowed value of x
     * @returns x, if it is greater than min, otherwise min
     */
    MathUtils.clampLow = function (x, min) {
        return x < min ? min : x;
    };
    /**
     * Clamps the lower end of the value of x to zero
     * @param x The value to be clamped
     * @returns x, if it is greater than 0, otherwise 0
     */
    MathUtils.clampLow0 = function (x) {
        return MathUtils.clampLow(x, 0);
    };
    MathUtils.clampMagnitude = function (v, m) {
        if (v.magSq() > m * m) {
            return v.scaleTo(m);
        }
        else {
            return v;
        }
    };
    MathUtils.changeRange = function (x, min, max, newMin, newMax) {
        return this.lerp(newMin, newMax, this.invLerp(min, max, x));
    };
    /**
     * Linear Interpolation
     * @param a The first value for the interpolation bound
     * @param b The second value for the interpolation bound
     * @param t The time we are interpolating to
     * @returns The value between a and b at time t
     */
    MathUtils.lerp = function (a, b, t) {
        return a + t * (b - a);
    };
    /**
     * Inverse Linear Interpolation. Finds the time at which a value between a and b would occur
     * @param a The first value for the interpolation bound
     * @param b The second value for the interpolation bound
     * @param value The current value
     * @returns The time at which the current value occurs between a and b
     */
    MathUtils.invLerp = function (a, b, value) {
        return (value - a) / (b - a);
    };
    /**
     * Cuts off decimal points of a number after a specified place
     * @param num The number to floor
     * @param place The last decimal place of the new number
     * @returns The floored number
     */
    MathUtils.floorToPlace = function (num, place) {
        if (place === 0) {
            return Math.floor(num);
        }
        var factor = 10;
        while (place > 1) {
            factor != 10;
            place--;
        }
        return Math.floor(num * factor) / factor;
    };
    /**
     * Returns a number from a hex string
     * @param str the string containing the hex number
     * @returns the number in decimal represented by the hex string
     */
    MathUtils.fromHex = function (str) {
        return parseInt(str, 16);
    };
    /**
     * Returns the number as a hexadecimal
     * @param num The number to convert to hex
     * @param minLength The length of the returned hex string (adds zero padding if needed)
     * @returns The hex representation of the number as a string
     */
    MathUtils.toHex = function (num, minLength) {
        if (minLength === void 0) { minLength = null; }
        var factor = 1;
        while (factor * 16 < num) {
            factor *= 16;
        }
        var hexStr = "";
        while (factor >= 1) {
            var digit = Math.floor(num / factor);
            hexStr += MathUtils.toHexDigit(digit);
            num -= digit * factor;
            factor /= 16;
        }
        if (minLength !== null) {
            while (hexStr.length < minLength) {
                hexStr = "0" + hexStr;
            }
        }
        return hexStr;
    };
    /**
     * Converts a digit to hexadecimal. In this case, a digit is between 0 and 15 inclusive
     * @param num The digit to convert to hexadecimal
     * @returns The hex representation of the digit as a string
     */
    MathUtils.toHexDigit = function (num) {
        if (num < 10) {
            return "" + num;
        }
        else {
            return String.fromCharCode(65 + num - 10);
        }
    };
    return MathUtils;
}());
exports["default"] = MathUtils;
},{}],98:[function(require,module,exports){
"use strict";
exports.__esModule = true;
var MathUtils_1 = require("./MathUtils");
var RenderingUtils = /** @class */ (function () {
    function RenderingUtils() {
    }
    RenderingUtils.toWebGLCoords = function (point, origin, worldSize) {
        return new Float32Array([
            MathUtils_1["default"].changeRange(point.x, origin.x, origin.x + worldSize.x, -1, 1),
            MathUtils_1["default"].changeRange(point.y, origin.y, origin.y + worldSize.y, 1, -1)
        ]);
    };
    RenderingUtils.toWebGLScale = function (size, worldSize) {
        return new Float32Array([
            2 * size.x / worldSize.x,
            2 * size.y / worldSize.y,
        ]);
    };
    RenderingUtils.toWebGLColor = function (color) {
        return new Float32Array([
            MathUtils_1["default"].changeRange(color.r, 0, 255, 0, 1),
            MathUtils_1["default"].changeRange(color.g, 0, 255, 0, 1),
            MathUtils_1["default"].changeRange(color.b, 0, 255, 0, 1),
            color.a
        ]);
    };
    return RenderingUtils;
}());
exports["default"] = RenderingUtils;
},{"./MathUtils":97}],99:[function(require,module,exports){
"use strict";
exports.__esModule = true;
/** Some utility functions for dealing with strings */
var StringUtils = /** @class */ (function () {
    function StringUtils() {
    }
    /**
     * Extracts the path from a filepath that includes the file
     * @param filePath the filepath to extract the path from
     * @returns The path portion of the filepath provided
     */
    StringUtils.getPathFromFilePath = function (filePath) {
        var splitPath = filePath.split("/");
        splitPath.pop();
        splitPath.push("");
        return splitPath.join("/");
    };
    return StringUtils;
}());
exports["default"] = StringUtils;
},{}],100:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
exports.__esModule = true;
var StateMachineAI_1 = require("../../Wolfie2D/AI/StateMachineAI");
var ElementController = /** @class */ (function (_super) {
    __extends(ElementController, _super);
    function ElementController() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ElementController.prototype.initializeAI = function (owner, options) {
        this.owner = owner;
    };
    ElementController.prototype.update = function (deltaT) {
    };
    return ElementController;
}(StateMachineAI_1["default"]));
exports["default"] = ElementController;
},{"../../Wolfie2D/AI/StateMachineAI":2}],101:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
exports.__esModule = true;
var StateMachineAI_1 = require("../../Wolfie2D/AI/StateMachineAI");
var Vec2_1 = require("../../Wolfie2D/DataTypes/Vec2");
var Input_1 = require("../../Wolfie2D/Input/Input");
var Player_enums_1 = require("./Player_enums");
var CTCEvent_1 = require("../Scenes/CTCEvent");
var Earth_1 = require("../Scenes/Earth");
var PlayerController = /** @class */ (function (_super) {
    __extends(PlayerController, _super);
    function PlayerController() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    PlayerController.prototype.initializeAI = function (owner, options) {
        this.owner = owner;
        this.tilemap = this.owner.getScene().getTilemap(options.tilemap);
        this.selectedElement = 1;
        this.facing_direction = Player_enums_1.Player_enums.FACING_DOWN;
        this.hasPower = new Array(5).fill(true);
        this.receiver.subscribe([CTCEvent_1.CTCevent.PLAYER_MOVE]);
    };
    PlayerController.prototype.update = function (deltaT) {
        var next_position = this.nextposition();
        if (Input_1["default"].isJustPressed("up")) {
            if (this.facing_direction == Player_enums_1.Player_enums.FACING_UP) {
                this.emitter.fireEvent(CTCEvent_1.CTCevent.PLAYER_MOVE_REQUEST, { "next": next_position });
            }
            this.facing_direction = Player_enums_1.Player_enums.FACING_UP;
            this.owner.animation.play("walking_up");
        }
        else if (Input_1["default"].isJustPressed("left")) {
            if (this.facing_direction == Player_enums_1.Player_enums.FACING_LEFT) {
                this.emitter.fireEvent(CTCEvent_1.CTCevent.PLAYER_MOVE_REQUEST, { "next": next_position });
            }
            this.facing_direction = Player_enums_1.Player_enums.FACING_LEFT;
            this.owner.animation.play("walking_left");
        }
        else if (Input_1["default"].isJustPressed("down")) {
            if (this.facing_direction == Player_enums_1.Player_enums.FACING_DOWN) {
                this.emitter.fireEvent(CTCEvent_1.CTCevent.PLAYER_MOVE_REQUEST, { "next": next_position });
            }
            this.facing_direction = Player_enums_1.Player_enums.FACING_DOWN;
            this.owner.animation.play("walking_down");
        }
        else if (Input_1["default"].isJustPressed("right")) {
            if (this.facing_direction == Player_enums_1.Player_enums.FACING_RIGHT) {
                this.emitter.fireEvent(CTCEvent_1.CTCevent.PLAYER_MOVE_REQUEST, { "next": next_position });
            }
            this.facing_direction = Player_enums_1.Player_enums.FACING_RIGHT;
            this.owner.animation.play("walking_right");
        }
        else if (Input_1["default"].isJustPressed("interact")) {
            this.owner.animation.play("casting_" + this.facing_direction);
            this.interact();
        }
        else if (Input_1["default"].isJustPressed("place")) {
            this.owner.animation.play("casting_" + this.facing_direction);
            this.placing_element();
        }
        else if (Input_1["default"].isJustPressed("el1") && this.hasPower[0]) {
            this.selectedElement = 1;
            this.emitter.fireEvent(CTCEvent_1.CTCevent.CHANGE_ELEMENT, { "el": this.selectedElement });
        }
        else if (Input_1["default"].isJustPressed("el2") && this.hasPower[1]) {
            this.selectedElement = 2;
            this.emitter.fireEvent(CTCEvent_1.CTCevent.CHANGE_ELEMENT, { "el": this.selectedElement });
        }
        else if (Input_1["default"].isJustPressed("el3") && this.hasPower[2]) {
            this.selectedElement = 3;
            this.emitter.fireEvent(CTCEvent_1.CTCevent.CHANGE_ELEMENT, { "el": this.selectedElement });
        }
        else if (Input_1["default"].isJustPressed("el4") && this.hasPower[3]) {
            this.selectedElement = 4;
            this.emitter.fireEvent(CTCEvent_1.CTCevent.CHANGE_ELEMENT, { "el": this.selectedElement });
        }
        else if (Input_1["default"].isJustPressed("el5") && this.hasPower[4]) {
            this.selectedElement = 5;
            this.emitter.fireEvent(CTCEvent_1.CTCevent.CHANGE_ELEMENT, { "el": this.selectedElement });
        }
        else if (Input_1["default"].isJustPressed("esc")) {
            console.log("paused");
            Earth_1["default"].paused = !Earth_1["default"].paused;
            //CTC todo: pause the game
        }
        // CTC TODO: if the level-end portal is a tile, use this.tilemap field here to fire the LEVEL_END event (should be similar to HW5 testing if switch is below player)
        while (this.receiver.hasNextEvent()) {
            var event_1 = this.receiver.getNextEvent();
            switch (event_1.type) {
                case CTCEvent_1.CTCevent.PLAYER_MOVE:
                    switch (this.facing_direction) {
                        case Player_enums_1.Player_enums.FACING_UP:
                            this.owner.move(new Vec2_1["default"](0, -16));
                            break;
                        case Player_enums_1.Player_enums.FACING_DOWN:
                            this.owner.move(new Vec2_1["default"](0, 16));
                            break;
                        case Player_enums_1.Player_enums.FACING_RIGHT:
                            this.owner.move(new Vec2_1["default"](16, 0));
                            break;
                        case Player_enums_1.Player_enums.FACING_LEFT:
                            this.owner.move(new Vec2_1["default"](-16, 0));
                            break;
                    }
            }
        }
    };
    PlayerController.prototype.nextposition = function () {
        var posX = this.owner.position.x;
        var posY = this.owner.position.y;
        switch (this.facing_direction) {
            case Player_enums_1.Player_enums.FACING_DOWN:
                posY += 16;
                break;
            case Player_enums_1.Player_enums.FACING_UP:
                posY -= 16;
                break;
            case Player_enums_1.Player_enums.FACING_LEFT:
                posX -= 16;
                break;
            case Player_enums_1.Player_enums.FACING_RIGHT:
                posX += 16;
                break;
        }
        posX = (posX - 8) / 16;
        posY = (posY - 8) / 16;
        // not absolute coordinant => Index of gameboard
        var next_position = new Vec2_1["default"](posX, posY);
        return next_position;
    };
    PlayerController.prototype.interact = function () {
        var next = this.nextposition();
        this.emitter.fireEvent(CTCEvent_1.CTCevent.INTERACT_ELEMENT, { "positionX": next.x, "positionY": next.y, "direction": this.facing_direction });
    };
    PlayerController.prototype.placing_element = function () {
        var next = this.nextposition();
        this.emitter.fireEvent(CTCEvent_1.CTCevent.PLACE_ELEMENT, { "positionX": next.x, "positionY": next.y, "type": this.selectedElement });
    };
    return PlayerController;
}(StateMachineAI_1["default"]));
exports["default"] = PlayerController;
},{"../../Wolfie2D/AI/StateMachineAI":2,"../../Wolfie2D/DataTypes/Vec2":20,"../../Wolfie2D/Input/Input":28,"../Scenes/CTCEvent":103,"../Scenes/Earth":104,"./Player_enums":102}],102:[function(require,module,exports){
"use strict";
exports.__esModule = true;
exports.Player_enums = void 0;
var Player_enums;
(function (Player_enums) {
    Player_enums["FACING_DOWN"] = "down";
    Player_enums["FACING_LEFT"] = "left";
    Player_enums["FACING_UP"] = "up";
    Player_enums["FACING_RIGHT"] = "right";
})(Player_enums = exports.Player_enums || (exports.Player_enums = {}));
},{}],103:[function(require,module,exports){
"use strict";
exports.__esModule = true;
exports.CTCevent = void 0;
var CTCevent;
(function (CTCevent) {
    CTCevent["PLACE_ELEMENT"] = "place_element";
    CTCevent["INTERACT_ELEMENT"] = "interact_element";
    CTCevent["PLAYER_MOVE_REQUEST"] = "player_move_request";
    CTCevent["PLAYER_MOVE"] = "player_move";
    CTCevent["ELEMENT_BREAK"] = "element_destroy";
    CTCevent["END_LEVEL"] = "end_level";
    CTCevent["CHANGE_ELEMENT"] = "change_element";
})(CTCevent = exports.CTCevent || (exports.CTCevent = {}));
},{}],104:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
exports.__esModule = true;
var Vec2_1 = require("../../Wolfie2D/DataTypes/Vec2");
var UIElementTypes_1 = require("../../Wolfie2D/Nodes/UIElements/UIElementTypes");
var Scene_1 = require("../../Wolfie2D/Scene/Scene");
var Color_1 = require("../../Wolfie2D/Utils/Color");
var AABB_1 = require("../../Wolfie2D/DataTypes/Shapes/AABB");
var PlayerController_1 = require("../Player/PlayerController");
var CTCEvent_1 = require("./CTCEvent");
var ElementController_1 = require("../Element/ElementController");
var Player_enums_1 = require("../Player/Player_enums");
var Earth = /** @class */ (function (_super) {
    __extends(Earth, _super);
    function Earth() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Earth.prototype.loadScene = function () {
        this.load.image("rock_S", "game_assets/sprites/rock_S.png");
        this.load.image("rock_M", "game_assets/sprites/rock_M.png");
        this.load.image("rock_L", "game_assets/sprites/rock_L.png");
        this.load.image("rock_P", "game_assets/sprites/rock_P.png");
        this.load.spritesheet("god", "game_assets/spritesheets/god.json");
        this.load.spritesheet("element_equipped", "game_assets/spritesheets/element_equipped.json");
        this.load.tilemap("level", "game_assets/tilemaps/earth.json");
        this.load.object("board", "game_assets/data/earth_board.json");
        //unlock all powers for testing
        this.load.spritesheet("whirlwind", "game_assets/spritesheets/whirlwind.json");
        this.load.image("gust", "game_assets/sprites/gust.png");
        this.load.spritesheet("airstream", "game_assets/spritesheets/airstream.json");
        this.load.image("bubble", "game_assets/sprites/bubble.png");
        this.load.image("shallow_water", "game_assets/sprites/shallow_water.png");
        this.load.spritesheet("ember", "game_assets/spritesheets/ember.json");
        this.load.image("flames", "game_assets/sprites/flames.png");
        this.load.image("ignite", "game_assets/sprites/ignite.png");
        this.load.image("ice_cube", "game_assets/sprites/ice_cube.png");
        this.load.spritesheet("torch", "game_assets/spritesheets/torch.json");
        this.load.spritesheet("cursor", "game_assets/spritesheets/cursor.json");
    };
    Earth.prototype.startScene = function () {
        // Add in the tilemap
        var tilemapLayers = this.add.tilemap("level");
        // Get the wall layer 
        this.walls = tilemapLayers[1].getItems()[0];
        // Set the viewport bounds to the tilemap
        var tilemapSize = this.walls.size;
        this.gameboard = new Array(this.walls.getDimensions().y);
        for (var i = 0; i < this.walls.getDimensions().y; i++) {
            this.gameboard[i] = new Array(this.walls.getDimensions().x).fill(null);
        }
        this.viewport.setBounds(0, 0, tilemapSize.x, tilemapSize.y);
        this.addLayer("primary", 10);
        this.elementGUI = this.add.animatedSprite("element_equipped", "primary");
        this.elementGUI.animation.play("none_equipped");
        this.elementGUI.position.set(3 * 16 + 4, 19 * 16);
        this.pauseGUI = this.addUILayer("pauseMenu");
        this.pauseGUI.setHidden(true);
        var pauseText = this.add.uiElement(UIElementTypes_1.UIElementType.LABEL, "pauseMenu", { position: new Vec2_1["default"](5 * 16, 16), text: "PAUSED (Work In Progress)" });
        pauseText.textColor = Color_1["default"].WHITE;
        this.initializeGameboard();
        this.initializePlayer();
        this.skillUsed = [false, false, false, false, false];
        // Zoom in to a reasonable level
        this.viewport.enableZoom();
        this.viewport.setZoomLevel(2.5);
        //this.viewport.follow(this.player);
        this.receiver.subscribe([
            CTCEvent_1.CTCevent.INTERACT_ELEMENT,
            CTCEvent_1.CTCevent.PLACE_ELEMENT,
            CTCEvent_1.CTCevent.PLAYER_MOVE_REQUEST,
            CTCEvent_1.CTCevent.CHANGE_ELEMENT
            // CTC TODO: subscribe to CTCevent.LEVEL_END event
        ]);
    };
    Earth.prototype.updateScene = function () {
        if (!Earth.paused) {
            this.pauseGUI.setHidden(true);
            while (this.receiver.hasNextEvent()) {
                var event_1 = this.receiver.getNextEvent();
                switch (event_1.type) {
                    // CTC TODO: interacting and placing (if placing then have to account for the walls so you cant place there)
                    case CTCEvent_1.CTCevent.INTERACT_ELEMENT:
                        console.log("interact happened");
                        console.log(event_1.data.get("positionX"));
                        console.log(event_1.data.get("positionY"));
                        var targetposX = event_1.data.get("positionX");
                        var targetposY = event_1.data.get("positionY");
                        var direction = event_1.data.get("direction");
                        var target = this.gameboard[targetposX][targetposY];
                        if (target != null) {
                            this.activateElement(target, targetposX, targetposY, direction);
                        }
                        break;
                    case CTCEvent_1.CTCevent.PLACE_ELEMENT:
                        var placeX = event_1.data.get("positionX");
                        var placeY = event_1.data.get("positionY");
                        if (!(placeX < 2 || placeX >= this.walls.getDimensions().y - 2 || placeY < 2 || placeY >= this.walls.getDimensions().x - 2)) {
                            if (this.gameboard[placeX][placeY] == null) {
                                switch (event_1.data.get("type")) {
                                    case 1:
                                        if (this.skillUsed[0])
                                            break;
                                        this.skillUsed[0] = true;
                                        var place_rock = this.add.sprite("rock_P", "primary");
                                        place_rock.position.set(placeX * 16 + 8, placeY * 16 + 8);
                                        place_rock.addPhysics(new AABB_1["default"](Vec2_1["default"].ZERO, new Vec2_1["default"](8, 8)));
                                        place_rock.addAI(ElementController_1["default"], {});
                                        this.gameboard[placeX][placeY] = place_rock;
                                        break;
                                    case 2:
                                        if (this.skillUsed[1])
                                            break;
                                        this.skillUsed[1] = true;
                                        var place_wind = this.add.animatedSprite("whirlwind", "primary");
                                        place_wind.position.set(placeX * 16 + 8, placeY * 16 + 8);
                                        place_wind.animation.play("idle");
                                        place_wind.addPhysics(new AABB_1["default"](Vec2_1["default"].ZERO, new Vec2_1["default"](8, 8)));
                                        place_wind.addAI(ElementController_1["default"], {});
                                        this.gameboard[placeX][placeY] = place_wind;
                                        break;
                                    case 3:
                                        if (this.skillUsed[2])
                                            break;
                                        this.skillUsed[2] = true;
                                        var place_water = this.add.sprite("bubble", "primary");
                                        place_water.position.set(placeX * 16 + 8, placeY * 16 + 8);
                                        place_water.addPhysics(new AABB_1["default"](Vec2_1["default"].ZERO, new Vec2_1["default"](8, 8)));
                                        place_water.addAI(ElementController_1["default"], {});
                                        this.gameboard[placeX][placeY] = place_water;
                                        break;
                                    case 4:
                                        if (this.skillUsed[3])
                                            break;
                                        this.skillUsed[3] = true;
                                        var place_fire = this.add.animatedSprite("ember", "primary");
                                        place_fire.position.set(placeX * 16 + 8, placeY * 16 + 8);
                                        place_fire.animation.play("idle");
                                        place_fire.addPhysics(new AABB_1["default"](Vec2_1["default"].ZERO, new Vec2_1["default"](8, 8)));
                                        place_fire.addAI(ElementController_1["default"], {});
                                        this.gameboard[placeX][placeY] = place_fire;
                                        break;
                                    case 5:
                                        if (this.skillUsed[4])
                                            break;
                                        this.skillUsed[4] = true;
                                        var place_ice = this.add.sprite("ice_cube", "primary");
                                        place_ice.position.set(placeX * 16 + 8, placeY * 16 + 8);
                                        place_ice.addPhysics(new AABB_1["default"](Vec2_1["default"].ZERO, new Vec2_1["default"](8, 8)));
                                        place_ice.addAI(ElementController_1["default"], {});
                                        this.gameboard[placeX][placeY] = place_ice;
                                        break;
                                }
                            }
                            else {
                                switch (event_1.data.get("type")) {
                                    case 1:
                                        if (this.gameboard[placeX][placeY].imageId == "rock_P") {
                                            var sprite = this.gameboard[placeX][placeY];
                                            sprite.destroy();
                                            this.gameboard[placeX][placeY] = null;
                                            this.skillUsed[0] = false;
                                        }
                                        break;
                                    case 2:
                                        if (this.gameboard[placeX][placeY].imageId == "whirlwind") {
                                            var sprite = this.gameboard[placeX][placeY];
                                            sprite.destroy();
                                            this.gameboard[placeX][placeY] = null;
                                            this.skillUsed[1] = false;
                                        }
                                        break;
                                    case 3:
                                        if (this.gameboard[placeX][placeY].imageId == "bubble") {
                                            var sprite = this.gameboard[placeX][placeY];
                                            sprite.destroy();
                                            this.gameboard[placeX][placeY] = null;
                                            this.skillUsed[2] = false;
                                        }
                                        break;
                                    case 4:
                                        if (this.gameboard[placeX][placeY].imageId == "ember") {
                                            var sprite = this.gameboard[placeX][placeY];
                                            sprite.destroy();
                                            this.gameboard[placeX][placeY] = null;
                                            this.skillUsed[3] = false;
                                        }
                                        break;
                                    case 5:
                                        if (this.gameboard[placeX][placeY].imageId == "ice_cube") {
                                            var sprite = this.gameboard[placeX][placeY];
                                            sprite.destroy();
                                            this.gameboard[placeX][placeY] = null;
                                            this.skillUsed[4] = false;
                                        }
                                        break;
                                }
                            }
                        }
                        break;
                    case CTCEvent_1.CTCevent.PLAYER_MOVE_REQUEST:
                        var next = event_1.data.get("next");
                        if (this.gameboard[next.x][next.y] == null || this.endposition == next) {
                            this.emitter.fireEvent(CTCEvent_1.CTCevent.PLAYER_MOVE);
                            if (this.endposition == next) {
                                this.emitter.fireEvent(CTCEvent_1.CTCevent.END_LEVEL, { "nextlevel": "earth_boss" });
                            }
                        }
                        break;
                    case CTCEvent_1.CTCevent.CHANGE_ELEMENT:
                        switch (event_1.data.get("el")) {
                            case 1:
                                this.elementGUI.animation.play("earth_equipped");
                                break;
                            case 2:
                                this.elementGUI.animation.play("wind_equipped");
                                break;
                            case 3:
                                this.elementGUI.animation.play("water_equipped");
                                break;
                            case 4:
                                this.elementGUI.animation.play("fire_equipped");
                                break;
                            case 5:
                                this.elementGUI.animation.play("ice_equipped");
                                break;
                        }
                }
            }
        }
        else {
            this.pauseGUI.setHidden(false);
        }
    };
    ;
    Earth.prototype.activateElement = function (target, targetposX, targetposY, direction) {
        var Vel = new Vec2_1["default"](0, 0); // velocity of sprite (if we make moving rock soothly.)
        var dest = new Vec2_1["default"](targetposX, targetposY); //destination that rock will go. (Index)
        var dir;
        switch (direction) {
            case Player_enums_1.Player_enums.FACING_UP:
                dir = new Vec2_1["default"](0, -1);
                break;
            case Player_enums_1.Player_enums.FACING_DOWN:
                dir = new Vec2_1["default"](0, 1);
                break;
            case Player_enums_1.Player_enums.FACING_LEFT:
                dir = new Vec2_1["default"](-1, 0);
                break;
            case Player_enums_1.Player_enums.FACING_RIGHT:
                dir = new Vec2_1["default"](1, 0);
                break;
        }
        switch (target.imageId) {
            case "rock_P":
            case "rock_S":
                if (dest.x + dir.x < 2 || dest.y + dir.y < 2 || dest.x + dir.x > 17 || dest.y + dir.y > 17 || this.gameboard[dest.x + dir.x][dest.y + dir.y] != null)
                    break;
                dest.add(dir);
            case "rock_M":
                if (dest.x + dir.x < 2 || dest.y + dir.y < 2 || dest.x + dir.x > 17 || dest.y + dir.y > 17 || this.gameboard[dest.x + dir.x][dest.y + dir.y] != null)
                    break;
                dest.add(dir);
            case "rock_L":
                if (dest.x + dir.x < 2 || dest.y + dir.y < 2 || dest.x + dir.x > 17 || dest.y + dir.y > 17 || this.gameboard[dest.x + dir.x][dest.y + dir.y] != null)
                    break;
                dest.add(dir);
                target.position.set(dest.x * 16 + 8, dest.y * 16 + 8);
                this.gameboard[targetposX][targetposY] = null;
                this.gameboard[dest.x][dest.y] = target;
                break;
            case "whirlwind":
                /*
                this.player.tweens.add("fly", {
                    startDelay: 0,
                    duration: 500,
                    effects: [
                        {
                            property: this.player.position,
                            start: this.player.position,
                            end: dest,
                            ease: EaseFunctionType.IN_OUT_QUAD
                        }
                    ]
                });*/
                this.gameboard[targetposX][targetposY] = null;
                target.destroy();
                this.skillUsed[1] = false;
                if (dest.x + dir.scaled(3).x >= 2 && dest.y + dir.scaled(3).y >= 2 && dest.x + dir.scaled(3).x <= 17 && dest.y + dir.scaled(3).y <= 17) {
                    if (this.gameboard[dest.x + dir.scaled(3).x][dest.y + dir.scaled(3).y] == null) {
                        //dest.add(dir.scaled(3));
                        //this.player.tweens.play("fly");
                        for (var i = 0; i < 3; i++) {
                            dest.add(dir);
                            this.emitter.fireEvent(CTCEvent_1.CTCevent.PLAYER_MOVE_REQUEST, { "next": dest });
                        }
                    }
                }
                else if (dest.x + dir.scaled(2).x >= 2 && dest.y + dir.scaled(2).y >= 2 && dest.x + dir.scaled(2).x <= 17 && dest.y + dir.scaled(2).y <= 17) {
                    if (this.gameboard[dest.x + dir.scaled(2).x][dest.y + dir.scaled(2).y] == null) {
                        //dest.add(dir.scaled(2));
                        //this.player.tweens.play("fly");
                        for (var i = 0; i < 2; i++) {
                            dest.add(dir);
                            this.emitter.fireEvent(CTCEvent_1.CTCevent.PLAYER_MOVE_REQUEST, { "next": dest });
                        }
                    }
                }
                break;
            case "bubble":
                break;
            case "ember":
                break;
            case "ice_cube":
                break;
        }
    };
    // CTC TODO: if level-end portal is a sprite, then right here you could make this.portal (a Sprite field) and test this.player.position === this.portal.position to fire LEVEL_END event. In this case you could refer to the following to initialize the portal (add this code in its own function or maybe right at the end of initializePlayer function?):
    /*
    this.portal = this.add.sprite("portal", "primary"); **HAVE TO LOAD PORTAL AS IMAGE IN LOADSCENE FUNCTION
    this.player.position.set(3*16 + 8, 3*16 + 8); **CHANGE THE 3s TO BE SOME OTHER TILE POSITION
    this.portal.addPhysics(new AABB(Vec2.ZERO, new Vec2(8, 8)));
    this.portal.addAI(ElementController, {});

    if the sprite is animated then you're on your own tbh lol, this should work for a non-animated sprite i hope
    */
    Earth.prototype.initializePlayer = function () {
        this.player = this.add.animatedSprite("god", "primary");
        this.player.animation.play("idle");
        this.player.position.set(3 * 16 + 8, 3 * 16 + 8);
        // CTC TODO: remove this todo, just note that i did not include player sprite in the gameboard array because thats too much work to update it lol
        this.player.addPhysics(new AABB_1["default"](Vec2_1["default"].ZERO, new Vec2_1["default"](8, 8)));
        this.player.addAI(PlayerController_1["default"], { tilemap: "Main" });
    };
    Earth.prototype.initializeGameboard = function () {
        var boardData = this.load.getObject("board");
        for (var i = 0; i < boardData.numElements; i++) {
            var element = boardData.elements[i];
            var sprite = this.add.sprite(element.type, "primary");
            sprite.position.set(element.position[0] * 16 + 8, element.position[1] * 16 + 8);
            sprite.addPhysics(new AABB_1["default"](Vec2_1["default"].ZERO, new Vec2_1["default"](8, 8)));
            sprite.addAI(ElementController_1["default"], {});
            this.gameboard[element.position[0]][element.position[1]] = sprite;
        }
        //set portal 
        //this.gameboard[this.endposition.x][this.endposition.y] = 
    };
    return Earth;
}(Scene_1["default"]));
exports["default"] = Earth;
},{"../../Wolfie2D/DataTypes/Shapes/AABB":14,"../../Wolfie2D/DataTypes/Vec2":20,"../../Wolfie2D/Nodes/UIElements/UIElementTypes":52,"../../Wolfie2D/Scene/Scene":89,"../../Wolfie2D/Utils/Color":94,"../Element/ElementController":100,"../Player/PlayerController":101,"../Player/Player_enums":102,"./CTCEvent":103}],105:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
exports.__esModule = true;
var Vec2_1 = require("../../Wolfie2D/DataTypes/Vec2");
var UIElementTypes_1 = require("../../Wolfie2D/Nodes/UIElements/UIElementTypes");
var Scene_1 = require("../../Wolfie2D/Scene/Scene");
var Color_1 = require("../../Wolfie2D/Utils/Color");
var MainMenu_1 = require("./MainMenu");
var Input_1 = require("../../Wolfie2D/Input/Input");
var Earth_1 = require("./Earth");
var LevelSelection = /** @class */ (function (_super) {
    __extends(LevelSelection, _super);
    function LevelSelection() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    LevelSelection.prototype.loadScene = function () { };
    LevelSelection.prototype.startScene = function () {
        var center = this.viewport.getCenter();
        // The main menu
        this.levels = this.addUILayer("levels");
        var levelsHeader = this.add.uiElement(UIElementTypes_1.UIElementType.LABEL, "levels", { position: new Vec2_1["default"](center.x, center.y - 250), text: "Level Select" });
        levelsHeader.fontSize = 50;
        /* EARTH ROW */
        var earthHeader = this.add.uiElement(UIElementTypes_1.UIElementType.LABEL, "levels", { position: new Vec2_1["default"](center.x - 225, center.y - 150), text: "EARTH" });
        ;
        var earth = this.add.uiElement(UIElementTypes_1.UIElementType.BUTTON, "levels", { position: new Vec2_1["default"](center.x, center.y - 150), text: "Puzzle Stage" });
        earth.size.set(200, 50);
        earth.borderWidth = 2;
        earth.borderColor = Color_1["default"].BLACK;
        earth.backgroundColor = new Color_1["default"](0, 255, 213);
        earth.textColor = Color_1["default"].BLACK;
        earth.onClickEventId = "play-earth";
        var earthB = this.add.uiElement(UIElementTypes_1.UIElementType.BUTTON, "levels", { position: new Vec2_1["default"](center.x + 250, center.y - 150), text: "Boss Stage" });
        earthB.clone(earth, "play-earth-boss");
        /* WIND ROW */
        var windHeader = this.add.uiElement(UIElementTypes_1.UIElementType.LABEL, "levels", { position: new Vec2_1["default"](center.x - 225, center.y - 75), text: "WIND" });
        ;
        var wind = this.add.uiElement(UIElementTypes_1.UIElementType.BUTTON, "levels", { position: new Vec2_1["default"](center.x, center.y - 75), text: "Puzzle Stage" });
        wind.clone(earth, "play-wind");
        var windB = this.add.uiElement(UIElementTypes_1.UIElementType.BUTTON, "levels", { position: new Vec2_1["default"](center.x + 250, center.y - 75), text: "Boss Stage" });
        windB.clone(earth, "play-wind-boss");
        /* WATER ROW */
        var waterHeader = this.add.uiElement(UIElementTypes_1.UIElementType.LABEL, "levels", { position: new Vec2_1["default"](center.x - 225, center.y), text: "WATER" });
        ;
        var water = this.add.uiElement(UIElementTypes_1.UIElementType.BUTTON, "levels", { position: new Vec2_1["default"](center.x, center.y), text: "Puzzle Stage" });
        water.clone(earth, "play-water");
        var waterB = this.add.uiElement(UIElementTypes_1.UIElementType.BUTTON, "levels", { position: new Vec2_1["default"](center.x + 250, center.y), text: "Boss Stage" });
        waterB.clone(earth, "play-water-boss");
        /* FIRE ROW */
        var fireHeader = this.add.uiElement(UIElementTypes_1.UIElementType.LABEL, "levels", { position: new Vec2_1["default"](center.x - 225, center.y + 75), text: "FIRE" });
        ;
        var fire = this.add.uiElement(UIElementTypes_1.UIElementType.BUTTON, "levels", { position: new Vec2_1["default"](center.x, center.y + 75), text: "Puzzle Stage" });
        fire.clone(earth, "play-fire");
        var fireB = this.add.uiElement(UIElementTypes_1.UIElementType.BUTTON, "levels", { position: new Vec2_1["default"](center.x + 250, center.y + 75), text: "Boss Stage" });
        fireB.clone(earth, "play-fire-boss");
        /* ICE ROW */
        var iceHeader = this.add.uiElement(UIElementTypes_1.UIElementType.LABEL, "levels", { position: new Vec2_1["default"](center.x - 225, center.y + 150), text: "ICE" });
        ;
        var ice = this.add.uiElement(UIElementTypes_1.UIElementType.BUTTON, "levels", { position: new Vec2_1["default"](center.x, center.y + 150), text: "Puzzle Stage" });
        ice.clone(earth, "play-ice");
        var iceB = this.add.uiElement(UIElementTypes_1.UIElementType.BUTTON, "levels", { position: new Vec2_1["default"](center.x + 250, center.y + 150), text: "Boss Stage" });
        iceB.clone(earth, "play-ice-boss");
        /* BACK BUTTON */
        var back = this.add.uiElement(UIElementTypes_1.UIElementType.BUTTON, "levels", { position: new Vec2_1["default"](center.x, center.y + 300), text: "Back" });
        back.clone(earth, "back");
        this.receiver.subscribe("play-earth");
        this.receiver.subscribe("back");
    };
    LevelSelection.prototype.updateScene = function () {
        // CTC TODO: ADD THE CHEATS
        if (Input_1["default"].isKeyJustPressed("y")) {
            console.log("CHEAT: UNLOCK ALL LEVELS");
        }
        if (Input_1["default"].isKeyJustPressed("u")) {
            console.log("CHEAT: UNLOCK ALL ELEMENTAL SKILS");
        }
        while (this.receiver.hasNextEvent()) {
            var event_1 = this.receiver.getNextEvent();
            console.log(event_1);
            if (event_1.type === "play-earth") {
                this.sceneManager.changeToScene(Earth_1["default"], {});
            }
            // CTC TODO: ADD THE OTHER LEVELS AND SUBSCRIBE TO THE EVENTS
            if (event_1.type === "back") {
                this.sceneManager.changeToScene(MainMenu_1["default"], {});
            }
        }
    };
    return LevelSelection;
}(Scene_1["default"]));
exports["default"] = LevelSelection;
},{"../../Wolfie2D/DataTypes/Vec2":20,"../../Wolfie2D/Input/Input":28,"../../Wolfie2D/Nodes/UIElements/UIElementTypes":52,"../../Wolfie2D/Scene/Scene":89,"../../Wolfie2D/Utils/Color":94,"./Earth":104,"./MainMenu":106}],106:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
exports.__esModule = true;
var Vec2_1 = require("../../Wolfie2D/DataTypes/Vec2");
var UIElementTypes_1 = require("../../Wolfie2D/Nodes/UIElements/UIElementTypes");
var Scene_1 = require("../../Wolfie2D/Scene/Scene");
var Color_1 = require("../../Wolfie2D/Utils/Color");
var LevelSelection_1 = require("./LevelSelection");
var Input_1 = require("../../Wolfie2D/Input/Input");
var MainMenu = /** @class */ (function (_super) {
    __extends(MainMenu, _super);
    function MainMenu() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    MainMenu.prototype.loadScene = function () { };
    MainMenu.prototype.startScene = function () {
        var center = this.viewport.getCenter();
        // The main menu
        this.mainMenu = this.addUILayer("mainMenu");
        var mainMenuHeader = this.add.uiElement(UIElementTypes_1.UIElementType.LABEL, "mainMenu", { position: new Vec2_1["default"](center.x, center.y - 250), text: "Calm The Calamities" });
        mainMenuHeader.textColor = Color_1["default"].BLACK;
        mainMenuHeader.fontSize = 50;
        // Add play button, and give it an event to emit on press
        var play = this.add.uiElement(UIElementTypes_1.UIElementType.BUTTON, "mainMenu", { position: new Vec2_1["default"](center.x, center.y - 100), text: "Start" });
        play.size.set(200, 50);
        play.borderWidth = 2;
        play.borderColor = Color_1["default"].BLACK;
        play.backgroundColor = new Color_1["default"](0, 255, 213);
        play.textColor = Color_1["default"].BLACK;
        play.onClickEventId = "play";
        // Add about button
        var about = this.add.uiElement(UIElementTypes_1.UIElementType.BUTTON, "mainMenu", { position: new Vec2_1["default"](center.x, center.y + 100), text: "Help" });
        about.size.set(200, 50);
        about.borderWidth = 2;
        about.borderColor = Color_1["default"].BLACK;
        about.backgroundColor = new Color_1["default"](0, 255, 213);
        about.textColor = Color_1["default"].BLACK;
        about.onClickEventId = "about";
        // Add controls button
        var control = this.add.uiElement(UIElementTypes_1.UIElementType.BUTTON, "mainMenu", { position: new Vec2_1["default"](center.x, center.y), text: "Controls" });
        control.size.set(200, 50);
        control.borderWidth = 2;
        control.borderColor = Color_1["default"].BLACK;
        control.backgroundColor = new Color_1["default"](0, 255, 213);
        control.textColor = Color_1["default"].BLACK;
        control.onClickEventId = "control";
        var credits = this.add.uiElement(UIElementTypes_1.UIElementType.BUTTON, "mainMenu", { position: new Vec2_1["default"](center.x, center.y + 200), text: "Credits" });
        credits.size.set(200, 50);
        credits.borderWidth = 2;
        credits.borderColor = Color_1["default"].BLACK;
        credits.backgroundColor = new Color_1["default"](0, 255, 213);
        credits.textColor = Color_1["default"].BLACK;
        credits.onClickEventId = "credits";
        /* ########## ABOUT SCREEN ########## */
        this.about = this.addUILayer("about");
        this.about.setHidden(true);
        var aboutHeader = this.add.uiElement(UIElementTypes_1.UIElementType.LABEL, "about", { position: new Vec2_1["default"](center.x, center.y - 250), text: "Help" });
        aboutHeader.textColor = Color_1["default"].BLACK;
        aboutHeader.fontSize = 50;
        var text1 = "You are a young god who just finished creating your first";
        var text2 = "world. You feel tired after making the world so you decided";
        var text3 = "to take a nap. The nap turns into a millennium long slumber.";
        var text4 = "While you were asleep, your powers leaked out from your";
        var text5 = "body into your world. They took the shape of violent spirits,";
        var text6 = "creating all kinds of natural disasters throughout your world.";
        var text7 = "CHEATS (Use on Main Menu/Level Select):";
        var text8 = "Y - Unlock All Levels";
        var text9 = "U - Unlock All Elemental Skills";
        var line1 = this.add.uiElement(UIElementTypes_1.UIElementType.LABEL, "about", { position: new Vec2_1["default"](center.x, center.y - 150), text: text1 });
        var line2 = this.add.uiElement(UIElementTypes_1.UIElementType.LABEL, "about", { position: new Vec2_1["default"](center.x, center.y - 100), text: text2 });
        var line3 = this.add.uiElement(UIElementTypes_1.UIElementType.LABEL, "about", { position: new Vec2_1["default"](center.x, center.y - 50), text: text3 });
        var line4 = this.add.uiElement(UIElementTypes_1.UIElementType.LABEL, "about", { position: new Vec2_1["default"](center.x, center.y), text: text4 });
        var line5 = this.add.uiElement(UIElementTypes_1.UIElementType.LABEL, "about", { position: new Vec2_1["default"](center.x, center.y + 50), text: text5 });
        var line6 = this.add.uiElement(UIElementTypes_1.UIElementType.LABEL, "about", { position: new Vec2_1["default"](center.x, center.y + 100), text: text6 });
        var line7 = this.add.uiElement(UIElementTypes_1.UIElementType.LABEL, "about", { position: new Vec2_1["default"](center.x - 100, center.y + 150), text: text7 });
        var line8 = this.add.uiElement(UIElementTypes_1.UIElementType.LABEL, "about", { position: new Vec2_1["default"](center.x + 150, center.y + 200), text: text8 });
        var line9 = this.add.uiElement(UIElementTypes_1.UIElementType.LABEL, "about", { position: new Vec2_1["default"](center.x + 200, center.y + 250), text: text9 });
        line1.textColor = Color_1["default"].BLACK;
        line2.textColor = Color_1["default"].BLACK;
        line3.textColor = Color_1["default"].BLACK;
        var aboutBack = this.add.uiElement(UIElementTypes_1.UIElementType.BUTTON, "about", { position: new Vec2_1["default"](center.x, center.y + 300), text: "Back" });
        aboutBack.size.set(200, 50);
        aboutBack.borderWidth = 2;
        aboutBack.borderColor = Color_1["default"].BLACK;
        aboutBack.backgroundColor = new Color_1["default"](0, 255, 213);
        aboutBack.textColor = Color_1["default"].BLACK;
        aboutBack.onClickEventId = "menu";
        /* ########## CONTROLS SCREEN ########## */
        this.control = this.addUILayer("control");
        this.control.setHidden(true);
        var controlHeader = this.add.uiElement(UIElementTypes_1.UIElementType.LABEL, "control", { position: new Vec2_1["default"](center.x, center.y - 250), text: "Controls" });
        controlHeader.textColor = Color_1["default"].BLACK;
        controlHeader.fontSize = 50;
        var ctext1 = "W - Move Up";
        var ctext2 = "A - Move Left";
        var ctext3 = "S - Move Down";
        var ctext4 = "D - Move Right";
        var ctext5 = "1,2,3,4,5 - Switch to Element 1-5";
        var ctext6 = "J - Interact With Element";
        var ctext7 = "K - Place/Remove Element";
        var ctext8 = "ESCAPE - Pause";
        var cline1 = this.add.uiElement(UIElementTypes_1.UIElementType.LABEL, "control", { position: new Vec2_1["default"](center.x, center.y - 150), text: ctext1 });
        var cline2 = this.add.uiElement(UIElementTypes_1.UIElementType.LABEL, "control", { position: new Vec2_1["default"](center.x, center.y - 100), text: ctext2 });
        var cline3 = this.add.uiElement(UIElementTypes_1.UIElementType.LABEL, "control", { position: new Vec2_1["default"](center.x, center.y - 50), text: ctext3 });
        var cline4 = this.add.uiElement(UIElementTypes_1.UIElementType.LABEL, "control", { position: new Vec2_1["default"](center.x, center.y), text: ctext4 });
        var cline5 = this.add.uiElement(UIElementTypes_1.UIElementType.LABEL, "control", { position: new Vec2_1["default"](center.x, center.y + 50), text: ctext5 });
        var cline6 = this.add.uiElement(UIElementTypes_1.UIElementType.LABEL, "control", { position: new Vec2_1["default"](center.x, center.y + 100), text: ctext6 });
        var cline7 = this.add.uiElement(UIElementTypes_1.UIElementType.LABEL, "control", { position: new Vec2_1["default"](center.x, center.y + 150), text: ctext7 });
        var cline8 = this.add.uiElement(UIElementTypes_1.UIElementType.LABEL, "control", { position: new Vec2_1["default"](center.x, center.y + 200), text: ctext8 });
        var controlBack = this.add.uiElement(UIElementTypes_1.UIElementType.BUTTON, "control", { position: new Vec2_1["default"](center.x, center.y + 300), text: "Back" });
        controlBack.size.set(200, 50);
        controlBack.borderWidth = 2;
        controlBack.borderColor = Color_1["default"].BLACK;
        controlBack.backgroundColor = new Color_1["default"](0, 255, 213);
        controlBack.textColor = Color_1["default"].BLACK;
        controlBack.onClickEventId = "menu";
        /* ########## CREDITS SCREEN ########## */
        this.credits = this.addUILayer("credits");
        this.credits.setHidden(true);
        var creditsHeader = this.add.uiElement(UIElementTypes_1.UIElementType.LABEL, "credits", { position: new Vec2_1["default"](center.x, center.y - 250), text: "Credits" });
        creditsHeader.textColor = Color_1["default"].BLACK;
        creditsHeader.fontSize = 50;
        var crtext1 = "This game was made by:";
        var crtext2 = "David Silverman";
        var crtext3 = "Wei Hang Hong";
        var crtext4 = "Jiwon Jang";
        var crline1 = this.add.uiElement(UIElementTypes_1.UIElementType.LABEL, "credits", { position: new Vec2_1["default"](center.x, center.y - 100), text: crtext1 });
        var crline2 = this.add.uiElement(UIElementTypes_1.UIElementType.LABEL, "credits", { position: new Vec2_1["default"](center.x, center.y), text: crtext2 });
        var crline3 = this.add.uiElement(UIElementTypes_1.UIElementType.LABEL, "credits", { position: new Vec2_1["default"](center.x, center.y + 50), text: crtext3 });
        var crline4 = this.add.uiElement(UIElementTypes_1.UIElementType.LABEL, "credits", { position: new Vec2_1["default"](center.x, center.y + 100), text: crtext4 });
        crline1.textColor = Color_1["default"].BLACK;
        crline2.textColor = Color_1["default"].BLACK;
        crline3.textColor = Color_1["default"].BLACK;
        crline4.textColor = Color_1["default"].BLACK;
        var creditsBack = this.add.uiElement(UIElementTypes_1.UIElementType.BUTTON, "credits", { position: new Vec2_1["default"](center.x, center.y + 300), text: "Back" });
        creditsBack.size.set(200, 50);
        creditsBack.borderWidth = 2;
        creditsBack.borderColor = Color_1["default"].BLACK;
        creditsBack.backgroundColor = new Color_1["default"](0, 255, 213);
        creditsBack.textColor = Color_1["default"].BLACK;
        creditsBack.onClickEventId = "menu";
        // Subscribe to the button events
        this.receiver.subscribe("play");
        this.receiver.subscribe("about");
        this.receiver.subscribe("menu");
        this.receiver.subscribe("control");
        this.receiver.subscribe("credits");
    };
    MainMenu.prototype.updateScene = function () {
        // CTC TODO: ADD THE CHEATS
        if (Input_1["default"].isKeyJustPressed("y")) {
            console.log("CHEAT: UNLOCK ALL LEVELS");
        }
        if (Input_1["default"].isKeyJustPressed("u")) {
            console.log("CHEAT: UNLOCK ALL ELEMENTAL SKILS");
        }
        while (this.receiver.hasNextEvent()) {
            var event_1 = this.receiver.getNextEvent();
            console.log(event_1);
            if (event_1.type === "play") {
                this.sceneManager.changeToScene(LevelSelection_1["default"], {});
            }
            if (event_1.type === "about") {
                this.about.setHidden(false);
                this.mainMenu.setHidden(true);
            }
            if (event_1.type === "menu") {
                this.mainMenu.setHidden(false);
                this.about.setHidden(true);
                this.control.setHidden(true);
                this.credits.setHidden(true);
            }
            if (event_1.type === "control") {
                this.mainMenu.setHidden(true);
                this.control.setHidden(false);
            }
            if (event_1.type === "credits") {
                this.mainMenu.setHidden(true);
                this.credits.setHidden(false);
            }
        }
    };
    return MainMenu;
}(Scene_1["default"]));
exports["default"] = MainMenu;
},{"../../Wolfie2D/DataTypes/Vec2":20,"../../Wolfie2D/Input/Input":28,"../../Wolfie2D/Nodes/UIElements/UIElementTypes":52,"../../Wolfie2D/Scene/Scene":89,"../../Wolfie2D/Utils/Color":94,"./LevelSelection":105}],107:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
exports.__esModule = true;
var Vec2_1 = require("../../Wolfie2D/DataTypes/Vec2");
var UIElementTypes_1 = require("../../Wolfie2D/Nodes/UIElements/UIElementTypes");
var Scene_1 = require("../../Wolfie2D/Scene/Scene");
var Color_1 = require("../../Wolfie2D/Utils/Color");
var MainMenu_1 = require("./MainMenu");
var GameNode_1 = require("../../Wolfie2D/Nodes/GameNode");
var EaseFunctions_1 = require("../../Wolfie2D/Utils/EaseFunctions");
var Input_1 = require("../../Wolfie2D/Input/Input");
var SplashScreen = /** @class */ (function (_super) {
    __extends(SplashScreen, _super);
    function SplashScreen() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    SplashScreen.prototype.loadScene = function () {
        this.load.image("logo", "game_assets/sprites/logo.png");
    };
    SplashScreen.prototype.startScene = function () {
        var center = this.viewport.getCenter();
        this.splash = this.addUILayer("splash");
        /* Game logo */
        this.logo = this.add.sprite("logo", "splash");
        this.logo.scale.set(2, 2);
        this.logo.alpha = 0;
        this.logo.position = new Vec2_1["default"](center.x, center.y - 100);
        this.logo.tweens.add("fadeIn", {
            startDelay: 1000,
            duration: 1000,
            effects: [
                {
                    property: GameNode_1.TweenableProperties.alpha,
                    start: 0,
                    end: 1,
                    ease: EaseFunctions_1.EaseFunctionType.OUT_SINE
                }
            ]
        });
        /* Click anywhere text */
        var clickText = "Click Anywhere To Continue";
        var clickLabel = this.add.uiElement(UIElementTypes_1.UIElementType.LABEL, "splash", { position: new Vec2_1["default"](center.x, center.y + 250), text: clickText });
        clickLabel.textColor = new Color_1["default"](0, 0, 0, 0);
        clickLabel.fontSize = 50;
        clickLabel.tweens.add("fadeIn", {
            startDelay: 2000,
            duration: 1000,
            effects: [
                {
                    property: "textAlpha",
                    start: 0,
                    end: 1,
                    ease: EaseFunctions_1.EaseFunctionType.OUT_SINE
                }
            ]
        });
        this.logo.tweens.play("fadeIn");
        clickLabel.tweens.play("fadeIn");
    };
    SplashScreen.prototype.updateScene = function () {
        if (Input_1["default"].isMouseJustPressed()) {
            this.sceneManager.changeToScene(MainMenu_1["default"], {});
        }
    };
    return SplashScreen;
}(Scene_1["default"]));
exports["default"] = SplashScreen;
},{"../../Wolfie2D/DataTypes/Vec2":20,"../../Wolfie2D/Input/Input":28,"../../Wolfie2D/Nodes/GameNode":36,"../../Wolfie2D/Nodes/UIElements/UIElementTypes":52,"../../Wolfie2D/Scene/Scene":89,"../../Wolfie2D/Utils/Color":94,"../../Wolfie2D/Utils/EaseFunctions":95,"./MainMenu":106}],108:[function(require,module,exports){
"use strict";
exports.__esModule = true;
var Game_1 = require("./Wolfie2D/Loop/Game");
var SplashScreen_1 = require("./game/Scenes/SplashScreen");
// The main function is your entrypoint into Wolfie2D. Specify your first scene and any options here.
(function main() {
    // Run any tests
    runTests();
    // Set up options for our game
    var options = {
        canvasSize: { x: 800, y: 800 },
        clearColor: { r: 214, g: 179, b: 179 },
        inputs: [
            { name: "up", keys: ["w"] },
            { name: "down", keys: ["s"] },
            { name: "left", keys: ["a"] },
            { name: "right", keys: ["d"] },
            { name: "interact", keys: ["j"] },
            { name: "place", keys: ["k"] },
            { name: "el1", keys: ["1"] },
            { name: "el2", keys: ["2"] },
            { name: "el3", keys: ["3"] },
            { name: "el4", keys: ["4"] },
            { name: "el5", keys: ["5"] },
            { name: "esc", keys: ["escape"] }
        ],
        useWebGL: false,
        showDebug: false
    };
    // Create a game with the options specified
    var game = new Game_1["default"](options);
    // Start our game
    game.start(SplashScreen_1["default"], {});
})();
function runTests() { }
;
},{"./Wolfie2D/Loop/Game":32,"./game/Scenes/SplashScreen":107}]},{},[108])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJzcmMvV29sZmllMkQvQUkvQUlNYW5hZ2VyLnRzIiwic3JjL1dvbGZpZTJEL0FJL1N0YXRlTWFjaGluZUFJLnRzIiwic3JjL1dvbGZpZTJEL0RhdGFUeXBlcy9GdW5jdGlvbnMvTnVsbEZ1bmMudHMiLCJzcmMvV29sZmllMkQvRGF0YVR5cGVzL0dyYXBocy9FZGdlTm9kZS50cyIsInNyYy9Xb2xmaWUyRC9EYXRhVHlwZXMvR3JhcGhzL0dyYXBoLnRzIiwic3JjL1dvbGZpZTJEL0RhdGFUeXBlcy9HcmFwaHMvUG9zaXRpb25HcmFwaC50cyIsInNyYy9Xb2xmaWUyRC9EYXRhVHlwZXMvSW50ZXJmYWNlcy9SZWdpb24udHMiLCJzcmMvV29sZmllMkQvRGF0YVR5cGVzL01hcC50cyIsInNyYy9Xb2xmaWUyRC9EYXRhVHlwZXMvTWF0NHg0LnRzIiwic3JjL1dvbGZpZTJEL0RhdGFUeXBlcy9QaHlzaWNzL0FyZWFDb2xsaXNpb24udHMiLCJzcmMvV29sZmllMkQvRGF0YVR5cGVzL1BoeXNpY3MvSGl0LnRzIiwic3JjL1dvbGZpZTJEL0RhdGFUeXBlcy9RdWV1ZS50cyIsInNyYy9Xb2xmaWUyRC9EYXRhVHlwZXMvUmVuZGVyaW5nL1dlYkdMUHJvZ3JhbVR5cGUudHMiLCJzcmMvV29sZmllMkQvRGF0YVR5cGVzL1NoYXBlcy9BQUJCLnRzIiwic3JjL1dvbGZpZTJEL0RhdGFUeXBlcy9TaGFwZXMvQ2lyY2xlLnRzIiwic3JjL1dvbGZpZTJEL0RhdGFUeXBlcy9TaGFwZXMvU2hhcGUudHMiLCJzcmMvV29sZmllMkQvRGF0YVR5cGVzL1N0YWNrLnRzIiwic3JjL1dvbGZpZTJEL0RhdGFUeXBlcy9TdGF0ZS9TdGF0ZU1hY2hpbmUudHMiLCJzcmMvV29sZmllMkQvRGF0YVR5cGVzL1RpbGVzZXRzL1RpbGVzZXQudHMiLCJzcmMvV29sZmllMkQvRGF0YVR5cGVzL1ZlYzIudHMiLCJzcmMvV29sZmllMkQvRGVidWcvRGVidWcudHMiLCJzcmMvV29sZmllMkQvRGVidWcvU3RhdHMudHMiLCJzcmMvV29sZmllMkQvRXZlbnRzL0VtaXR0ZXIudHMiLCJzcmMvV29sZmllMkQvRXZlbnRzL0V2ZW50UXVldWUudHMiLCJzcmMvV29sZmllMkQvRXZlbnRzL0dhbWVFdmVudC50cyIsInNyYy9Xb2xmaWUyRC9FdmVudHMvR2FtZUV2ZW50VHlwZS50cyIsInNyYy9Xb2xmaWUyRC9FdmVudHMvUmVjZWl2ZXIudHMiLCJzcmMvV29sZmllMkQvSW5wdXQvSW5wdXQudHMiLCJzcmMvV29sZmllMkQvSW5wdXQvSW5wdXRIYW5kbGVyLnRzIiwic3JjL1dvbGZpZTJEL0xvb3AvRW52aXJvbm1lbnRJbml0aWFsaXplci50cyIsInNyYy9Xb2xmaWUyRC9Mb29wL0ZpeGVkVXBkYXRlR2FtZUxvb3AudHMiLCJzcmMvV29sZmllMkQvTG9vcC9HYW1lLnRzIiwic3JjL1dvbGZpZTJEL0xvb3AvR2FtZUxvb3AudHMiLCJzcmMvV29sZmllMkQvTG9vcC9HYW1lT3B0aW9ucy50cyIsInNyYy9Xb2xmaWUyRC9Ob2Rlcy9DYW52YXNOb2RlLnRzIiwic3JjL1dvbGZpZTJEL05vZGVzL0dhbWVOb2RlLnRzIiwic3JjL1dvbGZpZTJEL05vZGVzL0dyYXBoaWMudHMiLCJzcmMvV29sZmllMkQvTm9kZXMvR3JhcGhpY3MvR3JhcGhpY1R5cGVzLnRzIiwic3JjL1dvbGZpZTJEL05vZGVzL0dyYXBoaWNzL0xpbmUudHMiLCJzcmMvV29sZmllMkQvTm9kZXMvR3JhcGhpY3MvUGFydGljbGUudHMiLCJzcmMvV29sZmllMkQvTm9kZXMvR3JhcGhpY3MvUG9pbnQudHMiLCJzcmMvV29sZmllMkQvTm9kZXMvR3JhcGhpY3MvUmVjdC50cyIsInNyYy9Xb2xmaWUyRC9Ob2Rlcy9TcHJpdGVzL0FuaW1hdGVkU3ByaXRlLnRzIiwic3JjL1dvbGZpZTJEL05vZGVzL1Nwcml0ZXMvU3ByaXRlLnRzIiwic3JjL1dvbGZpZTJEL05vZGVzL1RpbGVtYXAudHMiLCJzcmMvV29sZmllMkQvTm9kZXMvVGlsZW1hcHMvT3J0aG9nb25hbFRpbGVtYXAudHMiLCJzcmMvV29sZmllMkQvTm9kZXMvVUlFbGVtZW50LnRzIiwic3JjL1dvbGZpZTJEL05vZGVzL1VJRWxlbWVudHMvQnV0dG9uLnRzIiwic3JjL1dvbGZpZTJEL05vZGVzL1VJRWxlbWVudHMvTGFiZWwudHMiLCJzcmMvV29sZmllMkQvTm9kZXMvVUlFbGVtZW50cy9TbGlkZXIudHMiLCJzcmMvV29sZmllMkQvTm9kZXMvVUlFbGVtZW50cy9UZXh0SW5wdXQudHMiLCJzcmMvV29sZmllMkQvTm9kZXMvVUlFbGVtZW50cy9VSUVsZW1lbnRUeXBlcy50cyIsInNyYy9Xb2xmaWUyRC9QYXRoZmluZGluZy9OYXZpZ2F0aW9uTWFuYWdlci50cyIsInNyYy9Xb2xmaWUyRC9QYXRoZmluZGluZy9OYXZpZ2F0aW9uUGF0aC50cyIsInNyYy9Xb2xmaWUyRC9QYXRoZmluZGluZy9OYXZtZXNoLnRzIiwic3JjL1dvbGZpZTJEL1BoeXNpY3MvQmFzaWNQaHlzaWNzTWFuYWdlci50cyIsInNyYy9Xb2xmaWUyRC9QaHlzaWNzL1BoeXNpY3NNYW5hZ2VyLnRzIiwic3JjL1dvbGZpZTJEL1BsYXliYWNrL1JlY29yZGVyLnRzIiwic3JjL1dvbGZpZTJEL1JlZ2lzdHJ5L1JlZ2lzdHJpZXMvUmVnaXN0cnkudHMiLCJzcmMvV29sZmllMkQvUmVnaXN0cnkvUmVnaXN0cmllcy9TaGFkZXJSZWdpc3RyeS50cyIsInNyYy9Xb2xmaWUyRC9SZWdpc3RyeS9SZWdpc3RyeU1hbmFnZXIudHMiLCJzcmMvV29sZmllMkQvUmVuZGVyaW5nL0FuaW1hdGlvbnMvQW5pbWF0aW9uTWFuYWdlci50cyIsInNyYy9Xb2xmaWUyRC9SZW5kZXJpbmcvQW5pbWF0aW9ucy9BbmltYXRpb25UeXBlcy50cyIsInNyYy9Xb2xmaWUyRC9SZW5kZXJpbmcvQW5pbWF0aW9ucy9QYXJ0aWNsZVN5c3RlbU1hbmFnZXIudHMiLCJzcmMvV29sZmllMkQvUmVuZGVyaW5nL0FuaW1hdGlvbnMvVHdlZW5Db250cm9sbGVyLnRzIiwic3JjL1dvbGZpZTJEL1JlbmRlcmluZy9BbmltYXRpb25zL1R3ZWVuTWFuYWdlci50cyIsInNyYy9Xb2xmaWUyRC9SZW5kZXJpbmcvQ2FudmFzUmVuZGVyZXIudHMiLCJzcmMvV29sZmllMkQvUmVuZGVyaW5nL0NhbnZhc1JlbmRlcmluZy9HcmFwaGljUmVuZGVyZXIudHMiLCJzcmMvV29sZmllMkQvUmVuZGVyaW5nL0NhbnZhc1JlbmRlcmluZy9UaWxlbWFwUmVuZGVyZXIudHMiLCJzcmMvV29sZmllMkQvUmVuZGVyaW5nL0NhbnZhc1JlbmRlcmluZy9VSUVsZW1lbnRSZW5kZXJlci50cyIsInNyYy9Xb2xmaWUyRC9SZW5kZXJpbmcvUmVuZGVyaW5nTWFuYWdlci50cyIsInNyYy9Xb2xmaWUyRC9SZW5kZXJpbmcvV2ViR0xSZW5kZXJlci50cyIsInNyYy9Xb2xmaWUyRC9SZW5kZXJpbmcvV2ViR0xSZW5kZXJpbmcvU2hhZGVyVHlwZS50cyIsInNyYy9Xb2xmaWUyRC9SZW5kZXJpbmcvV2ViR0xSZW5kZXJpbmcvU2hhZGVyVHlwZXMvTGFiZWxTaGFkZXJUeXBlLnRzIiwic3JjL1dvbGZpZTJEL1JlbmRlcmluZy9XZWJHTFJlbmRlcmluZy9TaGFkZXJUeXBlcy9Qb2ludFNoYWRlclR5cGUudHMiLCJzcmMvV29sZmllMkQvUmVuZGVyaW5nL1dlYkdMUmVuZGVyaW5nL1NoYWRlclR5cGVzL1F1YWRTaGFkZXJUeXBlLnRzIiwic3JjL1dvbGZpZTJEL1JlbmRlcmluZy9XZWJHTFJlbmRlcmluZy9TaGFkZXJUeXBlcy9SZWN0U2hhZGVyVHlwZS50cyIsInNyYy9Xb2xmaWUyRC9SZW5kZXJpbmcvV2ViR0xSZW5kZXJpbmcvU2hhZGVyVHlwZXMvU3ByaXRlU2hhZGVyVHlwZS50cyIsInNyYy9Xb2xmaWUyRC9SZXNvdXJjZU1hbmFnZXIvUmVzb3VyY2VNYW5hZ2VyLnRzIiwic3JjL1dvbGZpZTJEL1NjZW5lR3JhcGgvU2NlbmVHcmFwaC50cyIsInNyYy9Xb2xmaWUyRC9TY2VuZUdyYXBoL1NjZW5lR3JhcGhBcnJheS50cyIsInNyYy9Xb2xmaWUyRC9TY2VuZUdyYXBoL1ZpZXdwb3J0LnRzIiwic3JjL1dvbGZpZTJEL1NjZW5lL0ZhY3Rvcmllcy9DYW52YXNOb2RlRmFjdG9yeS50cyIsInNyYy9Xb2xmaWUyRC9TY2VuZS9GYWN0b3JpZXMvRmFjdG9yeU1hbmFnZXIudHMiLCJzcmMvV29sZmllMkQvU2NlbmUvRmFjdG9yaWVzL1RpbGVtYXBGYWN0b3J5LnRzIiwic3JjL1dvbGZpZTJEL1NjZW5lL0xheWVyLnRzIiwic3JjL1dvbGZpZTJEL1NjZW5lL0xheWVycy9QYXJhbGxheExheWVyLnRzIiwic3JjL1dvbGZpZTJEL1NjZW5lL0xheWVycy9VSUxheWVyLnRzIiwic3JjL1dvbGZpZTJEL1NjZW5lL1NjZW5lLnRzIiwic3JjL1dvbGZpZTJEL1NjZW5lL1NjZW5lTWFuYWdlci50cyIsInNyYy9Xb2xmaWUyRC9TY2VuZS9TY2VuZU9wdGlvbnMudHMiLCJzcmMvV29sZmllMkQvU291bmQvQXVkaW9NYW5hZ2VyLnRzIiwic3JjL1dvbGZpZTJEL1RpbWluZy9UaW1lck1hbmFnZXIudHMiLCJzcmMvV29sZmllMkQvVXRpbHMvQ29sb3IudHMiLCJzcmMvV29sZmllMkQvVXRpbHMvRWFzZUZ1bmN0aW9ucy50cyIsInNyYy9Xb2xmaWUyRC9VdGlscy9HcmFwaFV0aWxzLnRzIiwic3JjL1dvbGZpZTJEL1V0aWxzL01hdGhVdGlscy50cyIsInNyYy9Xb2xmaWUyRC9VdGlscy9SZW5kZXJpbmdVdGlscy50cyIsInNyYy9Xb2xmaWUyRC9VdGlscy9TdHJpbmdVdGlscy50cyIsInNyYy9nYW1lL0VsZW1lbnQvRWxlbWVudENvbnRyb2xsZXIudHMiLCJzcmMvZ2FtZS9QbGF5ZXIvUGxheWVyQ29udHJvbGxlci50cyIsInNyYy9nYW1lL1BsYXllci9QbGF5ZXJfZW51bXMudHMiLCJzcmMvZ2FtZS9TY2VuZXMvQ1RDRXZlbnQudHMiLCJzcmMvZ2FtZS9TY2VuZXMvRWFydGgudHMiLCJzcmMvZ2FtZS9TY2VuZXMvTGV2ZWxTZWxlY3Rpb24udHMiLCJzcmMvZ2FtZS9TY2VuZXMvTWFpbk1lbnUudHMiLCJzcmMvZ2FtZS9TY2VuZXMvU3BsYXNoU2NyZWVuLnRzIiwic3JjL21haW4udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7OztBQ0lBLHdDQUFtQztBQUVuQzs7O0dBR0c7QUFDSDtJQU1DO1FBQ0MsSUFBSSxDQUFDLE1BQU0sR0FBRyxJQUFJLEtBQUssRUFBRSxDQUFDO1FBQzFCLElBQUksQ0FBQyxZQUFZLEdBQUcsSUFBSSxnQkFBRyxFQUFFLENBQUM7SUFDL0IsQ0FBQztJQUVEOzs7T0FHRztJQUNILGlDQUFhLEdBQWIsVUFBYyxLQUFZO1FBQ3pCLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQ3pCLENBQUM7SUFFRCwrQkFBVyxHQUFYLFVBQVksS0FBWTtRQUN2QixJQUFJLEtBQUssR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUV2QyxJQUFHLEtBQUssS0FBSyxDQUFDLENBQUMsRUFBQztZQUNmLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUMsQ0FBQztTQUM3QjtJQUNGLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsOEJBQVUsR0FBVixVQUFXLElBQVksRUFBRSxNQUEwQztRQUNsRSxJQUFJLENBQUMsWUFBWSxDQUFDLEdBQUcsQ0FBQyxJQUFJLEVBQUUsTUFBTSxDQUFDLENBQUM7SUFDckMsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCw4QkFBVSxHQUFWLFVBQVcsSUFBWTtRQUN0QixJQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxFQUFDO1lBQzlCLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQztTQUMzQzthQUFNO1lBQ04sTUFBTSxxQ0FBOEIs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QixJQUFJLENBQUMsU0FBUyxFQUFFLENBQUM7WUFFakIsTUFBTTtZQUNOLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztZQUN0QixJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1lBQzFCLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1lBRXRDLFFBQVE7WUFDUixJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztZQUM5QixJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1lBRTlDLFNBQVM7WUFDVCxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQzFCLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1lBRXRDLE9BQU87WUFDUCxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDdEIsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFBO1lBRTdCLElBQUksQ0FBQyxTQUFTLEVBQUUsQ0FBQztRQUNyQixDQUFDLENB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Q0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUM1QyxDQUFDO0lBRU0sMkJBQWEsR0FBcEIsVUFBcUIsQ0FBUztRQUMxQixPQUFPLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsRUFBRSxHQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLEdBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUUsR0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxHQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDekYsQ0FBQztJQUVNLHlCQUFXLEdBQWxCLFVBQW1CLENBQVM7UUFDeEIsT0FBTyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztJQUN2QyxDQUFDO0lBRU0sd0JBQVUsR0FBakIsVUFBa0IsQ0FBUztRQUN2QixPQUFPLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztJQUMzQyxDQUFDO0lBRU0sNEJBQWMsR0FBckIsVUFBc0IsQ0FBUztRQUMzQixPQUFPLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUM5RSxDQUFDO0lBRU0sMkJBQWEsR0FBcEIsVUFBcUIsQ0FBUztRQUMxQixPQUFPLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMs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QUM7U0FFMUI7YUFDSSxJQUFJLGtCQUFLLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxJQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLEVBQUU7WUFDckQsSUFBSSxDQUFDLGVBQWUsR0FBRyxDQUFDLENBQUM7WUFDekIsSUFBSSxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsbUJBQVEsQ0FBQyxjQUFjLEVBQUUsRUFBQyxJQUFJLEVBQUcsSUFBSSxDQUFDLGVBQWUsRUFBQyxDQUFDLENBQUM7U0FDbEY7YUFDSSxJQUFJLGtCQUFLLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxJQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLEVBQUU7WUFDckQsSUFBSSxDQUFDLGVBQWUsR0FBRyxDQUFDLENBQUM7WUFDekIsSUFBSSxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsbUJBQVEsQ0FBQyxjQUFjLEVBQUUsRUFBQyxJQUFJLEVBQUcsSUFBSSxDQUFDLGVBQWUsRUFBQyxDQUFDLENBQUM7U0FDbEY7YUFDSSxJQUFJLGtCQUFLLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxJQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLEVBQUU7WUFDckQsSUFBSSxDQUFDLGVBQWUsR0FBRyxDQUFDLENBQUM7WUFDekIsSUFBSSxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsbUJBQVEsQ0FBQyxjQUFjLEVBQUUsRUFBQyxJQUFJLEVBQUcsSUFBSSxDQUFDLGVBQWUsRUFBQyxDQUFDLENBQUM7U0FDbEY7YUFDSSxJQUFJLGtCQUFLLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxJQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLEVBQUU7WUFDckQsSUFBSSxDQUFDLGVBQWUsR0FBRyxDQUFDLENBQUM7WUFDekIsSUFBSSxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsbUJBQVEsQ0FBQyxjQUFjLEVBQUUsRUFBQyxJQUFJLEVBQUcsSUFBSSxDQUFDLGVBQWUsRUFBQyxDQUFDLENB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QUFFLENBQUMsRUFBRSxFQUFFO1lBQ25ELElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxLQUFLLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxhQUFhLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDMUU7UUFFRCxJQUFJLENBQUMsUUFBUSxDQUFDLFNBQVMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLFdBQVcsQ0FBQyxDQUFDLEVBQUUsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBRzVELElBQUksQ0FBQyxRQUFRLENBQUMsU0FBUyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBQzdCLElBQUksQ0FBQyxVQUFVLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxjQUFjLENBQUMsa0JBQWtCLEVBQUUsU0FBUyxDQUFDLENBQUM7UUFDekUsSUFBSSxDQUFDLFVBQVUsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxDQUFDO1FBQ2hELElBQUksQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUMsRUFBRSxHQUFDLENBQUMsRUFBRSxFQUFFLEdBQUMsRUFBRSxDQUFDLENBQUM7UUFFNUMsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBQzdDLElBQUksQ0FBQyxRQUFRLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQzlCLElBQUksU0FBUyxHQUFVLElBQUksQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLDhCQUFhLENBQUMsS0FBSyxFQUFFLFdBQVcsRUFBRSxFQUFDLFFBQVEsRUFBRSxJQUFJLGlCQUFJLENBQUMsQ0FBQyxHQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxJQUFJLEVBQUUsMkJBQTJCLEVBQUMsQ0FBQyxDQUFDO1FBQy9JLFNBQVMsQ0FBQyxTQUFTLEdBQUcsa0JBQUssQ0FBQyxLQUFLLENBQUM7UUFFbEMsSUFB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QUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO2dCQUNyQixNQUFNO1NBQ2I7UUFDRCxRQUFPLE1BQU0sQ0FBQyxPQUFPLEVBQUM7WUFDbEIsS0FBSyxRQUFRLENBQUM7WUFDZCxLQUFLLFFBQVE7Z0JBQ1QsSUFBRyxJQUFJLENBQUMsQ0FBQyxHQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxDQUFDLEdBQUMsR0FBRyxDQUFDLENBQUMsR0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLENBQUMsR0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFDLEVBQUUsSUFBSSxJQUFJLENBQUMsQ0FBQyxHQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUMsRUFBRSxJQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLElBQUksSUFBSTtvQkFBRSxNQUFNO2dCQUN0SSxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBQ2xCLEtBQUssUUFBUTtnQkFDVCxJQUFHLElBQUksQ0FBQyxDQUFDLEdBQUMsR0FBRyxDQUFDLENBQUMsR0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLENBQUMsR0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsQ0FBQyxHQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUMsRUFBRSxJQUFJLElBQUksQ0FBQyxDQUFDLEdBQUMsR0FBRyxDQUFDLENBQUMsR0FBQyxFQUFFLElBQUksSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsSUFBSSxJQUFJO29CQUFFLE1BQU07Z0JBQ3ZJLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDbEIsS0FBSyxRQUFR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Q0FBQztRQUN0QyxJQUFNLEtBQUssR0FBRyxpQ0FBaUMsQ0FBQztRQUVoRCxJQUFNLEtBQUssR0FBVSxJQUFJLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyw4QkFBYSxDQUFDLEtBQUssRUFBRSxPQUFPLEVBQUUsRUFBQyxRQUFRLEVBQUUsSUFBSSxpQkFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsRUFBRSxJQUFJLEVBQUUsS0FBSyxFQUFDLENBQUMsQ0FBQztRQUNuSSxJQUFNLEtBQUssR0FBVSxJQUFJLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyw4QkFBYSxDQUFDLEtBQUssRUFBRSxPQUFPLEVBQUUsRUFBQyxRQUFRLEVBQUUsSUFBSSxpQkFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsRUFBRSxJQUFJLEVBQUUsS0FBSyxFQUFDLENBQUMsQ0FBQztRQUNuSSxJQUFNLEtBQUssR0FBVSxJQUFJLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyw4QkFBYSxDQUFDLEtBQUssRUFBRSxPQUFPLEVBQUUsRUFBQyxRQUFRLEVBQUUsSUFBSSxpQkFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsRUFBRSxJQUFJLEVBQUUsS0FBSyxFQUFDLENBQUMsQ0FBQztRQUNsSSxJQUFNLEtBQUssR0FBVSxJQUFJLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyw4QkFBYSxDQUFDLEtBQUssRUFBRSxPQUFPLEVBQUUsRUFBQyxRQUFRLEVBQUUsSUFBSSxpQkFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksRUFBRSxLQUFLLEVBQUMsQ0FBQyxDQUFDO1FBQzdILElBQU0sS0FBSyxHQUFVLElBQUksQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLDhCQUFhLENBQUMsS0FBSyxFQUFFLE9BQU8sRUFB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Q0FBQyxLQUFLLEVBQUUsU0FBUyxFQUFFLEVBQUMsUUFBUSxFQUFFLElBQUksaUJBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLEVBQUUsSUFBSSxFQUFFLE1BQU0sRUFBQyxDQUFDLENBQUM7UUFDdEksSUFBTSxNQUFNLEdBQVUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsOEJBQWEsQ0FBQyxLQUFLLEVBQUUsU0FBUyxFQUFFLEVBQUMsUUFBUSxFQUFFLElBQUksaUJBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLEVBQUUsTUFBTSxFQUFDLENBQUMsQ0FBQztRQUNqSSxJQUFNLE1BQU0sR0FBVSxJQUFJLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyw4QkFBYSxDQUFDLEtBQUssRUFBRSxTQUFTLEVBQUUsRUFBQyxRQUFRLEVBQUUsSUFBSSxpQkFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsRUFBRSxJQUFJLEVBQUUsTUFBTSxFQUFDLENBQUMsQ0FBQztRQUN0SSxJQUFNLE1BQU0sR0FBVSxJQUFJLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyw4QkFBYSxDQUFDLEtBQUssRUFBRSxTQUFTLEVBQUUsRUFBQyxRQUFRLEVBQUUsSUFBSSxpQkFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsRUFBRSxJQUFJLEVBQUUsTUFBTSxFQUFDLENBQUMsQ0FBQztRQUN2SSxJQUFNLE1BQU0sR0FBVSxJQUFJLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyw4QkFBYSxDQUFDLEtBQUssRUFBRSxTQUFTLEVBQUUsRUFBQyxRQUFRLEVBQUUsSUFBSSxpQkFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsRUFBRSxJQUFJLEVB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QUFJLEdBQUcsSUFBSSxpQkFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBRS9CLGlCQUFpQjtJQUNqQixJQUFJLENBQUMsS0FBSyxDQUFDLHlCQUFZLEVBQUUsRUFBRSxDQUFDLENBQUM7QUFDakMsQ0FBQyxDQUFDLEVBQUUsQ0FBQztBQUVMLFNBQVMsUUFBUSxLQUFHLENBQUM7QUFBQSxDQUFDIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtmdW5jdGlvbiByKGUsbix0KXtmdW5jdGlvbiBvKGksZil7aWYoIW5baV0pe2lmKCFlW2ldKXt2YXIgYz1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlO2lmKCFmJiZjKXJldHVybiBjKGksITApO2lmKHUpcmV0dXJuIHUoaSwhMCk7dmFyIGE9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitpK1wiJ1wiKTt0aHJvdyBhLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsYX12YXIgcD1uW2ldPXtleHBvcnRzOnt9fTtlW2ldWzBdLmNhbGwocC5leHBvcnRzLGZ1bmN0aW9uKHIpe3ZhciBuPWVbaV1bMV1bcl07cmV0dXJuIG8obnx8cil9LHAscC5leHBvcnRzLHIsZSxuLHQpfXJldHVybiBuW2ldLmV4cG9ydHN9Zm9yKHZhciB1PVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUsaT0wO2k8dC5sZW5ndGg7aSsrKW8odFtpXSk7cmV0dXJuIG99cmV0dXJuIHJ9KSgpIiwiaW1wb3J0IEFjdG9yIGZyb20gXCIuLi9EYXRhVHlwZXMvSW50ZXJmYWNlcy9BY3RvclwiO1xyXG5pbXBvcnQgVXBkYXRlYWJsZSBmcm9tIFwiLi4vRGF0YVR5cGVzL0ludGVyZmFjZXMvVXBkYXRlYWJsZVwiO1xyXG5pbXBvcnQgQUkgZnJvbSBcIi4uL0RhdGFUeXBlcy9JbnRlcmZhY2VzL0FJXCI7XHJcbmltcG9ydCBHb2FwQUkgZnJvbSBcIi4uL0RhdGFUeXBlcy9JbnRlcmZhY2VzL0dvYXBBSVwiXHJcbmltcG9ydCBNYXAgZnJvbSBcIi4uL0RhdGFUeXBlcy9NYXBcIjtcclxuXHJcbi8qKlxyXG4gKiBBIG1hbmFnZXIgY2xhc3MgZm9yIGFsbCBvZiB0aGUgQUkgaW4gYSBzY2VuZS5cclxuICogS2VlcHMgYSBsaXN0IG9mIHJlZ2lzdGVyZWQgYWN0b3JzIGFuZCBoYW5kbGVzIEFJIGdlbmVyYXRpb24gZm9yIGFjdG9ycy5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFJTWFuYWdlciBpbXBsZW1lbnRzIFVwZGF0ZWFibGUge1xyXG5cdC8qKiBUaGUgYXJyYXkgb2YgcmVnaXN0ZXJlZCBhY3RvcnMgKi9cclxuXHRhY3RvcnM6IEFycmF5PEFjdG9yPjtcclxuXHQvKiogTWFwcyBBSSBuYW1lcyB0byB0aGVpciBjb25zdHJ1Y3RvcnMgKi9cclxuXHRyZWdpc3RlcmVkQUk6IE1hcDxBSUNvbnN0cnVjdG9yPjtcclxuXHJcblx0Y29uc3RydWN0b3IoKXtcclxuXHRcdHRoaXMuYWN0b3JzID0gbmV3IEFycmF5KCk7XHJcblx0XHR0aGlzLnJlZ2lzdGVyZWRBSSA9IG5ldyBNYXAoKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJlZ2lzdGVycyBhbiBhY3RvciB3aXRoIHRoZSBBSU1hbmFnZXJcclxuXHQgKiBAcGFyYW0gYWN0b3IgVGhlIGFjdG9yIHRvIHJlZ2lzdGVyXHJcblx0ICovXHJcblx0cmVnaXN0ZXJBY3RvcihhY3RvcjogQWN0b3IpOiB2b2lkIHtcclxuXHRcdHRoaXMuYWN0b3JzLnB1c2goYWN0b3IpO1xyXG5cdH1cclxuXHJcblx0cmVtb3ZlQWN0b3IoYWN0b3I6IEFjdG9yKTogdm9pZCB7XHJcblx0XHRsZXQgaW5kZXggPSB0aGlzLmFjdG9ycy5pbmRleE9mKGFjdG9yKTtcclxuXHJcblx0XHRpZihpbmRleCAhPT0gLTEpe1xyXG5cdFx0XHR0aGlzLmFjdG9ycy5zcGxpY2UoaW5kZXgsIDEpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmVnaXN0ZXJzIGFuIEFJIHdpdGggdGhlIEFJTWFuYWdlciBmb3IgdXNlIGxhdGVyIG9uXHJcblx0ICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIEFJIHRvIHJlZ2lzdGVyXHJcblx0ICogQHBhcmFtIGNvbnN0ciBUaGUgY29uc3RydWN0b3IgZm9yIHRoZSBBSVxyXG5cdCAqL1xyXG5cdHJlZ2lzdGVyQUkobmFtZTogc3RyaW5nLCBjb25zdHI6IG5ldyA8VCBleHRlbmRzIEFJIHwgR29hcEFJPigpID0+IFQgKTogdm9pZCB7XHJcblx0XHR0aGlzLnJlZ2lzdGVyZWRBSS5hZGQobmFtZSwgY29uc3RyKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdlbmVyYXRlcyBhbiBBSSBpbnN0YW5jZSBmcm9tIGl0cyBuYW1lXHJcblx0ICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIEFJIHRvIGFkZFxyXG5cdCAqIEByZXR1cm5zIEEgbmV3IEFJIGluc3RhbmNlXHJcblx0ICovXHJcblx0Z2VuZXJhdGVBSShuYW1lOiBzdHJpbmcpOiBBSSB8IEdvYXBBSSB7XHJcblx0XHRpZih0aGlzLnJlZ2lzdGVyZWRBSS5oYXMobmFtZSkpe1xyXG5cdFx0XHRyZXR1cm4gbmV3ICh0aGlzLnJlZ2lzdGVyZWRBSS5nZXQobmFtZSkpKCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aHJvdyBgQ2Fubm90IGNyZWF0ZSBBSSB3aXRoIG5hbWUgJHtuYW1lfSwgbm8gQUkgd2l0aCB0aGF0IG5hbWUgaXMgcmVnaXN0ZXJlZGA7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHR1cGRhdGUoZGVsdGFUOiBudW1iZXIpOiB2b2lkIHtcclxuXHRcdC8vIFJ1biB0aGUgYWkgZm9yIGV2ZXJ5IGFjdGl2ZSBhY3RvclxyXG5cdFx0dGhpcy5hY3RvcnMuZm9yRWFjaChhY3RvciA9PiB7IGlmKGFjdG9yLmFpQWN0aXZlKSBhY3Rvci5haS51cGRhdGUoZGVsdGFUKSB9KTtcclxuXHR9XHJcbn1cclxuXHJcbnR5cGUgQUlDb25zdHJ1Y3RvciA9IG5ldyA8VCBleHRlbmRzIEFJPigpID0+IFQ7IiwiaW1wb3J0IEFJIGZyb20gXCIuLi9EYXRhVHlwZXMvSW50ZXJmYWNlcy9BSVwiO1xyXG5pbXBvcnQgU3RhdGVNYWNoaW5lIGZyb20gXCIuLi9EYXRhVHlwZXMvU3RhdGUvU3RhdGVNYWNoaW5lXCI7XHJcbmltcG9ydCBHYW1lTm9kZSBmcm9tIFwiLi4vTm9kZXMvR2FtZU5vZGVcIjtcclxuXHJcbi8qKlxyXG4gKiBBIHZlcnNpb24gb2YgYSBAcmVmZXJlbmNlW1N0YXRlTWFjaGluZV0gdGhhdCBpcyBjb25maWd1cmVkIHRvIHdvcmsgYXMgYW4gQUkgY29udHJvbGxlciBmb3IgYSBAcmVmZXJlbmNlW0dhbWVOb2RlXVxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3RhdGVNYWNoaW5lQUkgZXh0ZW5kcyBTdGF0ZU1hY2hpbmUgaW1wbGVtZW50cyBBSSB7XHJcblx0LyoqXHRUaGUgR2FtZU5vZGUgdGhhdCB1c2VzIHRoaXMgU3RhdGVNYWNoaW5lIGZvciBpdHMgQUkgKi9cclxuXHRwcm90ZWN0ZWQgb3duZXI6IEdhbWVOb2RlO1xyXG5cclxuXHQvLyBAaW1wbGVtZW50ZWRcclxuXHRpbml0aWFsaXplQUkob3duZXI6IEdhbWVOb2RlLCBjb25maWc6IFJlY29yZDxzdHJpbmcsIGFueT4pOiB2b2lkIHt9XHJcblxyXG5cdC8vIEBpbXBsZW1lbnRlZFxyXG5cdGRlc3Ryb3koKXtcclxuXHRcdC8vIEdldCByaWQgb2Ygb3VyIHJlZmVyZW5jZSB0byB0aGUgb3duZXJcclxuXHRcdGRlbGV0ZSB0aGlzLm93bmVyO1xyXG5cdFx0dGhpcy5yZWNlaXZlci5kZXN0cm95KCk7XHJcblx0fVxyXG5cclxuXHQvLyBAaW1wbGVtZW50ZWRcclxuXHRhY3RpdmF0ZShvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogdm9pZCB7fVxyXG59IiwiLy8gQGlnbm9yZVBhZ2VcclxuXHJcbi8qKlxyXG4gKiBBIHBsYWNlaG9sZGVyIGZ1bmN0aW9uIGZvciBObyBPcGVyYXRpb24uIERvZXMgbm90aGluZ1xyXG4gKi9cclxuY29uc3QgTnVsbEZ1bmMgPSAoKSA9PiB7fTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IE51bGxGdW5jOyIsIi8qKlxyXG4gKiBBIGxpbmtlZC1saXN0IGZvciB0aGUgZWRnZXMgaW4gYSBAcmVmZXJlbmNlW0dyYXBoXS5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVkZ2VOb2RlIHtcclxuICAgIC8qKiBUaGUgbm9kZSBpbiB0aGUgR3JhcGggdGhpcyBlZGdlIGNvbm5lY3RzIHRvICovXHJcbiAgICB5OiBudW1iZXI7XHJcbiAgICAvKiogVGhlIHdlaWdodCBvZiB0aGlzIEVkZ2VOb2RlICovXHJcblx0d2VpZ2h0OiBudW1iZXI7XHJcbiAgICAvKiogVGhlIG5leHQgRWRnZU5vZGUgaW4gdGhlIGxpbmtlZC1saXN0ICovXHJcbiAgICBuZXh0OiBFZGdlTm9kZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgRWRnZU5vZGVcclxuICAgICAqIEBwYXJhbSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIG5vZGUgdGhpcyBlZGdlIGNvbm5lY3RzIHRvXHJcbiAgICAgKiBAcGFyYW0gd2VpZ2h0IFRoZSB3ZWlnaHQgb2YgdGhpcyBlZGdlXHJcbiAgICAgKi9cclxuXHRjb25zdHJ1Y3RvcihpbmRleDogbnVtYmVyLCB3ZWlnaHQ/OiBudW1iZXIpe1xyXG5cdFx0dGhpcy55ID0gaW5kZXg7XHJcblx0XHR0aGlzLm5leHQgPSBudWxsO1xyXG5cdFx0dGhpcy53ZWlnaHQgPSB3ZWlnaHQgPyB3ZWlnaHQgOiAxO1xyXG5cdH1cclxufSIsImltcG9ydCBFZGdlTm9kZSBmcm9tIFwiLi9FZGdlTm9kZVwiO1xyXG5cclxuZXhwb3J0IGNvbnN0IE1BWF9WID0gMTAwO1xyXG5cclxuLyoqXHJcbiAqIEFuIGltcGxlbWVudGF0aW9uIG9mIGEgZ3JhcGggZGF0YSBzdHJ1Y3R1cmUgdXNpbmcgZWRnZSBsaXN0cy4gSW5zcGlyZWQgYnkgVGhlIEFsZ29yaXRobSBEZXNpZ24gTWFudWFsLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgR3JhcGgge1xyXG5cdC8qKiBBbiBhcnJheSBvZiBlZGdlcyBhdCB0aGUgbm9kZSBzcGVjaWZpZWQgYnkgdGhlIGluZGV4ICovXHJcblx0ZWRnZXM6IEFycmF5PEVkZ2VOb2RlPjtcclxuXHQvKiogQW4gYXJyYXkgcmVwcmVzZW50aW5nIHRoZSBkZWdyZWUgb2YgdGhlIG5vZGUgc3BlY2lmaWVkIGJ5IHRoZSBpbmRleCAqL1xyXG5cdGRlZ3JlZTogQXJyYXk8bnVtYmVyPjtcclxuXHQvKiogVGhlIG51bWJlciBvZiB2ZXJ0aWNlcyBpbiB0aGUgZ3JhcGggKi9cclxuXHRudW1WZXJ0aWNlczogbnVtYmVyO1xyXG5cdC8qKiBUaGUgbnVtYmVyIG9mIGVkZ2VzIGluIHRoZSBncmFwaCAqL1xyXG5cdG51bUVkZ2VzOiBudW1iZXI7XHJcblx0LyoqIFdoZXRoZXIgb3Igbm90IHRoZSBncmFwaCBpcyBkaXJlY3RlZCAqL1xyXG5cdGRpcmVjdGVkOiBib29sZWFuO1xyXG5cdC8qKiBXaGV0aGVyIG9yIG5vdCB0aGUgZ3JhcGggaXMgd2VpZ2h0ZWQgKi9cclxuXHR3ZWlnaHRlZDogYm9vbGVhbjtcclxuXHJcblx0LyoqXHJcblx0ICogQ29uc3RydWN0cyBhIG5ldyBncmFwaFxyXG5cdCAqIEBwYXJhbSBkaXJlY3RlZCBXaGV0aGVyIG9yIG5vdCB0aGlzIGdyYXBoIGlzIGRpcmVjdGVkXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3IoZGlyZWN0ZWQ6IGJvb2xlYW4gPSBmYWxzZSl7XHJcblx0XHR0aGlzLmRpcmVjdGVkID0gZGlyZWN0ZWQ7XHJcblx0XHR0aGlzLndlaWdodGVkID0gZmFsc2U7XHJcblxyXG5cdFx0dGhpcy5udW1WZXJ0aWNlcyA9IDA7XHJcblx0XHR0aGlzLm51bUVkZ2VzID0gMDtcclxuXHJcblx0XHR0aGlzLmVkZ2VzID0gbmV3IEFycmF5KE1BWF9WKTtcclxuXHRcdHRoaXMuZGVncmVlID0gbmV3IEFycmF5KE1BWF9WKTtcclxuXHR9XHJcblxyXG5cdC8qKiBBZGRzIGEgbm9kZSB0byB0aGlzIGdyYXBoIGFuZCByZXR1cm5zIHRoZSBpbmRleCBvZiBpdFxyXG5cdCAqIEByZXR1cm5zIFRoZSBpbmRleCBvZiB0aGUgbmV3IG5vZGVcclxuXHQqL1xyXG5cdGFkZE5vZGUoKTogbnVtYmVyIHtcclxuXHRcdHRoaXMubnVtVmVydGljZXMrKztcclxuXHRcdHJldHVybiB0aGlzLm51bVZlcnRpY2VzO1xyXG5cdH1cclxuXHJcblx0LyoqIEFkZHMgYW4gZWRnZSBiZXR3ZWVuIG5vZGUgeCBhbmQgeSwgd2l0aCBhbiBvcHRpb25hbCB3ZWlnaHRcclxuXHQgKiBAcGFyYW0geCBUaGUgaW5kZXggb2YgdGhlIHN0YXJ0IG9mIHRoZSBlZGdlXHJcblx0ICogQHBhcmFtIHkgVGhlIGluZGV4IG9mIHRoZSBlbmQgb2YgdGhlIGVkZ2VcclxuXHQgKiBAcGFyYW0gd2VpZ2h0IFRoZSBvcHRpb25hbCB3ZWlnaHQgb2YgdGhlIG5ldyBlZGdlXHJcblx0Ki9cclxuXHRhZGRFZGdlKHg6IG51bWJlciwgeTogbnVtYmVyLCB3ZWlnaHQ/OiBudW1iZXIpOiB2b2lkIHtcclxuXHRcdGxldCBlZGdlID0gbmV3IEVkZ2VOb2RlKHksIHdlaWdodCk7XHJcblxyXG5cclxuXHJcblx0XHRpZih0aGlzLmVkZ2VzW3hdKXtcclxuXHRcdFx0ZWRnZS5uZXh0ID0gdGhpcy5lZGdlc1t4XTtcclxuXHRcdH1cclxuXHRcdFxyXG5cdFx0dGhpcy5lZGdlc1t4XSA9IGVkZ2U7XHJcblxyXG5cdFx0aWYoIXRoaXMuZGlyZWN0ZWQpe1xyXG5cdFx0XHRlZGdlID0gbmV3IEVkZ2VOb2RlKHgsIHdlaWdodCk7XHJcblxyXG5cdFx0XHRpZih0aGlzLmVkZ2VzW3ldKXtcclxuXHRcdFx0XHRlZGdlLm5leHQgPSB0aGlzLmVkZ2VzW3ldO1xyXG5cdFx0XHR9XHJcblx0XHRcdFxyXG5cdFx0XHR0aGlzLmVkZ2VzW3ldID0gZWRnZTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLm51bUVkZ2VzICs9IDE7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBDaGVja3Mgd2hldGhlciBvciBub3QgYW4gZWRnZSBleGlzdHMgYmV0d2VlbiB0d28gbm9kZXMuXHJcblx0ICogVGhpcyBjaGVjayBpcyBkaXJlY3Rpb25hbCBpZiB0aGlzIGlzIGEgZGlyZWN0ZWQgZ3JhcGguXHJcblx0ICogQHBhcmFtIHggVGhlIGZpcnN0IG5vZGVcclxuXHQgKiBAcGFyYW0geSBUaGUgc2Vjb25kIG5vZGVcclxuXHQgKiBAcmV0dXJucyB0cnVlIGlmIGFuIGVkZ2UgZXhpc3RzLCBmYWxzZSBvdGhlcndpc2VcclxuXHQgKi9cclxuXHRlZGdlRXhpc3RzKHg6IG51bWJlciwgeTogbnVtYmVyKTogYm9vbGVhbiB7XHJcblx0XHRsZXQgZWRnZSA9IHRoaXMuZWRnZXNbeF07XHJcblxyXG5cdFx0d2hpbGUoZWRnZSAhPT0gbnVsbCl7XHJcblx0XHRcdGlmKGVkZ2UueSA9PT0geSl7XHJcblx0XHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHRcdH1cclxuXHRcdFx0ZWRnZSA9IGVkZ2UubmV4dDtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldHMgdGhlIGVkZ2UgbGlzdCBhc3NvY2lhdGVkIHdpdGggbm9kZSB4XHJcblx0ICogQHBhcmFtIHggVGhlIGluZGV4IG9mIHRoZSBub2RlXHJcblx0ICogQHJldHVybnMgVGhlIGhlYWQgb2YgYSBsaW5rZWQtbGlzdCBvZiBlZGdlc1xyXG5cdCAqL1xyXG5cdGdldEVkZ2VzKHg6IG51bWJlcik6IEVkZ2VOb2RlIHtcclxuXHRcdHJldHVybiB0aGlzLmVkZ2VzW3hdO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogR2V0cyB0aGUgZGVncmVlIGFzc29jaWF0ZWQgd2l0aCBub2RlIHhcclxuXHQgKiBAcGFyYW0geCBUaGUgaW5kZXggb2YgdGhlIG5vZGVcclxuXHQgKi9cclxuXHRnZXREZWdyZWUoeDogbnVtYmVyKTogbnVtYmVyIHtcclxuXHRcdHJldHVybiB0aGlzLmRlZ3JlZVt4XTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnZlcnRzIHRoZSBzcGVjaWZlZCBub2RlIGludG8gYSBzdHJpbmdcclxuXHQgKiBAcGFyYW0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSBub2RlIHRvIGNvbnZlcnQgdG8gYSBzdHJpbmdcclxuXHQgKiBAcmV0dXJucyBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBub2RlOiBcIk5vZGUgeFwiXHJcblx0ICovXHJcblx0cHJvdGVjdGVkIG5vZGVUb1N0cmluZyhpbmRleDogbnVtYmVyKTogc3RyaW5nIHtcclxuXHRcdHJldHVybiBcIk5vZGUgXCIgKyBpbmRleDtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnZlcnRzIHRoZSBHcmFwaCBpbnRvIGEgc3RyaW5nIGZvcm1hdFxyXG5cdCAqIEByZXR1cm5zIFRoZSBncmFwaCBhcyBhIHN0cmluZ1xyXG5cdCAqL1xyXG5cdHRvU3RyaW5nKCk6IHN0cmluZyB7XHJcblx0XHRsZXQgcmV0dmFsID0gXCJcIjtcclxuXHJcblx0XHRmb3IobGV0IGkgPSAwOyBpIDwgdGhpcy5udW1WZXJ0aWNlczsgaSsrKXtcclxuXHRcdFx0bGV0IGVkZ2UgPSB0aGlzLmVkZ2VzW2ldO1xyXG5cdFx0XHRsZXQgZWRnZVN0ciA9IFwiXCI7XHJcblx0XHRcdHdoaWxlKGVkZ2UgIT09IHVuZGVmaW5lZCAmJiBlZGdlICE9PSBudWxsKXtcclxuXHRcdFx0XHRlZGdlU3RyICs9IGVkZ2UueS50b1N0cmluZygpO1xyXG5cdFx0XHRcdGlmKHRoaXMud2VpZ2h0ZWQpe1xyXG5cdFx0XHRcdFx0ZWRnZVN0ciArPSBcIiAoXCIgKyBlZGdlLndlaWdodCArIFwiKVwiO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZihlZGdlLm5leHQgIT09IG51bGwpe1xyXG5cdFx0XHRcdFx0ZWRnZVN0ciArPSBcIiwgXCI7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRlZGdlID0gZWRnZS5uZXh0O1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR2YWwgKz0gdGhpcy5ub2RlVG9TdHJpbmcoaSkgKyBcIjogXCIgKyBlZGdlU3RyICsgXCJcXG5cIjtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcmV0dmFsO1xyXG5cdH1cclxufSIsImltcG9ydCBHcmFwaCwgeyBNQVhfViB9IGZyb20gXCIuL0dyYXBoXCI7XHJcbmltcG9ydCBWZWMyIGZyb20gXCIuLi9WZWMyXCI7XHJcbmltcG9ydCBEZWJ1Z1JlbmRlcmFibGUgZnJvbSBcIi4uL0ludGVyZmFjZXMvRGVidWdSZW5kZXJhYmxlXCI7XHJcblxyXG4vKipcclxuICogQW4gZXh0ZW5zaW9uIG9mIEdyYXBoIHRoYXQgaGFzIG5vZGVzIHdpdGggcG9zaXRpb25zIGluIDJEIHNwYWNlLlxyXG4gKiBUaGlzIGlzIGEgd2VpZ2h0ZWQgZ3JhcGggKHRob3VnaCBub3QgaW5oZXJlbnRseSBkaXJlY3RkKVxyXG4qL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQb3NpdGlvbkdyYXBoIGV4dGVuZHMgR3JhcGggaW1wbGVtZW50cyBEZWJ1Z1JlbmRlcmFibGUge1xyXG5cdC8qKiBBbiBhcnJheSBvZiB0aGUgcG9zaXRpb25zIG9mIHRoZSBub2RlcyBpbiB0aGlzIGdyYXBoICovXHJcblx0cG9zaXRpb25zOiBBcnJheTxWZWMyPjtcclxuXHJcblx0LyoqXHJcblx0ICogQ3JlYXRlZXMgYSBuZXcgUG9zaXRpb25HcmFwaFxyXG5cdCAqIEBwYXJhbSBkaXJlY3RlZCBXaGV0aGVyIG9yIG5vdCB0aGlzIGdyYXBoIGlzIGRpcmVjdGVkXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3IoZGlyZWN0ZWQ6IGJvb2xlYW4gPSBmYWxzZSl7XHJcblx0XHRzdXBlcihkaXJlY3RlZCk7XHJcblx0XHR0aGlzLnBvc2l0aW9ucyA9IG5ldyBBcnJheShNQVhfVik7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBBZGRzIGEgcG9zaXRpb25lZCBub2RlIHRvIHRoaXMgZ3JhcGhcclxuXHQgKiBAcGFyYW0gcG9zaXRpb24gVGhlIHBvc2l0aW9uIG9mIHRoZSBub2RlIHRvIGFkZFxyXG5cdCAqIEByZXR1cm5zIFRoZSBpbmRleCBvZiB0aGUgYWRkZWQgbm9kZVxyXG5cdCAqL1xyXG5cdGFkZFBvc2l0aW9uZWROb2RlKHBvc2l0aW9uOiBWZWMyKTogbnVtYmVyIHtcclxuXHRcdHRoaXMucG9zaXRpb25zW3RoaXMubnVtVmVydGljZXNdID0gcG9zaXRpb247XHJcblx0XHRyZXR1cm4gdGhpcy5hZGROb2RlKCk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBDaGFuZ2VzIHRoZSBwb3NpdGlvbiBvZiBhIG5vZGUuXHJcblx0ICogQXV0b21hdGljYWxseSBhZGp1c3RzIHRoZSB3ZWlnaHRzIG9mIHRoZSBncmFwaCB0aWVkIHRvIHRoaXMgbm9kZS5cclxuXHQgKiBBcyBzdWNoLCBiZSB3YXJuZWQgdGhhdCB0aGlzIGZ1bmN0aW9uIGhhcyBhbiBPKG4gKyBtKSBydW5uaW5nIHRpbWUsIGFuZCB1c2UgaXQgc3BhcmluZ2x5LlxyXG5cdCAqIEBwYXJhbSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIG5vZGVcclxuXHQgKiBAcGFyYW0gcG9zaXRpb24gVGhlIG5ldyBwb3NpdGlvbiBvZiB0aGUgbm9kZVxyXG5cdCAqL1xyXG5cdHNldE5vZGVQb3NpdGlvbihpbmRleDogbnVtYmVyLCBwb3NpdGlvbjogVmVjMik6IHZvaWQge1xyXG5cdFx0dGhpcy5wb3NpdGlvbnNbaW5kZXhdID0gcG9zaXRpb247XHJcblxyXG5cdFx0Ly8gUmVjYWxjdWxhdGUgYWxsIHdlaWdodHMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgaW5kZXhcclxuXHRcdGZvcihsZXQgaSA9IDA7IGkgPCB0aGlzLm51bUVkZ2VzOyBpKyspe1xyXG5cclxuXHRcdFx0bGV0IGVkZ2UgPSB0aGlzLmVkZ2VzW2ldO1xyXG5cclxuXHRcdFx0d2hpbGUoZWRnZSAhPT0gbnVsbCl7XHJcblx0XHRcdFx0Ly8gSWYgdGhpcyBub2RlIGlzIG9uIGVpdGhlciBzaWRlIG9mIHRoZSBlZGdlLCByZWNhbGN1bGF0ZSB3ZWlnaHRcclxuXHRcdFx0XHRpZihpID09PSBpbmRleCB8fCBlZGdlLnkgPT09IGluZGV4KXtcclxuXHRcdFx0XHRcdGVkZ2Uud2VpZ2h0ID0gdGhpcy5wb3NpdGlvbnNbaV0uZGlzdGFuY2VUbyh0aGlzLnBvc2l0aW9uc1tlZGdlLnldKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGVkZ2UgPSBlZGdlLm5leHQ7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldHMgdGhlIHBvc2l0aW9uIG9mIGEgbm9kZVxyXG5cdCAqIEBwYXJhbSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIG5vZGVcclxuXHQgKiBAcmV0dXJucyBUaGUgcG9zaXRpb24gb2YgdGhlIG5vZGVcclxuXHQgKi9cclxuXHRnZXROb2RlUG9zaXRpb24oaW5kZXg6IG51bWJlcik6IFZlYzIge1xyXG5cdFx0cmV0dXJuIHRoaXMucG9zaXRpb25zW2luZGV4XTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEFkZHMgYW4gZWRnZSB0byB0aGlzIGdyYXBoIGJldHdlZW4gbm9kZSB4IGFuZCB5LlxyXG5cdCAqIEF1dG9tYXRpY2FsbHkgY2FsY3VsYXRlcyB0aGUgd2VpZ2h0IG9mIHRoZSBlZGdlIGFzIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBub2Rlcy5cclxuXHQgKiBAcGFyYW0geCBUaGUgYmVnaW5uaW5nIG9mIHRoZSBlZGdlXHJcblx0ICogQHBhcmFtIHkgVGhlIGVuZCBvZiB0aGUgZWRnZVxyXG5cdCAqL1xyXG5cdGFkZEVkZ2UoeDogbnVtYmVyLCB5OiBudW1iZXIpOiB2b2lkIHtcclxuXHRcdGlmKCF0aGlzLnBvc2l0aW9uc1t4XSB8fCAhdGhpcy5wb3NpdGlvbnNbeV0pe1xyXG5cdFx0XHR0aHJvdyBcIkNhbid0IGFkZCBlZGdlIHRvIHVuLXBvc2l0aW9uZWQgbm9kZSFcIjtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBXZWlnaHQgaXMgdGhlIGRpc3RhbmNlIGJldHdlZW4gdGhlIG5vZGVzXHJcblx0XHRsZXQgd2VpZ2h0ID0gdGhpcy5wb3NpdGlvbnNbeF0uZGlzdGFuY2VUbyh0aGlzLnBvc2l0aW9uc1t5XSk7XHJcblxyXG5cdFx0c3VwZXIuYWRkRWRnZSh4LCB5LCB3ZWlnaHQpO1xyXG5cdH1cclxuXHJcblx0Ly8gQG92ZXJyaWRlXHJcblx0cHJvdGVjdGVkIG5vZGVUb1N0cmluZyhpbmRleDogbnVtYmVyKTogc3RyaW5nIHtcclxuXHRcdHJldHVybiBcIk5vZGUgXCIgKyBpbmRleCArIFwiIC0gXCIgKyB0aGlzLnBvc2l0aW9uc1tpbmRleF0udG9TdHJpbmcoKTtcclxuXHR9XHJcblxyXG5cdGRlYnVnUmVuZGVyID0gKCk6IHZvaWQgPT4ge1xyXG5cdFx0Ly8gZm9yKGxldCBwb2ludCBvZiB0aGlzLnBvc2l0aW9ucyl7XHJcblx0XHQvLyBcdGN0eC5maWxsUmVjdCgocG9pbnQueCAtIG9yaWdpbi54IC0gNCkqem9vbSwgKHBvaW50LnkgLSBvcmlnaW4ueSAtIDQpKnpvb20sIDgsIDgpO1xyXG5cdFx0Ly8gfVxyXG5cdH1cclxufSIsImltcG9ydCBWZWMyIGZyb20gXCIuLi9WZWMyXCI7XHJcbmltcG9ydCBBQUJCIGZyb20gXCIuLi9TaGFwZXMvQUFCQlwiO1xyXG5cclxuLyoqIEFuIG9iamVjdCB0aGF0IGlzIGEgcmVnaW9uLCB3aXRoIGEgc2l6ZSwgc2NhbGUsIGFuZCBib3VuZGFyeS4gKi9cclxuZXhwb3J0IGRlZmF1bHQgaW50ZXJmYWNlIFJlZ2lvbiB7XHJcbiAgICAvKiogVGhlIHNpemUgb2YgdGhpcyBvYmplY3QuICovXHJcbiAgICBzaXplOiBWZWMyO1xyXG5cclxuICAgIC8qKiBUaGUgc2NhbGUgb2YgdGhpcyBvYmplY3QuICovXHJcbiAgICBzY2FsZTogVmVjMjtcclxuXHJcbiAgICAvKiogVGhlIHNpemUgb2YgdGhlIG9iamVjdCB0YWtpbmcgaW50byBhY2NvdW50IHRoZSB6b29tIGFuZCBzY2FsZSAqL1xyXG4gICAgcmVhZG9ubHkgc2l6ZVdpdGhab29tOiBWZWMyO1xyXG5cclxuICAgIC8qKiBUaGUgYm91bmRpbmcgYm94IG9mIHRoaXMgb2JqZWN0LiAqL1xyXG4gICAgYm91bmRhcnk6IEFBQkI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBpc1JlZ2lvbihhcmc6IGFueSk6IGJvb2xlYW4ge1xyXG4gICAgcmV0dXJuIGFyZyAmJiBhcmcuc2l6ZSAmJiBhcmcuc2NhbGUgJiYgYXJnLmJvdW5kYXJ5O1xyXG59IiwiaW1wb3J0IENvbGxlY3Rpb24gZnJvbSBcIi4vQ29sbGVjdGlvblwiO1xyXG5cclxuLyoqXHJcbiAqIEFzc29jaWF0ZXMgc3RyaW5ncyB3aXRoIGVsZW1lbnRzIG9mIHR5cGUgVFxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWFwPFQ+IGltcGxlbWVudHMgQ29sbGVjdGlvbiB7XHJcblx0cHJpdmF0ZSBtYXA6IFJlY29yZDxzdHJpbmcsIFQ+O1xyXG5cclxuXHQvKiogQ3JlYXRlcyBhIG5ldyBtYXAgKi9cclxuXHRjb25zdHJ1Y3Rvcigpe1xyXG5cdFx0dGhpcy5tYXAgPSB7fTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEFkZHMgYSB2YWx1ZSBUIHN0b3JlZCBhdCBhIGtleS5cclxuXHQgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIGl0ZW0gdG8gYmUgc3RvcmVkXHJcblx0ICogQHBhcmFtIHZhbHVlIFRoZSBpdGVtIHRvIGJlIHN0b3JlZFxyXG5cdCAqL1xyXG5cdGFkZChrZXk6IHN0cmluZywgdmFsdWU6IFQpOiB2b2lkIHtcclxuXHRcdHRoaXMubWFwW2tleV0gPSB2YWx1ZTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCB0aGUgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIGEga2V5LlxyXG5cdCAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgaXRlbVxyXG5cdCAqIEByZXR1cm5zIFRoZSBpdGVtIGF0IHRoZSBrZXkgb3IgdW5kZWZpbmVkXHJcblx0ICovXHJcblx0Z2V0KGtleTogc3RyaW5nKTogVCB7XHJcblx0XHRyZXR1cm4gdGhpcy5tYXBba2V5XTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEFuIGFsaWFzIG9mIGFkZC4gU2V0cyB0aGUgdmFsdWUgc3RvcmVkIGF0IGtleSB0byB0aGUgbmV3IHNwZWNpZmllZCB2YWx1ZVxyXG5cdCAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgaXRlbSB0byBiZSBzdG9yZWRcclxuXHQgKiBAcGFyYW0gdmFsdWUgVGhlIGl0ZW0gdG8gYmUgc3RvcmVkXHJcblx0ICovXHJcblx0c2V0KGtleTogc3RyaW5nLCB2YWx1ZTogVCk6IHZvaWQge1xyXG5cdFx0dGhpcy5hZGQoa2V5LCB2YWx1ZSk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdGhlcmUgaXMgYSB2YWx1ZSBzdG9yZWQgYXQgdGhlIHNwZWNpZmllZCBrZXksIGZhbHNlIG90aGVyd2lzZS5cclxuXHQgKiBAcGFyYW0ga2V5IFRoZSBrZXkgdG8gY2hlY2tcclxuXHQgKiBAcmV0dXJucyBBIGJvb2xlYW4gcmVwcmVzZW50aW5nIHdoZXRoZXIgb3Igbm90IHRoZXJlIGlzIGFuIGl0ZW0gYXQgdGhlIGdpdmVuIGtleS5cclxuXHQgKi9cclxuXHRoYXMoa2V5OiBzdHJpbmcpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiB0aGlzLm1hcFtrZXldICE9PSB1bmRlZmluZWQ7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIGFuIGFycmF5IG9mIGFsbCBvZiB0aGUga2V5cyBpbiB0aGlzIG1hcC5cclxuXHQgKiBAcmV0dXJucyBBbiBhcnJheSBjb250YWluaW5nIGFsbCBrZXlzIGluIHRoZSBtYXAuXHJcblx0ICovXHJcblx0a2V5cygpOiBBcnJheTxzdHJpbmc+IHtcclxuXHRcdHJldHVybiBPYmplY3Qua2V5cyh0aGlzLm1hcCk7XHJcblx0fVxyXG5cdFxyXG5cdC8vIEBpbXBsZW1lbnRlZFxyXG5cdGZvckVhY2goZnVuYzogKGtleTogc3RyaW5nKSA9PiB2b2lkKTogdm9pZCB7XHJcblx0XHRPYmplY3Qua2V5cyh0aGlzLm1hcCkuZm9yRWFjaChrZXkgPT4gZnVuYyhrZXkpKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIERlbGV0ZXMgYW4gaXRlbSBhc3NvY2lhdGVkIHdpdGggYSBrZXlcclxuXHQgKiBAcGFyYW0ga2V5IFRoZSBrZXkgYXQgd2hpY2ggdG8gZGVsZXRlIGFuIGl0ZW1cclxuXHQgKi9cclxuXHRkZWxldGUoa2V5OiBzdHJpbmcpOiB2b2lkIHtcclxuXHRcdGRlbGV0ZSB0aGlzLm1hcFtrZXldO1xyXG5cdH1cclxuXHJcblx0Ly8gQGltcGxlbWVudGVkXHJcblx0Y2xlYXIoKTogdm9pZCB7XHJcblx0XHR0aGlzLmZvckVhY2goa2V5ID0+IGRlbGV0ZSB0aGlzLm1hcFtrZXldKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnZlcnRzIHRoaXMgbWFwIHRvIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uLlxyXG5cdCAqIEByZXR1cm5zIFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBtYXAuXHJcblx0ICovXHJcblx0dG9TdHJpbmcoKTogc3RyaW5nIHtcclxuXHRcdGxldCBzdHIgPSBcIlwiO1xyXG5cclxuXHRcdHRoaXMuZm9yRWFjaCgoa2V5KSA9PiBzdHIgKz0ga2V5ICsgXCIgLT4gXCIgKyB0aGlzLmdldChrZXkpLnRvU3RyaW5nKCkgKyBcIlxcblwiKTtcclxuXHJcblx0XHRyZXR1cm4gc3RyO1xyXG5cdH1cclxufSIsImltcG9ydCBWZWMyIGZyb20gXCIuL1ZlYzJcIjtcclxuXHJcbi8qKiBBIDR4NCBtYXRyaXgwICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1hdDR4NCB7XHJcblx0cHJpdmF0ZSBtYXQ6IEZsb2F0MzJBcnJheTtcclxuXHJcblx0Y29uc3RydWN0b3IoKXtcclxuXHRcdHRoaXMubWF0ID0gbmV3IEZsb2F0MzJBcnJheShbXHJcblx0XHRcdDAsIDAsIDAsIDAsXHJcblx0XHRcdDAsIDAsIDAsIDAsXHJcblx0XHRcdDAsIDAsIDAsIDAsXHJcblx0XHRcdDAsIDAsIDAsIDBcclxuXHRcdF0pO1xyXG5cdH1cclxuXHJcblx0Ly8gU3RhdGljIG1lbWJlcnNcclxuXHRzdGF0aWMgZ2V0IElERU5USVRZKCk6IE1hdDR4NCB7XHJcblx0XHRyZXR1cm4gbmV3IE1hdDR4NCgpLmlkZW50aXR5KCk7XHJcblx0fVxyXG5cclxuXHRzdGF0aWMgZ2V0IFpFUk8oKTogTWF0NHg0IHtcclxuXHRcdHJldHVybiBuZXcgTWF0NHg0KCkuemVybygpO1xyXG5cdH1cclxuXHJcblx0Ly8gQWNjZXNzb3JzXHJcblx0c2V0IF8wMCh4OiBudW1iZXIpIHtcclxuXHRcdHRoaXMubWF0WzBdID0geDtcclxuXHR9XHJcblxyXG5cdHNldChjb2w6IG51bWJlciwgcm93OiBudW1iZXIsIHZhbHVlOiBudW1iZXIpOiBNYXQ0eDQge1xyXG5cdFx0aWYoY29sIDwgMCB8fCBjb2wgPiAzIHx8IHJvdyA8IDAgfHwgcm93ID4gMyl7XHJcblx0XHRcdHRocm93IGBFcnJvciAtIGluZGV4ICgke2NvbH0sICR7cm93fSkgaXMgb3V0IG9mIGJvdW5kcyBmb3IgTWF0NHg0YFxyXG5cdFx0fVxyXG5cdFx0dGhpcy5tYXRbcm93KjQgKyBjb2xdID0gdmFsdWU7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG5cclxuXHRnZXQoY29sOiBudW1iZXIsIHJvdzogbnVtYmVyKTogbnVtYmVyIHtcclxuXHRcdHJldHVybiB0aGlzLm1hdFtyb3cqNCArIGNvbF07XHJcblx0fVxyXG5cclxuXHRzZXRBbGwoLi4uaXRlbXM6IEFycmF5PG51bWJlcj4pOiBNYXQ0eDQge1xyXG5cdFx0dGhpcy5tYXQuc2V0KGl0ZW1zKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH1cclxuXHJcblx0aWRlbnRpdHkoKTogTWF0NHg0IHtcclxuXHRcdHJldHVybiB0aGlzLnNldEFsbChcclxuXHRcdFx0MSwgMCwgMCwgMCxcclxuXHRcdFx0MCwgMSwgMCwgMCxcclxuXHRcdFx0MCwgMCwgMSwgMCxcclxuXHRcdFx0MCwgMCwgMCwgMVxyXG5cdFx0KVxyXG5cdH1cclxuXHJcblx0emVybygpOiBNYXQ0eDQge1xyXG5cdFx0cmV0dXJuIHRoaXMuc2V0QWxsKFxyXG5cdFx0XHQwLCAwLCAwLCAwLFxyXG5cdFx0XHQwLCAwLCAwLCAwLFxyXG5cdFx0XHQwLCAwLCAwLCAwLFxyXG5cdFx0XHQwLCAwLCAwLCAwXHJcblx0XHQpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogTWFrZXMgdGhpcyBNYXQ0eDQgYSByb3RhdGlvbiBtYXRyaXggb2YgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgcmFkaWFucyBjY3dcclxuXHQgKiBAcGFyYW0gelJhZGlhbnMgVGhlIG51bWJlciBvZiByYWRpYW5zIHRvIHJvdGF0ZVxyXG5cdCAqIEByZXR1cm5zIHRoaXMgTWF0NHg0XHJcblx0ICovXHJcblx0cm90YXRlKHpSYWRpYW5zOiBudW1iZXIpOiBNYXQ0eDQge1xyXG5cdFx0cmV0dXJuIHRoaXMuc2V0QWxsKFxyXG5cdFx0XHRNYXRoLmNvcyh6UmFkaWFucyksIC1NYXRoLnNpbih6UmFkaWFucyksIFx0MCwgMCxcclxuXHRcdFx0TWF0aC5zaW4oelJhZGlhbnMpLCBNYXRoLmNvcyh6UmFkaWFucyksIFx0MCwgMCxcclxuXHRcdFx0MCwgXHRcdFx0XHRcdDAsIFx0XHRcdFx0XHRcdDEsIDAsXHJcblx0XHRcdDAsIFx0XHRcdFx0XHQwLCBcdFx0XHRcdFx0XHQwLCAxXHJcblx0XHQpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogVHVybnMgdGhpcyBNYXQ0eDQgaW50byBhIHRyYW5zbGF0aW9uIG1hdHJpeCBvZiB0aGUgc3BlY2lmaWVkIHRyYW5zbGF0aW9uXHJcblx0ICogQHBhcmFtIHRyYW5zbGF0aW9uIFRoZSB0cmFuc2xhdGlvbiBpbiB4IGFuZCB5XHJcblx0ICogQHJldHVybnMgdGhpcyBNYXQ0eDRcclxuXHQgKi9cclxuXHR0cmFuc2xhdGUodHJhbnNsYXRpb246IFZlYzIgfCBGbG9hdDMyQXJyYXkpOiBNYXQ0eDQge1xyXG5cdFx0Ly8gSWYgdHJhbnNsYXRpb24gaXMgYSB2ZWMsIGdldCBpdHMgYXJyYXlcclxuXHRcdGlmKHRyYW5zbGF0aW9uIGluc3RhbmNlb2YgVmVjMil7XHJcblx0XHRcdHRyYW5zbGF0aW9uID0gdHJhbnNsYXRpb24udG9BcnJheSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzLnNldEFsbChcclxuXHRcdFx0MSwgMCwgMCwgdHJhbnNsYXRpb25bMF0sXHJcblx0XHRcdDAsIDEsIDAsIHRyYW5zbGF0aW9uWzFdLFxyXG5cdFx0XHQwLCAwLCAxLCAwLFxyXG5cdFx0XHQwLCAwLCAwLCAxXHJcblx0XHQpO1xyXG5cdH1cclxuXHJcblx0c2NhbGUoc2NhbGU6IFZlYzIgfCBGbG9hdDMyQXJyYXkgfCBudW1iZXIpOiBNYXQ0eDQge1xyXG5cdFx0Ly8gTWFrZSBzdXJlIHNjYWxlIGlzIGEgZmxvYXQzMkFycmF5XHJcblx0XHRpZihzY2FsZSBpbnN0YW5jZW9mIFZlYzIpe1xyXG5cdFx0XHRzY2FsZSA9IHNjYWxlLnRvQXJyYXkoKTtcclxuXHRcdH0gZWxzZSBpZighKHNjYWxlIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5KSl7XHJcblx0XHRcdHNjYWxlID0gbmV3IEZsb2F0MzJBcnJheShbc2NhbGUsIHNjYWxlXSk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuc2V0QWxsKFxyXG5cdFx0XHRzY2FsZVswXSwgMCwgXHRcdDAsIDAsXHJcblx0XHRcdDAsIFx0XHQgIHNjYWxlWzFdLCAwLCAwLFxyXG5cdFx0XHQwLCBcdFx0ICAwLFx0XHQxLCAwLFxyXG5cdFx0XHQwLCBcdFx0ICAwLFx0XHQwLCAxXHJcblx0XHQpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyBhIG5ldyBNYXQ0eDQgdGhhdCByZXByZXNlbnRzIHRoZSByaWdodCBzaWRlIG11bHRpcGxpY2F0aW9uIFRISVMgeCBPVEhFUlxyXG5cdCAqIEBwYXJhbSBvdGhlciBUaGUgb3RoZXIgTWF0NHg0IHRvIG11bHRpcGx5IGJ5XHJcblx0ICogQHJldHVybnMgYSBuZXcgTWF0NHg0IGNvbnRhaW5pbmcgdGhlIHByb2R1Y3Qgb2YgdGhlc2UgdHdvIE1hdDR4NHNcclxuXHQgKi9cclxuXHRtdWx0KG90aGVyOiBNYXQ0eDQsIG91dD86IE1hdDR4NCk6IE1hdDR4NCB7XHJcblx0XHRsZXQgdGVtcCA9IG5ldyBGbG9hdDMyQXJyYXkoMTYpO1xyXG5cclxuXHRcdGZvcihsZXQgaSA9IDA7IGkgPCA0OyBpKyspe1xyXG5cdFx0XHRmb3IobGV0IGogPSAwOyBqIDwgNDsgaisrKXtcclxuXHRcdFx0XHRsZXQgdmFsdWUgPSAwO1xyXG5cdFx0XHRcdGZvcihsZXQgayA9IDA7IGsgPCA0OyBrKyspe1xyXG5cdFx0XHRcdFx0dmFsdWUgKz0gdGhpcy5nZXQoaywgaSkgKiBvdGhlci5nZXQoaiwgayk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHRlbXBbaio0ICsgaV0gID0gdmFsdWU7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZihvdXQgIT09IHVuZGVmaW5lZCl7XHJcblx0XHRcdHJldHVybiBvdXQuc2V0QWxsKC4uLnRlbXApO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cmV0dXJuIG5ldyBNYXQ0eDQoKS5zZXRBbGwoLi4udGVtcCk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBNdWx0aXBsaWVzIGFsbCBnaXZlbiBtYXRyaWNpZXMgaW4gb3JkZXIuIGUuZy4gTVVMVChBLCBCLCBDKSAtPiBBKkIqQ1xyXG5cdCAqIEBwYXJhbSBtYXRzIEEgbGlzdCBvZiBNYXQ0eDRzIHRvIG11bHRpcGx5IGluIG9yZGVyXHJcblx0ICogQHJldHVybnMgQSBuZXcgTWF0NHg0IGhvbGRpbmcgdGhlIHJlc3VsdCBvZiB0aGUgb3BlcmF0aW9uXHJcblx0ICovXHJcblx0c3RhdGljIE1VTFQoLi4ubWF0czogQXJyYXk8TWF0NHg0Pik6IE1hdDR4NCB7XHJcblx0XHQvLyBDcmVhdGUgYSBuZXcgYXJyYXlcclxuXHRcdGxldCB0ZW1wID0gTWF0NHg0LklERU5USVRZO1xyXG5cclxuXHRcdC8vIE11bHRpcGx5IGJ5IGV2ZXJ5IGFycmF5IGluIG9yZGVyLCBpbiBwbGFjZVxyXG5cdFx0Zm9yKGxldCBpID0gMDsgaSA8IG1hdHMubGVuZ3RoOyBpKyspe1xyXG5cdFx0XHR0ZW1wLm11bHQobWF0c1tpXSwgdGVtcCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRlbXA7XHJcblx0fVxyXG5cclxuXHR0b0FycmF5KCk6IEZsb2F0MzJBcnJheSB7XHJcblx0XHRyZXR1cm4gdGhpcy5tYXQ7XHJcblx0fVxyXG5cclxuXHR0b1N0cmluZygpOiBzdHJpbmcge1xyXG5cdFx0cmV0dXJuICBgfCR7dGhpcy5tYXRbMF0udG9GaXhlZCgyKX0sICR7dGhpcy5tYXRbMV0udG9GaXhlZCgyKX0sICR7dGhpcy5tYXRbMl0udG9GaXhlZCgyKX0sICR7dGhpcy5tYXRbM10udG9GaXhlZCgyKX18XFxuYCArIFxyXG5cdFx0XHRcdGB8JHt0aGlzLm1hdFs0XS50b0ZpeGVkKDIpfSwgJHt0aGlzLm1hdFs1XS50b0ZpeGVkKDIpfSwgJHt0aGlzLm1hdFs2XS50b0ZpeGVkKDIpfSwgJHt0aGlzLm1hdFs3XS50b0ZpeGVkKDIpfXxcXG5gICtcclxuXHRcdFx0XHRgfCR7dGhpcy5tYXRbOF0udG9GaXhlZCgyKX0sICR7dGhpcy5tYXRbOV0udG9GaXhlZCgyKX0sICR7dGhpcy5tYXRbMTBdLnRvRml4ZWQoMil9LCAke3RoaXMubWF0WzExXS50b0ZpeGVkKDIpfXxcXG5gICtcclxuXHRcdFx0XHRgfCR7dGhpcy5tYXRbMTJdLnRvRml4ZWQoMil9LCAke3RoaXMubWF0WzEzXS50b0ZpeGVkKDIpfSwgJHt0aGlzLm1hdFsxNF0udG9GaXhlZCgyKX0sICR7dGhpcy5tYXRbMTVdLnRvRml4ZWQoMil9fGA7XHJcblx0fVxyXG59IiwiaW1wb3J0IFBoeXNpY2FsIGZyb20gXCIuLi9JbnRlcmZhY2VzL1BoeXNpY2FsXCI7XHJcbmltcG9ydCBBQUJCIGZyb20gXCIuLi9TaGFwZXMvQUFCQlwiO1xyXG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vVmVjMlwiO1xyXG5pbXBvcnQgSGl0IGZyb20gXCIuL0hpdFwiO1xyXG5cclxuLyoqXHJcbiAqIEEgY2xhc3MgdGhhdCBjb250YWlucyB0aGUgYXJlYSBvZiBvdmVybGFwIG9mIHR3byBjb2xsaWRpbmcgb2JqZWN0cyB0byBhbGxvdyBmb3Igc29ydGluZyBieSB0aGUgcGh5c2ljcyBzeXN0ZW0uXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBcmVhQ29sbGlzaW9uIHtcclxuICAgIC8qKiBUaGUgYXJlYSBvZiB0aGUgb3ZlcmxhcCBmb3IgdGhlIGNvbGxpZGluZyBvYmplY3RzICovXHJcbiAgICBhcmVhOiBudW1iZXI7XHJcblxyXG4gICAgLyoqIFRoZSBBQUJCIG9mIHRoZSBvdGhlciBjb2xsaWRlciBpbiB0aGlzIGNvbGxpc2lvbiAqL1xyXG4gICAgY29sbGlkZXI6IEFBQkI7XHJcblxyXG4gICAgLyoqIFR5cGUgb2YgdGhlIGNvbGxpc2lvbiAqL1xyXG4gICAgdHlwZTogc3RyaW5nO1xyXG5cclxuICAgIC8qKiBUaGVyIG90aGVyIG9iamVjdCBpbiB0aGUgY29sbGlzaW9uICovXHJcbiAgICBvdGhlcjogUGh5c2ljYWw7XHJcblxyXG4gICAgLyoqIFRoZSB0aWxlLCBpZiB0aGlzIHdhcyBhIHRpbGVtYXAgY29sbGlzaW9uICovXHJcbiAgICB0aWxlOiBWZWMyO1xyXG5cclxuICAgIC8qKiBUaGUgcGh5c2ljcyBoaXQgZm9yIHRoaXMgb2JqZWN0ICovXHJcbiAgICBoaXQ6IEhpdDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgQXJlYUNvbGxpc2lvbiBvYmplY3RcclxuICAgICAqIEBwYXJhbSBhcmVhIFRoZSBhcmVhIG9mIHRoZSBjb2xsaXNpb25cclxuICAgICAqIEBwYXJhbSBjb2xsaWRlciBUaGUgb3RoZXIgY29sbGlkZXJcclxuICAgICAqL1xyXG5cdGNvbnN0cnVjdG9yKGFyZWE6IG51bWJlciwgY29sbGlkZXI6IEFBQkIsIG90aGVyOiBQaHlzaWNhbCwgdHlwZTogc3RyaW5nLCB0aWxlOiBWZWMyKXtcclxuXHRcdHRoaXMuYXJlYSA9IGFyZWE7XHJcbiAgICAgICAgdGhpcy5jb2xsaWRlciA9IGNvbGxpZGVyO1xyXG4gICAgICAgIHRoaXMub3RoZXIgPSBvdGhlcjtcclxuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xyXG4gICAgICAgIHRoaXMudGlsZSA9IHRpbGU7XHJcblx0fVxyXG59IiwiaW1wb3J0IFZlYzIgZnJvbSBcIi4uL1ZlYzJcIjtcclxuXHJcbi8qKlxyXG4gKiBBbiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBkYXRhIGNvbGxlY3RlZCBmcm9tIGEgcGh5c2ljcyBoaXQgYmV0d2VlbiB0d28gZ2VvbWV0cmljIG9iamVjdHMuXHJcbiAqIEluc3BpcmVkIGJ5IHRoZSBoZWxwZnVsIGNvbGxpc2lvbiBkb2N1bWVudGF0aW9uIEBsaW5rKGhlcmUpKGh0dHBzOi8vbm9vbmF0LmdpdGh1Yi5pby9pbnRlcnNlY3QvKS5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEhpdCB7XHJcbiAgICAvKiogVGhlIHRpbWUgb2YgdGhlIGNvbGxpc2lvbi4gT25seSBudW1iZXJzIDAgdGhyb3VnaCAxIGhhcHBlbiBpbiB0aGlzIGZyYW1lLiAqL1xyXG4gICAgdGltZTogbnVtYmVyO1xyXG4gICAgLyoqIFRoZSBuZWFyIHRpbWVzIG9mIHRoZSBjb2xsaXNpb24gKi9cclxuICAgIG5lYXJUaW1lczogVmVjMiA9IFZlYzIuWkVSTztcclxuICAgIC8qKiBUaGUgcG9zaXRpb24gb2YgdGhlIGNvbGxpc2lvbiAqL1xyXG4gICAgcG9zOiBWZWMyID0gVmVjMi5aRVJPO1xyXG4gICAgLyoqIFRoZSBvdmVybGFwIGRpc3RhbmNlIG9mIHRoZSBoaXQgKi9cclxuICAgIGRlbHRhOiBWZWMyID0gVmVjMi5aRVJPO1xyXG4gICAgLyoqIFRoZSBub3JtYWwgdmVjdG9yIG9mIHRoZSBoaXQgKi9cclxuICAgIG5vcm1hbDogVmVjMiA9IFZlYzIuWkVSTztcclxufSIsImltcG9ydCBDb2xsZWN0aW9uIGZyb20gXCIuL0NvbGxlY3Rpb25cIjtcclxuXHJcbi8qKlxyXG4gKiBBIEZJRk8gcXVldWUgd2l0aCBlbGVtZW50cyBvZiB0eXBlIFRcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFF1ZXVlPFQ+IGltcGxlbWVudHMgQ29sbGVjdGlvbiB7XHJcbiAgICAvKiogVGhlIG1heGltdW0gbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBRdWV1ZSAqL1xyXG4gICAgcHJpdmF0ZSByZWFkb25seSBNQVhfRUxFTUVOVFM6IG51bWJlcjtcclxuXHJcbiAgICAvKiogVGhlIGludGVybmFsIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBxdWV1ZSAqL1xyXG4gICAgcHJpdmF0ZSBxOiBBcnJheTxUPjtcclxuICAgIFxyXG4gICAgLyoqIFRoZSBoZWFkIG9mIHRoZSBxdWV1ZSAqL1xyXG4gICAgcHJpdmF0ZSBoZWFkOiBudW1iZXI7XHJcbiAgICBcclxuICAgIC8qKiBUaGUgdGFpbCBvZiB0aGUgcXVldWUgKi9cclxuICAgIHByaXZhdGUgdGFpbDogbnVtYmVyO1xyXG5cclxuICAgIC8qKiBUaGUgY3VycmVudCBudW1iZXIgb2YgaXRlbXMgaW4gdGhlIHF1ZXVlICovXHJcbiAgICBwcml2YXRlIHNpemU6IG51bWJlcjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnN0cnVjdHMgYSBuZXcgcXVldWVcclxuICAgICAqIEBwYXJhbSBtYXhFbGVtZW50cyBUaGUgbWF4aW11bSBzaXplIG9mIHRoZSBzdGFja1xyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihtYXhFbGVtZW50czogbnVtYmVyID0gMTAwKXtcclxuICAgICAgICB0aGlzLk1BWF9FTEVNRU5UUyA9IG1heEVsZW1lbnRzO1xyXG4gICAgICAgIHRoaXMucSA9IG5ldyBBcnJheSh0aGlzLk1BWF9FTEVNRU5UUyk7XHJcbiAgICAgICAgdGhpcy5oZWFkID0gMDtcclxuICAgICAgICB0aGlzLnRhaWwgPSAwO1xyXG4gICAgICAgIHRoaXMuc2l6ZSA9IDA7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGFuIGl0ZW0gdG8gdGhlIGJhY2sgb2YgdGhlIHF1ZXVlXHJcbiAgICAgKiBAcGFyYW0gaXRlbSBUaGUgaXRlbSB0byBhZGQgdG8gdGhlIGJhY2sgb2YgdGhlIHF1ZXVlXHJcbiAgICAgKi9cclxuICAgIGVucXVldWUoaXRlbTogVCk6IHZvaWR7XHJcbiAgICAgICAgaWYoKHRoaXMudGFpbCArIDEpICUgdGhpcy5NQVhfRUxFTUVOVFMgPT09IHRoaXMuaGVhZCl7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlF1ZXVlIGZ1bGwgLSBjYW5ub3QgYWRkIGVsZW1lbnRcIik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnNpemUgKz0gMTtcclxuICAgICAgICB0aGlzLnFbdGhpcy50YWlsXSA9IGl0ZW07XHJcbiAgICAgICAgdGhpcy50YWlsID0gKHRoaXMudGFpbCArIDEpICUgdGhpcy5NQVhfRUxFTUVOVFM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyaWV2ZXMgYW4gaXRlbSBmcm9tIHRoZSBmcm9udCBvZiB0aGUgcXVldWVcclxuICAgICAqIEByZXR1cm5zIFRoZSBpdGVtIGF0IHRoZSBmcm9udCBvZiB0aGUgcXVldWVcclxuICAgICAqL1xyXG4gICAgZGVxdWV1ZSgpOiBUIHtcclxuICAgICAgICBpZih0aGlzLmhlYWQgPT09IHRoaXMudGFpbCl7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlF1ZXVlIGVtcHR5IC0gY2Fubm90IHJlbW92ZSBlbGVtZW50XCIpO1xyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIHRoaXMuc2l6ZSAtPSAxO1xyXG4gICAgICAgIGxldCBpdGVtID0gdGhpcy5xW3RoaXMuaGVhZF07XHJcbiAgICAgICAgLy8gTm93IGRlbGV0ZSB0aGUgaXRlbVxyXG4gICAgICAgIGRlbGV0ZSB0aGlzLnFbdGhpcy5oZWFkXTtcclxuICAgICAgICB0aGlzLmhlYWQgPSAodGhpcy5oZWFkICsgMSkgJSB0aGlzLk1BWF9FTEVNRU5UUztcclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gaXRlbTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGl0ZW0gYXQgdGhlIGZyb250IG9mIHRoZSBxdWV1ZSwgYnV0IGRvZXMgbm90IHJlbW92ZSBpdFxyXG4gICAgICogQHJldHVybnMgVGhlIGl0ZW0gYXQgdGhlIGZyb250IG9mIHRoZSBxdWV1ZVxyXG4gICAgICovXHJcbiAgICBwZWVrTmV4dCgpOiBUIHtcclxuICAgICAgICBpZih0aGlzLmhlYWQgPT09IHRoaXMudGFpbCl7XHJcbiAgICAgICAgICAgIHRocm93IFwiUXVldWUgZW1wdHkgLSBjYW5ub3QgZ2V0IGVsZW1lbnRcIlxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IGl0ZW0gPSB0aGlzLnFbdGhpcy5oZWFkXTtcclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gaXRlbTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcXVldWUgaGFzIGl0ZW1zIGluIGl0LCBmYWxzZSBvdGhlcndpc2VcclxuICAgICAqIEByZXR1cm5zIEEgYm9vbGVhbiByZXByZXNlbnRpbmcgd2hldGhlciBvciBub3QgdGhpcyBxdWV1ZSBoYXMgaXRlbXNcclxuICAgICAqL1xyXG4gICAgaGFzSXRlbXMoKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaGVhZCAhPT0gdGhpcy50YWlsO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBxdWV1ZS5cclxuICAgICAqIEByZXR1cm5zIFRoZSBzaXplIG9mIHRoZSBxdWV1ZVxyXG4gICAgICovXHJcbiAgICBnZXRTaXplKCk6IG51bWJlciB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2l6ZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBAaW1wbGVtZW50ZWRcclxuICAgIGNsZWFyKCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IGRlbGV0ZSB0aGlzLnFbaW5kZXhdKTtcclxuICAgICAgICB0aGlzLnNpemUgPSAwO1xyXG4gICAgICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBAaW1wbGVtZW50ZWRcclxuICAgIGZvckVhY2goZnVuYzogKGl0ZW06IFQsIGluZGV4PzogbnVtYmVyKSA9PiB2b2lkKTogdm9pZCB7XHJcbiAgICAgICAgbGV0IGkgPSB0aGlzLmhlYWQ7XHJcbiAgICAgICAgd2hpbGUoaSAhPT0gdGhpcy50YWlsKXtcclxuICAgICAgICAgICAgZnVuYyh0aGlzLnFbaV0sIGkpO1xyXG4gICAgICAgICAgICBpID0gKGkgKyAxKSAlIHRoaXMuTUFYX0VMRU1FTlRTO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIHRoaXMgcXVldWUgaW50byBhIHN0cmluZyBmb3JtYXRcclxuICAgICAqIEByZXR1cm5zIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGlzIHF1ZXVlXHJcbiAgICAgKi9cclxuICAgIHRvU3RyaW5nKCk6IHN0cmluZyB7XHJcbiAgICAgICAgbGV0IHJldHZhbCA9IFwiXCI7XHJcblxyXG4gICAgICAgIHRoaXMuZm9yRWFjaCggKGl0ZW0sIGluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBzdHIgPSBpdGVtLnRvU3RyaW5nKClcclxuICAgICAgICAgICAgaWYoaW5kZXggIT09IDApe1xyXG4gICAgICAgICAgICAgICAgc3RyICs9IFwiIC0+IFwiXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dmFsID0gc3RyICsgcmV0dmFsO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gXCJUb3AgLT4gXCIgKyByZXR2YWw7XHJcbiAgICB9XHJcbn0iLCIvKiogQSBjb250YWluZXIgZm9yIGluZm8gYWJvdXQgYSB3ZWJHTCBzaGFkZXIgcHJvZ3JhbSAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXZWJHTFByb2dyYW1UeXBlIHtcclxuXHQvKiogQSB3ZWJHTCBwcm9ncmFtICovXHJcblx0cHJvZ3JhbTogV2ViR0xQcm9ncmFtO1xyXG5cdFxyXG5cdC8qKiBBIHZlcnRleCBzaGFkZXIgKi9cclxuXHR2ZXJ0ZXhTaGFkZXI6IFdlYkdMU2hhZGVyO1xyXG5cclxuXHQvKiogQSBmcmFnbWVudCBzaGFkZXIgKi9cclxuXHRmcmFnbWVudFNoYWRlcjogV2ViR0xTaGFkZXI7XHJcblxyXG5cdC8qKlxyXG5cdCAqIERlbGV0ZXMgdGhpcyBzaGFkZXIgcHJvZ3JhbVxyXG5cdCAqL1xyXG5cdGRlbGV0ZShnbDogV2ViR0xSZW5kZXJpbmdDb250ZXh0KTogdm9pZCB7XHJcblx0XHQvLyBDbGVhbiB1cCBhbGwgYXNwZWN0cyBvZiB0aGlzIHByb2dyYW1cclxuXHRcdGlmKHRoaXMucHJvZ3JhbSl7XHJcblx0XHRcdGdsLmRlbGV0ZVByb2dyYW0odGhpcy5wcm9ncmFtKTtcclxuXHRcdH1cclxuXHRcdFx0XHJcblx0XHRpZih0aGlzLnZlcnRleFNoYWRlcil7XHJcblx0XHRcdGdsLmRlbGV0ZVNoYWRlcih0aGlzLnZlcnRleFNoYWRlcik7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYodGhpcy5mcmFnbWVudFNoYWRlcil7XHJcblx0XHRcdGdsLmRlbGV0ZVNoYWRlcih0aGlzLmZyYWdtZW50U2hhZGVyKTtcclxuXHRcdH1cclxuXHR9XHJcbn0iLCJpbXBvcnQgU2hhcGUgZnJvbSBcIi4vU2hhcGVcIjtcclxuaW1wb3J0IFZlYzIgZnJvbSBcIi4uL1ZlYzJcIjtcclxuaW1wb3J0IE1hdGhVdGlscyBmcm9tIFwiLi4vLi4vVXRpbHMvTWF0aFV0aWxzXCI7XHJcbmltcG9ydCBDaXJjbGUgZnJvbSBcIi4vQ2lyY2xlXCI7XHJcbmltcG9ydCBIaXQgZnJvbSBcIi4uL1BoeXNpY3MvSGl0XCI7XHJcblxyXG4vKipcclxuICogQW4gQXhpcy1BbGlnbmVkIEJvdW5kaW5nIEJveC4gSW4gb3RoZXIgd29yZHMsIGEgcmVjdGFuZ2xlIHRoYXQgaXMgYWx3YXlzIGFsaWduZWQgdG8gdGhlIHgteSBncmlkLlxyXG4gKiBJbnNwaXJlZCBieSB0aGUgaGVscGZ1bCBjb2xsaXNpb24gZG9jdW1lbnRhdGlvbiBAbGluayhoZXJlKShodHRwczovL25vb25hdC5naXRodWIuaW8vaW50ZXJzZWN0LykuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBQUJCIGV4dGVuZHMgU2hhcGUge1xyXG4gICAgY2VudGVyOiBWZWMyO1xyXG4gICAgaGFsZlNpemU6IFZlYzI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IEFBQkJcclxuICAgICAqIEBwYXJhbSBjZW50ZXIgVGhlIGNlbnRlciBvZiB0aGUgQUFCQlxyXG4gICAgICogQHBhcmFtIGhhbGZTaXplIFRoZSBoYWxmIHNpemUgb2YgdGhlIEFBQkIgLSBUaGUgZGlzdGFuY2UgZnJvbSB0aGUgY2VudGVyIHRvIGFuIGVkZ2UgaW4geCBhbmQgeVxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihjZW50ZXI/OiBWZWMyLCBoYWxmU2l6ZT86IFZlYzIpe1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5jZW50ZXIgPSBjZW50ZXIgPyBjZW50ZXIgOiBuZXcgVmVjMigwLCAwKTtcclxuICAgICAgICB0aGlzLmhhbGZTaXplID0gaGFsZlNpemUgPyBoYWxmU2l6ZSA6IG5ldyBWZWMyKDAsIDApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBSZXR1cm5zIGEgcG9pbnQgcmVwcmVzZW50aW5nIHRoZSB0b3AgbGVmdCBjb3JuZXIgb2YgdGhlIEFBQkIgKi9cclxuICAgIGdldCB0b3BMZWZ0KCk6IFZlYzIge1xyXG4gICAgICAgIHJldHVybiBuZXcgVmVjMih0aGlzLmxlZnQsIHRoaXMudG9wKVxyXG4gICAgfVxyXG5cclxuICAgIC8qKiBSZXR1cm5zIGEgcG9pbnQgcmVwcmVzZW50aW5nIHRoZSB0b3AgcmlnaHQgY29ybmVyIG9mIHRoZSBBQUJCICovXHJcbiAgICBnZXQgdG9wUmlnaHQoKTogVmVjMiB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBWZWMyKHRoaXMucmlnaHQsIHRoaXMudG9wKVxyXG4gICAgfVxyXG5cclxuICAgIC8qKiBSZXR1cm5zIGEgcG9pbnQgcmVwcmVzZW50aW5nIHRoZSBib3R0b20gbGVmdCBjb3JuZXIgb2YgdGhlIEFBQkIgKi9cclxuICAgIGdldCBib3R0b21MZWZ0KCk6IFZlYzIge1xyXG4gICAgICAgIHJldHVybiBuZXcgVmVjMih0aGlzLmxlZnQsIHRoaXMuYm90dG9tKVxyXG4gICAgfVxyXG5cclxuICAgIC8qKiBSZXR1cm5zIGEgcG9pbnQgcmVwcmVzZW50aW5nIHRoZSBib3R0b20gcmlnaHQgY29ybmVyIG9mIHRoZSBBQUJCICovXHJcbiAgICBnZXQgYm90dG9tUmlnaHQoKTogVmVjMiB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBWZWMyKHRoaXMucmlnaHQsIHRoaXMuYm90dG9tKVxyXG4gICAgfVxyXG5cclxuICAgIC8vIEBvdmVycmlkZVxyXG4gICAgZ2V0Qm91bmRpbmdSZWN0KCk6IEFBQkIge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQG92ZXJyaWRlXHJcbiAgICBnZXRCb3VuZGluZ0NpcmNsZSgpOiBDaXJjbGUge1xyXG4gICAgICAgIGxldCByID0gTWF0aC5tYXgodGhpcy5odywgdGhpcy5oaClcclxuICAgICAgICByZXR1cm4gbmV3IENpcmNsZSh0aGlzLmNlbnRlci5jbG9uZSgpLCByKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBAZGVwcmVjYXRlZFxyXG4gICAgZ2V0SGFsZlNpemUoKTogVmVjMiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFsZlNpemU7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQGRlcHJlY2F0ZWRcclxuICAgIHNldEhhbGZTaXplKGhhbGZTaXplOiBWZWMyKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5oYWxmU2l6ZSA9IGhhbGZTaXplO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFRPRE8gLSBtb3ZlIHRoZXNlIGFsbCB0byB0aGUgU2hhcGUgY2xhc3NcclxuICAgIC8qKlxyXG4gICAgICogQSBzaW1wbGUgYm9vbGVhbiBjaGVjayBvZiB3aGV0aGVyIHRoaXMgQUFCQiBjb250YWlucyBhIHBvaW50XHJcbiAgICAgKiBAcGFyYW0gcG9pbnQgVGhlIHBvaW50IHRvIGNoZWNrXHJcbiAgICAgKiBAcmV0dXJucyBBIGJvb2xlYW4gcmVwcmVzZW50aW5nIHdoZXRoZXIgdGhpcyBBQUJCIGNvbnRhaW5zIHRoZSBzcGVjaWZpZWQgcG9pbnRcclxuICAgICAqL1xyXG4gICAgY29udGFpbnNQb2ludChwb2ludDogVmVjMik6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiBwb2ludC54ID49IHRoaXMueCAtIHRoaXMuaHcgJiYgcG9pbnQueCA8PSB0aGlzLnggKyB0aGlzLmh3XHJcbiAgICAgICAgICAgICYmIHBvaW50LnkgPj0gdGhpcy55IC0gdGhpcy5oaCAmJiBwb2ludC55IDw9IHRoaXMueSArIHRoaXMuaGhcclxuICAgIH1cclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgKiBBIHNpbXBsZSBib29sZWFuIGNoZWNrIG9mIHdoZXRoZXIgdGhpcyBBQUJCIGNvbnRhaW5zIGEgcG9pbnRcclxuICAgICAqIEBwYXJhbSBwb2ludCBUaGUgcG9pbnQgdG8gY2hlY2tcclxuICAgICAqIEByZXR1cm5zIEEgYm9vbGVhbiByZXByZXNlbnRpbmcgd2hldGhlciB0aGlzIEFBQkIgY29udGFpbnMgdGhlIHNwZWNpZmllZCBwb2ludFxyXG4gICAgICovXHJcbiAgICBpbnRlcnNlY3RQb2ludChwb2ludDogVmVjMik6IGJvb2xlYW4ge1xyXG4gICAgICAgIGxldCBkeCA9IHBvaW50LnggLSB0aGlzLng7XHJcbiAgICAgICAgbGV0IHB4ID0gdGhpcy5odyAtIE1hdGguYWJzKGR4KTtcclxuICAgICAgICBcclxuICAgICAgICBpZihweCA8PSAwKXtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IGR5ID0gcG9pbnQueSAtIHRoaXMueTtcclxuICAgICAgICBsZXQgcHkgPSB0aGlzLmhoIC0gTWF0aC5hYnMoZHkpO1xyXG5cclxuICAgICAgICBpZihweSA8PSAwKXtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGJvb2xlYW4gY2hlY2sgb2Ygd2hldGhlciB0aGlzIEFBQkIgY29udGFpbnMgYSBwb2ludCB3aXRoIHNvZnQgbGVmdCBhbmQgdG9wIGJvdW5kYXJpZXMuXHJcbiAgICAgKiBJbiBvdGhlciB3b3JkcywgaWYgdGhlIHRvcCBsZWZ0IGlzICgwLCAwKSwgdGhlIHBvaW50ICgwLCAwKSBpcyBub3QgaW4gdGhlIEFBQkJcclxuICAgICAqIEBwYXJhbSBwb2ludCBUaGUgcG9pbnQgdG8gY2hlY2tcclxuICAgICAqIEByZXR1cm5zIEEgYm9vbGVhbiByZXByZXNlbnRpbmcgd2hldGhlciB0aGlzIEFBQkIgY29udGFpbnMgdGhlIHNwZWNpZmllZCBwb2ludFxyXG4gICAgICovXHJcbiAgICBjb250YWluc1BvaW50U29mdChwb2ludDogVmVjMik6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiBwb2ludC54ID4gdGhpcy54IC0gdGhpcy5odyAmJiBwb2ludC54IDw9IHRoaXMueCArIHRoaXMuaHdcclxuICAgICAgICAgICAgJiYgcG9pbnQueSA+IHRoaXMueSAtIHRoaXMuaGggJiYgcG9pbnQueSA8PSB0aGlzLnkgKyB0aGlzLmhoXHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgZGF0YSBmcm9tIHRoZSBpbnRlcnNlY3Rpb24gb2YgdGhpcyBBQUJCIHdpdGggYSBsaW5lIHNlZ21lbnQgZnJvbSBhIHBvaW50IGluIGEgZGlyZWN0aW9uXHJcbiAgICAgKiBAcGFyYW0gcG9pbnQgVGhlIHBvaW50IHRoYXQgdGhlIGxpbmUgc2VnbWVudCBzdGFydHMgZnJvbVxyXG4gICAgICogQHBhcmFtIGRlbHRhIFRoZSBkaXJlY3Rpb24gYW5kIGRpc3RhbmNlIG9mIHRoZSBzZWdtZW50XHJcbiAgICAgKiBAcGFyYW0gcGFkZGluZyBQYWRzIHRoZSBBQUJCIHRvIG1ha2UgaXQgd2lkZXIgZm9yIHRoZSBpbnRlcnNlY3Rpb24gdGVzdFxyXG4gICAgICogQHJldHVybnMgVGhlIEhpdCBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBpbnRlcnNlY3Rpb24sIG9yIG51bGwgaWYgdGhlcmUgd2FzIG5vIGludGVyc2VjdGlvblxyXG4gICAgICovXHJcbiAgICBpbnRlcnNlY3RTZWdtZW50KHBvaW50OiBWZWMyLCBkZWx0YTogVmVjMiwgcGFkZGluZz86IFZlYzIpOiBIaXQge1xyXG4gICAgICAgIGxldCBwYWRkaW5nWCA9IHBhZGRpbmcgPyBwYWRkaW5nLnggOiAwO1xyXG4gICAgICAgIGxldCBwYWRkaW5nWSA9IHBhZGRpbmcgPyBwYWRkaW5nLnkgOiAwO1xyXG5cclxuICAgICAgICBsZXQgc2NhbGVYID0gMS9kZWx0YS54O1xyXG4gICAgICAgIGxldCBzY2FsZVkgPSAxL2RlbHRhLnk7XHJcblxyXG4gICAgICAgIGxldCBzaWduWCA9IE1hdGhVdGlscy5zaWduKHNjYWxlWCk7XHJcbiAgICAgICAgbGV0IHNpZ25ZID0gTWF0aFV0aWxzLnNpZ24oc2NhbGVZKTtcclxuXHJcbiAgICAgICAgbGV0IHRuZWFyeCA9IHNjYWxlWCoodGhpcy54IC0gc2lnblgqKHRoaXMuaHcgKyBwYWRkaW5nWCkgLSBwb2ludC54KTtcclxuICAgICAgICBsZXQgdG5lYXJ5ID0gc2NhbGVZKih0aGlzLnkgLSBzaWduWSoodGhpcy5oaCArIHBhZGRpbmdZKSAtIHBvaW50LnkpO1xyXG4gICAgICAgIGxldCB0ZmFyeCA9IHNjYWxlWCoodGhpcy54ICsgc2lnblgqKHRoaXMuaHcgKyBwYWRkaW5nWCkgLSBwb2ludC54KTtcclxuICAgICAgICBsZXQgdGZhcnkgPSBzY2FsZVkqKHRoaXMueSArIHNpZ25ZKih0aGlzLmhoICsgcGFkZGluZ1kpIC0gcG9pbnQueSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYodG5lYXJ4ID4gdGZhcnkgfHwgdG5lYXJ5ID4gdGZhcngpe1xyXG4gICAgICAgICAgICAvLyBXZSBhcmVuJ3QgY29sbGlkaW5nIC0gd2UgY2xlYXIgb25lIGF4aXMgYmVmb3JlIGludGVyc2VjdGluZyBhbm90aGVyXHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IHRuZWFyID0gTWF0aC5tYXgodG5lYXJ4LCB0bmVhcnkpO1xyXG5cclxuICAgICAgICAvLyBEb3VibGUgY2hlY2sgZm9yIE5hTnNcclxuICAgICAgICBpZih0bmVhcnggIT09IHRuZWFyeCl7XHJcbiAgICAgICAgICAgIHRuZWFyID0gdG5lYXJ5O1xyXG4gICAgICAgIH0gZWxzZSBpZiAodG5lYXJ5ICE9PSB0bmVhcnkpe1xyXG4gICAgICAgICAgICB0bmVhciA9IHRuZWFyeDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCB0ZmFyID0gTWF0aC5taW4odGZhcngsIHRmYXJ5KTtcclxuXHJcbiAgICAgICAgaWYodG5lYXIgPT09IC1JbmZpbml0eSl7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYodG5lYXIgPj0gMSB8fCB0ZmFyIDw9IDApe1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFdlIGFyZSBjb2xsaWRpbmdcclxuICAgICAgICBsZXQgaGl0ID0gbmV3IEhpdCgpO1xyXG4gICAgICAgIGhpdC50aW1lID0gTWF0aFV0aWxzLmNsYW1wMDEodG5lYXIpO1xyXG4gICAgICAgIGhpdC5uZWFyVGltZXMueCA9IHRuZWFyeDtcclxuICAgICAgICBoaXQubmVhclRpbWVzLnkgPSB0bmVhcnk7XHJcblxyXG4gICAgICAgIGlmKHRuZWFyeCA+IHRuZWFyeSl7XHJcbiAgICAgICAgICAgIC8vIFdlIGhpdCBvbiB0aGUgbGVmdCBvciByaWdodCBzaXplXHJcbiAgICAgICAgICAgIGhpdC5ub3JtYWwueCA9IC1zaWduWDtcclxuICAgICAgICAgICAgaGl0Lm5vcm1hbC55ID0gMDtcclxuICAgICAgICB9IGVsc2UgaWYoTWF0aC5hYnModG5lYXJ4IC0gdG5lYXJ5KSA8IDAuMDAwMSl7XHJcbiAgICAgICAgICAgIC8vIFdlIGhpdCBvbiB0aGUgY29ybmVyXHJcbiAgICAgICAgICAgIGhpdC5ub3JtYWwueCA9IC1zaWduWDtcclxuICAgICAgICAgICAgaGl0Lm5vcm1hbC55ID0gLXNpZ25ZO1xyXG4gICAgICAgICAgICBoaXQubm9ybWFsLm5vcm1hbGl6ZSgpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIFdlIGhpdCBvbiB0aGUgdG9wIG9yIGJvdHRvbVxyXG4gICAgICAgICAgICBoaXQubm9ybWFsLnggPSAwO1xyXG4gICAgICAgICAgICBoaXQubm9ybWFsLnkgPSAtc2lnblk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBoaXQuZGVsdGEueCA9ICgxLjAgLSBoaXQudGltZSkgKiAtZGVsdGEueDtcclxuICAgICAgICBoaXQuZGVsdGEueSA9ICgxLjAgLSBoaXQudGltZSkgKiAtZGVsdGEueTtcclxuICAgICAgICBoaXQucG9zLnggPSBwb2ludC54ICsgZGVsdGEueCAqIGhpdC50aW1lO1xyXG4gICAgICAgIGhpdC5wb3MueSA9IHBvaW50LnkgKyBkZWx0YS55ICogaGl0LnRpbWU7XHJcblxyXG4gICAgICAgIHJldHVybiBoaXQ7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQG92ZXJyaWRlXHJcbiAgICBvdmVybGFwcyhvdGhlcjogU2hhcGUpOiBib29sZWFuIHtcclxuICAgICAgICBpZihvdGhlciBpbnN0YW5jZW9mIEFBQkIpe1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vdmVybGFwc0FBQkIob3RoZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aHJvdyBcIk92ZXJsYXAgbm90IGRlZmluZWQgYmV0d2VlbiB0aGVzZSBzaGFwZXMuXCJcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgc2ltcGxlIGJvb2xlYW4gY2hlY2sgb2Ygd2hldGhlciB0aGlzIEFBQkIgb3ZlcmxhcHMgYW5vdGhlclxyXG4gICAgICogQHBhcmFtIG90aGVyIFRoZSBvdGhlciBBQUJCIHRvIGNoZWNrIGFnYWluc3RcclxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhpcyBBQUJCIG92ZXJsYXBzIHRoZSBvdGhlciwgZmFsc2Ugb3RoZXJ3aXNlXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBvdmVybGFwc0FBQkIob3RoZXI6IEFBQkIpOiBib29sZWFuIHtcclxuICAgICAgICBsZXQgZHggPSBvdGhlci54IC0gdGhpcy54O1xyXG4gICAgICAgIGxldCBweCA9IHRoaXMuaHcgKyBvdGhlci5odyAtIE1hdGguYWJzKGR4KTtcclxuICAgICAgICBcclxuICAgICAgICBpZihweCA8PSAwKXtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IGR5ID0gb3RoZXIueSAtIHRoaXMueTtcclxuICAgICAgICBsZXQgcHkgPSB0aGlzLmhoICsgb3RoZXIuaGggLSBNYXRoLmFicyhkeSk7XHJcblxyXG4gICAgICAgIGlmKHB5IDw9IDApe1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERldGVybWluZXMgd2hldGhlciB0aGVzZSBBQUJCcyBhcmUgSlVTVCB0b3VjaGluZyAtIG5vdCBvdmVybGFwcGluZy5cclxuICAgICAqIFZlYzIueCBpcyAtMSBpZiB0aGUgb3RoZXIgaXMgdG8gdGhlIGxlZnQsIDEgaWYgdG8gdGhlIHJpZ2h0LlxyXG4gICAgICogTGlrZXdpc2UsIFZlYzIueSBpcyAtMSBpZiB0aGUgb3RoZXIgaXMgb24gdG9wLCAxIGlmIG9uIGJvdHRvbS5cclxuICAgICAqIEBwYXJhbSBvdGhlciBUaGUgb3RoZXIgQUFCQiB0byBjaGVja1xyXG4gICAgICogQHJldHVybnMgVGhlIGNvbGxpc2lvbiBzaWRlcyBzdG9yZWQgaW4gYSBWZWMyIGlmIHRoZSBBQUJCcyBhcmUgdG91Y2hpbmcsIG51bGwgb3RoZXJ3aXNlXHJcbiAgICAgKi9cclxuICAgIHRvdWNoZXNBQUJCKG90aGVyOiBBQUJCKTogVmVjMiB7XHJcbiAgICAgICAgbGV0IGR4ID0gb3RoZXIueCAtIHRoaXMueDtcclxuICAgICAgICBsZXQgcHggPSB0aGlzLmh3ICsgb3RoZXIuaHcgLSBNYXRoLmFicyhkeCk7XHJcblxyXG4gICAgICAgIGxldCBkeSA9IG90aGVyLnkgLSB0aGlzLnk7XHJcbiAgICAgICAgbGV0IHB5ID0gdGhpcy5oaCArIG90aGVyLmhoIC0gTWF0aC5hYnMoZHkpO1xyXG5cclxuICAgICAgICAvLyBJZiBvbmUgYXhpcyBpcyBqdXN0IHRvdWNoaW5nIGFuZCB0aGUgb3RoZXIgaXMgb3ZlcmxhcHBpbmcsIHRydWVcclxuICAgICAgICBpZigocHggPT09IDAgJiYgcHkgPj0gMCkgfHwgKHB5ID09PSAwICYmIHB4ID49IDApKXtcclxuICAgICAgICAgICAgbGV0IHJldCA9IG5ldyBWZWMyKCk7XHJcblxyXG4gICAgICAgICAgICBpZihweCA9PT0gMCl7XHJcbiAgICAgICAgICAgICAgICByZXQueCA9IG90aGVyLnggPCB0aGlzLnggPyAtMSA6IDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmKHB5ID09PSAwKXtcclxuICAgICAgICAgICAgICAgIHJldC55ID0gb3RoZXIueSA8IHRoaXMueSA/IC0xIDogMTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHJldDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlc2UgQUFCQnMgYXJlIEpVU1QgdG91Y2hpbmcgLSBub3Qgb3ZlcmxhcHBpbmcuXHJcbiAgICAgKiBBbHNvLCBpZiB0aGV5IGFyZSBvbmx5IHRvdWNoaW5nIGNvcm5lcnMsIHRoZXkgYXJlIGNvbnNpZGVyZWQgbm90IHRvdWNoaW5nLlxyXG4gICAgICogVmVjMi54IGlzIC0xIGlmIHRoZSBvdGhlciBpcyB0byB0aGUgbGVmdCwgMSBpZiB0byB0aGUgcmlnaHQuXHJcbiAgICAgKiBMaWtld2lzZSwgVmVjMi55IGlzIC0xIGlmIHRoZSBvdGhlciBpcyBvbiB0b3AsIDEgaWYgb24gYm90dG9tLlxyXG4gICAgICogQHBhcmFtIG90aGVyIFRoZSBvdGhlciBBQUJCIHRvIGNoZWNrXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgc2lkZSBvZiB0aGUgdG91Y2gsIHN0b3JlZCBhcyBhIFZlYzIsIG9yIG51bGwgaWYgdGhlcmUgaXMgbm8gdG91Y2hcclxuICAgICAqL1xyXG4gICAgdG91Y2hlc0FBQkJXaXRob3V0Q29ybmVycyhvdGhlcjogQUFCQik6IFZlYzIge1xyXG4gICAgICAgIGxldCBkeCA9IG90aGVyLnggLSB0aGlzLng7XHJcbiAgICAgICAgbGV0IHB4ID0gdGhpcy5odyArIG90aGVyLmh3IC0gTWF0aC5hYnMoZHgpO1xyXG5cclxuICAgICAgICBsZXQgZHkgPSBvdGhlci55IC0gdGhpcy55O1xyXG4gICAgICAgIGxldCBweSA9IHRoaXMuaGggKyBvdGhlci5oaCAtIE1hdGguYWJzKGR5KTtcclxuXHJcbiAgICAgICAgLy8gSWYgb25lIGF4aXMgaXMgdG91Y2hpbmcsIGFuZCB0aGUgb3RoZXIgaXMgc3RyaWN0bHkgb3ZlcmxhcHBpbmdcclxuICAgICAgICBpZigocHggPT09IDAgJiYgcHkgPiAwKSB8fCAocHkgPT09IDAgJiYgcHggPiAwKSl7XHJcbiAgICAgICAgICAgIGxldCByZXQgPSBuZXcgVmVjMigpO1xyXG5cclxuICAgICAgICAgICAgaWYocHggPT09IDApe1xyXG4gICAgICAgICAgICAgICAgcmV0LnggPSBvdGhlci54IDwgdGhpcy54ID8gLTEgOiAxO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0LnkgPSBvdGhlci55IDwgdGhpcy55ID8gLTEgOiAxO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcmV0O1xyXG5cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBhcmVhIG9mIHRoZSBvdmVybGFwIGJldHdlZW4gdGhpcyBBQUJCIGFuZCBhbm90aGVyXHJcbiAgICAgKiBAcGFyYW0gb3RoZXIgVGhlIG90aGVyIEFBQkJcclxuICAgICAqIEByZXR1cm5zIFRoZSBhcmVhIG9mIHRoZSBvdmVybGFwIGJldHdlZW4gdGhlIEFBQkJzXHJcbiAgICAgKi9cclxuICAgIG92ZXJsYXBBcmVhKG90aGVyOiBBQUJCKTogbnVtYmVyIHtcclxuICAgICAgICBsZXQgbGVmdHggPSBNYXRoLm1heCh0aGlzLnggLSB0aGlzLmh3LCBvdGhlci54IC0gb3RoZXIuaHcpO1xyXG4gICAgICAgIGxldCByaWdodHggPSBNYXRoLm1pbih0aGlzLnggKyB0aGlzLmh3LCBvdGhlci54ICsgb3RoZXIuaHcpO1xyXG4gICAgICAgIGxldCBkeCA9IHJpZ2h0eCAtIGxlZnR4O1xyXG5cclxuICAgICAgICBsZXQgbGVmdHkgPSBNYXRoLm1heCh0aGlzLnkgLSB0aGlzLmhoLCBvdGhlci55IC0gb3RoZXIuaGgpO1xyXG4gICAgICAgIGxldCByaWdodHkgPSBNYXRoLm1pbih0aGlzLnkgKyB0aGlzLmhoLCBvdGhlci55ICsgb3RoZXIuaGgpO1xyXG4gICAgICAgIGxldCBkeSA9IHJpZ2h0eSAtIGxlZnR5O1xyXG5cclxuICAgICAgICBpZihkeCA8IDAgfHwgZHkgPCAwKSByZXR1cm4gMDtcclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gZHgqZHk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNb3ZlcyBhbmQgcmVzaXplcyB0aGlzIHJlY3QgZnJvbSBpdHMgY3VycmVudCBwb3NpdGlvbiB0byB0aGUgcG9zaXRpb24gc3BlY2lmaWVkXHJcbiAgICAgKiBAcGFyYW0gdmVsb2NpdHkgVGhlIG1vdmVtZW50IG9mIHRoZSByZWN0IGZyb20gaXRzIHBvc2l0aW9uXHJcbiAgICAgKiBAcGFyYW0gZnJvbVBvc2l0aW9uIEEgcG9zaXRpb24gc3BlY2lmaWVkIHRvIGJlIHRoZSBzdGFydGluZyBwb2ludCBvZiBzd2VlcGluZ1xyXG4gICAgICogQHBhcmFtIGhhbGZTaXplIFRoZSBoYWxmU2l6ZSBvZiB0aGUgc3dlZXBpbmcgcmVjdCBcclxuICAgICAqL1xyXG4gICAgc3dlZXAodmVsb2NpdHk6IFZlYzIsIGZyb21Qb3NpdGlvbj86IFZlYzIsIGhhbGZTaXplPzogVmVjMik6IHZvaWQge1xyXG4gICAgICAgIGlmKCFmcm9tUG9zaXRpb24pe1xyXG4gICAgICAgICAgICBmcm9tUG9zaXRpb24gPSB0aGlzLmNlbnRlcjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmKCFoYWxmU2l6ZSl7XHJcbiAgICAgICAgICAgIGhhbGZTaXplID0gdGhpcy5oYWxmU2l6ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBjZW50ZXJYID0gZnJvbVBvc2l0aW9uLnggKyB2ZWxvY2l0eS54LzI7XHJcbiAgICAgICAgbGV0IGNlbnRlclkgPSBmcm9tUG9zaXRpb24ueSArIHZlbG9jaXR5LnkvMjtcclxuXHJcbiAgICAgICAgbGV0IG1pblggPSBNYXRoLm1pbihmcm9tUG9zaXRpb24ueCAtIGhhbGZTaXplLngsIGZyb21Qb3NpdGlvbi54ICsgdmVsb2NpdHkueCAtIGhhbGZTaXplLngpO1xyXG4gICAgICAgIGxldCBtaW5ZID0gTWF0aC5taW4oZnJvbVBvc2l0aW9uLnkgLSBoYWxmU2l6ZS55LCBmcm9tUG9zaXRpb24ueSArIHZlbG9jaXR5LnkgLSBoYWxmU2l6ZS55KTtcclxuXHJcbiAgICAgICAgdGhpcy5jZW50ZXIuc2V0KGNlbnRlclgsIGNlbnRlclkpO1xyXG4gICAgICAgIHRoaXMuaGFsZlNpemUuc2V0KGNlbnRlclggLSBtaW5YLCBjZW50ZXJZIC0gbWluWSk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIEBvdmVycmlkZVxyXG4gICAgY2xvbmUoKTogQUFCQiB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBBQUJCKHRoaXMuY2VudGVyLmNsb25lKCksIHRoaXMuaGFsZlNpemUuY2xvbmUoKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0cyB0aGlzIEFBQkIgdG8gYSBzdHJpbmcgZm9ybWF0XHJcbiAgICAgKiBAcmV0dXJucyAoY2VudGVyOiAoeCwgeSksIGhhbGZTaXplOiAoeCwgeSkpXHJcbiAgICAgKi9cclxuICAgIHRvU3RyaW5nKCk6IHN0cmluZyB7XHJcbiAgICAgICAgcmV0dXJuIFwiKGNlbnRlcjogXCIgKyB0aGlzLmNlbnRlci50b1N0cmluZygpICsgXCIsIGhhbGYtc2l6ZTogXCIgKyB0aGlzLmhhbGZTaXplLnRvU3RyaW5nKCkgKyBcIilcIlxyXG4gICAgfVxyXG59IiwiaW1wb3J0IFZlYzIgZnJvbSBcIi4uL1ZlYzJcIjtcclxuaW1wb3J0IEFBQkIgZnJvbSBcIi4vQUFCQlwiO1xyXG5pbXBvcnQgU2hhcGUgZnJvbSBcIi4vU2hhcGVcIjtcclxuXHJcbi8qKlxyXG4gKiBBIENpcmNsZVxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2lyY2xlIGV4dGVuZHMgU2hhcGUge1xyXG5cdHByaXZhdGUgX2NlbnRlcjogVmVjMjtcclxuXHRyYWRpdXM6IG51bWJlcjtcclxuXHRcclxuXHQvKipcclxuXHQgKiBDcmVhdGVzIGEgbmV3IENpcmNsZVxyXG5cdCAqIEBwYXJhbSBjZW50ZXIgVGhlIGNlbnRlciBvZiB0aGUgY2lyY2xlXHJcblx0ICogQHBhcmFtIHJhZGl1cyBUaGUgcmFkaXVzIG9mIHRoZSBjaXJjbGVcclxuXHQgKi9cclxuXHRjb25zdHJ1Y3RvcihjZW50ZXI6IFZlYzIsIHJhZGl1czogbnVtYmVyKSB7XHJcblx0XHRzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuX2NlbnRlciA9IGNlbnRlciA/IGNlbnRlciA6IG5ldyBWZWMyKDAsIDApO1xyXG4gICAgICAgIHRoaXMucmFkaXVzID0gcmFkaXVzID8gcmFkaXVzIDogMDtcclxuXHR9XHJcblxyXG5cdGdldCBjZW50ZXIoKTogVmVjMiB7XHJcblx0XHRyZXR1cm4gdGhpcy5fY2VudGVyO1xyXG5cdH1cclxuXHJcblx0c2V0IGNlbnRlcihjZW50ZXI6IFZlYzIpIHtcclxuXHRcdHRoaXMuX2NlbnRlciA9IGNlbnRlcjtcclxuXHR9XHJcblxyXG5cdGdldCBoYWxmU2l6ZSgpOiBWZWMyIHtcclxuXHRcdHJldHVybiBuZXcgVmVjMih0aGlzLnJhZGl1cywgdGhpcy5yYWRpdXMpO1xyXG5cdH1cclxuXHJcblx0Z2V0IHIoKTogbnVtYmVyIHtcclxuXHRcdHJldHVybiB0aGlzLnJhZGl1cztcclxuXHR9XHJcblxyXG5cdHNldCByKHJhZGl1czogbnVtYmVyKSB7XHJcblx0XHR0aGlzLnJhZGl1cyA9IHJhZGl1cztcclxuXHR9XHJcblxyXG5cdC8vIEBvdmVycmlkZVxyXG5cdC8qKlxyXG4gICAgICogQSBzaW1wbGUgYm9vbGVhbiBjaGVjayBvZiB3aGV0aGVyIHRoaXMgQUFCQiBjb250YWlucyBhIHBvaW50XHJcbiAgICAgKiBAcGFyYW0gcG9pbnQgVGhlIHBvaW50IHRvIGNoZWNrXHJcbiAgICAgKiBAcmV0dXJucyBBIGJvb2xlYW4gcmVwcmVzZW50aW5nIHdoZXRoZXIgdGhpcyBBQUJCIGNvbnRhaW5zIHRoZSBzcGVjaWZpZWQgcG9pbnRcclxuICAgICAqL1xyXG4gICAgY29udGFpbnNQb2ludChwb2ludDogVmVjMik6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNlbnRlci5kaXN0YW5jZVNxVG8ocG9pbnQpIDw9IHRoaXMucmFkaXVzKnRoaXMucmFkaXVzO1xyXG4gICAgfVxyXG5cclxuXHQvLyBAb3ZlcnJpZGVcclxuXHRnZXRCb3VuZGluZ1JlY3QoKTogQUFCQiB7XHJcblx0XHRyZXR1cm4gbmV3IEFBQkIodGhpcy5fY2VudGVyLmNsb25lKCksIG5ldyBWZWMyKHRoaXMucmFkaXVzLCB0aGlzLnJhZGl1cykpO1xyXG5cdH1cclxuXHJcblx0Ly8gQG92ZXJyaWRlXHJcblx0Z2V0Qm91bmRpbmdDaXJjbGUoKTogQ2lyY2xlIHtcclxuXHRcdHJldHVybiB0aGlzLmNsb25lKCk7XHJcblx0fVxyXG5cclxuXHQvLyBAb3ZlcnJpZGVcclxuXHRvdmVybGFwcyhvdGhlcjogU2hhcGUpOiBib29sZWFuIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcihcIk1ldGhvZCBub3QgaW1wbGVtZW50ZWQuXCIpO1xyXG5cdH1cclxuXHJcblx0Ly8gQG92ZXJyaWRlXHJcblx0Y2xvbmUoKTogQ2lyY2xlIHtcclxuXHRcdHJldHVybiBuZXcgQ2lyY2xlKHRoaXMuX2NlbnRlci5jbG9uZSgpLCB0aGlzLnJhZGl1cyk7XHJcblx0fVxyXG5cclxuXHR0b1N0cmluZygpOiBzdHJpbmcge1xyXG5cdFx0cmV0dXJuIFwiKGNlbnRlcjogXCIgKyB0aGlzLmNlbnRlci50b1N0cmluZygpICsgXCIsIHJhZGl1czogXCIgKyB0aGlzLnJhZGl1cyArIFwiKVwiO1xyXG5cdH1cclxufSIsImltcG9ydCBWZWMyIGZyb20gXCIuLi9WZWMyXCI7XHJcbmltcG9ydCBBQUJCIGZyb20gXCIuL0FBQkJcIjtcclxuaW1wb3J0IENpcmNsZSBmcm9tIFwiLi9DaXJjbGVcIjtcclxuXHJcbi8qKlxyXG4gKiBBbiBhYnN0cmFjdCBTaGFwZSBjbGFzcyB0aGF0IGFjdHMgYXMgYW4gaW50ZXJmYWNlIGZvciBiZXR0ZXIgaW50ZXJhY3Rpb25zIHdpdGggc3ViY2xhc3Nlcy5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGFic3RyYWN0IGNsYXNzIFNoYXBlIHtcclxuICAgIGFic3RyYWN0IGdldCBjZW50ZXIoKTogVmVjMjtcclxuXHJcbiAgICBhYnN0cmFjdCBzZXQgY2VudGVyKGNlbnRlcjogVmVjMik7XHJcblxyXG4gICAgYWJzdHJhY3QgZ2V0IGhhbGZTaXplKCk6IFZlYzI7XHJcblxyXG4gICAgZ2V0IHgoKTogbnVtYmVyIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jZW50ZXIueDtcclxuICAgIH1cclxuXHJcbiAgICBnZXQgeSgpOiBudW1iZXIge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNlbnRlci55O1xyXG4gICAgfVxyXG5cclxuICAgIGdldCBodygpOiBudW1iZXIge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmhhbGZTaXplLng7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IGhoKCk6IG51bWJlciB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFsZlNpemUueTtcclxuICAgIH1cclxuXHJcbiAgICBnZXQgdG9wKCk6IG51bWJlciB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMueSAtIHRoaXMuaGg7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IGJvdHRvbSgpOiBudW1iZXIge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnkgKyB0aGlzLmhoO1xyXG4gICAgfVxyXG5cclxuICAgIGdldCBsZWZ0KCk6IG51bWJlciB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMueCAtIHRoaXMuaHc7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IHJpZ2h0KCk6IG51bWJlciB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMueCArIHRoaXMuaHc7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIGEgYm91bmRpbmcgcmVjdGFuZ2xlIGZvciB0aGlzIHNoYXBlLiBXYXJuaW5nIC0gbWF5IGJlIHRoZSBzYW1lIGFzIHRoaXMgU2hhcGUuXHJcbiAgICAgKiBGb3IgaW5zdGFuY2UsIHRoZSBib3VuZGluZyBjaXJjbGUgb2YgYW4gQUFCQiBpcyBpdHNlbGYuIFVzZSBjbG9uZSgpIGlmIHlvdSBuZWVkIGEgbmV3IHNoYXBlLlxyXG4gICAgICogQHJldHVybnMgQW4gQUFCQiB0aGF0IGJvdW5kcyB0aGlzIHNoYXBlXHJcbiAgICAgKi9cclxuICAgIGFic3RyYWN0IGdldEJvdW5kaW5nUmVjdCgpOiBBQUJCO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBhIGJvdW5kaW5nIGNpcmNsZSBmb3IgdGhpcyBzaGFwZS4gV2FybmluZyAtIG1heSBiZSB0aGUgc2FtZSBhcyB0aGlzIFNoYXBlLlxyXG4gICAgICogRm9yIGluc3RhbmNlLCB0aGUgYm91bmRpbmcgY2lyY2xlIG9mIGEgQ2lyY2xlIGlzIGl0c2VsZi4gVXNlIGNsb25lKCkgaWYgeW91IG5lZWQgYSBuZXcgc2hhcGUuXHJcbiAgICAgKiBAcmV0dXJucyBBIENpcmNsZSB0aGF0IGJvdW5kcyB0aGlzIHNoYXBlXHJcbiAgICAgKi9cclxuICAgIGFic3RyYWN0IGdldEJvdW5kaW5nQ2lyY2xlKCk6IENpcmNsZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBjb3B5IG9mIHRoaXMgU2hhcGVcclxuICAgICAqIEByZXR1cm5zIEEgbmV3IGNvcHkgb2YgdGhpcyBzaGFwZVxyXG4gICAgICovXHJcbiAgICBhYnN0cmFjdCBjbG9uZSgpOiBTaGFwZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyBpZiB0aGlzIHNoYXBlIG92ZXJsYXBzIGFub3RoZXJcclxuICAgICAqIEBwYXJhbSBvdGhlciBUaGUgb3RoZXIgc2hhcGUgdG8gY2hlY2sgYWdhaW5zdFxyXG4gICAgICogQHJldHVybnMgYSBib29sZWFuIHRoYXQgcmVwcmVzZW50cyB3aGV0aGVyIHRoaXMgU2hhcGUgb3ZlcmxhcHMgdGhlIG90aGVyIG9uZVxyXG4gICAgICovXHJcbiAgICBhYnN0cmFjdCBvdmVybGFwcyhvdGhlcjogU2hhcGUpOiBib29sZWFuO1xyXG5cclxuICAgICAvKipcclxuICAgICAqIEEgc2ltcGxlIGJvb2xlYW4gY2hlY2sgb2Ygd2hldGhlciB0aGlzIFNoYXBlIGNvbnRhaW5zIGEgcG9pbnRcclxuICAgICAqIEBwYXJhbSBwb2ludCBUaGUgcG9pbnQgdG8gY2hlY2tcclxuICAgICAqIEByZXR1cm5zIEEgYm9vbGVhbiByZXByZXNlbnRpbmcgd2hldGhlciB0aGlzIFNoYXBlIGNvbnRhaW5zIHRoZSBzcGVjaWZpZWQgcG9pbnRcclxuICAgICAqL1xyXG4gICAgYWJzdHJhY3QgY29udGFpbnNQb2ludChwb2ludDogVmVjMik6IGJvb2xlYW47XHJcblxyXG4gICAgc3RhdGljIGdldFRpbWVPZkNvbGxpc2lvbihBOiBTaGFwZSwgdmVsQTogVmVjMiwgQjogU2hhcGUsIHZlbEI6IFZlYzIpOiBbVmVjMiwgVmVjMiwgYm9vbGVhbiwgYm9vbGVhbl0ge1xyXG5cdFx0aWYoQSBpbnN0YW5jZW9mIEFBQkIgJiYgQiBpbnN0YW5jZW9mIEFBQkIpe1xyXG5cdFx0XHRyZXR1cm4gU2hhcGUuZ2V0VGltZU9mQ29sbGlzaW9uX0FBQkJfQUFCQihBLCB2ZWxBLCBCLCB2ZWxCKTtcclxuXHRcdH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgcHJpdmF0ZSBzdGF0aWMgZ2V0VGltZU9mQ29sbGlzaW9uX0FBQkJfQUFCQihBOiBBQUJCLCB2ZWxBOiBWZWMyLCBCOiBTaGFwZSwgdmVsQjogVmVjMik6IFtWZWMyLCBWZWMyLCBib29sZWFuLCBib29sZWFuXSB7XHJcbiAgICAgICAgbGV0IHBvc1NtYWxsZXIgPSBBLmNlbnRlcjtcclxuICAgICAgICBsZXQgcG9zTGFyZ2VyID0gQi5jZW50ZXI7XHJcbiAgICAgICAgXHJcbiAgICAgICAgbGV0IHNpemVTbWFsbGVyID0gQS5oYWxmU2l6ZTtcclxuICAgICAgICBsZXQgc2l6ZUxhcmdlciA9IEIuaGFsZlNpemU7XHJcbiAgICBcclxuICAgICAgICBsZXQgZmlyc3RDb250YWN0ID0gbmV3IFZlYzIoMCwgMCk7XHJcbiAgICAgICAgbGV0IGxhc3RDb250YWN0ID0gbmV3IFZlYzIoMCwgMCk7XHJcbiAgICBcclxuICAgICAgICBsZXQgY29sbGlkaW5nWCA9IGZhbHNlO1xyXG4gICAgICAgIGxldCBjb2xsaWRpbmdZID0gZmFsc2U7XHJcbiAgICBcclxuICAgICAgICAvLyBTb3J0IGJ5IHBvc2l0aW9uXHJcbiAgICAgICAgaWYocG9zTGFyZ2VyLnggPCBwb3NTbWFsbGVyLngpe1xyXG4gICAgICAgICAgICAvLyBTd2FwLCBiZWNhdXNlIHNtYWxsZXIgaXMgZnVydGhlciByaWdodCB0aGFuIGxhcmdlclxyXG4gICAgICAgICAgICBsZXQgdGVtcDogVmVjMjtcclxuICAgICAgICAgICAgdGVtcCA9IHNpemVTbWFsbGVyO1xyXG4gICAgICAgICAgICBzaXplU21hbGxlciA9IHNpemVMYXJnZXI7XHJcbiAgICAgICAgICAgIHNpemVMYXJnZXIgPSB0ZW1wO1xyXG4gICAgXHJcbiAgICAgICAgICAgIHRlbXAgPSBwb3NTbWFsbGVyO1xyXG4gICAgICAgICAgICBwb3NTbWFsbGVyID0gcG9zTGFyZ2VyO1xyXG4gICAgICAgICAgICBwb3NMYXJnZXIgPSB0ZW1wO1xyXG4gICAgXHJcbiAgICAgICAgICAgIHRlbXAgPSB2ZWxBO1xyXG4gICAgICAgICAgICB2ZWxBID0gdmVsQjtcclxuICAgICAgICAgICAgdmVsQiA9IHRlbXA7XHJcbiAgICAgICAgfVxyXG4gICAgXHJcbiAgICAgICAgLy8gQSBpcyBsZWZ0LCBCIGlzIHJpZ2h0XHJcbiAgICAgICAgZmlyc3RDb250YWN0LnggPSBJbmZpbml0eTtcclxuICAgICAgICBsYXN0Q29udGFjdC54ID0gSW5maW5pdHk7XHJcbiAgICBcclxuICAgICAgICBpZiAocG9zTGFyZ2VyLnggLSBzaXplTGFyZ2VyLnggPj0gcG9zU21hbGxlci54ICsgc2l6ZVNtYWxsZXIueCl7XHJcbiAgICAgICAgICAgIC8vIElmIHdlIGFyZW4ndCBjdXJyZW50bHkgY29sbGlkaW5nXHJcbiAgICAgICAgICAgIGxldCByZWxWZWwgPSB2ZWxBLnggLSB2ZWxCLng7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZihyZWxWZWwgPiAwKXtcclxuICAgICAgICAgICAgICAgIC8vIElmIHRoZXkgYXJlIG1vdmluZyB0b3dhcmRzIGVhY2ggb3RoZXJcclxuICAgICAgICAgICAgICAgIGZpcnN0Q29udGFjdC54ID0gKChwb3NMYXJnZXIueCAtIHNpemVMYXJnZXIueCkgLSAocG9zU21hbGxlci54ICsgc2l6ZVNtYWxsZXIueCkpLyhyZWxWZWwpO1xyXG4gICAgICAgICAgICAgICAgbGFzdENvbnRhY3QueCA9ICgocG9zTGFyZ2VyLnggKyBzaXplTGFyZ2VyLngpIC0gKHBvc1NtYWxsZXIueCAtIHNpemVTbWFsbGVyLngpKS8ocmVsVmVsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbGxpZGluZ1ggPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIFxyXG4gICAgICAgIGlmKHBvc0xhcmdlci55IDwgcG9zU21hbGxlci55KXtcclxuICAgICAgICAgICAgLy8gU3dhcCwgYmVjYXVzZSBzbWFsbGVyIGlzIGZ1cnRoZXIgdXAgdGhhbiBsYXJnZXJcclxuICAgICAgICAgICAgbGV0IHRlbXA6IFZlYzI7XHJcbiAgICAgICAgICAgIHRlbXAgPSBzaXplU21hbGxlcjtcclxuICAgICAgICAgICAgc2l6ZVNtYWxsZXIgPSBzaXplTGFyZ2VyO1xyXG4gICAgICAgICAgICBzaXplTGFyZ2VyID0gdGVtcDtcclxuICAgIFxyXG4gICAgICAgICAgICB0ZW1wID0gcG9zU21hbGxlcjtcclxuICAgICAgICAgICAgcG9zU21hbGxlciA9IHBvc0xhcmdlcjtcclxuICAgICAgICAgICAgcG9zTGFyZ2VyID0gdGVtcDtcclxuICAgIFxyXG4gICAgICAgICAgICB0ZW1wID0gdmVsQTtcclxuICAgICAgICAgICAgdmVsQSA9IHZlbEI7XHJcbiAgICAgICAgICAgIHZlbEIgPSB0ZW1wO1xyXG4gICAgICAgIH1cclxuICAgIFxyXG4gICAgICAgIC8vIEEgaXMgdG9wLCBCIGlzIGJvdHRvbVxyXG4gICAgICAgIGZpcnN0Q29udGFjdC55ID0gSW5maW5pdHk7XHJcbiAgICAgICAgbGFzdENvbnRhY3QueSA9IEluZmluaXR5O1xyXG4gICAgXHJcbiAgICAgICAgaWYgKHBvc0xhcmdlci55IC0gc2l6ZUxhcmdlci55ID49IHBvc1NtYWxsZXIueSArIHNpemVTbWFsbGVyLnkpe1xyXG4gICAgICAgICAgICAvLyBJZiB3ZSBhcmVuJ3QgY3VycmVudGx5IGNvbGxpZGluZ1xyXG4gICAgICAgICAgICBsZXQgcmVsVmVsID0gdmVsQS55IC0gdmVsQi55O1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYocmVsVmVsID4gMCl7XHJcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGV5IGFyZSBtb3ZpbmcgdG93YXJkcyBlYWNoIG90aGVyXHJcbiAgICAgICAgICAgICAgICBmaXJzdENvbnRhY3QueSA9ICgocG9zTGFyZ2VyLnkgLSBzaXplTGFyZ2VyLnkpIC0gKHBvc1NtYWxsZXIueSArIHNpemVTbWFsbGVyLnkpKS8ocmVsVmVsKTtcclxuICAgICAgICAgICAgICAgIGxhc3RDb250YWN0LnkgPSAoKHBvc0xhcmdlci55ICsgc2l6ZUxhcmdlci55KSAtIChwb3NTbWFsbGVyLnkgLSBzaXplU21hbGxlci55KSkvKHJlbFZlbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb2xsaWRpbmdZID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICBcclxuICAgICAgICByZXR1cm4gW2ZpcnN0Q29udGFjdCwgbGFzdENvbnRhY3QsIGNvbGxpZGluZ1gsIGNvbGxpZGluZ1ldO1xyXG4gICAgfVxyXG59IiwiaW1wb3J0IENvbGxlY3Rpb24gZnJvbSBcIi4vQ29sbGVjdGlvblwiO1xyXG5cclxuLyoqXHJcbiAqIEEgTElGTyBzdGFjayB3aXRoIGl0ZW1zIG9mIHR5cGUgVFxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3RhY2s8VD4gaW1wbGVtZW50cyBDb2xsZWN0aW9uIHtcclxuICAgIC8qKiBUaGUgbWF4aW11bSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIFN0YWNrICovXHJcbiAgICBwcml2YXRlIE1BWF9FTEVNRU5UUzogbnVtYmVyO1xyXG4gICAgXHJcbiAgICAvKiogVGhlIGludGVybmFsIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBzdGFjayAqL1xyXG4gICAgcHJpdmF0ZSBzdGFjazogQXJyYXk8VD47XHJcbiAgICBcclxuICAgIC8qKiBUaGUgaGVhZCBvZiB0aGUgc3RhY2sgKi9cclxuXHRwcml2YXRlIGhlYWQ6IG51bWJlcjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnN0cnVjdHMgYSBuZXcgc3RhY2tcclxuICAgICAqIEBwYXJhbSBtYXhFbGVtZW50cyBUaGUgbWF4aW11bSBzaXplIG9mIHRoZSBzdGFja1xyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihtYXhFbGVtZW50czogbnVtYmVyID0gMTAwKXtcclxuICAgICAgICB0aGlzLk1BWF9FTEVNRU5UUyA9IG1heEVsZW1lbnRzO1xyXG4gICAgICAgIHRoaXMuc3RhY2sgPSBuZXcgQXJyYXk8VD4odGhpcy5NQVhfRUxFTUVOVFMpO1xyXG4gICAgICAgIHRoaXMuaGVhZCA9IC0xO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYW4gaXRlbSB0byB0aGUgdG9wIG9mIHRoZSBzdGFja1xyXG4gICAgICogQHBhcmFtIGl0ZW0gVGhlIG5ldyBpdGVtIHRvIGFkZCB0byB0aGUgc3RhY2tcclxuICAgICAqL1xyXG4gICAgcHVzaChpdGVtOiBUKTogdm9pZCB7XHJcbiAgICAgICAgaWYodGhpcy5oZWFkICsgMSA9PT0gdGhpcy5NQVhfRUxFTUVOVFMpe1xyXG4gICAgICAgICAgICB0aHJvdyBcIlN0YWNrIGZ1bGwgLSBjYW5ub3QgYWRkIGVsZW1lbnRcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5oZWFkICs9IDE7XHJcbiAgICAgICAgdGhpcy5zdGFja1t0aGlzLmhlYWRdID0gaXRlbTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgYW4gaXRlbSBmcm9tIHRoZSB0b3Agb2YgdGhlIHN0YWNrXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgaXRlbSBhdCB0aGUgdG9wIG9mIHRoZSBzdGFja1xyXG4gICAgICovXHJcbiAgICBwb3AoKTogVCB7XHJcbiAgICAgICAgaWYodGhpcy5oZWFkID09PSAtMSl7XHJcbiAgICAgICAgICAgIHRocm93IFwiU3RhY2sgZW1wdHkgLSBjYW5ub3QgcmVtb3ZlIGVsZW1lbnRcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5oZWFkIC09IDE7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhY2tbdGhpcy5oZWFkICsgMV07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBlbGVtZW50IGN1cnJlbnRseSBhdCB0aGUgdG9wIG9mIHRoZSBzdGFja1xyXG4gICAgICogQHJldHVybnMgVGhlIGl0ZW0gYXQgdGhlIHRvcCBvZiB0aGUgc3RhY2tcclxuICAgICAqL1xyXG4gICAgcGVlaygpOiBUIHtcclxuICAgICAgICBpZih0aGlzLmhlYWQgPT09IC0xKXtcclxuICAgICAgICAgICAgdGhyb3cgXCJTdGFjayBlbXB0eSAtIGNhbm5vdCBnZXQgZWxlbWVudFwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5zdGFja1t0aGlzLmhlYWRdO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBzdGFjayBpcyBlbXB0eVxyXG4gICAgICogQHJldHVybnMgQSBib29sZWFuIHRoYXQgcmVwcmVzZW50cyB3aGV0aGVyIG9yIG5vdCB0aGUgc3RhY2sgaXMgZW1wdHlcclxuICAgICovXHJcbiAgICBpc0VtcHR5KCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmhlYWQgPT09IC0xO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEBpbXBsZW1lbnRlZFxyXG4gICAgY2xlYXIoKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5mb3JFYWNoKChpdGVtLCBpbmRleCkgPT4gZGVsZXRlIHRoaXMuc3RhY2tbaW5kZXhdKTtcclxuICAgICAgICB0aGlzLmhlYWQgPSAtMTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIG51bWJlciBvZiBpdGVtcyBjdXJyZW50bHkgaW4gdGhlIHN0YWNrXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgbnVtYmVyIG9mIGl0ZW1zIGluIHRoZSBzdGFja1xyXG4gICAgICovXHJcbiAgICBzaXplKCk6IG51bWJlciB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaGVhZCArIDE7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQGltcGxlbWVudGVkXHJcbiAgICBmb3JFYWNoKGZ1bmM6IChpdGVtOiBULCBpbmRleD86IG51bWJlcikgPT4gdm9pZCk6IHZvaWR7XHJcbiAgICAgICAgbGV0IGkgPSAwO1xyXG4gICAgICAgIHdoaWxlKGkgPD0gdGhpcy5oZWFkKXtcclxuICAgICAgICAgICAgZnVuYyh0aGlzLnN0YWNrW2ldLCBpKTtcclxuICAgICAgICAgICAgaSArPSAxO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIHRoaXMgc3RhY2sgaW50byBhIHN0cmluZyBmb3JtYXRcclxuICAgICAqIEByZXR1cm5zIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGlzIHN0YWNrXHJcbiAgICAgKi9cclxuICAgIHRvU3RyaW5nKCk6IHN0cmluZyB7XHJcbiAgICAgICAgbGV0IHJldHZhbCA9IFwiXCI7XHJcblxyXG4gICAgICAgIHRoaXMuZm9yRWFjaCggKGl0ZW0sIGluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBzdHIgPSBpdGVtLnRvU3RyaW5nKClcclxuICAgICAgICAgICAgaWYoaW5kZXggIT09IDApe1xyXG4gICAgICAgICAgICAgICAgc3RyICs9IFwiIC0+IFwiXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dmFsID0gc3RyICsgcmV0dmFsO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gXCJUb3AgLT4gXCIgKyByZXR2YWw7XHJcbiAgICB9XHJcbn0iLCJpbXBvcnQgU3RhY2sgZnJvbSBcIi4uL1N0YWNrXCI7XHJcbmltcG9ydCBTdGF0ZSBmcm9tIFwiLi9TdGF0ZVwiO1xyXG5pbXBvcnQgTWFwIGZyb20gXCIuLi9NYXBcIjtcclxuaW1wb3J0IEdhbWVFdmVudCBmcm9tIFwiLi4vLi4vRXZlbnRzL0dhbWVFdmVudFwiO1xyXG5pbXBvcnQgUmVjZWl2ZXIgZnJvbSBcIi4uLy4uL0V2ZW50cy9SZWNlaXZlclwiO1xyXG5pbXBvcnQgRW1pdHRlciBmcm9tIFwiLi4vLi4vRXZlbnRzL0VtaXR0ZXJcIjtcclxuaW1wb3J0IFVwZGF0ZWFibGUgZnJvbSBcIi4uL0ludGVyZmFjZXMvVXBkYXRlYWJsZVwiO1xyXG5cclxuLyoqXHJcbiAqIEFuIGltcGxlbWVudGF0aW9uIG9mIGEgUHVzaCBEb3duIEF1dG9tYXRhIFN0YXRlIG1hY2hpbmUuIFN0YXRlcyBjYW4gYWxzbyBiZSBoaWVyYXJjaGljYWxcclxuICogZm9yIG1vcmUgZmxleGliaWxpdHksIGFzIGRlc2NyaWJlZCBpbiBAbGluayhHYW1lIFByb2dyYW1taW5nIFBhdHRlcm5zKShodHRwczovL2dhbWVwcm9ncmFtbWluZ3BhdHRlcm5zLmNvbS9zdGF0ZS5odG1sKS5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0YXRlTWFjaGluZSBpbXBsZW1lbnRzIFVwZGF0ZWFibGUge1xyXG4gICAgLyoqIEEgc3RhY2sgb2YgdGhlIGN1cnJlbnQgc3RhdGVzICovXHJcbiAgICBwcm90ZWN0ZWQgc3RhY2s6IFN0YWNrPFN0YXRlPjtcclxuICAgIC8qKiBBIG1hcGUgb2Ygc3RhdGUga2V5cyB0byBhY3R1YWwgc3RhdGUgaW5zdGFuY2VzICovXHJcbiAgICBwcm90ZWN0ZWQgc3RhdGVNYXA6IE1hcDxTdGF0ZT47XHJcbiAgICAvKiogVGhlIGN1cnJlbnQgc3RhdGUgKi9cclxuICAgIHByb3RlY3RlZCBjdXJyZW50U3RhdGU6IFN0YXRlO1xyXG4gICAgLyoqIEFuIGV2ZW50IHJlY2VpdmVyICovXHJcbiAgICBwcm90ZWN0ZWQgcmVjZWl2ZXI6IFJlY2VpdmVyO1xyXG4gICAgLyoqIEFuIGV2ZW50IGVtaXR0ZXIgKi9cclxuICAgIHByb3RlY3RlZCBlbWl0dGVyOiBFbWl0dGVyO1xyXG4gICAgLyoqIEEgYm9vbGVhbiByZXByZXNlbnRpbmcgd2hldGhlciBvciBub3QgdGhpcyBTdGF0ZU1hY2hpbmUgaXMgY3VycmVudGx5IGFjdGl2ZSAqL1xyXG4gICAgcHJvdGVjdGVkIGFjdGl2ZTogYm9vbGVhbjtcclxuICAgIC8qKiBBIGJvb2xlYW4gcmVwcmVzZW50aW5nIHdoZXRoZXIgb3Igbm90IHRoaXMgU3RhdGVNYWNoaW5lIHNob3VsZCBlbWl0IGFuIGV2ZW50IG9uIHN0YXRlIGNoYW5nZSAqL1xyXG4gICAgcHJvdGVjdGVkIGVtaXRFdmVudE9uU3RhdGVDaGFuZ2U6IGJvb2xlYW47XHJcbiAgICAvKiogVGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIGJlIGVtaXR0ZWQgb24gc3RhdGUgY2hhbmdlICovXHJcbiAgICBwcm90ZWN0ZWQgc3RhdGVDaGFuZ2VFdmVudE5hbWU6IHN0cmluZztcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgU3RhdGVNYWNoaW5lXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKCl7XHJcbiAgICAgICAgdGhpcy5zdGFjayA9IG5ldyBTdGFjaygpO1xyXG4gICAgICAgIHRoaXMuc3RhdGVNYXAgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy5yZWNlaXZlciA9IG5ldyBSZWNlaXZlcigpO1xyXG4gICAgICAgIHRoaXMuZW1pdHRlciA9IG5ldyBFbWl0dGVyKCk7XHJcbiAgICAgICAgdGhpcy5lbWl0RXZlbnRPblN0YXRlQ2hhbmdlID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBhY3Rpdml0eSBzdGF0ZSBvZiB0aGlzIHN0YXRlIG1hY2hpbmVcclxuICAgICAqIEBwYXJhbSBmbGFnIFRydWUgaWYgeW91IHdhbnQgdG8gc2V0IHRoaXMgbWFjaGluZSBydW5uaW5nLCBmYWxzZSBvdGhlcndpc2VcclxuICAgICAqL1xyXG4gICAgc2V0QWN0aXZlKGZsYWc6IGJvb2xlYW4pOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmFjdGl2ZSA9IGZsYWc7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNYWtlcyB0aGlzIHN0YXRlIG1hY2hpbmUgZW1pdCBhbiBldmVudCBhbnkgdGltZSBpdHMgc3RhdGUgY2hhbmdlc1xyXG4gICAgICogQHBhcmFtIHN0YXRlQ2hhbmdlRXZlbnROYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byBlbWl0XHJcbiAgICAgKi9cclxuICAgIHNldEVtaXRFdmVudE9uU3RhdGVDaGFuZ2Uoc3RhdGVDaGFuZ2VFdmVudE5hbWU6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuZW1pdEV2ZW50T25TdGF0ZUNoYW5nZSA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5zdGF0ZUNoYW5nZUV2ZW50TmFtZSA9IHN0YXRlQ2hhbmdlRXZlbnROYW1lO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3RvcHMgdGhpcyBzdGF0ZSBtYWNoaW5lIGZyb20gZW1pdHRpbmcgZXZlbnRzIG9uIHN0YXRlIGNoYW5nZS5cclxuICAgICAqL1xyXG4gICAgY2FuY2VsRW1pdEV2ZW50T25TdGF0ZUNoYW5nZSgpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmVtaXRFdmVudE9uU3RhdGVDaGFuZ2UgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgKiBJbml0aWFsaXplcyB0aGlzIHN0YXRlIG1hY2hpbmUgd2l0aCBhbiBpbml0aWFsIHN0YXRlIGFuZCBzZXRzIGl0IHJ1bm5pbmdcclxuICAgICAqIEBwYXJhbSBpbml0aWFsU3RhdGUgVGhlIG5hbWUgb2YgaW5pdGlhbCBzdGF0ZSBvZiB0aGUgc3RhdGUgbWFjaGluZVxyXG4gICAgICovXHJcbiAgICBpbml0aWFsaXplKGluaXRpYWxTdGF0ZTogc3RyaW5nLCBvcHRpb25zPzogUmVjb3JkPHN0cmluZywgYW55Pik6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuc3RhY2sucHVzaCh0aGlzLnN0YXRlTWFwLmdldChpbml0aWFsU3RhdGUpKTtcclxuICAgICAgICB0aGlzLmN1cnJlbnRTdGF0ZSA9IHRoaXMuc3RhY2sucGVlaygpO1xyXG4gICAgICAgIHRoaXMuY3VycmVudFN0YXRlLm9uRW50ZXIob3B0aW9ucyk7XHJcbiAgICAgICAgdGhpcy5zZXRBY3RpdmUodHJ1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgc3RhdGUgdG8gdGhpcyBzdGF0ZSBtYWNoaW5lXHJcbiAgICAgKiBAcGFyYW0gc3RhdGVOYW1lIFRoZSBuYW1lIG9mIHRoZSBzdGF0ZSB0byBhZGRcclxuICAgICAqIEBwYXJhbSBzdGF0ZSBUaGUgc3RhdGUgdG8gYWRkXHJcbiAgICAgKi9cclxuICAgIGFkZFN0YXRlKHN0YXRlTmFtZTogc3RyaW5nLCBzdGF0ZTogU3RhdGUpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLnN0YXRlTWFwLmFkZChzdGF0ZU5hbWUsIHN0YXRlKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENoYW5nZXMgdGhlIHN0YXRlIG9mIHRoaXMgc3RhdGUgbWFjaGluZSB0byB0aGUgcHJvdmlkZWQgc3RyaW5nXHJcbiAgICAgKiBAcGFyYW0gc3RhdGUgVGhlIHN0cmluZyBuYW1lIG9mIHRoZSBzdGF0ZSB0byBjaGFuZ2UgdG9cclxuICAgICAqL1xyXG4gICAgY2hhbmdlU3RhdGUoc3RhdGU6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgICAgIC8vIEV4aXQgdGhlIGN1cnJlbnQgc3RhdGVcclxuICAgICAgICBsZXQgb3B0aW9ucyA9IHRoaXMuY3VycmVudFN0YXRlLm9uRXhpdCgpO1xyXG5cclxuICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIGNvcnJlY3Qgc3RhdGUgaXMgYXQgdGhlIHRvcCBvZiB0aGUgc3RhY2tcclxuICAgICAgICBpZihzdGF0ZSA9PT0gXCJwcmV2aW91c1wiKXtcclxuICAgICAgICAgICAgLy8gUG9wIHRoZSBjdXJyZW50IHN0YXRlIG9mZiB0aGUgc3RhY2tcclxuICAgICAgICAgICAgdGhpcy5zdGFjay5wb3AoKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBSZXRyaWV2ZSB0aGUgbmV3IHN0YXRlIGZyb20gdGhlIHN0YXRlbWFwIGFuZCBwdXQgaXQgYXQgdGhlIHRvcCBvZiB0aGUgc3RhY2tcclxuICAgICAgICAgICAgdGhpcy5zdGFjay5wb3AoKTtcclxuICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKHRoaXMuc3RhdGVNYXAuZ2V0KHN0YXRlKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBSZXRyZWl2ZSB0aGUgbmV3IHN0YXRlIGZyb20gdGhlIHN0YWNrXHJcbiAgICAgICAgdGhpcy5jdXJyZW50U3RhdGUgPSB0aGlzLnN0YWNrLnBlZWsoKTtcclxuXHJcbiAgICAgICAgLy8gRW1pdCBhbiBldmVudCBpZiB0dXJuZWQgb25cclxuICAgICAgICBpZih0aGlzLmVtaXRFdmVudE9uU3RhdGVDaGFuZ2Upe1xyXG4gICAgICAgICAgICB0aGlzLmVtaXR0ZXIuZmlyZUV2ZW50KHRoaXMuc3RhdGVDaGFuZ2VFdmVudE5hbWUsIHtzdGF0ZTogdGhpcy5jdXJyZW50U3RhdGV9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEVudGVyIHRoZSBuZXcgc3RhdGVcclxuICAgICAgICB0aGlzLmN1cnJlbnRTdGF0ZS5vbkVudGVyKG9wdGlvbnMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSGFuZGxlcyBpbnB1dC4gVGhpcyBoYXBwZW5zIGF0IHRoZSB2ZXJ5IGJlZ2lubmluZyBvZiB0aGlzIHN0YXRlIG1hY2hpbmUncyB1cGRhdGUgY3ljbGUuXHJcbiAgICAgKiBAcGFyYW0gZXZlbnQgVGhlIGdhbWUgZXZlbnQgdG8gcHJvY2Vzc1xyXG4gICAgICovXHJcbiAgICBoYW5kbGVFdmVudChldmVudDogR2FtZUV2ZW50KTogdm9pZCB7XHJcbiAgICAgICAgaWYodGhpcy5hY3RpdmUpe1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRTdGF0ZS5oYW5kbGVJbnB1dChldmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIEBpbXBsZW1lbnRlZFxyXG4gICAgdXBkYXRlKGRlbHRhVDogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgICAgLy8gRGlzdHJpYnV0ZSBldmVudHNcclxuICAgICAgICB3aGlsZSh0aGlzLnJlY2VpdmVyLmhhc05leHRFdmVudCgpKXtcclxuICAgICAgICAgICAgbGV0IGV2ZW50ID0gdGhpcy5yZWNlaXZlci5nZXROZXh0RXZlbnQoKTtcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVFdmVudChldmVudCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBEZWxlZ2F0ZSB0aGUgdXBkYXRlIHRvIHRoZSBjdXJyZW50IHN0YXRlXHJcbiAgICAgICAgdGhpcy5jdXJyZW50U3RhdGUudXBkYXRlKGRlbHRhVCk7XHJcbiAgICB9XHJcbn0iLCJpbXBvcnQgUmVzb3VyY2VNYW5hZ2VyIGZyb20gXCIuLi8uLi9SZXNvdXJjZU1hbmFnZXIvUmVzb3VyY2VNYW5hZ2VyXCI7XHJcbmltcG9ydCBWZWMyIGZyb20gXCIuLi9WZWMyXCI7XHJcbmltcG9ydCB7IFRpbGVkVGlsZXNldERhdGEgfSBmcm9tIFwiLi9UaWxlZERhdGFcIjtcclxuXHJcbi8qKlxyXG4gKiBUaGUgZGF0YSByZXByZXNlbnRhdGlvbiBvZiBhIFRpbGVzZXQgZm9yIHRoZSBnYW1lIGVuZ2luZS4gVGhpcyByZXByZXNlbnRzIG9uZSBpbWFnZSxcclxuICogd2l0aCBhIHN0YXJ0SW5kZXggaWYgcmVxdWlyZWQgKGFzIGl0IGlzIHdpdGggVGlsZWQgdXNpbmcgdHdvIGltYWdlcyBpbiBvbmUgdGlsc2V0KS5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRpbGVzZXQge1xyXG4gICAgLyoqIFRoZSBrZXkgb2YgdGhlIGltYWdlIHVzZWQgYnkgdGhpcyB0aWxlc2V0ICovXHJcbiAgICBwcm90ZWN0ZWQgaW1hZ2VLZXk6IHN0cmluZztcclxuICAgIC8qKiBUaGUgc2l6ZSBvZiB0aGUgdGlsZXNldCBpbWFnZSAqL1xyXG4gICAgcHJvdGVjdGVkIGltYWdlU2l6ZTogVmVjMjtcclxuICAgIC8qKiBUaGUgaW5kZXggb2YgMHRoIGltYWdlIG9mIHRoaXMgdGlsZXNldCAqL1xyXG4gICAgcHJvdGVjdGVkIHN0YXJ0SW5kZXg6IG51bWJlcjtcclxuICAgIC8qKiBUaGUgaW5kZXggb2YgdGhlIGxhc3QgaW1hZ2Ugb2YgdGhpcyB0aWxzZXQgKi9cclxuICAgIHByb3RlY3RlZCBlbmRJbmRleDogbnVtYmVyO1xyXG4gICAgLyoqIFRoZSBzaXplIG9mIHRoZSB0aWxlcyBpbiB0aGlzIHRpbGVzZXQgKi9cclxuICAgIHByb3RlY3RlZCB0aWxlU2l6ZTogVmVjMjtcclxuICAgIC8qKiBUaGUgbnVtYmVyIG9mIHJvd3MgaW4gdGhpcyB0aWxlc2V0ICovXHJcbiAgICBwcm90ZWN0ZWQgbnVtUm93czogbnVtYmVyO1xyXG4gICAgLyoqIFRoZSBudW1iZXIgb2YgY29sdW1ucyBpbiB0aGlzIHRpbGVzZXQgKi9cclxuICAgIHByb3RlY3RlZCBudW1Db2xzOiBudW1iZXI7XHJcblxyXG4gICAgLy8gVE9ETzogQ2hhbmdlIHRoaXMgdG8gYmUgbW9yZSBnZW5lcmFsIGFuZCB3b3JrIHdpdGggb3RoZXIgdGlsZXNldCBmb3JtYXRzXHJcbiAgICBjb25zdHJ1Y3Rvcih0aWxlc2V0RGF0YTogVGlsZWRUaWxlc2V0RGF0YSl7XHJcbiAgICAgICAgLy8gRGVmZXIgaGFuZGxpbmcgb2YgdGhlIGRhdGEgdG8gYSBoZWxwZXIgY2xhc3NcclxuICAgICAgICB0aGlzLmluaXRGcm9tVGlsZWREYXRhKHRpbGVzZXREYXRhKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEluaXRpYWxpemUgdGhlIHRpbGVzZXQgZnJvbSB0aGUgZGF0YSBmcm9tIGEgVGlsZWQganNvbiBmaWxlXHJcbiAgICAgKiBAcGFyYW0gdGlsZWREYXRhIFRoZSBwYXJzZWQgb2JqZWN0IGZyb20gYSBUaWxlZCBqc29uIGZpbGVcclxuICAgICAqL1xyXG4gICAgaW5pdEZyb21UaWxlZERhdGEodGlsZWREYXRhOiBUaWxlZFRpbGVzZXREYXRhKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5udW1Sb3dzID0gdGlsZWREYXRhLnRpbGVjb3VudC90aWxlZERhdGEuY29sdW1ucztcclxuICAgICAgICB0aGlzLm51bUNvbHMgPSB0aWxlZERhdGEuY29sdW1ucztcclxuICAgICAgICB0aGlzLnN0YXJ0SW5kZXggPSB0aWxlZERhdGEuZmlyc3RnaWQ7XHJcbiAgICAgICAgdGhpcy5lbmRJbmRleCA9IHRoaXMuc3RhcnRJbmRleCArIHRpbGVkRGF0YS50aWxlY291bnQgLSAxO1xyXG4gICAgICAgIHRoaXMudGlsZVNpemUgPSBuZXcgVmVjMih0aWxlZERhdGEudGlsZXdpZHRoLCB0aWxlZERhdGEudGlsZXdpZHRoKTtcclxuICAgICAgICB0aGlzLmltYWdlS2V5ID0gdGlsZWREYXRhLmltYWdlO1xyXG4gICAgICAgIHRoaXMuaW1hZ2VTaXplID0gbmV3IFZlYzIodGlsZWREYXRhLmltYWdld2lkdGgsIHRpbGVkRGF0YS5pbWFnZWhlaWdodCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogR2V0cyB0aGUgaW1hZ2Uga2V5IGFzc29jaWF0ZWQgd2l0aCB0aGlzIHRpbGVtYXBcclxuICAgICAqIEByZXR1cm5zIFRoZSBpbWFnZSBrZXkgb2YgdGhpcyB0aWxlbWFwXHJcbiAgICAgKi9cclxuICAgIGdldEltYWdlS2V5KCk6IHN0cmluZyB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaW1hZ2VLZXk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgVmVjMiBjb250YWluaW5nIHRoZSBsZWZ0IGFuZCB0b3Agb2Zmc2V0IGZyb20gdGhlIGltYWdlIG9yaWdpbiBmb3IgdGhpcyB0aWxlLlxyXG4gICAgICogQHBhcmFtIHRpbGVJbmRleCBUaGUgaW5kZXggb2YgdGhlIHRpbGUgZnJvbSBzdGFydEluZGV4IHRvIGVuZEluZGV4IG9mIHRoaXMgdGlsZXNldFxyXG4gICAgICogQHJldHVybnMgQSBWZWMyIGNvbnRhaW5pbmcgdGhlIG9mZnNldCBmb3IgdGhlIHNwZWNpZmllZCB0aWxlLlxyXG4gICAgICovXHJcbiAgICBnZXRJbWFnZU9mZnNldEZvclRpbGUodGlsZUluZGV4OiBudW1iZXIpOiBWZWMyIHtcclxuICAgICAgICAvLyBHZXQgdGhlIHRydWUgaW5kZXhcclxuICAgICAgICBsZXQgaW5kZXggPSB0aWxlSW5kZXggLSB0aGlzLnN0YXJ0SW5kZXg7XHJcbiAgICAgICAgbGV0IHJvdyA9IE1hdGguZmxvb3IoaW5kZXggLyB0aGlzLm51bUNvbHMpO1xyXG4gICAgICAgIGxldCBjb2wgPSBpbmRleCAlIHRoaXMubnVtQ29scztcclxuICAgICAgICBsZXQgd2lkdGggPSB0aGlzLnRpbGVTaXplLng7XHJcbiAgICAgICAgbGV0IGhlaWdodCA9IHRoaXMudGlsZVNpemUueTtcclxuXHJcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBwb3NpdGlvbiB0byBzdGFydCBhIGNyb3AgaW4gdGhlIHRpbGVzZXQgaW1hZ2VcclxuICAgICAgICBsZXQgbGVmdCA9IGNvbCAqIHdpZHRoO1xyXG4gICAgICAgIGxldCB0b3AgPSByb3cgKiBoZWlnaHQ7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgVmVjMihsZWZ0LCB0b3ApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgc3RhcnQgaW5kZXhcclxuICAgICAqIEByZXR1cm5zIFRoZSBzdGFydCBpbmRleFxyXG4gICAgICovXHJcbiAgICBnZXRTdGFydEluZGV4KCk6IG51bWJlciB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnRJbmRleDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIHRpbGUgc2V0XHJcbiAgICAgKiBAcmV0dXJucyBBIFZlYzIgY29udGFpbmluZyB0aGUgdGlsZSBzaXplXHJcbiAgICAgKi9cclxuICAgIGdldFRpbGVTaXplKCk6IFZlYzIge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRpbGVTaXplO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgbnVtYmVyIG9mIHJvd3MgaW4gdGhlIHRpbGVzZXRcclxuICAgICAqIEByZXR1cm5zIFRoZSBudW1iZXIgb2Ygcm93c1xyXG4gICAgICovXHJcbiAgICBnZXROdW1Sb3dzKCk6IG51bWJlciB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubnVtUm93cztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIG51bWJlciBvZiBjb2x1bW5zIGluIHRoZSB0aWxzZXRcclxuICAgICAqIEByZXR1cm5zIFRoZSBudW1iZXIgb2YgY29sdW1uc1xyXG4gICAgICovXHJcbiAgICBnZXROdW1Db2xzKCk6IG51bWJlciB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubnVtQ29scztcclxuICAgIH1cclxuXHJcbiAgICBnZXRUaWxlQ291bnQoKTogbnVtYmVyIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5lbmRJbmRleCAtIHRoaXMuc3RhcnRJbmRleCArIDE7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3Mgd2hldGhlciBvciBub3QgdGhpcyB0aWxzZXQgY29udGFpbnMgdGhlIHNwZWNpZmllZCB0aWxlIGluZGV4LiBUaGlzIGlzIHVzZWQgZm9yIHJlbmRlcmluZy5cclxuICAgICAqIEBwYXJhbSB0aWxlSW5kZXggVGhlIGluZGV4IG9mIHRoZSB0aWxlIHRvIGNoZWNrXHJcbiAgICAgKiBAcmV0dXJucyBBIGJvb2xlYW4gcmVwcmVzZW50aW5nIHdoZXRoZXIgb3Igbm90IHRoaXMgdGlsc2V0IHVzZXMgdGhlIHNwZWNpZmllZCBpbmRleFxyXG4gICAgICovXHJcbiAgICBoYXNUaWxlKHRpbGVJbmRleDogbnVtYmVyKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIHRpbGVJbmRleCA+PSB0aGlzLnN0YXJ0SW5kZXggJiYgdGlsZUluZGV4IDw9IHRoaXMuZW5kSW5kZXg7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW5kZXIgYSBzaW5ndWxhciB0aWxlIHdpdGggaW5kZXggdGlsZUluZGV4IGZyb20gdGhlIHRpbGVzZXQgbG9jYXRlZCBhdCBwb3NpdGlvbiBkYXRhSW5kZXhcclxuICAgICAqIEBwYXJhbSBjdHggVGhlIHJlbmRlcmluZyBjb250ZXh0XHJcbiAgICAgKiBAcGFyYW0gdGlsZUluZGV4IFRoZSB2YWx1ZSBvZiB0aGUgdGlsZSB0byByZW5kZXJcclxuICAgICAqIEBwYXJhbSBkYXRhSW5kZXggVGhlIGluZGV4IG9mIHRoZSB0aWxlIGluIHRoZSBkYXRhIGFycmF5XHJcbiAgICAgKiBAcGFyYW0gd29ybGRTaXplIFRoZSBzaXplIG9mIHRoZSB3b3JsZFxyXG4gICAgICogQHBhcmFtIG9yaWdpbiBUaGUgdmlld3BvcnQgb3JpZ2luIGluIHRoZSBjdXJyZW50IGxheWVyXHJcbiAgICAgKiBAcGFyYW0gc2NhbGUgVGhlIHNjYWxlIG9mIHRoZSB0aWxlbWFwXHJcbiAgICAgKi9cclxuICAgIHJlbmRlclRpbGUoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIHRpbGVJbmRleDogbnVtYmVyLCBkYXRhSW5kZXg6IG51bWJlciwgbWF4Q29sczogbnVtYmVyLCBvcmlnaW46IFZlYzIsIHNjYWxlOiBWZWMyLCB6b29tOiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgICBsZXQgaW1hZ2UgPSBSZXNvdXJjZU1hbmFnZXIuZ2V0SW5zdGFuY2UoKS5nZXRJbWFnZSh0aGlzLmltYWdlS2V5KTtcclxuXHJcbiAgICAgICAgLy8gR2V0IHRoZSB0cnVlIGluZGV4XHJcbiAgICAgICAgbGV0IGluZGV4ID0gdGlsZUluZGV4IC0gdGhpcy5zdGFydEluZGV4O1xyXG4gICAgICAgIGxldCByb3cgPSBNYXRoLmZsb29yKGluZGV4IC8gdGhpcy5udW1Db2xzKTtcclxuICAgICAgICBsZXQgY29sID0gaW5kZXggJSB0aGlzLm51bUNvbHM7XHJcbiAgICAgICAgbGV0IHdpZHRoID0gdGhpcy50aWxlU2l6ZS54O1xyXG4gICAgICAgIGxldCBoZWlnaHQgPSB0aGlzLnRpbGVTaXplLnk7XHJcblxyXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgcG9zaXRpb24gdG8gc3RhcnQgYSBjcm9wIGluIHRoZSB0aWxlc2V0IGltYWdlXHJcbiAgICAgICAgbGV0IGxlZnQgPSBjb2wgKiB3aWR0aDtcclxuICAgICAgICBsZXQgdG9wID0gcm93ICogaGVpZ2h0O1xyXG5cclxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIHBvc2l0aW9uIGluIHRoZSB3b3JsZCB0byByZW5kZXIgdGhlIHRpbGVcclxuICAgICAgICBsZXQgeCA9IE1hdGguZmxvb3IoKGRhdGFJbmRleCAlIG1heENvbHMpICogd2lkdGggKiBzY2FsZS54KTtcclxuICAgICAgICBsZXQgeSA9IE1hdGguZmxvb3IoTWF0aC5mbG9vcihkYXRhSW5kZXggLyBtYXhDb2xzKSAqIGhlaWdodCAqIHNjYWxlLnkpO1xyXG4gICAgICAgIGN0eC5kcmF3SW1hZ2UoaW1hZ2UsIGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCwgTWF0aC5mbG9vcigoeCAtIG9yaWdpbi54KSp6b29tKSwgTWF0aC5mbG9vcigoeSAtIG9yaWdpbi55KSp6b29tKSwgTWF0aC5jZWlsKHdpZHRoICogc2NhbGUueCAqIHpvb20pLCBNYXRoLmNlaWwoaGVpZ2h0ICogc2NhbGUueSAqIHpvb20pKTtcclxuICAgIH1cclxufSIsImltcG9ydCBNYXRoVXRpbHMgZnJvbSBcIi4uL1V0aWxzL01hdGhVdGlsc1wiO1xyXG5cclxuLyoqXHJcbiAqIEEgdHdvLWRpbWVuc2lvbmFsIHZlY3RvciAoeCwgeSlcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFZlYzIge1xyXG5cclxuXHQvLyBTdG9yZSB4IGFuZCB5IGluIGFuIGFycmF5XHJcblx0LyoqIFRoZSBhcnJheSB0aGF0IHN0b3JlcyB0aGUgYWN0dWFsIHZlY3RvciB2YWx1ZXMgeCBhbmQgeSAqL1xyXG5cdHByaXZhdGUgdmVjOiBGbG9hdDMyQXJyYXk7XHJcblxyXG5cdC8qKlx0XHJcblx0ICogV2hlbiB0aGlzIHZlY3RvciBjaGFuZ2VzIGl0cyB2YWx1ZSwgZG8gc29tZXRoaW5nXHJcblx0ICovXHJcblx0cHJpdmF0ZSBvbkNoYW5nZTogRnVuY3Rpb24gPSAoKSA9PiB7fTtcclxuXHJcblx0LyoqXHJcblx0ICogQ3JlYXRlcyBhIG5ldyBWZWMyXHJcblx0ICogQHBhcmFtIHggVGhlIHggdmFsdWUgb2YgdGhlIHZlY3RvclxyXG5cdCAqIEBwYXJhbSB5IFRoZSB5IHZhbHVlIG9mIHRoZSB2ZWN0b3JcclxuXHQgKi9cclxuXHRjb25zdHJ1Y3Rvcih4OiBudW1iZXIgPSAwLCB5OiBudW1iZXIgPSAwKSB7XHJcblx0XHR0aGlzLnZlYyA9IG5ldyBGbG9hdDMyQXJyYXkoMik7XHJcblx0XHR0aGlzLnZlY1swXSA9IHg7XHJcblx0XHR0aGlzLnZlY1sxXSA9IHk7XHJcblx0fVxyXG5cclxuXHQvLyBFeHBvc2UgeCBhbmQgeSB3aXRoIGdldHRlcnMgYW5kIHNldHRlcnNcclxuXHRnZXQgeCgpIHtcclxuXHRcdHJldHVybiB0aGlzLnZlY1swXTtcclxuXHR9XHJcblxyXG5cdHNldCB4KHg6IG51bWJlcikge1xyXG5cdFx0dGhpcy52ZWNbMF0gPSB4O1xyXG5cclxuXHRcdGlmKHRoaXMub25DaGFuZ2Upe1xyXG5cdFx0XHR0aGlzLm9uQ2hhbmdlKCk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRnZXQgeSgpIHtcclxuXHRcdHJldHVybiB0aGlzLnZlY1sxXTtcclxuXHR9XHJcblxyXG5cdHNldCB5KHk6IG51bWJlcikge1xyXG5cdFx0dGhpcy52ZWNbMV0gPSB5O1xyXG5cclxuXHRcdGlmKHRoaXMub25DaGFuZ2Upe1xyXG5cdFx0XHR0aGlzLm9uQ2hhbmdlKCk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRzdGF0aWMgZ2V0IFpFUk8oKSB7XHJcblx0XHRyZXR1cm4gbmV3IFZlYzIoMCwgMCk7XHJcblx0fVxyXG5cclxuXHRzdGF0aWMgcmVhZG9ubHkgWkVST19TVEFUSUMgPSBuZXcgVmVjMigwLCAwKTtcclxuXHJcblx0c3RhdGljIGdldCBJTkYoKSB7XHJcblx0XHRyZXR1cm4gbmV3IFZlYzIoSW5maW5pdHksIEluZmluaXR5KTtcclxuXHR9XHJcblxyXG5cdHN0YXRpYyBnZXQgVVAoKSB7XHJcblx0XHRyZXR1cm4gbmV3IFZlYzIoMCwgLTEpO1xyXG5cdH1cclxuXHJcblx0c3RhdGljIGdldCBET1dOKCkge1xyXG5cdFx0cmV0dXJuIG5ldyBWZWMyKDAsIDEpO1xyXG5cdH1cclxuXHJcblx0c3RhdGljIGdldCBMRUZUKCkge1xyXG5cdFx0cmV0dXJuIG5ldyBWZWMyKC0xLCAwKTtcclxuXHR9XHJcblxyXG5cdHN0YXRpYyBnZXQgUklHSFQoKSB7XHJcblx0XHRyZXR1cm4gbmV3IFZlYzIoMSwgMCk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBUaGUgc3F1YXJlZCBtYWduaXR1ZGUgb2YgdGhlIHZlY3Rvci4gVGhpcyB0ZW5kcyB0byBiZSBmYXN0ZXIsIHNvIHVzZSBpdCBpbiBzaXR1YXRpb25zIHdoZXJlIHRha2luZyB0aGVcclxuXHQgKiBzcXVhcmUgcm9vdCBkb2Vzbid0IG1hdHRlciwgbGlrZSBmb3IgY29tcGFyaW5nIGRpc3RhbmNlcy5cclxuXHQgKiBAcmV0dXJucyBUaGUgc3F1YXJlZCBtYWduaXR1ZGUgb2YgdGhlIHZlY3RvclxyXG5cdCAqL1xyXG5cdG1hZ1NxKCk6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gdGhpcy54KnRoaXMueCArIHRoaXMueSp0aGlzLnk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBUaGUgbWFnbml0dWRlIG9mIHRoZSB2ZWN0b3IuXHJcblx0ICogQHJldHVybnMgVGhlIG1hZ25pdHVkZSBvZiB0aGUgdmVjdG9yLlxyXG5cdCAqL1xyXG5cdG1hZygpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIE1hdGguc3FydCh0aGlzLm1hZ1NxKCkpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogRGl2ZGVzIHggYW5kIHkgYnkgdGhlIG1hZ25pdHVkZSB0byBvYnRhaW4gdGhlIHVuaXQgdmVjdG9yIGluIHRoZSBkaXJlY3Rpb24gb2YgdGhpcyB2ZWN0b3IuXHJcblx0ICogQHJldHVybnMgVGhpcyB2ZWN0b3IgYXMgYSB1bml0IHZlY3Rvci5cclxuXHQgKi9cclxuXHRub3JtYWxpemUoKTogVmVjMiB7XHJcblx0XHRpZih0aGlzLnggPT09IDAgJiYgdGhpcy55ID09PSAwKSByZXR1cm4gdGhpcztcclxuXHRcdGxldCBtYWcgPSB0aGlzLm1hZygpO1xyXG5cdFx0dGhpcy54IC89IG1hZztcclxuXHRcdHRoaXMueSAvPSBtYWc7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFdvcmtzIGxpa2Ugbm9ybWFsaXplKCksIGJ1dCByZXR1cm5zIGEgbmV3IFZlYzJcclxuXHQgKiBAcmV0dXJucyBBIG5ldyB2ZWN0b3IgdGhhdCBpcyB0aGUgdW5pdCB2ZWN0b3IgZm9yIHRoaXMgb25lXHJcblx0ICovXHJcblx0bm9ybWFsaXplZCgpOiBWZWMyIHtcclxuXHRcdGlmKHRoaXMuaXNaZXJvKCkpe1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHRcdFxyXG5cdFx0bGV0IG1hZyA9IHRoaXMubWFnKCk7XHJcblx0XHRyZXR1cm4gbmV3IFZlYzIodGhpcy54L21hZywgdGhpcy55L21hZyk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBTZXRzIHRoZSB4IGFuZCB5IGVsZW1lbnRzIG9mIHRoaXMgdmVjdG9yIHRvIHplcm8uXHJcblx0ICogQHJldHVybnMgVGhpcyB2ZWN0b3IsIHdpdGggeCBhbmQgeSBzZXQgdG8gemVyby5cclxuXHQgKi9cclxuXHR6ZXJvKCk6IFZlYzIge1xyXG5cdFx0cmV0dXJuIHRoaXMuc2V0KDAsIDApO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogU2V0cyB0aGUgdmVjdG9yJ3MgeCBhbmQgeSBiYXNlZCBvbiB0aGUgYW5nbGUgcHJvdmlkZWQuIEdvZXMgY291bnRlciBjbG9ja3dpc2UuXHJcblx0ICogQHBhcmFtIGFuZ2xlIFRoZSBhbmdsZSBpbiByYWRpYW5zXHJcblx0ICogQHBhcmFtIHJhZGl1cyBUaGUgbWFnbml0dWRlIG9mIHRoZSB2ZWN0b3IgYXQgdGhlIHNwZWNpZmllZCBhbmdsZVxyXG5cdCAqIEByZXR1cm5zIFRoaXMgdmVjdG9yLlxyXG5cdCAqL1xyXG5cdHNldFRvQW5nbGUoYW5nbGU6IG51bWJlciwgcmFkaXVzOiBudW1iZXIgPSAxKTogVmVjMiB7XHJcblx0XHR0aGlzLnggPSBNYXRoVXRpbHMuZmxvb3JUb1BsYWNlKE1hdGguY29zKGFuZ2xlKSpyYWRpdXMsIDUpO1xyXG5cdFx0dGhpcy55ID0gTWF0aFV0aWxzLmZsb29yVG9QbGFjZSgtTWF0aC5zaW4oYW5nbGUpKnJhZGl1cywgNSk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgYSB2ZWN0b3IgdGhhdCBwb2ludCBmcm9tIHRoaXMgdmVjdG9yIHRvIGFub3RoZXIgb25lXHJcblx0ICogQHBhcmFtIG90aGVyIFRoZSB2ZWN0b3IgdG8gcG9pbnQgdG9cclxuXHQgKiBAcmV0dXJucyBBIG5ldyBWZWMyIHRoYXQgcG9pbnRzIGZyb20gdGhpcyB2ZWN0b3IgdG8gdGhlIG9uZSBwcm92aWRlZFxyXG5cdCAqL1xyXG5cdHZlY1RvKG90aGVyOiBWZWMyKTogVmVjMiB7XHJcblx0XHRyZXR1cm4gbmV3IFZlYzIob3RoZXIueCAtIHRoaXMueCwgb3RoZXIueSAtIHRoaXMueSk7XHJcblx0fVxyXG5cdFxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgYSB2ZWN0b3IgY29udGFpbmluZyB0aGUgZGlyZWN0aW9uIGZyb20gdGhpcyB2ZWN0b3IgdG8gYW5vdGhlclxyXG5cdCAqIEBwYXJhbSBvdGhlciBUaGUgdmVjdG9yIHRvIHBvaW50IHRvXHJcblx0ICogQHJldHVybnMgQSBuZXcgVmVjMiB0aGF0IHBvaW50cyBmcm9tIHRoaXMgdmVjdG9yIHRvIHRoZSBvbmUgcHJvdmlkZWQuIFRoaXMgbmV3IFZlYzIgd2lsbCBiZSBhIHVuaXQgdmVjdG9yLlxyXG5cdCAqL1xyXG5cdGRpclRvKG90aGVyOiBWZWMyKTogVmVjMiB7XHJcblx0XHRyZXR1cm4gdGhpcy52ZWNUbyhvdGhlcikubm9ybWFsaXplKCk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBLZWVwcyB0aGUgdmVjdG9yJ3MgZGlyZWN0aW9uLCBidXQgc2V0cyBpdHMgbWFnbml0dWRlIHRvIGJlIHRoZSBwcm92aWRlZCBtYWduaXR1ZGVcclxuXHQgKiBAcGFyYW0gbWFnbml0dWRlIFRoZSBtYWduaXR1ZGUgdGhlIHZlY3RvciBzaG91bGQgYmVcclxuXHQgKiBAcmV0dXJucyBUaGlzIHZlY3RvciB3aXRoIGl0cyBtYWduaXR1ZGUgc2V0IHRvIHRoZSBuZXcgbWFnbml0dWRlXHJcblx0ICovXHJcblx0c2NhbGVUbyhtYWduaXR1ZGU6IG51bWJlcik6IFZlYzIge1xyXG5cdFx0cmV0dXJuIHRoaXMubm9ybWFsaXplKCkuc2NhbGUobWFnbml0dWRlKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFNjYWxlcyB4IGFuZCB5IGJ5IHRoZSBudW1iZXIgcHJvdmlkZWQsIG9yIGlmIHR3byBudW1iZXIgYXJlIHByb3ZpZGVkLCBzY2FsZXMgdGhlbSBpbmRpdmlkdWFsbHkuXHJcblx0ICogQHBhcmFtIGZhY3RvciBUaGUgc2NhbGluZyBmYWN0b3IgZm9yIHRoZSB2ZWN0b3IsIG9yIGZvciBvbmx5IHRoZSB4LWNvbXBvbmVudCBpZiB5RmFjdG9yIGlzIHByb3ZpZGVkXHJcblx0ICogQHBhcmFtIHlGYWN0b3IgVGhlIHNjYWxpbmcgZmFjdG9yIGZvciB0aGUgeS1jb21wb25lbnQgb2YgdGhlIHZlY3RvclxyXG5cdCAqIEByZXR1cm5zIFRoaXMgdmVjdG9yIGFmdGVyIHNjYWxpbmdcclxuXHQgKi9cclxuXHRzY2FsZShmYWN0b3I6IG51bWJlciwgeUZhY3RvcjogbnVtYmVyID0gbnVsbCk6IFZlYzIge1xyXG5cdFx0aWYoeUZhY3RvciAhPT0gbnVsbCl7XHJcblx0XHRcdHRoaXMueCAqPSBmYWN0b3I7XHJcblx0XHRcdHRoaXMueSAqPSB5RmFjdG9yO1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHRcdHRoaXMueCAqPSBmYWN0b3I7XHJcblx0XHR0aGlzLnkgKj0gZmFjdG9yO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIGEgc2NhbGVkIHZlcnNpb24gb2YgdGhpcyB2ZWN0b3Igd2l0aG91dCBtb2RpZnlpbmcgaXQuXHJcblx0ICogQHBhcmFtIGZhY3RvciBUaGUgc2NhbGluZyBmYWN0b3IgZm9yIHRoZSB2ZWN0b3IsIG9yIGZvciBvbmx5IHRoZSB4LWNvbXBvbmVudCBpZiB5RmFjdG9yIGlzIHByb3ZpZGVkXHJcblx0ICogQHBhcmFtIHlGYWN0b3IgVGhlIHNjYWxpbmcgZmFjdG9yIGZvciB0aGUgeS1jb21wb25lbnQgb2YgdGhlIHZlY3RvclxyXG5cdCAqIEByZXR1cm5zIEEgbmV3IHZlY3RvciB0aGF0IGhhcyB0aGUgdmFsdWVzIG9mIHRoaXMgdmVjdG9yIGFmdGVyIHNjYWxpbmdcclxuXHQgKi9cclxuXHRzY2FsZWQoZmFjdG9yOiBudW1iZXIsIHlGYWN0b3I6IG51bWJlciA9IG51bGwpOiBWZWMyIHtcclxuXHRcdHJldHVybiB0aGlzLmNsb25lKCkuc2NhbGUoZmFjdG9yLCB5RmFjdG9yKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJvdGF0ZXMgdGhlIHZlY3RvciBjb3VudGVyLWNsb2Nrd2lzZSBieSB0aGUgYW5nbGUgYW1vdW50IHNwZWNpZmllZFxyXG5cdCAqIEBwYXJhbSBhbmdsZSBUaGUgYW5nbGUgdG8gcm90YXRlIGJ5IGluIHJhZGlhbnNcclxuXHQgKiBAcmV0dXJucyBUaGlzIHZlY3RvciBhZnRlciByb3RhdGlvbi5cclxuXHQgKi9cclxuXHRyb3RhdGVDQ1coYW5nbGU6IG51bWJlcik6IFZlYzIge1xyXG5cdFx0bGV0IGNzID0gTWF0aC5jb3MoYW5nbGUpO1xyXG5cdFx0bGV0IHNuID0gTWF0aC5zaW4oYW5nbGUpO1xyXG5cdFx0bGV0IHRlbXBYID0gdGhpcy54KmNzIC0gdGhpcy55KnNuO1xyXG5cdFx0bGV0IHRlbXBZID0gdGhpcy54KnNuICsgdGhpcy55KmNzO1xyXG5cdFx0dGhpcy54ID0gdGVtcFg7XHJcblx0XHR0aGlzLnkgPSB0ZW1wWTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogU2V0cyB0aGUgdmVjdG9ycyBjb29yZGluYXRlcyB0byBiZSB0aGUgb25lcyBwcm92aWRlZFxyXG5cdCAqIEBwYXJhbSB4IFRoZSBuZXcgeCB2YWx1ZSBmb3IgdGhpcyB2ZWN0b3JcclxuXHQgKiBAcGFyYW0geSBUaGUgbmV3IHkgdmFsdWUgZm9yIHRoaXMgdmVjdG9yXHJcblx0ICogQHJldHVybnMgVGhpcyB2ZWN0b3JcclxuXHQgKi9cclxuXHRzZXQoeDogbnVtYmVyLCB5OiBudW1iZXIpOiBWZWMyIHtcclxuXHRcdHRoaXMueCA9IHg7XHJcblx0XHR0aGlzLnkgPSB5O1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBDb3BpZXMgdGhlIHZhbHVlcyBvZiB0aGUgb3RoZXIgVmVjMiBpbnRvIHRoaXMgb25lLlxyXG5cdCAqIEBwYXJhbSBvdGhlciBUaGUgVmVjMiB0byBjb3B5XHJcblx0ICogQHJldHVybnMgVGhpcyB2ZWN0b3Igd2l0aCBpdHMgdmFsdWVzIHNldCB0byB0aGUgdmVjdG9yIHByb3ZpZGVkXHJcblx0ICovXHJcblx0Y29weShvdGhlcjogVmVjMik6IFZlYzIge1xyXG5cdFx0cmV0dXJuIHRoaXMuc2V0KG90aGVyLngsIG90aGVyLnkpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQWRkcyB0aGlzIHZlY3RvciB0aGUgYW5vdGhlciB2ZWN0b3JcclxuXHQgKiBAcGFyYW0gb3RoZXIgVGhlIFZlYzIgdG8gYWRkIHRvIHRoaXMgb25lXHJcblx0ICogQHJldHVybnMgVGhpcyB2ZWN0b3IgYWZ0ZXIgYWRkaW5nIHRoZSBvbmUgcHJvdmlkZWRcclxuXHQgKi9cclxuXHRhZGQob3RoZXI6IFZlYzIpOiBWZWMyIHtcclxuXHRcdHRoaXMueCArPSBvdGhlci54O1xyXG5cdFx0dGhpcy55ICs9IG90aGVyLnk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEluY3JlbWVudHMgdGhlIGZpZWxkcyBvZiB0aGlzIHZlY3Rvci4gQm90aCBhcmUgaW5jcmVtZW50ZWQgd2l0aCBhLCBpZiBvbmx5IGEgaXMgcHJvdmlkZWQuXHJcblx0ICogQHBhcmFtIGEgVGhlIGZpcnN0IG51bWJlciB0byBpbmNyZW1lbnQgYnlcclxuXHQgKiBAcGFyYW0gYiBUaGUgc2Vjb25kIG51bWJlciB0byBpbmNyZW1lbnQgYnlcclxuXHQgKiBAcmV0dXJuc3MgVGhpcyB2ZWN0b3IgYWZ0ZXIgaW5jcmVtZW50aW5nXHJcblx0ICovXHJcblx0aW5jKGE6IG51bWJlciwgYj86IG51bWJlcik6IFZlYzIge1xyXG5cdFx0aWYoYiA9PT0gdW5kZWZpbmVkKXtcclxuXHRcdFx0dGhpcy54ICs9IGE7XHJcblx0XHRcdHRoaXMueSArPSBhO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dGhpcy54ICs9IGE7XHJcblx0XHRcdHRoaXMueSArPSBiO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBTdWJ0cmFjdHMgYW5vdGhlciB2ZWN0b3IgZnJvbSB0aGlzIHZlY3RvclxyXG5cdCAqIEBwYXJhbSBvdGhlciBUaGUgVmVjMiB0byBzdWJ0cmFjdCBmcm9tIHRoaXMgb25lXHJcblx0ICogQHJldHVybnMgVGhpcyB2ZWN0b3IgYWZ0ZXIgc3VidHJhY3RpbmcgdGhlIG9uZSBwcm92aWRlZFxyXG5cdCAqL1xyXG5cdHN1YihvdGhlcjogVmVjMik6IFZlYzIge1xyXG5cdFx0dGhpcy54IC09IG90aGVyLng7XHJcblx0XHR0aGlzLnkgLT0gb3RoZXIueTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogTXVsdGlwbGllcyB0aGlzIHZlY3RvciB3aXRoIGFub3RoZXIgdmVjdG9yIGVsZW1lbnQtd2lzZS4gSW4gb3RoZXIgd29yZHMsIHRoaXMueCAqPSBvdGhlci54IGFuZCB0aGlzLnkgKj0gb3RoZXIueVxyXG5cdCAqIEBwYXJhbSBvdGhlciBUaGUgVmVjMiB0byBtdWx0aXBseSB0aGlzIG9uZSBieVxyXG5cdCAqIEByZXR1cm5zIFRoaXMgdmVjdG9yIGFmdGVyIG11bHRpcGx5aW5nIGl0cyBjb21wb25lbnRzIGJ5IHRoaXMgb25lXHJcblx0ICovXHJcblx0bXVsdChvdGhlcjogVmVjMik6IFZlYzIge1xyXG5cdFx0dGhpcy54ICo9IG90aGVyLng7XHJcblx0XHR0aGlzLnkgKj0gb3RoZXIueTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogRGl2aWRlcyB0aGlzIHZlY3RvciB3aXRoIGFub3RoZXIgdmVjdG9yIGVsZW1lbnQtd2lzZS4gSW4gb3RoZXIgd29yZHMsIHRoaXMueCAvPSBvdGhlci54IGFuZCB0aGlzLnkgLz0gb3RoZXIueVxyXG5cdCAqIEBwYXJhbSBvdGhlciBUaGUgdmVjdG9yIHRvIGRpdmlkZSB0aGlzIG9uZSBieVxyXG5cdCAqIEByZXR1cm5zIFRoaXMgdmVjdG9yIGFmdGVyIGRpdmlzaW9uXHJcblx0ICovXHJcblx0ZGl2KG90aGVyOiBWZWMyKTogVmVjMiB7XHJcblx0XHRpZihvdGhlci54ID09PSAwIHx8IG90aGVyLnkgPT09IDApIHRocm93IFwiRGl2aWRlIGJ5IHplcm8gZXJyb3JcIjtcclxuXHRcdHRoaXMueCAvPSBvdGhlci54O1xyXG5cdFx0dGhpcy55IC89IG90aGVyLnk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIERvZXMgYW4gZWxlbWVudCB3aXNlIHJlbWFpbmRlciBvcGVyYXRpb24gb24gdGhpcyB2ZWN0b3IuIHRoaXMueCAlPSBvdGhlci54IGFuZCB0aGlzLnkgJT0gb3RoZXIueVxyXG5cdCAqIEBwYXJhbSBvdGhlciBUaGUgb3RoZXIgdmVjdG9yXHJcblx0ICogQHJldHVybnMgdGhpcyB2ZWN0b3JcclxuXHQgKi9cclxuXHRyZW1haW5kZXIob3RoZXI6IFZlYzIpOiBWZWMyIHtcclxuXHRcdHRoaXMueCA9IHRoaXMueCAlIG90aGVyLng7XHJcblx0XHR0aGlzLnkgPSB0aGlzLnkgJSBvdGhlci55O1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRoZSBzcXVhcmVkIGRpc3RhbmNlIGJldHdlZW4gdGhpcyB2ZWN0b3IgYW5kIGFub3RoZXIgdmVjdG9yXHJcblx0ICogQHBhcmFtIG90aGVyIFRoZSB2ZWN0b3IgdG8gY29tcHV0ZSBkaXN0YW5jZSBzcXVhcmVkIHRvXHJcblx0ICogQHJldHVybnMgVGhlIHNxdWFyZWQgZGlzdGFuY2UgYmV0d2VlbiB0aGlzIHZlY3RvciBhbmQgdGhlIG9uZSBwcm92aWRlZFxyXG5cdCAqL1xyXG5cdGRpc3RhbmNlU3FUbyhvdGhlcjogVmVjMik6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gKHRoaXMueCAtIG90aGVyLngpKih0aGlzLnggLSBvdGhlci54KSArICh0aGlzLnkgLSBvdGhlci55KSoodGhpcy55IC0gb3RoZXIueSk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoaXMgdmVjdG9yIGFuZCBhbm90aGVyIHZlY3RvclxyXG5cdCAqIEBwYXJhbSBvdGhlciBUaGUgdmVjdG9yIHRvIGNvbXB1dGUgZGlzdGFuY2UgdG9cclxuXHQgKiBAcmV0dXJucyBUaGUgZGlzdGFuY2UgYmV0d2VlbiB0aGlzIHZlY3RvciBhbmQgdGhlIG9uZSBwcm92aWRlZFxyXG5cdCAqL1xyXG5cdGRpc3RhbmNlVG8ob3RoZXI6IFZlYzIpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIE1hdGguc3FydCh0aGlzLmRpc3RhbmNlU3FUbyhvdGhlcikpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0aGUgZG90IHByb2R1Y3Qgb2YgdGhpcyB2ZWN0b3IgYW5kIGFub3RoZXJcclxuXHQgKiBAcGFyYW0gb3RoZXIgVGhlIHZlY3RvciB0byBjb21wdXRlIHRoZSBkb3QgcHJvZHVjdCB3aXRoXHJcblx0ICogQHJldHVybnMgVGhlIGRvdCBwcm9kdWN0IG9mIHRoaXMgdmVjdG9yIGFuZCB0aGUgb25lIHByb3ZpZGVkLlxyXG5cdCAqL1xyXG5cdGRvdChvdGhlcjogVmVjMik6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gdGhpcy54Km90aGVyLnggKyB0aGlzLnkqb3RoZXIueTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgdGhlIGFuZ2xlIGNvdW50ZXItY2xvY2t3aXNlIGluIHJhZGlhbnMgZnJvbSB0aGlzIHZlY3RvciB0byBhbm90aGVyIHZlY3RvclxyXG5cdCAqIEBwYXJhbSBvdGhlciBUaGUgdmVjdG9yIHRvIGNvbXB1dGUgdGhlIGFuZ2xlIHRvXHJcblx0ICogQHJldHVybnMgVGhlIGFuZ2xlLCByb3RhdGluZyBDQ1csIGZyb20gdGhpcyB2ZWN0b3IgdG8gdGhlIG90aGVyIHZlY3RvclxyXG5cdCAqL1xyXG5cdGFuZ2xlVG9DQ1cob3RoZXI6IFZlYzIpOiBudW1iZXIge1xyXG5cdFx0bGV0IGRvdCA9IHRoaXMuZG90KG90aGVyKTtcclxuXHRcdGxldCBkZXQgPSB0aGlzLngqb3RoZXIueSAtIHRoaXMueSpvdGhlci54O1xyXG5cdFx0bGV0IGFuZ2xlID0gLU1hdGguYXRhbjIoZGV0LCBkb3QpO1xyXG5cclxuXHRcdGlmKGFuZ2xlIDwgMCl7XHJcblx0XHRcdGFuZ2xlICs9IDIqTWF0aC5QSTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gYW5nbGU7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgdmVjdG9yIHJvdW5kZWQgdG8gMSBkZWNpbWFsIHBvaW50XHJcblx0ICogQHJldHVybnMgVGhpcyB2ZWN0b3IgYXMgYSBzdHJpbmdcclxuXHQgKi9cclxuXHR0b1N0cmluZygpOiBzdHJpbmcge1xyXG5cdFx0cmV0dXJuIHRoaXMudG9GaXhlZCgpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHZlY3RvciByb3VuZGVkIHRvIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIGRlY2ltYWwgcG9pbnRzXHJcblx0ICogQHBhcmFtIG51bURlY2ltYWxQb2ludHMgVGhlIG51bWJlciBvZiBkZWNpbWFsIHBvaW50cyB0byBjcmVhdGUgYSBzdHJpbmcgdG9cclxuXHQgKiBAcmV0dXJucyBUaGlzIHZlY3RvciBhcyBhIHN0cmluZ1xyXG5cdCAqL1xyXG5cdHRvRml4ZWQobnVtRGVjaW1hbFBvaW50czogbnVtYmVyID0gMSk6IHN0cmluZyB7XHJcblx0XHRyZXR1cm4gXCIoXCIgKyB0aGlzLngudG9GaXhlZChudW1EZWNpbWFsUG9pbnRzKSArIFwiLCBcIiArIHRoaXMueS50b0ZpeGVkKG51bURlY2ltYWxQb2ludHMpICsgXCIpXCI7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIGEgbmV3IHZlY3RvciB3aXRoIHRoZSBzYW1lIGNvb3JkaW5hdGVzIGFzIHRoaXMgb25lLlxyXG5cdCAqIEByZXR1cm5zIEEgbmV3IFZlYzIgd2l0aCB0aGUgc2FtZSB2YWx1ZXMgYXMgdGhpcyBvbmVcclxuXHQgKi9cclxuXHRjbG9uZSgpOiBWZWMyIHtcclxuXHRcdHJldHVybiBuZXcgVmVjMih0aGlzLngsIHRoaXMueSk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyB2ZWN0b3IgYW5kIG90aGVyIGhhdmUgdGhlIEVYQUNUIHNhbWUgeCBhbmQgeSAobm90IGFzc3VyZWQgdG8gYmUgc2FmZSBmb3IgZmxvYXRzKVxyXG5cdCAqIEBwYXJhbSBvdGhlciBUaGUgdmVjdG9yIHRvIGNoZWNrIGFnYWluc3RcclxuXHQgKiBAcmV0dXJucyBBIGJvb2xlYW4gcmVwcmVzZW50aW5nIHRoZSBlcXVhbGl0eSBvZiB0aGUgdHdvIHZlY3RvcnNcclxuXHQgKi9cclxuXHRzdHJpY3RFcXVhbHMob3RoZXI6IFZlYzIpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiB0aGlzLnggPT09IG90aGVyLnggJiYgdGhpcy55ID09PSBvdGhlci55O1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0cnVlIGlmIHRoaXMgdmVjdG9yIGFuZCBvdGhlciBoYXZlIHRoZSBzYW1lIHggYW5kIHlcclxuXHQgKiBAcGFyYW0gb3RoZXIgVGhlIHZlY3RvciB0byBjaGVjayBhZ2FpbnN0XHJcblx0ICogQHJldHVybnMgQSBib29sZWFuIHJlcHJlc2VudGluZyB0aGUgZXF1YWxpdHkgb2YgdGhlIHR3byB2ZWN0b3JzXHJcblx0ICovXHJcblx0ZXF1YWxzKG90aGVyOiBWZWMyKTogYm9vbGVhbiB7XHJcblx0XHRsZXQgeEVxID0gTWF0aC5hYnModGhpcy54IC0gb3RoZXIueCkgPCAwLjAwMDAwMDE7XHJcblx0XHRsZXQgeUVxID0gTWF0aC5hYnModGhpcy55IC0gb3RoZXIueSkgPCAwLjAwMDAwMDE7XHJcblxyXG5cdFx0cmV0dXJuIHhFcSAmJiB5RXE7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyB2ZWN0b3IgaXMgdGhlIHplcm8gdmVjdG9yIGV4YWN0bHkgKG5vdCBhc3N1cmVkIHRvIGJlIHNhZmUgZm9yIGZsb2F0cykuXHJcblx0ICogQHJldHVybnMgQSBib29sZWFuIHJlcHJlc2VudGluZyB0aGUgZXF1YWxpdHkgb2YgdGhpcyB2ZWN0b3IgYW5kIHRoZSB6ZXJvIHZlY3RvclxyXG5cdCAqL1xyXG5cdHN0cmljdElzWmVybygpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiB0aGlzLnggPT09IDAgJiYgdGhpcy55ID09PSAwO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0cnVlIGlmIHRoaXMgeCBhbmQgeSBmb3IgdGhpcyB2ZWN0b3IgYXJlIGJvdGggemVyby5cclxuXHQgKiBAcmV0dXJucyBBIGJvb2xlYW4gcmVwcmVzZW50aW5nIHRoZSBlcXVhbGl0eSBvZiB0aGlzIHZlY3RvciBhbmQgdGhlIHplcm8gdmVjdG9yXHJcblx0ICovXHJcblx0aXNaZXJvKCk6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIE1hdGguYWJzKHRoaXMueCkgPCAwLjAwMDAwMDEgJiYgTWF0aC5hYnModGhpcy55KSA8IDAuMDAwMDAwMTtcclxuXHR9XHJcblx0XHJcblx0LyoqXHJcblx0ICogU2V0cyB0aGUgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2hlbmV2ZXIgdGhpcyB2ZWN0b3IgaXMgY2hhbmdlZC5cclxuXHQgKiBAcGFyYW0gZiBUaGUgZnVuY3Rpb24gdG8gYmUgY2FsbGVkXHJcblx0ICovXHJcblx0c2V0T25DaGFuZ2UoZjogRnVuY3Rpb24pOiB2b2lkIHtcclxuXHRcdHRoaXMub25DaGFuZ2UgPSBmO1xyXG5cdH1cclxuXHJcblx0dG9BcnJheSgpOiBGbG9hdDMyQXJyYXkge1xyXG5cdFx0cmV0dXJuIHRoaXMudmVjO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUGVyZm9ybXMgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gdmVjdG9yc1xyXG5cdCAqIEBwYXJhbSBhIFRoZSBmaXJzdCB2ZWN0b3JcclxuXHQgKiBAcGFyYW0gYiBUaGUgc2Vjb25kIHZlY3RvclxyXG5cdCAqIEBwYXJhbSB0IFRoZSB0aW1lIG9mIHRoZSBsZXJwLCB3aXRoIDAgYmVpbmcgdmVjdG9yIEEsIGFuZCAxIGJlaW5nIHZlY3RvciBCXHJcblx0ICogQHJldHVybnMgQSBuZXcgVmVjMiByZXByZXNlbnRpbmcgdGhlIGxlcnAgYmV0d2VlbiB2ZWN0b3IgYSBhbmQgYi5cclxuXHQgKi9cclxuXHRzdGF0aWMgbGVycChhOiBWZWMyLCBiOiBWZWMyLCB0OiBudW1iZXIpOiBWZWMyIHtcclxuXHRcdHJldHVybiBuZXcgVmVjMihNYXRoVXRpbHMubGVycChhLngsIGIueCwgdCksIE1hdGhVdGlscy5sZXJwKGEueSwgYi55LCB0KSk7XHJcblx0fVxyXG59IiwiaW1wb3J0IE1hcCBmcm9tIFwiLi4vRGF0YVR5cGVzL01hcFwiO1xyXG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vRGF0YVR5cGVzL1ZlYzJcIjtcclxuaW1wb3J0IEdhbWVOb2RlIGZyb20gXCIuLi9Ob2Rlcy9HYW1lTm9kZVwiO1xyXG5pbXBvcnQgQ29sb3IgZnJvbSBcIi4uL1V0aWxzL0NvbG9yXCI7XHJcblxyXG4vKipcclxuICogQSB1dGlsIGNsYXNzIGZvciByZW5kZXJpbmcgRGVidWcgbWVzc2FnZXMgdG8gdGhlIGNhbnZhcy5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERlYnVnIHtcclxuXHJcblx0LyoqIEEgbWFwIG9mIGxvZyBtZXNzYWdlcyB0byBkaXNwbGF5IG9uIHRoZSBzY3JlZW4gKi8gXHJcblx0cHJpdmF0ZSBzdGF0aWMgbG9nTWVzc2FnZXM6IE1hcDxzdHJpbmc+ID0gbmV3IE1hcCgpO1xyXG5cclxuXHQvKiogQW4gYXJyYXkgb2YgZ2FtZSBub2RlcyB0byByZW5kZXIgZGVidWcgaW5mbyBmb3IgKi9cclxuXHRwcml2YXRlIHN0YXRpYyBub2RlczogQXJyYXk8R2FtZU5vZGU+O1xyXG5cclxuXHQvKiogVGhlIHJlbmRlcmluZyBjb250ZXh0IGZvciBhbnkgZGVidWcgbWVzc2FnZXMgKi9cclxuXHRwcml2YXRlIHN0YXRpYyBkZWJ1Z1JlbmRlcmluZ0NvbnRleHQ6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRDtcclxuXHJcblx0LyoqXHRUaGUgc2l6ZSBvZiB0aGUgZGVidWcgY2FudmFzICovXHJcblx0cHJpdmF0ZSBzdGF0aWMgZGVidWdDYW52YXNTaXplOiBWZWMyO1xyXG5cclxuXHQvKiogVGhlIHJlbmRlcmluZyBjb2xvciBmb3IgdGV4dCAqL1xyXG5cdHByaXZhdGUgc3RhdGljIGRlZmF1bHRUZXh0Q29sb3I6IENvbG9yID0gQ29sb3IuV0hJVEU7XHJcblxyXG5cdC8qKlxyXG5cdCAqIEFkZCBhIG1lc3NhZ2UgdG8gZGlzcGxheSBvbiB0aGUgZGVidWcgc2NyZWVuXHJcblx0ICogQHBhcmFtIGlkIEEgdW5pcXVlIElEIGZvciB0aGlzIG1lc3NhZ2VcclxuXHQgKiBAcGFyYW0gbWVzc2FnZXMgVGhlIG1lc3NhZ2VzIHRvIHByaW50IHRvIHRoZSBkZWJ1ZyBzY3JlZW5cclxuXHQgKi9cclxuXHRzdGF0aWMgbG9nKGlkOiBzdHJpbmcsIC4uLm1lc3NhZ2VzOiBhbnkpOiB2b2lkIHtcclxuXHRcdC8vIGxldCBtZXNzYWdlID0gXCJcIjtcclxuXHRcdC8vIGZvcihsZXQgaSA9IDA7IGkgPCBtZXNzYWdlcy5sZW5ndGg7IGkrKyl7XHJcblx0XHQvLyBcdG1lc3NhZ2UgKz0gbWVzc2FnZXNbaV0udG9TdHJpbmcoKTtcclxuXHRcdC8vIH1cclxuXHRcdC8vIEpvaW4gYWxsIG1lc3NhZ2VzIHdpdGggc3BhY2VzXHJcblx0XHRsZXQgbWVzc2FnZSA9IG1lc3NhZ2VzLm1hcCgobTogYW55KSA9PiBtLnRvU3RyaW5nKCkpLmpvaW4oXCIgXCIpO1xyXG5cdFx0dGhpcy5sb2dNZXNzYWdlcy5hZGQoaWQsIG1lc3NhZ2UpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogRGVsZXRlcyBhIGEga2V5IGZyb20gdGhlIGxvZyBhbmQgc3RvcHMgaXQgZnJvbSBrZWVwaW5nIHVwIHNwYWNlIG9uIHRoZSBzY3JlZW5cclxuXHQgKiBAcGFyYW0gaWQgVGhlIGlkIG9mIHRoZSBsb2cgaXRlbSB0byBjbGVhclxyXG5cdCAqL1xyXG5cdHN0YXRpYyBjbGVhckxvZ0l0ZW0oaWQ6IHN0cmluZyk6IHZvaWQge1xyXG5cdFx0dGhpcy5sb2dNZXNzYWdlcy5kZWxldGUoaWQpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogU2V0cyB0aGUgbGlzdCBvZiBub2RlcyB0byByZW5kZXIgd2l0aCB0aGUgZGVidWdnZXJcclxuXHQgKiBAcGFyYW0gbm9kZXMgVGhlIG5ldyBsaXN0IG9mIG5vZGVzXHJcblx0ICovXHJcblx0c3RhdGljIHNldE5vZGVzKG5vZGVzOiBBcnJheTxHYW1lTm9kZT4pOiB2b2lkIHtcclxuXHRcdHRoaXMubm9kZXMgPSBub2RlcztcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIERyYXdzIGEgYm94IGF0IHRoZSBzcGVjaWZpZWQgcG9zaXRpb25cclxuXHQgKiBAcGFyYW0gY2VudGVyIFRoZSBjZW50ZXIgb2YgdGhlIGJveFxyXG5cdCAqIEBwYXJhbSBoYWxmU2l6ZSBUaGUgZGltZW5zaW9ucyBvZiB0aGUgYm94XHJcblx0ICogQHBhcmFtIGZpbGxlZCBBIGJvb2xlYW4gZm9yIHdoZXRoZXIgb3Igbm90IHRoZSBib3ggaXMgZmlsbGVkXHJcblx0ICogQHBhcmFtIGNvbG9yIFRoZSBjb2xvciBvZiB0aGUgYm94IHRvIGRyYXdcclxuXHQgKi9cclxuXHRzdGF0aWMgZHJhd0JveChjZW50ZXI6IFZlYzIsIGhhbGZTaXplOiBWZWMyLCBmaWxsZWQ6IGJvb2xlYW4sIGNvbG9yOiBDb2xvcik6IHZvaWQge1xyXG5cdFx0bGV0IGFscGhhID0gdGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQuZ2xvYmFsQWxwaGE7XHJcblx0XHR0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5nbG9iYWxBbHBoYSA9IGNvbG9yLmE7XHJcblxyXG5cdFx0aWYoZmlsbGVkKXtcclxuXHRcdFx0dGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQuZmlsbFN0eWxlID0gY29sb3IudG9TdHJpbmcoKTtcclxuXHRcdFx0dGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQuZmlsbFJlY3QoY2VudGVyLnggLSBoYWxmU2l6ZS54LCBjZW50ZXIueSAtIGhhbGZTaXplLnksIGhhbGZTaXplLngqMiwgaGFsZlNpemUueSoyKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGxldCBsaW5lV2lkdGggPSAyO1xyXG5cdFx0XHR0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5saW5lV2lkdGggPSBsaW5lV2lkdGg7XHJcblx0XHRcdHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0LnN0cm9rZVN0eWxlID0gY29sb3IudG9TdHJpbmcoKTtcclxuXHRcdFx0dGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQuc3Ryb2tlUmVjdChjZW50ZXIueCAtIGhhbGZTaXplLngsIGNlbnRlci55IC0gaGFsZlNpemUueSwgaGFsZlNpemUueCoyLCBoYWxmU2l6ZS55KjIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0Lmdsb2JhbEFscGhhID0gYWxwaGE7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBEcmF3cyBhIGNpcmNsZSBhdCB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uXHJcblx0ICogQHBhcmFtIGNlbnRlciBUaGUgY2VudGVyIG9mIHRoZSBjaXJjbGVcclxuXHQgKiBAcGFyYW0gcmFkaXVzIFRoZSBkaW1lbnNpb25zIG9mIHRoZSBib3hcclxuXHQgKiBAcGFyYW0gZmlsbGVkIEEgYm9vbGVhbiBmb3Igd2hldGhlciBvciBub3QgdGhlIGNpcmNsZSBpcyBmaWxsZWRcclxuXHQgKiBAcGFyYW0gY29sb3IgVGhlIGNvbG9yIG9mIHRoZSBjaXJjbGVcclxuXHQgKi9cclxuXHRzdGF0aWMgZHJhd0NpcmNsZShjZW50ZXI6IFZlYzIsIHJhZGl1czogbnVtYmVyLCBmaWxsZWQ6IGJvb2xlYW4sIGNvbG9yOiBDb2xvcik6IHZvaWQge1xyXG5cdFx0bGV0IGFscGhhID0gdGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQuZ2xvYmFsQWxwaGE7XHJcblx0XHR0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5nbG9iYWxBbHBoYSA9IGNvbG9yLmE7XHJcblxyXG5cdFx0aWYoZmlsbGVkKXtcclxuXHRcdFx0dGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQuZmlsbFN0eWxlID0gY29sb3IudG9TdHJpbmcoKTtcclxuXHRcdFx0dGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQuYmVnaW5QYXRoKCk7XHJcblx0XHRcdHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0LmFyYyhjZW50ZXIueCwgY2VudGVyLnksIHJhZGl1cywgMCwgMiAqIE1hdGguUEkpO1xyXG5cdFx0XHR0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5jbG9zZVBhdGgoKTtcclxuXHRcdFx0dGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQuZmlsbCgpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0bGV0IGxpbmVXaWR0aCA9IDI7XHJcblx0XHRcdHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0LmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcclxuXHRcdFx0dGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQuc3Ryb2tlU3R5bGUgPSBjb2xvci50b1N0cmluZygpO1xyXG5cdFx0XHR0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5iZWdpblBhdGgoKTtcclxuXHRcdFx0dGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQuYXJjKGNlbnRlci54LCBjZW50ZXIueSwgcmFkaXVzLCAwLCAyICogTWF0aC5QSSk7XHJcblx0XHRcdHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0LmNsb3NlUGF0aCgpO1xyXG5cdFx0XHR0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5zdHJva2UoKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5nbG9iYWxBbHBoYSA9IGFscGhhO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogRHJhd3MgYSByYXkgYXQgdGhlIHNwZWNpZmllZCBwb3NpdGlvblxyXG5cdCAqIEBwYXJhbSBmcm9tIFRoZSBzdGFydGluZyBwb3NpdGlvbiBvZiB0aGUgcmF5XHJcblx0ICogQHBhcmFtIHRvIFRoZSBlbmRpbmcgcG9zaXRpb24gb2YgdGhlIHJheVxyXG5cdCAqIEBwYXJhbSBjb2xvciBUaGUgY29sb3Igb2YgdGhlIHJheVxyXG5cdCAqL1xyXG5cdHN0YXRpYyBkcmF3UmF5KGZyb206IFZlYzIsIHRvOiBWZWMyLCBjb2xvcjogQ29sb3IpOiB2b2lkIHtcclxuXHRcdHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0LmxpbmVXaWR0aCA9IDI7XHJcblx0XHR0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5zdHJva2VTdHlsZSA9IGNvbG9yLnRvU3RyaW5nKCk7XHJcblxyXG5cdFx0dGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQuYmVnaW5QYXRoKCk7XHJcblx0XHR0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5tb3ZlVG8oZnJvbS54LCBmcm9tLnkpO1xyXG5cdFx0dGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQubGluZVRvKHRvLngsIHRvLnkpO1xyXG5cdFx0dGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQuY2xvc2VQYXRoKCk7XHJcblx0XHR0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5zdHJva2UoKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIERyYXdzIGEgcG9pbnQgYXQgdGhlIHNwZWNpZmllZCBwb3NpdGlvblxyXG5cdCAqIEBwYXJhbSBwb3MgVGhlIHBvc2l0aW9uIG9mIHRoZSBwb2ludFxyXG5cdCAqIEBwYXJhbSBjb2xvciBUaGUgY29sb3Igb2YgdGhlIHBvaW50XHJcblx0ICovXHJcblx0c3RhdGljIGRyYXdQb2ludChwb3M6IFZlYzIsIGNvbG9yOiBDb2xvcik6IHZvaWQge1xyXG5cdFx0bGV0IHBvaW50U2l6ZSA9IDY7XHJcblx0XHR0aGlzLmRlYnVnUmVuZGVyaW5nQ29udGV4dC5maWxsU3R5bGUgPSBjb2xvci50b1N0cmluZygpO1xyXG5cdFx0dGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQuZmlsbFJlY3QocG9zLnggLSBwb2ludFNpemUvMiwgcG9zLnkgLSBwb2ludFNpemUvMiwgcG9pbnRTaXplLCBwb2ludFNpemUpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogU2V0cyB0aGUgZGVmYXVsdCByZW5kZXJpbmcgY29sb3IgZm9yIHRleHQgZm9yIHRoZSBkZWJ1Z2dlclxyXG5cdCAqIEBwYXJhbSBjb2xvciBUaGUgY29sb3IgdG8gcmVuZGVyIHRoZSB0ZXh0XHJcblx0ICovXHJcblx0c3RhdGljIHNldERlZmF1bHRUZXh0Q29sb3IoY29sb3I6IENvbG9yKTogdm9pZCB7XHJcblx0XHR0aGlzLmRlZmF1bHRUZXh0Q29sb3IgPSBjb2xvcjtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFBlcmZvcm1zIGFueSBuZWNlc3Nhcnkgc2V0dXAgb3BlcmF0aW9ucyBvbiB0aGUgRGVidWcgY2FudmFzXHJcblx0ICogQHBhcmFtIGNhbnZhcyBUaGUgZGVidWcgY2FudmFzXHJcblx0ICogQHBhcmFtIHdpZHRoIFRoZSBkZXNpcmVkIHdpZHRoIG9mIHRoZSBjYW52YXNcclxuXHQgKiBAcGFyYW0gaGVpZ2h0IFRoZSBkZXNpcmVkIGhlaWdodCBvZiB0aGUgY2FudmFzXHJcblx0ICogQHJldHVybnMgVGhlIHJlbmRlcmluZyBjb250ZXh0IGV4dHJhY3RlZCBmcm9tIHRoZSBjYW52YXNcclxuXHQgKi9cclxuXHRzdGF0aWMgaW5pdGlhbGl6ZURlYnVnQ2FudmFzKGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyKTogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEIHtcclxuICAgICAgICBjYW52YXMud2lkdGggPSB3aWR0aDtcclxuXHRcdGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XHJcblx0XHRcclxuXHRcdHRoaXMuZGVidWdDYW52YXNTaXplID0gbmV3IFZlYzIod2lkdGgsIGhlaWdodCk7XHJcblxyXG4gICAgICAgIHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0O1xyXG5cdH1cclxuXHJcblx0LyoqIENsZWFycyB0aGUgZGVidWcgY2FudmFzICovXHJcblx0c3RhdGljIGNsZWFyQ2FudmFzKCk6IHZvaWQge1xyXG5cdFx0dGhpcy5kZWJ1Z1JlbmRlcmluZ0NvbnRleHQuY2xlYXJSZWN0KDAsIDAsIHRoaXMuZGVidWdDYW52YXNTaXplLngsIHRoaXMuZGVidWdDYW52YXNTaXplLnkpO1xyXG5cdH1cclxuXHJcblx0LyoqIFJlbmRlcnMgdGhlIHRleHQgYW5kIG5vZGVzIHNlbnQgdG8gdGhlIERlYnVnIHN5c3RlbSAqL1xyXG5cdHN0YXRpYyByZW5kZXIoKTogdm9pZCB7XHJcblx0XHR0aGlzLnJlbmRlclRleHQoKTtcclxuXHRcdHRoaXMucmVuZGVyTm9kZXMoKTtcclxuXHR9XHJcblxyXG5cdC8qKiBSZW5kZXJzIHRoZSB0ZXh0IHNlbnQgdG8gdGhlIERlYnVnIGNhbnZhcyAqL1xyXG5cdHN0YXRpYyByZW5kZXJUZXh0KCk6IHZvaWQge1xyXG5cdFx0bGV0IHkgPSAyMDtcclxuXHRcdHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0LmZvbnQgPSBcIjIwcHggQXJpYWxcIjtcclxuXHRcdHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0LmZpbGxTdHlsZSA9IHRoaXMuZGVmYXVsdFRleHRDb2xvci50b1N0cmluZygpO1xyXG5cclxuXHRcdC8vIERyYXcgYWxsIG9mIHRoZSB0ZXh0XHJcblx0XHR0aGlzLmxvZ01lc3NhZ2VzLmZvckVhY2goKGtleTogc3RyaW5nKSA9PiB7XHJcblx0XHRcdHRoaXMuZGVidWdSZW5kZXJpbmdDb250ZXh0LmZpbGxUZXh0KHRoaXMubG9nTWVzc2FnZXMuZ2V0KGtleSksIDEwLCB5KVxyXG5cdFx0XHR5ICs9IDMwO1x0XHJcblx0XHR9KTtcclxuXHR9XHJcblxyXG5cdC8qKiBSZW5kZXJzIHRoZSBub2RlcyByZWdpc3RlcmVkIHdpdGggdGhlIGRlYnVnIGNhbnZhcyAqL1xyXG5cdHN0YXRpYyByZW5kZXJOb2RlcygpOiB2b2lkIHtcclxuXHRcdGlmKHRoaXMubm9kZXMpe1xyXG5cdFx0XHR0aGlzLm5vZGVzLmZvckVhY2gobm9kZSA9PiB7XHJcblx0XHRcdFx0bm9kZS5kZWJ1Z1JlbmRlcigpO1xyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHR9XHJcbn0iLCJpbXBvcnQgQ29sb3IgZnJvbSBcIi4uL1V0aWxzL0NvbG9yXCI7XHJcblxyXG4vLyBAaWdub3JlUGFnZVxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdGF0cyBleHRlbmRzIE9iamVjdCB7XHJcbiAgICAvLyBUaGUgZnBzIG9mIHRoZSBnYW1lLlxyXG4gICAgcHJpdmF0ZSBzdGF0aWMgcHJldmZwczogQXJyYXk8bnVtYmVyPjtcclxuICAgIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IE5VTV9QT0lOVFM6IG51bWJlciA9IDYwO1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQ7XHJcbiAgICBwcml2YXRlIHN0YXRpYyBDQU5WQVNfV0lEVEg6IG51bWJlciA9IDMwMDtcclxuICAgIHByaXZhdGUgc3RhdGljIENBTlZBU19IRUlHSFQ6IG51bWJlciA9IDMwMDtcclxuICAgIHByaXZhdGUgc3RhdGljIHN0YXRzRGl2OiBIVE1MRGl2RWxlbWVudDtcclxuICAgIHByaXZhdGUgc3RhdGljIGdyYXBoQ2hvaWNlczogSFRNTFNlbGVjdEVsZW1lbnQ7XHJcblxyXG4gICAgLy8gUXVhZHRyZWUgc3RhdHNcclxuICAgIHByaXZhdGUgc3RhdGljIHByZXZDbGVhclRpbWVzOiBBcnJheTxudW1iZXI+O1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgU0dDbGVhclRpbWVzOiBBcnJheTxudW1iZXI+O1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgYXZnU0dDbGVhclRpbWU6IG51bWJlcjtcclxuXHJcbiAgICBwcml2YXRlIHN0YXRpYyBwcmV2RmlsbFRpbWVzOiBBcnJheTxudW1iZXI+O1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgU0dGaWxsVGltZXM6IEFycmF5PG51bWJlcj47XHJcbiAgICBwcml2YXRlIHN0YXRpYyBhdmdTR0ZpbGxUaW1lOiBudW1iZXI7XHJcblxyXG4gICAgcHJpdmF0ZSBzdGF0aWMgcHJldlVwZGF0ZVRpbWVzOiBBcnJheTxudW1iZXI+O1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgU0dVcGRhdGVUaW1lczogQXJyYXk8bnVtYmVyPjtcclxuICAgIHByaXZhdGUgc3RhdGljIGF2Z1NHVXBkYXRlVGltZTogbnVtYmVyO1xyXG5cclxuICAgIHByaXZhdGUgc3RhdGljIHByZXZRdWVyeVRpbWVzOiBBcnJheTxudW1iZXI+O1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgU0dRdWVyeVRpbWVzOiBBcnJheTxudW1iZXI+O1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgYXZnU0dRdWVyeVRpbWU6IG51bWJlcjtcclxuXHJcbiAgICBzdGF0aWMgaW5pdFN0YXRzKCk6IHZvaWQge1xyXG4gICAgICAgIGxldCBjYW52YXMgPSA8SFRNTENhbnZhc0VsZW1lbnQ+ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzdGF0cy1jYW52YXNcIik7XHJcbiAgICAgICAgY2FudmFzLndpZHRoID0gdGhpcy5DQU5WQVNfV0lEVEg7XHJcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IHRoaXMuQ0FOVkFTX0hFSUdIVDtcclxuICAgICAgICB0aGlzLmN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XHJcblxyXG4gICAgICAgIHRoaXMuc3RhdHNEaXYgPSA8SFRNTERpdkVsZW1lbnQ+ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzdGF0cy1kaXNwbGF5XCIpO1xyXG5cclxuICAgICAgICB0aGlzLnByZXZmcHMgPSBuZXcgQXJyYXkoKTtcclxuXHJcbiAgICAgICAgdGhpcy5wcmV2Q2xlYXJUaW1lcyA9IG5ldyBBcnJheSgpO1xyXG4gICAgICAgIHRoaXMuU0dDbGVhclRpbWVzID0gbmV3IEFycmF5KCk7XHJcbiAgICAgICAgdGhpcy5hdmdTR0NsZWFyVGltZSA9IDA7XHJcblxyXG4gICAgICAgIHRoaXMucHJldkZpbGxUaW1lcyA9IG5ldyBBcnJheSgpO1xyXG4gICAgICAgIHRoaXMuU0dGaWxsVGltZXMgPSBuZXcgQXJyYXkoKTtcclxuICAgICAgICB0aGlzLmF2Z1NHRmlsbFRpbWUgPSAwO1xyXG5cclxuICAgICAgICB0aGlzLnByZXZVcGRhdGVUaW1lcyA9IG5ldyBBcnJheSgpO1xyXG4gICAgICAgIHRoaXMuU0dVcGRhdGVUaW1lcyA9IG5ldyBBcnJheSgpO1xyXG4gICAgICAgIHRoaXMuYXZnU0dVcGRhdGVUaW1lID0gMDtcclxuXHJcbiAgICAgICAgdGhpcy5wcmV2UXVlcnlUaW1lcyA9IG5ldyBBcnJheSgpO1xyXG4gICAgICAgIHRoaXMuU0dRdWVyeVRpbWVzID0gbmV3IEFycmF5KCk7XHJcbiAgICAgICAgdGhpcy5hdmdTR1F1ZXJ5VGltZSA9IDA7XHJcblxyXG4gICAgICAgIGxldCBjbGVhclRpbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcclxuICAgICAgICBjbGVhclRpbWUuc2V0QXR0cmlidXRlKFwiaWRcIiwgXCJzZ2NsZWFyXCIpO1xyXG4gICAgICAgIGxldCBmaWxsVGltZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xyXG4gICAgICAgIGZpbGxUaW1lLnNldEF0dHJpYnV0ZShcImlkXCIsIFwic2dmaWxsXCIpO1xyXG4gICAgICAgIGxldCB1cGRhdGVUaW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XHJcbiAgICAgICAgdXBkYXRlVGltZS5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBcInNndXBkYXRlXCIpO1xyXG4gICAgICAgIGxldCBxdWVyeVRpbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcclxuICAgICAgICBxdWVyeVRpbWUuc2V0QXR0cmlidXRlKFwiaWRcIiwgXCJzZ3F1ZXJ5XCIpO1xyXG4gICAgICAgIGxldCBicjEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnJcIik7XHJcbiAgICAgICAgbGV0IGJyMiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJiclwiKTtcclxuICAgICAgICBsZXQgYnIzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJyXCIpO1xyXG5cclxuICAgICAgICB0aGlzLnN0YXRzRGl2LmFwcGVuZChjbGVhclRpbWUsIGJyMSwgZmlsbFRpbWUsIGJyMiwgdXBkYXRlVGltZSwgYnIzLCBxdWVyeVRpbWUpO1xyXG5cclxuICAgICAgICB0aGlzLmdyYXBoQ2hvaWNlcyA9IDxIVE1MU2VsZWN0RWxlbWVudD5kb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImNoYXJ0LW9wdGlvblwiKTtcclxuICAgICAgICBsZXQgb3B0aW9uMSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIik7XHJcbiAgICAgICAgb3B0aW9uMS52YWx1ZSA9IFwicHJldmZwc1wiO1xyXG4gICAgICAgIG9wdGlvbjEubGFiZWwgPSBcIkZQU1wiO1xyXG4gICAgICAgIGxldCBvcHRpb24yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiKTtcclxuICAgICAgICBvcHRpb24yLnZhbHVlID0gXCJwcmV2Q2xlYXJUaW1lc1wiO1xyXG4gICAgICAgIG9wdGlvbjIubGFiZWwgPSBcIkNsZWFyIFRpbWVcIjtcclxuICAgICAgICBsZXQgb3B0aW9uMyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIik7XHJcbiAgICAgICAgb3B0aW9uMy52YWx1ZSA9IFwicHJldkZpbGxUaW1lc1wiO1xyXG4gICAgICAgIG9wdGlvbjMubGFiZWwgPSBcIkZpbGwgdGltZVwiO1xyXG4gICAgICAgIGxldCBvcHRpb240ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiKTtcclxuICAgICAgICBvcHRpb240LnZhbHVlID0gXCJwcmV2VXBkYXRlVGltZXNcIjtcclxuICAgICAgICBvcHRpb240LmxhYmVsID0gXCJVcGRhdGUgdGltZVwiO1xyXG4gICAgICAgIGxldCBvcHRpb241ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiKTtcclxuICAgICAgICBvcHRpb241LnZhbHVlID0gXCJwcmV2UXVlcnlUaW1lc1wiO1xyXG4gICAgICAgIG9wdGlvbjUubGFiZWwgPSBcIlF1ZXJ5IFRpbWVcIjtcclxuICAgICAgICBsZXQgb3B0aW9uQWxsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiKTtcclxuICAgICAgICBvcHRpb25BbGwudmFsdWUgPSBcImFsbFwiO1xyXG4gICAgICAgIG9wdGlvbkFsbC5sYWJlbCA9IFwiQWxsXCI7XHJcbiAgICAgICAgdGhpcy5ncmFwaENob2ljZXMuYXBwZW5kKG9wdGlvbjEsIG9wdGlvbjIsIG9wdGlvbjMsIG9wdGlvbjQsIG9wdGlvbjUsIG9wdGlvbkFsbCk7XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIHVwZGF0ZUZQUyhmcHM6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICAgIHRoaXMucHJldmZwcy5wdXNoKGZwcyk7XHJcbiAgICAgICAgaWYodGhpcy5wcmV2ZnBzLmxlbmd0aCA+IFN0YXRzLk5VTV9QT0lOVFMpe1xyXG4gICAgICAgICAgICB0aGlzLnByZXZmcHMuc2hpZnQoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmKHRoaXMuU0dDbGVhclRpbWVzLmxlbmd0aCA+IDApe1xyXG4gICAgICAgICAgICB0aGlzLnByZXZDbGVhclRpbWVzLnB1c2godGhpcy5hdmdTR0NsZWFyVGltZSk7XHJcbiAgICAgICAgICAgIGlmKHRoaXMucHJldkNsZWFyVGltZXMubGVuZ3RoID4gdGhpcy5OVU1fUE9JTlRTKXtcclxuICAgICAgICAgICAgICAgIHRoaXMucHJldkNsZWFyVGltZXMuc2hpZnQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZih0aGlzLlNHRmlsbFRpbWVzLmxlbmd0aCA+IDApe1xyXG4gICAgICAgICAgICB0aGlzLnByZXZGaWxsVGltZXMucHVzaCh0aGlzLmF2Z1NHRmlsbFRpbWUpO1xyXG4gICAgICAgICAgICBpZih0aGlzLnByZXZGaWxsVGltZXMubGVuZ3RoID4gdGhpcy5OVU1fUE9JTlRTKXtcclxuICAgICAgICAgICAgICAgIHRoaXMucHJldkZpbGxUaW1lcy5zaGlmdCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKHRoaXMuU0dVcGRhdGVUaW1lcy5sZW5ndGggPiAwKXtcclxuICAgICAgICAgICAgdGhpcy5wcmV2VXBkYXRlVGltZXMucHVzaCh0aGlzLmF2Z1NHVXBkYXRlVGltZSk7XHJcbiAgICAgICAgICAgIGlmKHRoaXMucHJldlVwZGF0ZVRpbWVzLmxlbmd0aCA+IHRoaXMuTlVNX1BPSU5UUyl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnByZXZVcGRhdGVUaW1lcy5zaGlmdCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKHRoaXMuU0dRdWVyeVRpbWVzLmxlbmd0aCA+IDApe1xyXG4gICAgICAgICAgICB0aGlzLnByZXZRdWVyeVRpbWVzLnB1c2godGhpcy5hdmdTR1F1ZXJ5VGltZSk7XHJcbiAgICAgICAgICAgIGlmKHRoaXMucHJldlF1ZXJ5VGltZXMubGVuZ3RoID4gdGhpcy5OVU1fUE9JTlRTKXtcclxuICAgICAgICAgICAgICAgIHRoaXMucHJldlF1ZXJ5VGltZXMuc2hpZnQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy51cGRhdGVTR1N0YXRzKCk7XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIGxvZyhrZXk6IHN0cmluZywgZGF0YTogYW55KTogdm9pZCB7XHJcbiAgICAgICAgaWYoa2V5ID09PSBcInNnY2xlYXJcIil7XHJcbiAgICAgICAgICAgIHRoaXMuU0dDbGVhclRpbWVzLnB1c2goZGF0YSk7XHJcbiAgICAgICAgICAgIGlmKHRoaXMuU0dDbGVhclRpbWVzLmxlbmd0aCA+IDEwMCl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLlNHQ2xlYXJUaW1lcy5zaGlmdCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmKGtleSA9PT0gXCJzZ2ZpbGxcIil7XHJcbiAgICAgICAgICAgIHRoaXMuU0dGaWxsVGltZXMucHVzaChkYXRhKTtcclxuICAgICAgICAgICAgaWYodGhpcy5TR0ZpbGxUaW1lcy5sZW5ndGggPiAxMDApe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5TR0ZpbGxUaW1lcy5zaGlmdCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmKGtleSA9PT0gXCJzZ3VwZGF0ZVwiKXtcclxuICAgICAgICAgICAgdGhpcy5TR1VwZGF0ZVRpbWVzLnB1c2goZGF0YSk7XHJcbiAgICAgICAgICAgIGlmKHRoaXMuU0dVcGRhdGVUaW1lcy5sZW5ndGggPiAxMDApe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5TR1VwZGF0ZVRpbWVzLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2UgaWYoa2V5ID09PSBcInNncXVlcnlcIil7XHJcbiAgICAgICAgICAgIHRoaXMuU0dRdWVyeVRpbWVzLnB1c2goZGF0YSk7XHJcbiAgICAgICAgICAgIGlmKHRoaXMuU0dRdWVyeVRpbWVzLmxlbmd0aCA+IDEwMDApe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5TR1F1ZXJ5VGltZXMuc2hpZnQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIHJlbmRlcigpOiB2b2lkIHtcclxuICAgICAgICAvLyBEaXNwbGF5IHN0YXRzXHJcbiAgICAgICAgdGhpcy5kcmF3Q2hhcnRzKCk7XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIGRyYXdDaGFydHMoKXtcclxuICAgICAgICB0aGlzLmN0eC5jbGVhclJlY3QoMCwgMCwgdGhpcy5DQU5WQVNfV0lEVEgsIHRoaXMuQ0FOVkFTX0hFSUdIVCk7XHJcblxyXG4gICAgICAgIGxldCBwYXJhbVN0cmluZyA9IHRoaXMuZ3JhcGhDaG9pY2VzLnZhbHVlO1xyXG5cclxuICAgICAgICBpZihwYXJhbVN0cmluZyA9PT0gXCJwcmV2ZnBzXCIgfHwgcGFyYW1TdHJpbmcgPT09IFwiYWxsXCIpe1xyXG4gICAgICAgICAgICBsZXQgcGFyYW0gPSB0aGlzLnByZXZmcHM7XHJcbiAgICAgICAgICAgIGxldCBjb2xvciA9IENvbG9yLkJMVUUudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgdGhpcy5kcmF3Q2hhcnQocGFyYW0sIGNvbG9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYocGFyYW1TdHJpbmcgPT09IFwicHJldkNsZWFyVGltZXNcIiB8fCBwYXJhbVN0cmluZyA9PT0gXCJhbGxcIil7XHJcbiAgICAgICAgICAgIGxldCBwYXJhbSA9IHRoaXMucHJldkNsZWFyVGltZXM7XHJcbiAgICAgICAgICAgIGxldCBjb2xvciA9IENvbG9yLlJFRC50b1N0cmluZygpO1xyXG4gICAgICAgICAgICB0aGlzLmRyYXdDaGFydChwYXJhbSwgY29sb3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZihwYXJhbVN0cmluZyA9PT0gXCJwcmV2RmlsbFRpbWVzXCIgfHwgcGFyYW1TdHJpbmcgPT09IFwiYWxsXCIpe1xyXG4gICAgICAgICAgICBsZXQgcGFyYW0gPSB0aGlzLnByZXZGaWxsVGltZXM7XHJcbiAgICAgICAgICAgIGxldCBjb2xvciA9IENvbG9yLkdSRUVOLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIHRoaXMuZHJhd0NoYXJ0KHBhcmFtLCBjb2xvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKHBhcmFtU3RyaW5nID09PSBcInByZXZVcGRhdGVUaW1lc1wiIHx8IHBhcmFtU3RyaW5nID09PSBcImFsbFwiKXtcclxuICAgICAgICAgICAgbGV0IHBhcmFtID0gdGhpcy5wcmV2VXBkYXRlVGltZXM7XHJcbiAgICAgICAgICAgIGxldCBjb2xvciA9IENvbG9yLkNZQU4udG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgdGhpcy5kcmF3Q2hhcnQocGFyYW0sIGNvbG9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYocGFyYW1TdHJpbmcgPT09IFwicHJldlF1ZXJ5VGltZXNcIiB8fCBwYXJhbVN0cmluZyA9PT0gXCJhbGxcIil7XHJcbiAgICAgICAgICAgIGxldCBwYXJhbSA9IHRoaXMucHJldlF1ZXJ5VGltZXM7XHJcbiAgICAgICAgICAgIGxldCBjb2xvciA9IENvbG9yLk9SQU5HRS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICB0aGlzLmRyYXdDaGFydChwYXJhbSwgY29sb3IpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgZHJhd0NoYXJ0KHBhcmFtOiBBcnJheTxudW1iZXI+LCBjb2xvcjogc3RyaW5nKXtcclxuICAgICAgICB0aGlzLmN0eC5zdHJva2VTdHlsZSA9IENvbG9yLkJMQUNLLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgdGhpcy5jdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgdGhpcy5jdHgubW92ZVRvKDEwLCAxMCk7XHJcbiAgICAgICAgdGhpcy5jdHgubGluZVRvKDEwLCB0aGlzLkNBTlZBU19IRUlHSFQgLSAxMCk7XHJcbiAgICAgICAgdGhpcy5jdHguY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgdGhpcy5jdHguc3Ryb2tlKCk7XHJcbiAgICAgICAgdGhpcy5jdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgdGhpcy5jdHgubW92ZVRvKDEwLCB0aGlzLkNBTlZBU19IRUlHSFQgLSAxMCk7XHJcbiAgICAgICAgdGhpcy5jdHgubGluZVRvKHRoaXMuQ0FOVkFTX1dJRFRIIC0gMTAsIHRoaXMuQ0FOVkFTX0hFSUdIVCAtIDEwKTtcclxuICAgICAgICB0aGlzLmN0eC5jbG9zZVBhdGgoKTtcclxuICAgICAgICB0aGlzLmN0eC5zdHJva2UoKTtcclxuXHJcbiAgICAgICAgbGV0IG1heCA9IE1hdGgubWF4KC4uLnBhcmFtKTtcclxuICAgICAgICBsZXQgcHJldlggPSAxMDtcclxuICAgICAgICBsZXQgcHJldlkgPSB0aGlzLkNBTlZBU19IRUlHSFQgLSAxMCAtIHBhcmFtWzBdL21heCoodGhpcy5DQU5WQVNfSEVJR0hULTIwKTtcclxuICAgICAgICB0aGlzLmN0eC5zdHJva2VTdHlsZSA9IGNvbG9yO1xyXG5cclxuICAgICAgICBmb3IobGV0IGkgPSAxOyBpIDwgcGFyYW0ubGVuZ3RoOyBpKyspe1xyXG4gICAgICAgICAgICBsZXQgZnBzID0gcGFyYW1baV07XHJcbiAgICAgICAgICAgIGxldCB4ID0gMTAgKyBpKih0aGlzLkNBTlZBU19XSURUSCAtIDIwKS90aGlzLk5VTV9QT0lOVFM7XHJcbiAgICAgICAgICAgIGxldCB5ID0gdGhpcy5DQU5WQVNfSEVJR0hUIC0gMTAgLSBmcHMvbWF4Kih0aGlzLkNBTlZBU19IRUlHSFQtMjApXHJcbiAgICAgICAgICAgIHRoaXMuY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgICAgICB0aGlzLmN0eC5tb3ZlVG8ocHJldlgsIHByZXZZKTtcclxuICAgICAgICAgICAgdGhpcy5jdHgubGluZVRvKHgsIHkpO1xyXG4gICAgICAgICAgICB0aGlzLmN0eC5jbG9zZVBhdGgoKTtcclxuICAgICAgICAgICAgdGhpcy5jdHguc3Ryb2tlKCk7XHJcblxyXG4gICAgICAgICAgICBwcmV2WCA9IHg7XHJcbiAgICAgICAgICAgIHByZXZZID0geTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIHVwZGF0ZVNHU3RhdHMoKXtcclxuICAgICAgICBpZih0aGlzLlNHQ2xlYXJUaW1lcy5sZW5ndGggPiAwKXtcclxuICAgICAgICAgICAgdGhpcy5hdmdTR0NsZWFyVGltZSA9IHRoaXMuU0dDbGVhclRpbWVzLnJlZHVjZSgoYWNjLCB2YWwpID0+IGFjYyArIHZhbCkvdGhpcy5TR0NsZWFyVGltZXMubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYodGhpcy5TR0ZpbGxUaW1lcy5sZW5ndGggPiAwKXtcclxuICAgICAgICAgICAgdGhpcy5hdmdTR0ZpbGxUaW1lID0gdGhpcy5TR0ZpbGxUaW1lcy5yZWR1Y2UoKGFjYywgdmFsKSA9PiBhY2MgKyB2YWwpL3RoaXMuU0dGaWxsVGltZXMubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYodGhpcy5TR1VwZGF0ZVRpbWVzLmxlbmd0aCA+IDApe1xyXG4gICAgICAgIHRoaXMuYXZnU0dVcGRhdGVUaW1lID0gdGhpcy5TR1VwZGF0ZVRpbWVzLnJlZHVjZSgoYWNjLCB2YWwpID0+IGFjYyArIHZhbCkvdGhpcy5TR1VwZGF0ZVRpbWVzLmxlbmd0aDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmKHRoaXMuU0dRdWVyeVRpbWVzLmxlbmd0aCA+IDApe1xyXG4gICAgICAgICAgICB0aGlzLmF2Z1NHUXVlcnlUaW1lID0gdGhpcy5TR1F1ZXJ5VGltZXMucmVkdWNlKChhY2MsIHZhbCkgPT4gYWNjICsgdmFsKS90aGlzLlNHUXVlcnlUaW1lcy5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInNnY2xlYXJcIikuaW5uZXJIVE1MID0gXCJBdmcgU0cgY2xlYXIgdGltZTogXCIgKyB0aGlzLmF2Z1NHQ2xlYXJUaW1lO1xyXG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic2dmaWxsXCIpLmlubmVySFRNTCA9IFwiQXZnIFNHIGZpbGwgdGltZTogXCIgKyB0aGlzLmF2Z1NHRmlsbFRpbWU7XHJcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzZ3VwZGF0ZVwiKS5pbm5lckhUTUwgPSBcIkF2ZyBTRyB1cGRhdGUgdGltZTogXCIgKyB0aGlzLmF2Z1NHVXBkYXRlVGltZTtcclxuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInNncXVlcnlcIikuaW5uZXJIVE1MID0gXCJBdmcgU0cgcXVlcnkgdGltZTogXCIgKyB0aGlzLmF2Z1NHUXVlcnlUaW1lO1xyXG4gICAgfVxyXG59IiwiaW1wb3J0IE1hcCBmcm9tIFwiLi4vRGF0YVR5cGVzL01hcFwiO1xyXG5pbXBvcnQgRXZlbnRRdWV1ZSBmcm9tIFwiLi9FdmVudFF1ZXVlXCI7XHJcbmltcG9ydCBHYW1lRXZlbnQgZnJvbSBcIi4vR2FtZUV2ZW50XCI7XHJcblxyXG4vKipcclxuICogQW4gZXZlbnQgZW1pdHRlciBvYmplY3Qgb3RoZXIgc3lzdGVtcyBjYW4gdXNlIHRvIGhvb2sgaW50byB0aGUgRXZlbnRRdWV1ZS5cclxuICogUHJvdmlkZXMgYW4gZWFzeSBpbnRlcmZhY2UgZm9yIGZpcmluZyBvZmYgZXZlbnRzLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRW1pdHRlciB7XHJcblx0LyoqIEEgcmVmZXJlbmNlIHRvIHRoZSBFdmVudFF1ZXVlICovXHJcblx0cHJpdmF0ZSBldmVudFF1ZXVlOiBFdmVudFF1ZXVlO1xyXG5cclxuXHQvKiogQ3JlYXRlcyBhIG5ldyBFbWl0dGVyICovXHJcblx0Y29uc3RydWN0b3IoKXtcclxuXHRcdHRoaXMuZXZlbnRRdWV1ZSA9IEV2ZW50UXVldWUuZ2V0SW5zdGFuY2UoKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEVtaXQgYW5kIGV2ZW50IG9mIHR5cGUgZXZlbnRUeXBlIHdpdGggdGhlIGRhdGEgcGFja2V0IGRhdGFcclxuXHQgKiBAcGFyYW0gZXZlbnRUeXBlIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byBmaXJlIG9mZlxyXG5cdCAqIEBwYXJhbSBkYXRhIEEgQHJlZmVyZW5jZVtNYXBdIG9yIHJlY29yZCBjb250YWluaW5nIGFueSBkYXRhIGFib3V0IHRoZSBldmVudFxyXG5cdCAqL1xyXG5cdGZpcmVFdmVudChldmVudFR5cGU6IHN0cmluZywgZGF0YTogTWFwPGFueT4gfCBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0gbnVsbCk6IHZvaWQge1xyXG5cdFx0dGhpcy5ldmVudFF1ZXVlLmFkZEV2ZW50KG5ldyBHYW1lRXZlbnQoZXZlbnRUeXBlLCBkYXRhKSk7XHJcblx0fVxyXG59IiwiaW1wb3J0IFF1ZXVlIGZyb20gXCIuLi9EYXRhVHlwZXMvUXVldWVcIjtcclxuaW1wb3J0IE1hcCBmcm9tIFwiLi4vRGF0YVR5cGVzL01hcFwiO1xyXG5pbXBvcnQgR2FtZUV2ZW50IGZyb20gXCIuL0dhbWVFdmVudFwiO1xyXG5pbXBvcnQgUmVjZWl2ZXIgZnJvbSBcIi4vUmVjZWl2ZXJcIjtcclxuaW1wb3J0IHsgR2FtZUV2ZW50VHlwZSB9IGZyb20gXCIuL0dhbWVFdmVudFR5cGVcIjtcclxuXHJcbi8qKlxyXG4gKiBUaGUgbWFpbiBldmVudCBzeXN0ZW0gb2YgdGhlIGdhbWUgZW5naW5lLlxyXG4gKiBFdmVudHMgYXJlIHNlbnQgdG8gdGhlIEV2ZW50UXVldWUsIHdoaWNoIGhhbmRsZXMgZGlzdHJpYnV0aW9uIHRvIGFueSBzeXN0ZW1zIHRoYXQgYXJlIGxpc3RlbmluZyBmb3IgdGhvc2UgZXZlbnRzLlxyXG4gKiBUaGlzIGFsbG93cyBmb3IgaGFuZGxpbmcgb2YgaW5wdXQgd2l0aG91dCBoYXZpbmcgY2xhc3NlcyBkaXJlY3RseSBob29rIGludG8gamF2YXNjcmlwdCBldmVudCBoYW5kbGVzLCBcclxuICogYW5kIGFsbG93cyBvdGhlcndpc2Ugc2VwYXJhdGUgY2xhc3NlcyB0byBjb21tdW5pY2F0ZSB3aXRoIGVhY2ggb3RoZXIgY2xlYW5seSwgc3VjaCBhcyBhIFBsYXllciBvYmplY3QgXHJcbiAqIHJlcXVlc3RpbmcgYSBzb3VuZCBiZSBwbGF5ZWQgYnkgdGhlIGF1ZGlvIHN5c3RlbS5cclxuICogXHJcbiAqIFRoZSBkaXN0cmlidXRpb24gb2YgQHJlZmVyZW5jZVtHYW1lRXZlbnRdcyBoYXBwZW5zIGFzIGZvbGxvd3M6XHJcbiAqIFxyXG4gKiBFdmVudHMgYXJlIHJlY2lldmVkIHRocm91Z2hvdXQgYSBmcmFtZSBhbmQgYXJlIHF1ZXVlZCB1cCBieSB0aGUgRXZlbnRRdWV1ZS5cclxuICogQXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgbmV4dCBmcmFtZSwgZXZlbnRzIGFyZSBzZW50IG91dCB0byBhbnkgcmVjZWl2ZXJzIHRoYXQgYXJlIGhvb2tlZCBpbnRvIHRoZSBldmVudCB0eXBlLlxyXG4gKiBAcmVmZXJlbmNlW1JlY2VpdmVyXXMgYXJlIHRoZW4gZnJlZSB0byBwcm9jZXNzIGV2ZW50cyBhcyB0aGV5IHNlZSBmaXQuXHJcbiAqIFxyXG4gKiBPdmVyYWxsLCB0aGUgRXZlbnRRdWV1ZSBjYW4gYmUgY29uc2lkZXJlZCBhcyBzb21ldGhpbmcgc2ltaWxhciB0byBhbiBlbWFpbCBzZXJ2ZXIsXHJcbiAqIGFuZCB0aGUgQHJlZmVyZW5jZVtSZWNlaXZlcl1zIGNhbiBiZSBjb25zaWRlcmVkIGFzIHRoZSBjbGllbnQgaW5ib3hlcy5cclxuICogXHJcbiAqIFNlZSBAbGluayhHYW1lIFByb2dyYW1taW5nIFBhdHRlcm5zKShodHRwczovL2dhbWVwcm9ncmFtbWluZ3BhdHRlcm5zLmNvbS9ldmVudC1xdWV1ZS5odG1sKSBmb3IgbW9yZSBkaXNjdXNzaW9uIG9uIEV2ZW50UXVldWVzXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFdmVudFF1ZXVlIHtcclxuICAgIHByaXZhdGUgc3RhdGljIGluc3RhbmNlOiBFdmVudFF1ZXVlID0gbnVsbDtcclxuICAgIFxyXG4gICAgLyoqIFRoZSBtYXhpbXVtIG51bWJlciBvZiBldmVudHMgdmlzaWJsZSAqL1xyXG4gICAgcHJpdmF0ZSByZWFkb25seSBNQVhfU0laRTogbnVtYmVyO1xyXG4gICAgXHJcbiAgICAvKiogVGhlIGFjdHVhbCBxdWV1ZSBvZiBldmVudHMgKi9cclxuICAgIHByaXZhdGUgcTogUXVldWU8R2FtZUV2ZW50PjtcclxuICAgIFxyXG4gICAgLyoqIFRoZSBtYXAgb2YgcmVjZWl2ZXJzIHJlZ2lzdGVyZWQgZm9yIGFuIGV2ZW50IG5hbWUgKi9cclxuXHRwcml2YXRlIHJlY2VpdmVyczogTWFwPEFycmF5PFJlY2VpdmVyPj47XHJcblxyXG4gICAgcHJpdmF0ZSBjb25zdHJ1Y3Rvcigpe1xyXG4gICAgICAgIHRoaXMuTUFYX1NJWkUgPSAxMDA7XHJcbiAgICAgICAgdGhpcy5xID0gbmV3IFF1ZXVlPEdhbWVFdmVudD4odGhpcy5NQVhfU0laRSk7XHJcbiAgICAgICAgdGhpcy5yZWNlaXZlcnMgPSBuZXcgTWFwPEFycmF5PFJlY2VpdmVyPj4oKTtcclxuXHR9XHJcbiAgICBcclxuICAgIC8qKiBSZXRyaWV2ZXMgdGhlIGluc3RhbmNlIG9mIHRoZSBTaW5nbGV0b24gRXZlbnRRdWV1ZSAqL1xyXG5cdHN0YXRpYyBnZXRJbnN0YW5jZSgpOiBFdmVudFF1ZXVlIHtcclxuXHRcdGlmKHRoaXMuaW5zdGFuY2UgPT09IG51bGwpe1xyXG5cdFx0XHR0aGlzLmluc3RhbmNlID0gbmV3IEV2ZW50UXVldWUoKTtcclxuXHRcdH1cclxuXHRcdFxyXG5cdFx0cmV0dXJuIHRoaXMuaW5zdGFuY2U7XHJcblx0fVxyXG5cclxuICAgIC8qKiBBZGRzIGFuIGV2ZW50IHRvIHRoZSBFdmVudFF1ZXVlLlxyXG4gICAgICogVGhpcyBpcyBleHBvc2VkIHRvIHRoZSByZXN0IG9mIHRoZSBnYW1lIGVuZ2luZSB0aHJvdWdoIHRoZSBAcmVmZXJlbmNlW0VtaXR0ZXJdIGNsYXNzICovXHJcbiAgICBhZGRFdmVudChldmVudDogR2FtZUV2ZW50KTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5xLmVucXVldWUoZXZlbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQXNzb2NpYXRlcyBhIHJlY2VpdmVyIHdpdGggYSB0eXBlIG9mIGV2ZW50LiBFdmVyeSB0aW1lIHRoaXMgZXZlbnQgYXBwZWFycyBpbiB0aGUgZnV0dXJlLFxyXG4gICAgICogaXQgd2lsbCBiZSBnaXZlbiB0byB0aGUgcmVjZWl2ZXIgKGFuZCBhbnkgb3RoZXJzIHdhdGNoaW5nIHRoYXQgdHlwZSkuXHJcbiAgICAgKiBUaGlzIGlzIGV4cG9zZWQgdG8gdGhlIHJlc3Qgb2YgdGhlIGdhbWUgZW5naW5lIHRocm91Z2ggdGhlIEByZWZlcmVuY2VbUmVjZWl2ZXJdIGNsYXNzXHJcbiAgICAgKiBAcGFyYW0gcmVjZWl2ZXIgVGhlIGV2ZW50IHJlY2VpdmVyXHJcbiAgICAgKiBAcGFyYW0gdHlwZSBUaGUgdHlwZSBvciB0eXBlcyBvZiBldmVudHMgdG8gc3Vic2NyaWJlIHRvXHJcbiAgICAgKi9cclxuICAgIHN1YnNjcmliZShyZWNlaXZlcjogUmVjZWl2ZXIsIHR5cGU6IHN0cmluZyB8IEFycmF5PHN0cmluZz4pOiB2b2lkIHtcclxuICAgICAgICBpZih0eXBlIGluc3RhbmNlb2YgQXJyYXkpe1xyXG4gICAgICAgICAgICAvLyBJZiBpdCBpcyBhbiBhcnJheSwgc3Vic2NyaWJlIHRvIGFsbCBldmVudCB0eXBlc1xyXG4gICAgICAgICAgICBmb3IobGV0IHQgb2YgdHlwZSl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFkZExpc3RlbmVyKHJlY2VpdmVyLCB0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkTGlzdGVuZXIocmVjZWl2ZXIsIHR5cGUpO1xyXG4gICAgICAgIH1cclxuXHR9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVbnN1YnNjcmliZXMgdGhlIHNwZWNpZmllZCByZWNlaXZlciBmcm9tIGFsbCBldmVudHMsIG9yIGZyb20gd2hhdGV2ZXIgZXZlbnRzIGFyZSBwcm92aWRlZFxyXG4gICAgICogQHBhcmFtIHJlY2VpdmVyIFRoZSByZWNlaXZlciB0byB1bnN1YnNjcmliZVxyXG4gICAgICogQHBhcmFtIGtleXMgVGhlIGV2ZW50cyB0byB1bnN1YnNjcmliZSBmcm9tLiBJZiBub25lIGFyZSBwcm92aWRlZCwgdW5zdWJzY3JpYmUgZnJvbSBhbGxcclxuICAgICAqL1xyXG4gICAgdW5zdWJzY3JpYmUocmVjZWl2ZXI6IFJlY2VpdmVyLCAuLi5ldmVudHM6IEFycmF5PHN0cmluZz4pOiB2b2lkIHtcclxuICAgICAgICB0aGlzLnJlY2VpdmVycy5mb3JFYWNoKGV2ZW50TmFtZSA9PiB7XHJcbiAgICAgICAgICAgIC8vIElmIGtleXMgd2VyZSBwcm92aWRlZCwgb25seSBjb250aW51ZSBpZiB0aGlzIGtleSBpcyBvbmUgb2YgdGhlbVxyXG4gICAgICAgICAgICBpZihldmVudHMubGVuZ3RoID4gMCAmJiBldmVudHMuaW5kZXhPZihldmVudE5hbWUpID09PSAtMSkgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgLy8gRmluZCB0aGUgaW5kZXggb2Ygb3VyIHJlY2VpdmVyIGZvciB0aGlzIGtleVxyXG4gICAgICAgICAgICBsZXQgaW5kZXggPSB0aGlzLnJlY2VpdmVycy5nZXQoZXZlbnROYW1lKS5pbmRleE9mKHJlY2VpdmVyKTtcclxuXHJcbiAgICAgICAgICAgIC8vIElmIGFuIGluZGV4IHdhcyBmb3VuZCwgcmVtb3ZlIHRoZSByZWNlaXZlclxyXG4gICAgICAgICAgICBpZihpbmRleCAhPT0gLTEpe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZWNlaXZlcnMuZ2V0KGV2ZW50TmFtZSkuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEFzc29jaWF0ZSB0aGUgcmVjZWl2ZXIgYW5kIHRoZSB0eXBlXHJcblx0cHJpdmF0ZSBhZGRMaXN0ZW5lcihyZWNlaXZlcjogUmVjZWl2ZXIsIHR5cGU6IHN0cmluZyk6IHZvaWQge1xyXG5cdFx0aWYodGhpcy5yZWNlaXZlcnMuaGFzKHR5cGUpKXtcclxuXHRcdFx0dGhpcy5yZWNlaXZlcnMuZ2V0KHR5cGUpLnB1c2gocmVjZWl2ZXIpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dGhpcy5yZWNlaXZlcnMuYWRkKHR5cGUsIFtyZWNlaXZlcl0pO1xyXG5cdFx0fVxyXG5cdH1cclxuICAgIFxyXG4gICAgdXBkYXRlKGRlbHRhVDogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgICAgd2hpbGUodGhpcy5xLmhhc0l0ZW1zKCkpe1xyXG4gICAgICAgICAgICAvLyBSZXRyaWV2ZSBlYWNoIGV2ZW50XHJcblx0XHRcdGxldCBldmVudCA9IHRoaXMucS5kZXF1ZXVlKCk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyBJZiBhIHJlY2VpdmVyIGhhcyB0aGlzIGV2ZW50IHR5cGUsIHNlbmQgaXQgdGhlIGV2ZW50XHJcbiAgICAgICAgICAgIGlmKHRoaXMucmVjZWl2ZXJzLmhhcyhldmVudC50eXBlKSl7XHJcbiAgICAgICAgICAgICAgICBmb3IobGV0IHJlY2VpdmVyIG9mIHRoaXMucmVjZWl2ZXJzLmdldChldmVudC50eXBlKSl7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVjZWl2ZXIucmVjZWl2ZShldmVudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblx0XHRcdH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIElmIGEgcmVjZWl2ZXIgaXMgc3Vic2NyaWJlZCB0byBhbGwgZXZlbnRzLCBzZW5kIGl0IHRoZSBldmVudFxyXG4gICAgICAgICAgICBpZih0aGlzLnJlY2VpdmVycy5oYXMoR2FtZUV2ZW50VHlwZS5BTEwpKXtcclxuICAgICAgICAgICAgICAgIGZvcihsZXQgcmVjZWl2ZXIgb2YgdGhpcy5yZWNlaXZlcnMuZ2V0KEdhbWVFdmVudFR5cGUuQUxMKSl7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVjZWl2ZXIucmVjZWl2ZShldmVudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0iLCJpbXBvcnQgTWFwIGZyb20gXCIuLi9EYXRhVHlwZXMvTWFwXCJcclxuXHJcbi8qKlxyXG4gKiBBIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluLWdhbWUgZXZlbnQgdGhhdCBpcyBwYXNzZWQgdGhyb3VnaCB0aGUgQHJlZmVyZW5jZVtFdmVudFF1ZXVlXVxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgR2FtZUV2ZW50IHtcclxuICAgIC8qKiBUaGUgdHlwZSBvZiB0aGUgZXZlbnQgKi9cclxuICAgIHB1YmxpYyB0eXBlOiBzdHJpbmc7XHJcbiAgICAvKiogVGhlIGRhdGEgY29udGFpbmVkIGJ5IHRoZSBldmVudCAqL1xyXG4gICAgcHVibGljIGRhdGE6IE1hcDxhbnk+O1xyXG4gICAgLyoqIFRoZSB0aW1lIG9mIHRoZSBldmVudCBpbiBtcyAqL1xyXG5cdHB1YmxpYyB0aW1lOiBudW1iZXI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IEdhbWVFdmVudC5cclxuICAgICAqIFRoaXMgaXMgaGFuZGxlZCBpbXBsaWNpdGx5IHRocm91Z2ggdGhlIEByZWZlcmVuY2VbRW1pdHRlcl0gY2xhc3NcclxuICAgICAqIEBwYXJhbSB0eXBlIFRoZSB0eXBlIG9mIHRoZSBHYW1lRXZlbnRcclxuICAgICAqIEBwYXJhbSBkYXRhIFRoZSBkYXRhIGNvbnRhaW5lZCBieSB0aGUgR2FtZUV2ZW50XHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHR5cGU6IHN0cmluZywgZGF0YTogTWFwPGFueT4gfCBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0gbnVsbCkge1xyXG4gICAgICAgIC8vIFBhcnNlIHRoZSBnYW1lIGV2ZW50IGRhdGFcclxuICAgICAgICBpZiAoZGF0YSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLmRhdGEgPSBuZXcgTWFwPGFueT4oKTtcclxuICAgICAgICB9IGVsc2UgaWYgKCEoZGF0YSBpbnN0YW5jZW9mIE1hcCkpe1xyXG4gICAgICAgICAgICAvLyBkYXRhIGlzIGEgcmF3IG9iamVjdCwgdW5wYWNrXHJcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IG5ldyBNYXA8YW55PigpO1xyXG4gICAgICAgICAgICBmb3IobGV0IGtleSBpbiBkYXRhKXtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGF0YS5hZGQoa2V5LCBkYXRhW2tleV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XHJcbiAgICAgICAgdGhpcy50aW1lID0gRGF0ZS5ub3coKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyB0aGUgdHlwZSBvZiB0aGUgR2FtZUV2ZW50XHJcbiAgICAgKiBAcGFyYW0gdHlwZSBUaGUgdHlwZSB0byBjaGVja1xyXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgR2FtZUV2ZW50IGlzIHRoZSBzcGVjaWZpZWQgdHlwZSwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gICAgICovXHJcbiAgICBpc1R5cGUodHlwZTogc3RyaW5nKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gdHlwZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhpcyBHYW1lRXZlbnQgYXMgYSBzdHJpbmdcclxuICAgICAqIEByZXR1cm5zIFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIEdhbWVFdmVudFxyXG4gICAgICovXHJcbiAgICB0b1N0cmluZygpOiBzdHJpbmcge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgKyBcIjogQFwiICsgdGhpcy50aW1lO1xyXG4gICAgfVxyXG59IiwiLy8gQGlnbm9yZVBhZ2VcclxuXHJcbmV4cG9ydCBlbnVtIEdhbWVFdmVudFR5cGUge1xyXG5cdC8qKlxyXG5cdCAqIE1vdXNlIERvd24gZXZlbnQuIEhhcyBkYXRhOiB7cG9zaXRpb246IFZlYzIgLSBNb3VzZSBQb3NpdGlvbn1cclxuXHQgKi9cclxuXHRNT1VTRV9ET1dOID0gXCJtb3VzZV9kb3duXCIsXHJcblx0LyoqXHJcblx0ICogTW91c2UgVXAgZXZlbnQuIEhhcyBkYXRhOiB7cG9zaXRpb246IFZlYzIgLSBNb3VzZSBQb3NpdGlvbn1cclxuXHQgKi9cclxuXHRNT1VTRV9VUCA9IFwibW91c2VfdXBcIixcclxuXHQvKipcclxuXHQgKiBNb3VzZSBNb3ZlIGV2ZW50LiBIYXMgZGF0YToge3Bvc2l0aW9uOiBWZWMyIC0gTW91c2UgUG9zaXRpb259XHJcblx0ICovXHJcblx0TU9VU0VfTU9WRSA9IFwibW91c2VfbW92ZVwiLFxyXG5cclxuXHQvKipcclxuXHQgKiBLZXkgRG93biBldmVudC4gSGFzIGRhdGE6IHtrZXk6IHN0cmluZyAtIFRoZSBrZXkgdGhhdCBpcyBkb3dufVxyXG5cdCAqL1xyXG5cdEtFWV9ET1dOID0gXCJrZXlfZG93blwiLFxyXG5cclxuXHQvKipcclxuXHQgKiBLZXkgVXAgZXZlbnQuIEhhcyBkYXRhOiB7a2V5OiBzdHJpbmcgLSBUaGUga2V5IHRoYXQgaXMgdXB9XHJcblx0ICovXHJcblx0S0VZX1VQID0gXCJrZXlfdXBcIixcclxuXHJcblx0LyoqXHJcblx0ICogQ2FudmFzIEJsdXIgZXZlbnQuIEhhcyBkYXRhOiB7fVxyXG5cdCAqL1xyXG5cdENBTlZBU19CTFVSID0gXCJjYW52YXNfYmx1clwiLFxyXG5cclxuXHQvKipcclxuXHQgKiBNb3VzZSB3aGVlbCB1cCBldmVudC4gSGFzIGRhdGE6IHt9XHJcblx0ICovXHJcblx0V0hFRUxfVVAgPSBcIndoZWVsX3VwXCIsXHJcblxyXG5cdC8qKlxyXG5cdCAqIE1vdXNlIHdoZWVsIGRvd24gZXZlbnQuIEhhcyBkYXRhOiB7fVxyXG5cdCAqL1xyXG5cdFdIRUVMX0RPV04gPSBcIndoZWVsX2Rvd25cIixcclxuXHJcblx0LyoqXHJcblx0ICogU3RhcnQgUmVjb3JkaW5nIGV2ZW50LiBIYXMgZGF0YToge31cclxuXHQgKi9cclxuXHRTVEFSVF9SRUNPUkRJTkcgPSBcInN0YXJ0X3JlY29yZGluZ1wiLFxyXG5cclxuXHQvKipcclxuXHQgKiBTdG9wIFJlY29yZGluZyBldmVudC4gSGFzIGRhdGE6IHt9XHJcblx0ICovXHJcblx0U1RPUF9SRUNPUkRJTkcgPSBcInN0b3BfcmVjb3JkaW5nXCIsXHJcblx0XHJcblx0LyoqXHJcblx0ICogUGxheSBSZWNvcmRpbmcgZXZlbnQuIEhhcyBkYXRhOiB7fVxyXG5cdCAqL1xyXG5cdFBMQVlfUkVDT1JESU5HID0gXCJwbGF5X3JlY29yZGluZ1wiLFxyXG5cclxuXHQvKipcclxuXHQgKiBQbGF5IFNvdW5kIGV2ZW50LiBIYXMgZGF0YToge2tleTogc3RyaW5nLCBsb29wOiBib29sZWFuLCBob2xkUmVmZXJlbmNlOiBib29sZWFuIH1cclxuXHQgKi9cclxuXHRQTEFZX1NPVU5EID0gXCJwbGF5X3NvdW5kXCIsXHJcblxyXG5cdC8qKlxyXG5cdCAqIFBsYXkgU291bmQgZXZlbnQuIEhhcyBkYXRhOiB7a2V5OiBzdHJpbmd9XHJcblx0ICovXHJcblx0U1RPUF9TT1VORCA9IFwic3RvcF9zb3VuZFwiLFxyXG5cclxuXHQvKipcclxuXHQgKiBQbGF5IFNvdW5kIGV2ZW50LiBIYXMgZGF0YToge2tleTogc3RyaW5nLCBsb29wOiBib29sZWFuLCBob2xkUmVmZXJlbmNlOiBib29sZWFuLCBjaGFubmVsOiBBdWRpb0NoYW5uZWxUeXBlIH1cclxuXHQgKi9cclxuIFx0UExBWV9TRlggPSBcInBsYXlfc2Z4XCIsXHJcblxyXG4gXHQvKipcclxuXHQgKiBQbGF5IFNvdW5kIGV2ZW50LiBIYXMgZGF0YToge2tleTogc3RyaW5nLCBsb29wOiBib29sZWFuLCBob2xkUmVmZXJlbmNlOiBib29sZWFuIH1cclxuXHQgKi9cclxuICBcdFBMQVlfTVVTSUMgPSBcInBsYXlfbXVzaWNcIixcclxuXHJcblx0LyoqXHJcblx0ICogTXV0ZSBhdWRpbyBjaGFubmVsIGV2ZW50LiBIYXMgZGF0YToge2NoYW5uZWw6IEF1ZGlvQ2hhbm5lbFR5cGV9XHJcblx0ICovXHJcblx0TVVURV9DSEFOTkVMID0gXCJtdXRlX2NoYW5uZWxcIixcclxuXHJcblx0LyoqXHJcblx0ICogVW5tdXRlIGF1ZGlvIGNoYW5uZWwgZXZlbnQuIEhhcyBkYXRhOiB7Y2hhbm5lbDogQXVkaW9DaGFubmVsVHlwZX1cclxuXHQgKi9cclxuXHRVTk1VVEVfQ0hBTk5FTCA9IFwidW5tdXRlX2NoYW5uZWxcIixcclxuXHJcblx0LyoqXHJcblx0ICogRW5jb21wYXNzZXMgYWxsIGV2ZW50IHR5cGVzLiBVc2VkIGZvciByZWNlaXZlcnMgb25seS5cclxuXHQgKi9cclxuXHRBTEwgPSBcImFsbFwiLFxyXG59IiwiaW1wb3J0IFF1ZXVlIGZyb20gXCIuLi9EYXRhVHlwZXMvUXVldWVcIjtcclxuaW1wb3J0IEV2ZW50UXVldWUgZnJvbSBcIi4vRXZlbnRRdWV1ZVwiO1xyXG5pbXBvcnQgR2FtZUV2ZW50IGZyb20gXCIuL0dhbWVFdmVudFwiO1xyXG5cclxuLyoqXHJcbiAqIFJlY2VpdmVzIHN1YnNjcmliZWQgZXZlbnRzIGZyb20gdGhlIEV2ZW50UXVldWUuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZWNlaXZlciB7XHJcblx0LyoqIFRoZSBtYXhpbXVtIG51bWJlciBvZiBldmVudHMgdGhpcyBSZWNlaXZlciBjYW4gaG9sZCBhdCBvbmUgdGltZSAqL1xyXG5cdHJlYWRvbmx5IE1BWF9TSVpFOiBudW1iZXI7XHJcblxyXG5cdC8qKiBUaGUgaW5ib3ggb2YgdGhlIFJlY2VpdmVyICovXHJcblx0cHJpdmF0ZSBxOiBRdWV1ZTxHYW1lRXZlbnQ+O1xyXG5cclxuXHQvKiogQ3JlYXRlcyBhIG5ldyBSZWNlaXZlciAqL1xyXG5cdGNvbnN0cnVjdG9yKCl7XHJcblx0XHR0aGlzLk1BWF9TSVpFID0gMTAwO1xyXG4gICAgICAgIHRoaXMucSA9IG5ldyBRdWV1ZSh0aGlzLk1BWF9TSVpFKTtcclxuXHR9XHJcblxyXG5cdGRlc3Ryb3koKXtcclxuXHRcdEV2ZW50UXVldWUuZ2V0SW5zdGFuY2UoKS51bnN1YnNjcmliZSh0aGlzKTtcclxuXHR9XHJcblx0XHJcblx0LyoqXHJcblx0ICogQWRkcyB0aGVzZSB0eXBlcyBvZiBldmVudHMgdG8gdGhpcyByZWNlaXZlcidzIHF1ZXVlIGV2ZXJ5IHVwZGF0ZS5cclxuXHQgKiBAcGFyYW0gZXZlbnRUeXBlcyBUaGUgdHlwZXMgb2YgZXZlbnRzIHRoaXMgcmVjZWl2ZXIgd2lsbCBiZSBzdWJzY3JpYmVkIHRvXHJcblx0ICovXHJcblx0c3Vic2NyaWJlKGV2ZW50VHlwZXM6IHN0cmluZyB8IEFycmF5PHN0cmluZz4pOiB2b2lkIHtcclxuXHRcdEV2ZW50UXVldWUuZ2V0SW5zdGFuY2UoKS5zdWJzY3JpYmUodGhpcywgZXZlbnRUeXBlcyk7XHJcblx0XHR0aGlzLnEuY2xlYXIoKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEFkZHMgYW4gZXZlbnQgdG8gdGhlIHF1ZXVlIG9mIHRoaXMgcmVjaWV2ZXIuIFRoaXMgaXMgdXNlZCBieSB0aGUgQHJlZmVyZW5jZVtFdmVudFF1ZXVlXSB0byBkaXN0cmlidXRlIGV2ZW50c1xyXG5cdCAqIEBwYXJhbSBldmVudCBUaGUgZXZlbnQgdG8gcmVjZWl2ZVxyXG5cdCAqL1xyXG5cdHJlY2VpdmUoZXZlbnQ6IEdhbWVFdmVudCk6IHZvaWQge1xyXG5cdFx0dHJ5e1xyXG5cdFx0dGhpcy5xLmVucXVldWUoZXZlbnQpO1xyXG5cdFx0fSBjYXRjaChlKXtcclxuXHRcdFx0Y29uc29sZS53YXJuKFwiUmVjZWl2ZXIgb3ZlcmZsb3cgZm9yIGV2ZW50IFwiICsgZXZlbnQudG9TdHJpbmcoKSk7XHJcblx0XHRcdHRocm93IGU7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXRyaWV2ZXMgdGhlIG5leHQgZXZlbnQgZnJvbSB0aGUgcmVjZWl2ZXIncyBxdWV1ZVxyXG5cdCAqIEByZXR1cm5zIFRoZSBuZXh0IEdhbWVFdmVudFxyXG5cdCAqL1xyXG5cdGdldE5leHRFdmVudCgpOiBHYW1lRXZlbnQge1xyXG5cdFx0cmV0dXJuIHRoaXMucS5kZXF1ZXVlKCk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBMb29rcyBhdCB0aGUgbmV4dCBldmVudCBpbiB0aGUgcmVjZWl2ZXIncyBxdWV1ZSwgYnV0IGRvZXNuJ3QgcmVtb3ZlIGl0IGZyb20gdGhlIHF1ZXVlXHJcblx0ICogQHJldHVybnMgVGhlIG5leHQgR2FtZUV2ZW50XHJcblx0ICovXHJcblx0cGVla05leHRFdmVudCgpOiBHYW1lRXZlbnQge1xyXG5cdFx0cmV0dXJuIHRoaXMucS5wZWVrTmV4dCgpXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHJlY2VpdmVyIGhhcyBhbnkgZXZlbnRzIGluIGl0cyBxdWV1ZVxyXG5cdCAqIEByZXR1cm5zIFRydWUgaWYgdGhlIHJlY2VpdmVyIGhhcyBhbm90aGVyIGV2ZW50LCBmYWxzZSBvdGhlcndpc2VcclxuXHQgKi9cclxuXHRoYXNOZXh0RXZlbnQoKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gdGhpcy5xLmhhc0l0ZW1zKCk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBJZ25vcmUgYWxsIGV2ZW50cyB0aGlzIGZyYW1lXHJcblx0ICovXHJcblx0aWdub3JlRXZlbnRzKCk6IHZvaWQge1xyXG5cdFx0dGhpcy5xLmNsZWFyKCk7XHJcblx0fVxyXG59IiwiaW1wb3J0IFJlY2VpdmVyIGZyb20gXCIuLi9FdmVudHMvUmVjZWl2ZXJcIjtcclxuaW1wb3J0IE1hcCBmcm9tIFwiLi4vRGF0YVR5cGVzL01hcFwiO1xyXG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vRGF0YVR5cGVzL1ZlYzJcIjtcclxuaW1wb3J0IEV2ZW50UXVldWUgZnJvbSBcIi4uL0V2ZW50cy9FdmVudFF1ZXVlXCI7XHJcbmltcG9ydCBWaWV3cG9ydCBmcm9tIFwiLi4vU2NlbmVHcmFwaC9WaWV3cG9ydFwiO1xyXG5pbXBvcnQgR2FtZUV2ZW50IGZyb20gXCIuLi9FdmVudHMvR2FtZUV2ZW50XCI7XHJcbmltcG9ydCB7IEdhbWVFdmVudFR5cGUgfSBmcm9tIFwiLi4vRXZlbnRzL0dhbWVFdmVudFR5cGVcIjtcclxuXHJcbi8qKlxyXG4gKiBSZWNlaXZlcyBpbnB1dCBldmVudHMgZnJvbSB0aGUgQHJlZmVyZW5jZVtFdmVudFF1ZXVlXSBhbmQgYWxsb3dzIGZvciBlYXN5IGFjY2VzcyBvZiBpbmZvcm1hdGlvbiBhYm91dCBpbnB1dCBieSBvdGhlciBzeXN0ZW1zXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJbnB1dCB7XHJcblx0cHJpdmF0ZSBzdGF0aWMgbW91c2VQcmVzc2VkOiBib29sZWFuO1xyXG5cdHByaXZhdGUgc3RhdGljIG1vdXNlSnVzdFByZXNzZWQ6IGJvb2xlYW47XHJcblx0cHJpdmF0ZSBzdGF0aWMgbW91c2VCdXR0b25QcmVzc2VkOiBudW1iZXI7XHJcblxyXG5cdHByaXZhdGUgc3RhdGljIGtleUp1c3RQcmVzc2VkOiBNYXA8Ym9vbGVhbj47XHJcblx0cHJpdmF0ZSBzdGF0aWMga2V5UHJlc3NlZDogTWFwPGJvb2xlYW4+O1xyXG5cclxuXHRwcml2YXRlIHN0YXRpYyBtb3VzZVBvc2l0aW9uOiBWZWMyO1xyXG5cdHByaXZhdGUgc3RhdGljIG1vdXNlUHJlc3NQb3NpdGlvbjogVmVjMjtcclxuXHJcblx0cHJpdmF0ZSBzdGF0aWMgc2Nyb2xsRGlyZWN0aW9uOiBudW1iZXI7XHJcblx0cHJpdmF0ZSBzdGF0aWMganVzdFNjcm9sbGVkOiBib29sZWFuO1xyXG5cclxuXHRwcml2YXRlIHN0YXRpYyBldmVudFF1ZXVlOiBFdmVudFF1ZXVlO1xyXG5cdHByaXZhdGUgc3RhdGljIHJlY2VpdmVyOiBSZWNlaXZlcjtcclxuXHRwcml2YXRlIHN0YXRpYyB2aWV3cG9ydDogVmlld3BvcnQ7XHJcblxyXG5cdHByaXZhdGUgc3RhdGljIGtleU1hcDogTWFwPEFycmF5PHN0cmluZz4+O1xyXG5cclxuXHRwcml2YXRlIHN0YXRpYyBrZXlzRGlzYWJsZWQ6IGJvb2xlYW47XHJcblx0cHJpdmF0ZSBzdGF0aWMgbW91c2VEaXNhYmxlZDogYm9vbGVhbjtcclxuXHJcblx0LyoqXHJcblx0ICogSW5pdGlhbGl6ZXMgdGhlIElucHV0IG9iamVjdFxyXG5cdCAqIEBwYXJhbSB2aWV3cG9ydCBBIHJlZmVyZW5jZSB0byB0aGUgdmlld3BvcnQgb2YgdGhlIGdhbWVcclxuXHQgKi9cclxuXHRzdGF0aWMgaW5pdGlhbGl6ZSh2aWV3cG9ydDogVmlld3BvcnQsIGtleU1hcDogQXJyYXk8UmVjb3JkPHN0cmluZywgYW55Pj4pIHtcclxuXHRcdElucHV0LnZpZXdwb3J0ID0gdmlld3BvcnQ7XHJcblx0XHRJbnB1dC5tb3VzZVByZXNzZWQgPSBmYWxzZTtcclxuXHRcdElucHV0Lm1vdXNlSnVzdFByZXNzZWQgPSBmYWxzZTtcclxuXHRcdElucHV0LnJlY2VpdmVyID0gbmV3IFJlY2VpdmVyKCk7XHJcblx0XHRJbnB1dC5rZXlKdXN0UHJlc3NlZCA9IG5ldyBNYXA8Ym9vbGVhbj4oKTtcclxuXHRcdElucHV0LmtleVByZXNzZWQgPSBuZXcgTWFwPGJvb2xlYW4+KCk7XHJcblx0XHRJbnB1dC5tb3VzZVBvc2l0aW9uID0gbmV3IFZlYzIoMCwgMCk7XHJcblx0XHRJbnB1dC5tb3VzZVByZXNzUG9zaXRpb24gPSBuZXcgVmVjMigwLCAwKTtcclxuXHRcdElucHV0LnNjcm9sbERpcmVjdGlvbiA9IDA7XHJcblx0XHRJbnB1dC5qdXN0U2Nyb2xsZWQgPSBmYWxzZTtcclxuXHRcdElucHV0LmtleXNEaXNhYmxlZCA9IGZhbHNlO1xyXG5cdFx0SW5wdXQubW91c2VEaXNhYmxlZCA9IGZhbHNlO1xyXG5cclxuXHRcdC8vIEluaXRpYWxpemUgdGhlIGtleW1hcFxyXG5cdFx0SW5wdXQua2V5TWFwID0gbmV3IE1hcCgpO1xyXG5cclxuXHRcdC8vIEFkZCBhbGwga2V5cyB0byB0aGUga2V5bWFwXHJcblx0XHRmb3IgKGxldCBlbnRyeSBpbiBrZXlNYXApIHtcclxuXHRcdFx0bGV0IG5hbWUgPSBrZXlNYXBbZW50cnldLm5hbWU7XHJcblx0XHRcdGxldCBrZXlzID0ga2V5TWFwW2VudHJ5XS5rZXlzO1xyXG5cdFx0XHRJbnB1dC5rZXlNYXAuYWRkKG5hbWUsIGtleXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdElucHV0LmV2ZW50UXVldWUgPSBFdmVudFF1ZXVlLmdldEluc3RhbmNlKCk7XHJcblx0XHQvLyBTdWJzY3JpYmUgdG8gYWxsIGlucHV0IGV2ZW50c1xyXG5cdFx0SW5wdXQuZXZlbnRRdWV1ZS5zdWJzY3JpYmUoSW5wdXQucmVjZWl2ZXIsIFtHYW1lRXZlbnRUeXBlLk1PVVNFX0RPV04sIEdhbWVFdmVudFR5cGUuTU9VU0VfVVAsIEdhbWVFdmVudFR5cGUuTU9VU0VfTU9WRSxcclxuXHRcdEdhbWVFdmVudFR5cGUuS0VZX0RPV04sIEdhbWVFdmVudFR5cGUuS0VZX1VQLCBHYW1lRXZlbnRUeXBlLkNBTlZBU19CTFVSLCBHYW1lRXZlbnRUeXBlLldIRUVMX1VQLCBHYW1lRXZlbnRUeXBlLldIRUVMX0RPV05dKTtcclxuXHR9XHJcblxyXG5cdHN0YXRpYyB1cGRhdGUoZGVsdGFUOiBudW1iZXIpOiB2b2lkIHtcclxuXHRcdC8vIFJlc2V0IHRoZSBqdXN0UHJlc3NlZCB2YWx1ZXMgdG8gZmFsc2VcclxuXHRcdElucHV0Lm1vdXNlSnVzdFByZXNzZWQgPSBmYWxzZTtcclxuXHRcdElucHV0LmtleUp1c3RQcmVzc2VkLmZvckVhY2goKGtleTogc3RyaW5nKSA9PiBJbnB1dC5rZXlKdXN0UHJlc3NlZC5zZXQoa2V5LCBmYWxzZSkpO1xyXG5cdFx0SW5wdXQuanVzdFNjcm9sbGVkID0gZmFsc2U7XHJcblx0XHRJbnB1dC5zY3JvbGxEaXJlY3Rpb24gPSAwO1xyXG5cclxuXHRcdHdoaWxlIChJbnB1dC5yZWNlaXZlci5oYXNOZXh0RXZlbnQoKSkge1xyXG5cdFx0XHRsZXQgZXZlbnQgPSBJbnB1dC5yZWNlaXZlci5nZXROZXh0RXZlbnQoKTtcclxuXHJcblx0XHRcdC8vIEhhbmRsZSBlYWNoIGV2ZW50IHR5cGVcclxuXHRcdFx0aWYgKGV2ZW50LnR5cGUgPT09IEdhbWVFdmVudFR5cGUuTU9VU0VfRE9XTikge1xyXG5cdFx0XHRcdElucHV0Lm1vdXNlSnVzdFByZXNzZWQgPSB0cnVlO1xyXG5cdFx0XHRcdElucHV0Lm1vdXNlUHJlc3NlZCA9IHRydWU7XHJcblx0XHRcdFx0SW5wdXQubW91c2VQcmVzc1Bvc2l0aW9uID0gZXZlbnQuZGF0YS5nZXQoXCJwb3NpdGlvblwiKTtcclxuXHRcdFx0XHRJbnB1dC5tb3VzZUJ1dHRvblByZXNzZWQgPSBldmVudC5kYXRhLmdldChcImJ1dHRvblwiKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKGV2ZW50LnR5cGUgPT09IEdhbWVFdmVudFR5cGUuTU9VU0VfVVApIHtcclxuXHRcdFx0XHRJbnB1dC5tb3VzZVByZXNzZWQgPSBmYWxzZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKGV2ZW50LnR5cGUgPT09IEdhbWVFdmVudFR5cGUuTU9VU0VfTU9WRSkge1xyXG5cdFx0XHRcdElucHV0Lm1vdXNlUG9zaXRpb24gPSBldmVudC5kYXRhLmdldChcInBvc2l0aW9uXCIpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoZXZlbnQudHlwZSA9PT0gR2FtZUV2ZW50VHlwZS5LRVlfRE9XTikge1xyXG5cdFx0XHRcdGxldCBrZXkgPSBldmVudC5kYXRhLmdldChcImtleVwiKTtcclxuXHRcdFx0XHQvLyBIYW5kbGUgc3BhY2UgYmFyXHJcblx0XHRcdFx0aWYgKGtleSA9PT0gXCIgXCIpIHtcclxuXHRcdFx0XHRcdGtleSA9IFwic3BhY2VcIjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYgKCFJbnB1dC5rZXlQcmVzc2VkLmdldChrZXkpKSB7XHJcblx0XHRcdFx0XHRJbnB1dC5rZXlKdXN0UHJlc3NlZC5zZXQoa2V5LCB0cnVlKTtcclxuXHRcdFx0XHRcdElucHV0LmtleVByZXNzZWQuc2V0KGtleSwgdHJ1ZSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoZXZlbnQudHlwZSA9PT0gR2FtZUV2ZW50VHlwZS5LRVlfVVApIHtcclxuXHRcdFx0XHRsZXQga2V5ID0gZXZlbnQuZGF0YS5nZXQoXCJrZXlcIik7XHJcblx0XHRcdFx0Ly8gSGFuZGxlIHNwYWNlIGJhclxyXG5cdFx0XHRcdGlmIChrZXkgPT09IFwiIFwiKSB7XHJcblx0XHRcdFx0XHRrZXkgPSBcInNwYWNlXCI7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdElucHV0LmtleVByZXNzZWQuc2V0KGtleSwgZmFsc2UpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoZXZlbnQudHlwZSA9PT0gR2FtZUV2ZW50VHlwZS5DQU5WQVNfQkxVUikge1xyXG5cdFx0XHRcdElucHV0LmNsZWFyS2V5UHJlc3NlcygpXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChldmVudC50eXBlID09PSBHYW1lRXZlbnRUeXBlLldIRUVMX1VQKSB7XHJcblx0XHRcdFx0SW5wdXQuc2Nyb2xsRGlyZWN0aW9uID0gLTE7XHJcblx0XHRcdFx0SW5wdXQuanVzdFNjcm9sbGVkID0gdHJ1ZTtcclxuXHRcdFx0fSBlbHNlIGlmIChldmVudC50eXBlID09PSBHYW1lRXZlbnRUeXBlLldIRUVMX0RPV04pIHtcclxuXHRcdFx0XHRJbnB1dC5zY3JvbGxEaXJlY3Rpb24gPSAxO1xyXG5cdFx0XHRcdElucHV0Lmp1c3RTY3JvbGxlZCA9IHRydWU7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHByaXZhdGUgc3RhdGljIGNsZWFyS2V5UHJlc3NlcygpOiB2b2lkIHtcclxuXHRcdElucHV0LmtleUp1c3RQcmVzc2VkLmZvckVhY2goKGtleTogc3RyaW5nKSA9PiBJbnB1dC5rZXlKdXN0UHJlc3NlZC5zZXQoa2V5LCBmYWxzZSkpO1xyXG5cdFx0SW5wdXQua2V5UHJlc3NlZC5mb3JFYWNoKChrZXk6IHN0cmluZykgPT4gSW5wdXQua2V5UHJlc3NlZC5zZXQoa2V5LCBmYWxzZSkpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCBhIGtleSB3YXMgbmV3bHkgcHJlc3NlZCBJbnB1dCBmcmFtZS5cclxuXHQgKiBJZiB0aGUga2V5IGlzIHN0aWxsIHByZXNzZWQgZnJvbSBsYXN0IGZyYW1lIGFuZCB3YXNuJ3QgcmUtcHJlc3NlZCwgSW5wdXQgd2lsbCByZXR1cm4gZmFsc2UuXHJcblx0ICogQHBhcmFtIGtleSBUaGUga2V5XHJcblx0ICogQHJldHVybnMgVHJ1ZSBpZiB0aGUga2V5IHdhcyBqdXN0IHByZXNzZWQsIGZhbHNlIG90aGVyd2lzZVxyXG5cdCAqL1xyXG5cdHN0YXRpYyBpc0tleUp1c3RQcmVzc2VkKGtleTogc3RyaW5nKTogYm9vbGVhbiB7XHJcblx0XHRpZiAoSW5wdXQua2V5c0Rpc2FibGVkKSByZXR1cm4gZmFsc2U7XHJcblxyXG5cdFx0aWYgKElucHV0LmtleUp1c3RQcmVzc2VkLmhhcyhrZXkpKSB7XHJcblx0XHRcdHJldHVybiBJbnB1dC5rZXlKdXN0UHJlc3NlZC5nZXQoa2V5KVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyBhbiBhcnJheSBvZiBhbGwgb2YgdGhlIGtleXMgdGhhdCBhcmUgbmV3bHkgcHJlc3NlZCBJbnB1dCBmcmFtZS5cclxuXHQgKiBJZiBhIGtleSBpcyBzdGlsbCBwcmVzc2VkIGZyb20gbGFzdCBmcmFtZSBhbmQgd2Fzbid0IHJlLXByZXNzZWQsIGl0IHdpbGwgbm90IGJlIGluIElucHV0IGxpc3QuXHJcblx0ICogQHJldHVybnMgQW4gYXJyYXkgb2YgYWxsIG9mIHRoZSBuZXdseSBwcmVzc2VkIGtleXMuXHJcblx0ICovXHJcblx0c3RhdGljIGdldEtleXNKdXN0UHJlc3NlZCgpOiBBcnJheTxzdHJpbmc+IHtcclxuXHRcdGlmIChJbnB1dC5rZXlzRGlzYWJsZWQpIHJldHVybiBbXTtcclxuXHJcblx0XHRsZXQga2V5cyA9IEFycmF5PHN0cmluZz4oKTtcclxuXHRcdElucHV0LmtleUp1c3RQcmVzc2VkLmZvckVhY2goa2V5ID0+IHtcclxuXHRcdFx0aWYgKElucHV0LmtleUp1c3RQcmVzc2VkLmdldChrZXkpKSB7XHJcblx0XHRcdFx0a2V5cy5wdXNoKGtleSk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdFx0cmV0dXJuIGtleXM7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IGEga2V5IGlzIGJlaW5nIHByZXNzZWQuXHJcblx0ICogQHBhcmFtIGtleSBUaGUga2V5XHJcblx0ICogQHJldHVybnMgVHJ1ZSBpZiB0aGUga2V5IGlzIGN1cnJlbnRseSBwcmVzc2VkLCBmYWxzZSBvdGhlcndpc2VcclxuXHQgKi9cclxuXHRzdGF0aWMgaXNLZXlQcmVzc2VkKGtleTogc3RyaW5nKTogYm9vbGVhbiB7XHJcblx0XHRpZiAoSW5wdXQua2V5c0Rpc2FibGVkKSByZXR1cm4gZmFsc2U7XHJcblxyXG5cdFx0aWYgKElucHV0LmtleVByZXNzZWQuaGFzKGtleSkpIHtcclxuXHRcdFx0cmV0dXJuIElucHV0LmtleVByZXNzZWQuZ2V0KGtleSlcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENoYW5nZXMgdGhlIGJpbmRpbmcgb2YgYW4gaW5wdXQgbmFtZSB0byBrZXlzXHJcblx0ICogQHBhcmFtIGlucHV0TmFtZSBUaGUgbmFtZSBvZiB0aGUgaW5wdXRcclxuXHQgKiBAcGFyYW0ga2V5cyBUaGUgY29ycmVzcG9uZGluZyBrZXlzXHJcblx0ICovXHJcblx0c3RhdGljIGNoYW5nZUtleUJpbmRpbmcoaW5wdXROYW1lOiBzdHJpbmcsIGtleXM6IEFycmF5PHN0cmluZz4pOiB2b2lkIHtcclxuXHRcdElucHV0LmtleU1hcC5zZXQoaW5wdXROYW1lLCBrZXlzKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENsZWFycyBhbGwga2V5IGJpbmRpbmdzXHJcblx0ICovXHJcblx0c3RhdGljIGNsZWFyQWxsS2V5QmluZGluZ3MoKTogdm9pZCB7XHJcblx0XHRJbnB1dC5rZXlNYXAuY2xlYXIoKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgd2hldGhlciBvciBub3QgYW4gaW5wdXQgd2FzIGp1c3QgcHJlc3NlZCB0aGlzIGZyYW1lXHJcblx0ICogQHBhcmFtIGlucHV0TmFtZSBUaGUgbmFtZSBvZiB0aGUgaW5wdXRcclxuXHQgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBpbnB1dCB3YXMganVzdCBwcmVzc2VkLCBmYWxzZSBvdGhlcndpc2VcclxuXHQgKi9cclxuXHRzdGF0aWMgaXNKdXN0UHJlc3NlZChpbnB1dE5hbWU6IHN0cmluZyk6IGJvb2xlYW4ge1xyXG5cdFx0aWYgKElucHV0LmtleXNEaXNhYmxlZCkgcmV0dXJuIGZhbHNlO1xyXG5cclxuXHRcdGlmIChJbnB1dC5rZXlNYXAuaGFzKGlucHV0TmFtZSkpIHtcclxuXHRcdFx0Y29uc3Qga2V5cyA9IElucHV0LmtleU1hcC5nZXQoaW5wdXROYW1lKTtcclxuXHRcdFx0bGV0IGp1c3RQcmVzc2VkID0gZmFsc2U7XHJcblxyXG5cdFx0XHRmb3IgKGxldCBrZXkgb2Yga2V5cykge1xyXG5cdFx0XHRcdGp1c3RQcmVzc2VkID0ganVzdFByZXNzZWQgfHwgSW5wdXQuaXNLZXlKdXN0UHJlc3NlZChrZXkpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4ganVzdFByZXNzZWQ7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IGFuIGlucHV0IGlzIGN1cnJlbnRseSBwcmVzc2VkXHJcblx0ICogQHBhcmFtIGlucHV0TmFtZSBUaGUgbmFtZSBvZiB0aGUgaW5wdXRcclxuXHQgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBpbnB1dCBpcyBwcmVzc2VkLCBmYWxzZSBvdGhlcndpc2VcclxuXHQgKi9cclxuXHRzdGF0aWMgaXNQcmVzc2VkKGlucHV0TmFtZTogc3RyaW5nKTogYm9vbGVhbiB7XHJcblx0XHRpZiAoSW5wdXQua2V5c0Rpc2FibGVkKSByZXR1cm4gZmFsc2U7XHJcblxyXG5cdFx0aWYgKElucHV0LmtleU1hcC5oYXMoaW5wdXROYW1lKSkge1xyXG5cdFx0XHRjb25zdCBrZXlzID0gSW5wdXQua2V5TWFwLmdldChpbnB1dE5hbWUpO1xyXG5cdFx0XHRsZXQgcHJlc3NlZCA9IGZhbHNlO1xyXG5cclxuXHRcdFx0Zm9yIChsZXQga2V5IG9mIGtleXMpIHtcclxuXHRcdFx0XHRwcmVzc2VkID0gcHJlc3NlZCB8fCBJbnB1dC5pc0tleVByZXNzZWQoa2V5KTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHByZXNzZWQ7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblx0fVxyXG5cdC8qKlxyXG5cdCAqIFxyXG5cdCAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIG1vdXNlIHdhcyBuZXdseSBwcmVzc2VkIElucHV0IGZyYW1lLlxyXG5cdCAqIEBwYXJhbSBtb3VzZUJ1dHRvbiBPcHRpb25hbGx5IHNwZWNpZnkgd2hpY2ggbW91c2UgY2xpY2sgeW91IHdhbnQgdG8ga25vdyB3YXMgcHJlc3NlZC4gXHJcblx0ICogMCBmb3IgbGVmdCBjbGljaywgMSBmb3IgbWlkZGxlIGNsaWNrLCAyIGZvciByaWdodCBjbGljay5cclxuXHQgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBtb3VzZSB3YXMganVzdCBwcmVzc2VkLCBmYWxzZSBvdGhlcndpc2VcclxuXHQgKi9cclxuXHRzdGF0aWMgaXNNb3VzZUp1c3RQcmVzc2VkKG1vdXNlQnV0dG9uPzogbnVtYmVyKTogYm9vbGVhbiB7XHJcblx0XHRpZiAobW91c2VCdXR0b24pIHtcclxuXHRcdFx0cmV0dXJuIElucHV0Lm1vdXNlSnVzdFByZXNzZWQgJiYgIUlucHV0Lm1vdXNlRGlzYWJsZWQgJiYgbW91c2VCdXR0b24gPT0gdGhpcy5tb3VzZUJ1dHRvblByZXNzZWQ7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gSW5wdXQubW91c2VKdXN0UHJlc3NlZCAmJiAhSW5wdXQubW91c2VEaXNhYmxlZDtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIG1vdXNlIGlzIGN1cnJlbnRseSBwcmVzc2VkXHJcblx0ICogQHBhcmFtIG1vdXNlQnV0dG9uIE9wdGlvbmFsbHkgc3BlY2lmeSB3aGljaCBtb3VzZSBjbGljayB5b3Ugd2FudCB0byBrbm93IHdhcyBwcmVzc2VkLiBcclxuXHQgKiAwIGZvciBsZWZ0IGNsaWNrLCAxIGZvciBtaWRkbGUgY2xpY2ssIDIgZm9yIHJpZ2h0IGNsaWNrLlxyXG5cdCAqIEByZXR1cm5zIFRydWUgaWYgdGhlIG1vdXNlIGlzIGN1cnJlbnRseSBwcmVzc2VkLCBmYWxzZSBvdGhlcndpc2VcclxuXHQgKi9cclxuXHRzdGF0aWMgaXNNb3VzZVByZXNzZWQobW91c2VCdXR0b24/OiBudW1iZXIpOiBib29sZWFuIHtcclxuXHRcdGlmIChtb3VzZUJ1dHRvbikge1xyXG5cdFx0XHRyZXR1cm4gSW5wdXQubW91c2VQcmVzc2VkICYmICFJbnB1dC5tb3VzZURpc2FibGVkICYmIG1vdXNlQnV0dG9uID09IHRoaXMubW91c2VCdXR0b25QcmVzc2VkO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIElucHV0Lm1vdXNlUHJlc3NlZCAmJiAhSW5wdXQubW91c2VEaXNhYmxlZDtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgd2hldGhlciB0aGUgdXNlciBzY3JvbGxlZCBvciBub3RcclxuXHQgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSB1c2VyIGp1c3Qgc2Nyb2xsZWQgSW5wdXQgZnJhbWUsIGZhbHNlIG90aGVyd2lzZVxyXG5cdCAqL1xyXG5cdHN0YXRpYyBkaWRKdXN0U2Nyb2xsKCk6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIElucHV0Lmp1c3RTY3JvbGxlZCAmJiAhSW5wdXQubW91c2VEaXNhYmxlZDtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldHMgdGhlIGRpcmVjdGlvbiBvZiB0aGUgc2Nyb2xsXHJcblx0ICogQHJldHVybnMgLTEgaWYgdGhlIHVzZXIgc2Nyb2xsZWQgdXAsIDEgaWYgdGhleSBzY3JvbGxlZCBkb3duXHJcblx0ICovXHJcblx0c3RhdGljIGdldFNjcm9sbERpcmVjdGlvbigpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIElucHV0LnNjcm9sbERpcmVjdGlvbjtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldHMgdGhlIHBvc2l0aW9uIG9mIHRoZSBwbGF5ZXIncyBtb3VzZVxyXG5cdCAqIEByZXR1cm5zIFRoZSBtb3VzZSBwb3NpdGlvbiBzdG9yZWQgYXMgYSBWZWMyXHJcblx0ICovXHJcblx0c3RhdGljIGdldE1vdXNlUG9zaXRpb24oKTogVmVjMiB7XHJcblx0XHRyZXR1cm4gSW5wdXQubW91c2VQb3NpdGlvbi5zY2FsZWQoMSAvIHRoaXMudmlld3BvcnQuZ2V0Wm9vbUxldmVsKCkpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogR2V0cyB0aGUgcG9zaXRpb24gb2YgdGhlIHBsYXllcidzIG1vdXNlIGluIHRoZSBnYW1lIHdvcmxkLFxyXG5cdCAqIHRha2luZyBpbnRvIGNvbnNpZGVyYXRpb24gdGhlIHNjcm9sbGluZyBvZiB0aGUgdmlld3BvcnRcclxuXHQgKiBAcmV0dXJucyBUaGUgbW91c2UgcG9zaXRpb24gc3RvcmVkIGFzIGEgVmVjMlxyXG5cdCAqL1xyXG5cdHN0YXRpYyBnZXRHbG9iYWxNb3VzZVBvc2l0aW9uKCk6IFZlYzIge1xyXG5cdFx0cmV0dXJuIElucHV0Lm1vdXNlUG9zaXRpb24uY2xvbmUoKS5zY2FsZSgxIC8gdGhpcy52aWV3cG9ydC5nZXRab29tTGV2ZWwoKSkuYWRkKElucHV0LnZpZXdwb3J0LmdldE9yaWdpbigpKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldHMgdGhlIHBvc2l0aW9uIG9mIHRoZSBsYXN0IG1vdXNlIHByZXNzXHJcblx0ICogQHJldHVybnMgVGhlIG1vdXNlIHBvc2l0aW9uIHN0b3JlZCBhcyBhIFZlYzJcclxuXHQgKi9cclxuXHRzdGF0aWMgZ2V0TW91c2VQcmVzc1Bvc2l0aW9uKCk6IFZlYzIge1xyXG5cdFx0cmV0dXJuIElucHV0Lm1vdXNlUHJlc3NQb3NpdGlvbjtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldHMgdGhlIHBvc2l0aW9uIG9mIHRoZSBsYXN0IG1vdXNlIHByZXNzIGluIHRoZSBnYW1lIHdvcmxkLFxyXG5cdCAqIHRha2luZyBpbnRvIGNvbnNpZGVyYXRpb24gdGhlIHNjcm9sbGluZyBvZiB0aGUgdmlld3BvcnRcclxuXHQgKiBAcmV0dXJucyBUaGUgbW91c2UgcG9zaXRpb24gc3RvcmVkIGFzIGEgVmVjMlxyXG5cdCAqL1xyXG5cdHN0YXRpYyBnZXRHbG9iYWxNb3VzZVByZXNzUG9zaXRpb24oKTogVmVjMiB7XHJcblx0XHRyZXR1cm4gSW5wdXQubW91c2VQcmVzc1Bvc2l0aW9uLmNsb25lKCkuYWRkKElucHV0LnZpZXdwb3J0LmdldE9yaWdpbigpKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIERpc2FibGVzIGFsbCBrZXlwcmVzcyBhbmQgbW91c2UgY2xpY2sgaW5wdXRzXHJcblx0ICovXHJcblx0c3RhdGljIGRpc2FibGVJbnB1dCgpOiB2b2lkIHtcclxuXHRcdElucHV0LmtleXNEaXNhYmxlZCA9IHRydWU7XHJcblx0XHRJbnB1dC5tb3VzZURpc2FibGVkID0gdHJ1ZTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEVuYWJsZXMgYWxsIGtleXByZXNzIGFuZCBtb3VzZSBjbGljayBpbnB1dHNcclxuXHQgKi9cclxuXHRzdGF0aWMgZW5hYmxlSW5wdXQoKTogdm9pZCB7XHJcblx0XHRJbnB1dC5rZXlzRGlzYWJsZWQgPSBmYWxzZTtcclxuXHRcdElucHV0Lm1vdXNlRGlzYWJsZWQgPSBmYWxzZTtcclxuXHR9XHJcbn0iLCJpbXBvcnQgRXZlbnRRdWV1ZSBmcm9tIFwiLi4vRXZlbnRzL0V2ZW50UXVldWVcIjtcclxuaW1wb3J0IFZlYzIgZnJvbSBcIi4uL0RhdGFUeXBlcy9WZWMyXCI7XHJcbmltcG9ydCBHYW1lRXZlbnQgZnJvbSBcIi4uL0V2ZW50cy9HYW1lRXZlbnRcIjtcclxuaW1wb3J0IHsgR2FtZUV2ZW50VHlwZSB9IGZyb20gXCIuLi9FdmVudHMvR2FtZUV2ZW50VHlwZVwiO1xyXG5cclxuLyoqXHJcbiAqIEhhbmRsZXMgY29tbXVuaWNhdGlvbiB3aXRoIHRoZSB3ZWIgYnJvd3NlciB0byByZWNlaXZlIGFzeW5jaHJvbm91cyBldmVudHMgYW5kIHNlbmQgdGhlbSB0byB0aGUgQHJlZmVyZW5jZVtFdmVudFF1ZXVlXVxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW5wdXRIYW5kbGVyIHtcclxuXHRwcml2YXRlIGV2ZW50UXVldWU6IEV2ZW50UXVldWU7XHJcbiAgICAgXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgSW5wdXRIYW5kbGVyXHJcbiAgICAgKiBAcGFyYW0gY2FudmFzIFRoZSBnYW1lIGNhbnZhc1xyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KXtcclxuXHRcdHRoaXMuZXZlbnRRdWV1ZSA9IEV2ZW50UXVldWUuZ2V0SW5zdGFuY2UoKTtcclxuXHRcdFxyXG4gICAgICAgIGNhbnZhcy5vbm1vdXNlZG93biA9IChldmVudCkgPT4gdGhpcy5oYW5kbGVNb3VzZURvd24oZXZlbnQsIGNhbnZhcyk7XHJcbiAgICAgICAgY2FudmFzLm9ubW91c2V1cCA9IChldmVudCkgPT4gdGhpcy5oYW5kbGVNb3VzZVVwKGV2ZW50LCBjYW52YXMpO1xyXG4gICAgICAgIGNhbnZhcy5vbmNvbnRleHRtZW51ID0gdGhpcy5oYW5kbGVDb250ZXh0TWVudTtcclxuICAgICAgICBjYW52YXMub25tb3VzZW1vdmUgPSAoZXZlbnQpID0+IHRoaXMuaGFuZGxlTW91c2VNb3ZlKGV2ZW50LCBjYW52YXMpO1xyXG4gICAgICAgIGRvY3VtZW50Lm9ua2V5ZG93biA9IHRoaXMuaGFuZGxlS2V5RG93bjtcclxuICAgICAgICBkb2N1bWVudC5vbmtleXVwID0gdGhpcy5oYW5kbGVLZXlVcDtcclxuICAgICAgICBkb2N1bWVudC5vbmJsdXIgPSB0aGlzLmhhbmRsZUJsdXI7XHJcbiAgICAgICAgZG9jdW1lbnQub25jb250ZXh0bWVudSA9IHRoaXMuaGFuZGxlQmx1cjtcclxuICAgICAgICBkb2N1bWVudC5vbndoZWVsID0gdGhpcy5oYW5kbGVXaGVlbDtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGhhbmRsZU1vdXNlRG93biA9IChldmVudDogTW91c2VFdmVudCwgY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCk6IHZvaWQgPT4ge1xyXG5cdFx0bGV0IHBvcyA9IHRoaXMuZ2V0TW91c2VQb3NpdGlvbihldmVudCwgY2FudmFzKTtcclxuICAgICAgICBsZXQgYnV0dG9uID0gZXZlbnQuYnV0dG9uO1xyXG4gICAgICAgIGxldCBnYW1lRXZlbnQgPSBuZXcgR2FtZUV2ZW50KEdhbWVFdmVudFR5cGUuTU9VU0VfRE9XTiwge3Bvc2l0aW9uOiBwb3MsIGJ1dHRvbjogYnV0dG9ufSk7XHJcbiAgICAgICAgdGhpcy5ldmVudFF1ZXVlLmFkZEV2ZW50KGdhbWVFdmVudCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBoYW5kbGVNb3VzZVVwID0gKGV2ZW50OiBNb3VzZUV2ZW50LCBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KTogdm9pZCA9PiB7XHJcbiAgICAgICAgbGV0IHBvcyA9IHRoaXMuZ2V0TW91c2VQb3NpdGlvbihldmVudCwgY2FudmFzKTtcclxuICAgICAgICBsZXQgZ2FtZUV2ZW50ID0gbmV3IEdhbWVFdmVudChHYW1lRXZlbnRUeXBlLk1PVVNFX1VQLCB7cG9zaXRpb246IHBvc30pO1xyXG4gICAgICAgIHRoaXMuZXZlbnRRdWV1ZS5hZGRFdmVudChnYW1lRXZlbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgaGFuZGxlTW91c2VNb3ZlID0gKGV2ZW50OiBNb3VzZUV2ZW50LCBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KTogdm9pZCA9PiB7XHJcbiAgICAgICAgbGV0IHBvcyA9IHRoaXMuZ2V0TW91c2VQb3NpdGlvbihldmVudCwgY2FudmFzKTtcclxuICAgICAgICBsZXQgZ2FtZUV2ZW50ID0gbmV3IEdhbWVFdmVudChHYW1lRXZlbnRUeXBlLk1PVVNFX01PVkUsIHtwb3NpdGlvbjogcG9zfSk7XHJcbiAgICAgICAgdGhpcy5ldmVudFF1ZXVlLmFkZEV2ZW50KGdhbWVFdmVudCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBoYW5kbGVLZXlEb3duID0gKGV2ZW50OiBLZXlib2FyZEV2ZW50KTogdm9pZCA9PiB7XHJcbiAgICAgICAgbGV0IGtleSA9IHRoaXMuZ2V0S2V5KGV2ZW50KTtcclxuICAgICAgICBsZXQgZ2FtZUV2ZW50ID0gbmV3IEdhbWVFdmVudChHYW1lRXZlbnRUeXBlLktFWV9ET1dOLCB7a2V5OiBrZXl9KTtcclxuICAgICAgICB0aGlzLmV2ZW50UXVldWUuYWRkRXZlbnQoZ2FtZUV2ZW50KTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGhhbmRsZUtleVVwID0gKGV2ZW50OiBLZXlib2FyZEV2ZW50KTogdm9pZCA9PiB7XHJcbiAgICAgICAgbGV0IGtleSA9IHRoaXMuZ2V0S2V5KGV2ZW50KTtcclxuICAgICAgICBsZXQgZ2FtZUV2ZW50ID0gbmV3IEdhbWVFdmVudChHYW1lRXZlbnRUeXBlLktFWV9VUCwge2tleToga2V5fSk7XHJcbiAgICAgICAgdGhpcy5ldmVudFF1ZXVlLmFkZEV2ZW50KGdhbWVFdmVudCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBoYW5kbGVCbHVyID0gKGV2ZW50OiBFdmVudCk6IHZvaWQgPT4ge1xyXG4gICAgICAgIGxldCBnYW1lRXZlbnQgPSBuZXcgR2FtZUV2ZW50KEdhbWVFdmVudFR5cGUuQ0FOVkFTX0JMVVIsIHt9KTtcclxuICAgICAgICB0aGlzLmV2ZW50UXVldWUuYWRkRXZlbnQoZ2FtZUV2ZW50KTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGhhbmRsZUNvbnRleHRNZW51ID0gKGV2ZW50OiBFdmVudCk6IHZvaWQgPT4ge1xyXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBoYW5kbGVXaGVlbCA9IChldmVudDogV2hlZWxFdmVudCk6IHZvaWQgPT4ge1xyXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgbGV0IGdhbWVFdmVudDogR2FtZUV2ZW50O1xyXG4gICAgICAgIGlmKGV2ZW50LmRlbHRhWSA8IDApe1xyXG4gICAgICAgICAgICBnYW1lRXZlbnQgPSBuZXcgR2FtZUV2ZW50KEdhbWVFdmVudFR5cGUuV0hFRUxfVVAsIHt9KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBnYW1lRXZlbnQgPSBuZXcgR2FtZUV2ZW50KEdhbWVFdmVudFR5cGUuV0hFRUxfRE9XTiwge30pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmV2ZW50UXVldWUuYWRkRXZlbnQoZ2FtZUV2ZW50KTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGdldEtleShrZXlFdmVudDogS2V5Ym9hcmRFdmVudCl7XHJcbiAgICAgICAgcmV0dXJuIGtleUV2ZW50LmtleS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgZ2V0TW91c2VQb3NpdGlvbihtb3VzZUV2ZW50OiBNb3VzZUV2ZW50LCBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KTogVmVjMiB7XHJcbiAgICAgICAgbGV0IHJlY3QgPSBjYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICAgICAgbGV0IHggPSBtb3VzZUV2ZW50LmNsaWVudFggLSByZWN0LmxlZnQ7XHJcbiAgICAgICAgbGV0IHkgPSBtb3VzZUV2ZW50LmNsaWVudFkgLSByZWN0LnRvcDtcclxuICAgICAgICByZXR1cm4gbmV3IFZlYzIoeCwgeSk7XHJcbiAgICB9XHJcbn0iLCJpbXBvcnQge30gZnJvbSBcIi4uLy4uL2luZGV4XCI7ICAvLyBUaGlzIGltcG9ydCBhbGxvd3MgdXMgdG8gbW9kaWZ5IHRoZSBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQgdG8gYWRkIGV4dHJhIGZ1bmN0aW9uYWxpdHlcclxuLy8gQGlnbm9yZVBhZ2VcclxuXHJcbi8qKlxyXG4gKiBTZXRzIHVwIHRoZSBlbnZpcm9ubWVudCBvZiB0aGUgZ2FtZSBlbmdpbmVcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVudmlyb25tZW50SW5pdGlhbGl6ZXIge1xyXG4gICAgc3RhdGljIHNldHVwKCl7XHJcbiAgICAgICAgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELnByb3RvdHlwZS5yb3VuZGVkUmVjdCA9IGZ1bmN0aW9uKHg6IG51bWJlciwgeTogbnVtYmVyLCB3OiBudW1iZXIsIGg6IG51bWJlciwgcjogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgICAgICAgIC8vIENsYW1wIHRoZSByYWRpdXMgYmV0d2VlbiAwIGFuZCB0aGUgbWluIG9mIHRoZSB3aWR0aCBvciBoZWlnaHRcclxuICAgICAgICAgICAgaWYociA8IDApIHIgPSAwO1xyXG4gICAgICAgICAgICBpZihyID4gTWF0aC5taW4odywgaCkpIHIgPSBNYXRoLm1pbih3LCBoKTtcclxuICAgICAgICBcclxuICAgICAgICAgICAgLy8gRHJhdyB0aGUgcm91bmRlZCByZWN0XHJcbiAgICAgICAgICAgIHRoaXMuYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIFRvcFxyXG4gICAgICAgICAgICB0aGlzLm1vdmVUbyh4ICsgciwgeSk7XHJcbiAgICAgICAgICAgIHRoaXMubGluZVRvKHggKyB3IC0gciwgeSk7XHJcbiAgICAgICAgICAgIHRoaXMuYXJjVG8oeCArIHcsIHksIHggKyB3LCB5ICsgciwgcik7XHJcbiAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIFJpZ2h0XHJcbiAgICAgICAgICAgIHRoaXMubGluZVRvKHggKyB3LCB5ICsgaCAtIHIpO1xyXG4gICAgICAgICAgICB0aGlzLmFyY1RvKHggKyB3LCB5ICsgaCwgeCArIHcgLSByLCB5ICsgaCwgcik7XHJcbiAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIEJvdHRvbVxyXG4gICAgICAgICAgICB0aGlzLmxpbmVUbyh4ICsgciwgeSArIGgpO1xyXG4gICAgICAgICAgICB0aGlzLmFyY1RvKHgsIHkgKyBoLCB4LCB5ICsgaCAtIHIsIHIpO1xyXG4gICAgICAgIFxyXG4gICAgICAgICAgICAvLyBMZWZ0XHJcbiAgICAgICAgICAgIHRoaXMubGluZVRvKHgsIHkgKyByKTtcclxuICAgICAgICAgICAgdGhpcy5hcmNUbyh4LCB5LCB4ICsgciwgeSwgcilcclxuICAgICAgICBcclxuICAgICAgICAgICAgdGhpcy5jbG9zZVBhdGgoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELnByb3RvdHlwZS5zdHJva2VSb3VuZGVkUmVjdCA9IGZ1bmN0aW9uKHgsIHksIHcsIGgsIHIpe1xyXG4gICAgICAgICAgICB0aGlzLnJvdW5kZWRSZWN0KHgsIHksIHcsIGgsIHIpO1xyXG4gICAgICAgICAgICB0aGlzLnN0cm9rZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQucHJvdG90eXBlLmZpbGxSb3VuZGVkUmVjdCA9IGZ1bmN0aW9uKHgsIHksIHcsIGgsIHIpe1xyXG4gICAgICAgICAgICB0aGlzLnJvdW5kZWRSZWN0KHgsIHksIHcsIGgsIHIpO1xyXG4gICAgICAgICAgICB0aGlzLmZpbGwoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0iLCJpbXBvcnQgR2FtZUxvb3AgZnJvbSBcIi4vR2FtZUxvb3BcIjtcclxuaW1wb3J0IERlYnVnIGZyb20gXCIuLi9EZWJ1Zy9EZWJ1Z1wiO1xyXG5pbXBvcnQgU3RhdHMgZnJvbSBcIi4uL0RlYnVnL1N0YXRzXCI7XHJcblxyXG4vKipcclxuICogQSBnYW1lIGxvb3Agd2l0aCBhIGZpeGVkIHVwZGF0ZSB0aW1lIGFuZCBhIHZhcmlhYmxlIHJlbmRlciB0aW1lLlxyXG4gKiBFdmVyeSBmcmFtZSwgdGhlIGdhbWUgdXBkYXRlcyB1bnRpbCBhbGwgdGltZSBzaW5jZSB0aGUgbGFzdCBmcmFtZSBoYXMgYmVlbiBwcm9jZXNzZWQuXHJcbiAqIElmIHRvbyBtdWNoIHRpbWUgaGFzIHBhc3NlZCwgc3VjaCBhcyBpZiB0aGUgbGFzdCB1cGRhdGUgd2FzIHRvbyBzbG93LCBcclxuICogb3IgaWYgdGhlIGJyb3dzZXIgd2FzIHB1dCBpbnRvIHRoZSBiYWNrZ3JvdW5kLCB0aGUgbG9vcCB3aWxsIHBhbmljIGFuZCBkaXNjYXJkIHRpbWUuXHJcbiAqIEEgcmVuZGVyIGhhcHBlbnMgYXQgdGhlIGVuZCBvZiBldmVyeSBmcmFtZS4gVGhpcyBoYXBwZW5zIGFzIGZhc3QgYXMgcG9zc2libGUgdW5sZXNzIHNwZWNpZmllZC5cclxuICogQSBsb29wIG9mIHRoaXMgdHlwZSBhbGxvd3MgZm9yIGRldGVybWluaXN0aWMgYmVoYXZpb3IgLSBObyBtYXR0ZXIgd2hhdCB0aGUgZnJhbWUgcmF0ZSBpcywgdGhlIHVwZGF0ZSBzaG91bGQgYmVoYXZlIHRoZSBzYW1lLCBcclxuICogYXMgaXQgaXMgb2NjdXJpbmcgaW4gYSBmaXhlZCBpbnRlcnZhbC5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZpeGVkVXBkYXRlR2FtZUxvb3AgZXh0ZW5kcyBHYW1lTG9vcCB7XHJcblxyXG5cdC8qKiBUaGUgbWF4IGFsbG93ZWQgdXBkYXRlIGZwcy4qL1xyXG4gICAgcHJpdmF0ZSBtYXhVcGRhdGVGUFM6IG51bWJlcjtcclxuICAgIFxyXG4gICAgLyoqIFRoZSB0aW1lc3RlcCBmb3IgZWFjaCB1cGRhdGUuIFRoaXMgaXMgdGhlIGRlbHRhVCBwYXNzZWQgdG8gdXBkYXRlIGNhbGxzLiAqL1xyXG5cdHByaXZhdGUgdXBkYXRlVGltZXN0ZXA6IG51bWJlcjtcclxuXHJcbiAgICAvKiogVGhlIGFtb3VudCBvZiB0aW1lIHdlIGFyZSB5ZXQgdG8gc2ltdWxhdGUuICovXHJcbiAgICBwcml2YXRlIGZyYW1lRGVsdGE6IG51bWJlcjtcclxuXHJcbiAgICAvKiogVGhlIHRpbWUgd2hlbiB0aGUgbGFzdCBmcmFtZSB3YXMgZHJhd24uICovXHJcbiAgICBwcml2YXRlIGxhc3RGcmFtZVRpbWU6IG51bWJlcjtcclxuICAgIFxyXG4gICAgLyoqIFRoZSBtaW5pbXVtIHRpbWUgd2Ugd2FudCB0byB3YWl0IGJldHdlZW4gZ2FtZSBmcmFtZXMuICovXHJcbiAgICBwcml2YXRlIG1pbkZyYW1lRGVsYXk6IG51bWJlcjtcclxuXHJcblx0LyoqIFRoZSBjdXJyZW50IGZyYW1lIG9mIHRoZSBnYW1lLiAqL1xyXG5cdHByaXZhdGUgZnJhbWU6IG51bWJlcjtcclxuXHJcblx0LyoqIFRoZSBhY3R1YWwgZnBzIG9mIHRoZSBnYW1lLiAqL1xyXG4gICAgcHJpdmF0ZSBmcHM6IG51bWJlcjtcclxuICAgIFxyXG4gICAgLyoqIFRoZSB0aW1lIGJldHdlZW4gZnBzIG1lYXN1cmVtZW50IHVwZGF0ZXMuICovXHJcbiAgICBwcml2YXRlIGZwc1VwZGF0ZUludGVydmFsOiBudW1iZXI7XHJcblxyXG4gICAgLyoqIFRoZSB0aW1lIG9mIHRoZSBsYXN0IGZwcyB1cGRhdGUuICovXHJcbiAgICBwcml2YXRlIGxhc3RGcHNVcGRhdGU6IG51bWJlcjtcclxuXHJcbiAgICAvKiogVGhlIG51bWJlciBvZiBmcmFtZXMgc2luY2UgdGhlIGxhc3QgZnBzIHVwZGF0ZSB3YXMgZG9uZS4gKi9cclxuICAgIHByaXZhdGUgZnJhbWVzU2luY2VMYXN0RnBzVXBkYXRlOiBudW1iZXI7XHJcblxyXG4gICAgLyoqIFRoZSBzdGF0dXMgb2Ygd2hldGhlciBvciBub3QgdGhlIGdhbWUgbG9vcCBoYXMgc3RhcnRlZC4gKi9cclxuICAgIHByaXZhdGUgc3RhcnRlZDogYm9vbGVhbjtcclxuXHJcbiAgICAvKiogVGhlIHN0YXR1cyBvZiB3aGV0aGVyIG9yIG5vdCB0aGUgZ2FtZSBsb29wIGlzIHBhdXNlZCAqL1xyXG4gICAgcHJpdmF0ZSBwYXVzZWQ6IGJvb2xlYW47XHJcbiAgICBcclxuICAgIC8qKiBUaGUgc3RhdHVzIG9mIHdoZXRoZXIgb3Igbm90IHRoZSBnYW1lIGxvb3AgaXMgY3VycmVudGx5IHJ1bm5pbmcuICovXHJcbiAgICBwcml2YXRlIHJ1bm5pbmc6IGJvb2xlYW47XHJcblxyXG4gICAgLyoqIFRoZSBudW1iZXIgb2YgdXBkYXRlIHN0ZXBzIHRoaXMgaXRlcmF0aW9uIG9mIHRoZSBnYW1lIGxvb3AuICovXHJcbiAgICBwcml2YXRlIG51bVVwZGF0ZVN0ZXBzOiBudW1iZXI7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCkge1xyXG5cdFx0c3VwZXIoKTtcclxuICAgICAgICB0aGlzLm1heFVwZGF0ZUZQUyA9IDYwO1xyXG4gICAgICAgIHRoaXMudXBkYXRlVGltZXN0ZXAgPSBNYXRoLmZsb29yKDEwMDAvdGhpcy5tYXhVcGRhdGVGUFMpO1xyXG4gICAgICAgIHRoaXMuZnJhbWVEZWx0YSA9IDA7XHJcbiAgICAgICAgdGhpcy5sYXN0RnJhbWVUaW1lID0gMDtcclxuICAgICAgICB0aGlzLm1pbkZyYW1lRGVsYXkgPSAwO1xyXG4gICAgICAgIHRoaXMuZnJhbWUgPSAwO1xyXG4gICAgICAgIHRoaXMuZnBzID0gdGhpcy5tYXhVcGRhdGVGUFM7ICAgLy8gSW5pdGlhbGl6ZSB0aGUgZnBzIHRvIHRoZSBtYXggYWxsb3dlZCBmcHNcclxuICAgICAgICB0aGlzLmZwc1VwZGF0ZUludGVydmFsID0gMTAwMDtcclxuICAgICAgICB0aGlzLmxhc3RGcHNVcGRhdGUgPSAwO1xyXG4gICAgICAgIHRoaXMuZnJhbWVzU2luY2VMYXN0RnBzVXBkYXRlID0gMDtcclxuICAgICAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnBhdXNlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMubnVtVXBkYXRlU3RlcHMgPSAwO1xyXG5cdH1cclxuXHJcblx0Z2V0RlBTKCk6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gMDtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG4gICAgICogVXBkYXRlcyB0aGUgZnJhbWUgY291bnQgYW5kIHN1bSBvZiB0aW1lIGZvciB0aGUgZnJhbWVyYXRlIG9mIHRoZSBnYW1lXHJcbiAgICAgKiBAcGFyYW0gdGltZXN0ZXAgVGhlIGN1cnJlbnQgdGltZSBpbiBtc1xyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgdXBkYXRlRlBTKHRpbWVzdGFtcDogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5mcHMgPSAwLjkgKiB0aGlzLmZyYW1lc1NpbmNlTGFzdEZwc1VwZGF0ZSAqIDEwMDAgLyAodGltZXN0YW1wIC0gdGhpcy5sYXN0RnBzVXBkYXRlKSArKDEgLSAwLjkpICogdGhpcy5mcHM7XHJcbiAgICAgICAgdGhpcy5sYXN0RnBzVXBkYXRlID0gdGltZXN0YW1wO1xyXG4gICAgICAgIHRoaXMuZnJhbWVzU2luY2VMYXN0RnBzVXBkYXRlID0gMDtcclxuXHJcbiAgICAgICAgRGVidWcubG9nKFwiZnBzXCIsIFwiRlBTOiBcIiArIHRoaXMuZnBzLnRvRml4ZWQoMSkpO1xyXG4gICAgICAgIFN0YXRzLnVwZGF0ZUZQUyh0aGlzLmZwcyk7XHJcbiAgICB9XHJcblxyXG5cdCAgICAvKipcclxuICAgICAqIENoYW5nZXMgdGhlIG1heGltdW0gYWxsb3dlZCBwaHlzaWNzIGZyYW1lcmF0ZSBvZiB0aGUgZ2FtZVxyXG4gICAgICogQHBhcmFtIGluaXRNYXggVGhlIG1heCBmcmFtZXJhdGVcclxuICAgICAqL1xyXG4gICAgc2V0TWF4VXBkYXRlRlBTKGluaXRNYXg6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICAgIHRoaXMubWF4VXBkYXRlRlBTID0gaW5pdE1heDtcclxuICAgICAgICB0aGlzLnVwZGF0ZVRpbWVzdGVwID0gTWF0aC5mbG9vcigxMDAwL3RoaXMubWF4VXBkYXRlRlBTKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIG1heGltdW0gcmVuZGVyaW5nIGZyYW1lcmF0ZVxyXG4gICAgICogQHBhcmFtIG1heEZQUyBUaGUgbWF4IGZyYW1lcmF0ZVxyXG4gICAgICovXHJcbiAgICBzZXRNYXhGUFMobWF4RlBTOiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLm1pbkZyYW1lRGVsYXkgPSAxMDAwL21heEZQUztcclxuXHR9XHJcblx0XHJcblx0LyoqXHJcblx0ICogVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgd2hlbiB0aGUgZ2FtZSBsb29wIHBhbmljcywgaS5lLiBpdCB0cmllcyB0byBwcm9jZXNzIHRvbyBtdWNoIHRpbWUgaW4gYW4gZW50aXJlIGZyYW1lLlxyXG5cdCAqIFRoaXMgd2lsbCByZXNldCB0aGUgYW1vdW50IG9mIHRpbWUgYmFjayB0byB6ZXJvLlxyXG5cdCAqIEByZXR1cm5zIFRoZSBhbW91bnQgb2YgdGltZSB3ZSBhcmUgZGlzY2FyZGluZyBmcm9tIHByb2Nlc3NpbmcuXHJcblx0ICovXHJcblx0cmVzZXRGcmFtZURlbHRhKCkgOiBudW1iZXIge1xyXG4gICAgICAgIGxldCBvbGRGcmFtZURlbHRhID0gdGhpcy5mcmFtZURlbHRhO1xyXG4gICAgICAgIHRoaXMuZnJhbWVEZWx0YSA9IDA7XHJcbiAgICAgICAgcmV0dXJuIG9sZEZyYW1lRGVsdGE7XHJcbiAgICB9XHJcblxyXG5cdC8qKlxyXG4gICAgICogU3RhcnRzIHVwIHRoZSBnYW1lIGxvb3AgYW5kIGNhbGxzIHRoZSBmaXJzdCByZXF1ZXN0QW5pbWF0aW9uRnJhbWVcclxuICAgICAqL1xyXG5cdHN0YXJ0KCk6IHZvaWQge1xyXG4gICAgICAgIGlmKCF0aGlzLnN0YXJ0ZWQpe1xyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0ZWQgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgodGltZXN0YW1wKSA9PiB0aGlzLmRvRmlyc3RGcmFtZSh0aW1lc3RhbXApKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcGF1c2UoKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5wYXVzZWQgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIHJlc3VtZSgpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLnBhdXNlZCA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuXHQvKipcclxuICAgICAqIFRoZSBmaXJzdCBnYW1lIGZyYW1lIC0gaW5pdGlhbGl6ZXMgdGhlIGZpcnN0IGZyYW1lIHRpbWUgYW5kIGJlZ2lucyB0aGUgcmVuZGVyXHJcbiAgICAgKiBAcGFyYW0gdGltZXN0YW1wIFRoZSBjdXJyZW50IHRpbWUgaW4gbXNcclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGRvRmlyc3RGcmFtZSh0aW1lc3RhbXA6IG51bWJlcik6IHZvaWQgIHtcclxuICAgICAgICB0aGlzLnJ1bm5pbmcgPSB0cnVlO1xyXG5cclxuICAgICAgICB0aGlzLl9kb1JlbmRlcigpO1xyXG5cclxuICAgICAgICB0aGlzLmxhc3RGcmFtZVRpbWUgPSB0aW1lc3RhbXA7XHJcbiAgICAgICAgdGhpcy5sYXN0RnBzVXBkYXRlID0gdGltZXN0YW1wO1xyXG4gICAgICAgIHRoaXMuZnJhbWVzU2luY2VMYXN0RnBzVXBkYXRlID0gMDtcclxuXHJcbiAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgodCkgPT4gdGhpcy5kb0ZyYW1lKHQpKTtcclxuICAgIH1cclxuXHJcblx0LyoqXHJcblx0ICogSGFuZGxlcyBhbnkgcHJvY2Vzc2luZyB0aGF0IG5lZWRzIHRvIGJlIGRvbmUgYXQgdGhlIHN0YXJ0IG9mIHRoZSBmcmFtZVxyXG5cdCAqIEBwYXJhbSB0aW1lc3RhbXAgVGhlIHRpbWUgb2YgdGhlIGZyYW1lIGluIG1zXHJcblx0ICovXHJcblx0cHJvdGVjdGVkIHN0YXJ0RnJhbWUodGltZXN0YW1wOiBudW1iZXIpOiB2b2lkIHtcclxuXHRcdC8vIFVwZGF0ZSB0aGUgYW1vdW50IG9mIHRpbWUgd2UgbmVlZCBvdXIgdXBkYXRlIHRvIHByb2Nlc3NcclxuXHRcdHRoaXMuZnJhbWVEZWx0YSArPSB0aW1lc3RhbXAgLSB0aGlzLmxhc3RGcmFtZVRpbWU7XHJcblxyXG5cdFx0Ly8gU2V0IHRoZSBuZXcgdGltZSBvZiB0aGUgbGFzdCBmcmFtZVxyXG4gICAgICAgIHRoaXMubGFzdEZyYW1lVGltZSA9IHRpbWVzdGFtcDtcclxuXHJcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBlc3RpbWF0ZSBvZiB0aGUgZnJhbWVyYXRlXHJcbiAgICAgICAgaWYodGltZXN0YW1wID4gdGhpcy5sYXN0RnBzVXBkYXRlICsgdGhpcy5mcHNVcGRhdGVJbnRlcnZhbCl7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRlBTKHRpbWVzdGFtcCk7XHJcbiAgICAgICAgfVxyXG5cclxuXHRcdC8vIEluY3JlbWVudCB0aGUgbnVtYmVyIG9mIGZyYW1lc1xyXG4gICAgICAgIHRoaXMuZnJhbWUrKztcclxuICAgICAgICB0aGlzLmZyYW1lc1NpbmNlTGFzdEZwc1VwZGF0ZSsrO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcbiAgICAgKiBUaGUgbWFpbiBsb29wIG9mIHRoZSBnYW1lLiBVcGRhdGVzIHVudGlsIHRoZSBjdXJyZW50IHRpbWUgaXMgcmVhY2hlZC4gUmVuZGVycyBvbmNlXHJcbiAgICAgKiBAcGFyYW0gdGltZXN0YW1wIFRoZSBjdXJyZW50IHRpbWUgaW4gbXNcclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGRvRnJhbWUgPSAodGltZXN0YW1wOiBudW1iZXIpOiB2b2lkID0+IHtcclxuICAgICAgICAvLyBJZiBhIHBhdXNlIHdhcyBleGVjdXRlZCwgc3RvcCBkb2luZyB0aGUgbG9vcC5cclxuICAgICAgICBpZih0aGlzLnBhdXNlZCl7IFxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBSZXF1ZXN0IGFuaW1hdGlvbiBmcmFtZSB0byBwcmVwYXJlIGZvciBhbm90aGVyIHVwZGF0ZSBvciByZW5kZXJcclxuICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCh0KSA9PiB0aGlzLmRvRnJhbWUodCkpO1xyXG5cclxuICAgICAgICAvLyBJZiB3ZSBhcmUgdHJ5aW5nIHRvIHJlbmRlciB0b28gc29vbiwgZG8gbm90aGluZy5cclxuICAgICAgICBpZih0aW1lc3RhbXAgPCB0aGlzLmxhc3RGcmFtZVRpbWUgKyB0aGlzLm1pbkZyYW1lRGVsYXkpe1xyXG4gICAgICAgICAgICByZXR1cm47XHJcblx0XHR9XHJcblx0XHRcclxuXHRcdC8vIEEgZnJhbWUgaXMgYWN0dWFsbHkgaGFwcGVuaW5nXHJcblx0XHR0aGlzLnN0YXJ0RnJhbWUodGltZXN0YW1wKTtcclxuXHJcblx0XHQvLyBVcGRhdGUgd2hpbGUgdGhlcmUgaXMgc3RpbGwgdGltZSB0byBtYWtlIHVwLiBJZiB3ZSBkbyB0b28gbWFueSB1cGRhdGUgc3RlcHMsIHBhbmljIGFuZCBleGl0IHRoZSBsb29wLlxyXG5cdFx0dGhpcy5udW1VcGRhdGVTdGVwcyA9IDA7XHJcblx0XHRsZXQgcGFuaWMgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgd2hpbGUodGhpcy5mcmFtZURlbHRhID49IHRoaXMudXBkYXRlVGltZXN0ZXApe1xyXG5cdFx0XHQvLyBEbyBhbiB1cGRhdGVcclxuXHRcdFx0dGhpcy5fZG9VcGRhdGUodGhpcy51cGRhdGVUaW1lc3RlcC8xMDAwKTtcclxuXHRcdFx0XHJcblx0XHRcdC8vIFJlbW92ZSB0aGUgdXBkYXRlIHN0ZXAgdGltZSBmcm9tIHRoZSB0aW1lIHdlIGhhdmUgdG8gcHJvY2Vzc1xyXG4gICAgICAgICAgICB0aGlzLmZyYW1lRGVsdGEgLT0gdGhpcy51cGRhdGVUaW1lc3RlcDtcclxuXHJcblx0XHRcdC8vIEluY3JlbWVudCBzdGVwcyBhbmQgY2hlY2sgaWYgd2UndmUgZG9uZSB0b28gbWFueVxyXG4gICAgICAgICAgICB0aGlzLm51bVVwZGF0ZVN0ZXBzKys7XHJcbiAgICAgICAgICAgIGlmKHRoaXMubnVtVXBkYXRlU3RlcHMgPiAxMDApe1xyXG4gICAgICAgICAgICAgICAgcGFuaWMgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFVwZGF0ZXMgYXJlIGRvbmUsIHJlbmRlclxyXG4gICAgICAgIHRoaXMuX2RvUmVuZGVyKCk7XHJcblxyXG4gICAgICAgIC8vIFdyYXAgdXAgdGhlIGZyYW1lXHJcbiAgICAgICAgdGhpcy5maW5pc2hGcmFtZShwYW5pYyk7XHJcbiAgICB9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFdyYXBzIHVwIHRoZSBmcmFtZSBhbmQgaGFuZGxlcyB0aGUgcGFuaWMgc3RhdGUgaWYgdGhlcmUgaXMgb25lXHJcblx0ICogQHBhcmFtIHBhbmljIFdoZXRoZXIgb3Igbm90IHRoZSBsb29wIHBhbmlja2VkXHJcblx0ICovXHJcblx0cHJvdGVjdGVkIGZpbmlzaEZyYW1lKHBhbmljOiBib29sZWFuKTogdm9pZCB7XHJcblx0XHRpZihwYW5pYykge1xyXG4gICAgICAgICAgICB2YXIgZGlzY2FyZGVkVGltZSA9IE1hdGgucm91bmQodGhpcy5yZXNldEZyYW1lRGVsdGEoKSk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignTWFpbiBsb29wIHBhbmlja2VkLCBwcm9iYWJseSBiZWNhdXNlIHRoZSBicm93c2VyIHRhYiB3YXMgcHV0IGluIHRoZSBiYWNrZ3JvdW5kLiBEaXNjYXJkaW5nICcgKyBkaXNjYXJkZWRUaW1lICsgJ21zJyk7XHJcbiAgICAgICAgfVxyXG5cdH1cclxuXHJcbn0iLCJpbXBvcnQgRXZlbnRRdWV1ZSBmcm9tIFwiLi4vRXZlbnRzL0V2ZW50UXVldWVcIjtcclxuaW1wb3J0IElucHV0IGZyb20gXCIuLi9JbnB1dC9JbnB1dFwiO1xyXG5pbXBvcnQgSW5wdXRIYW5kbGVyIGZyb20gXCIuLi9JbnB1dC9JbnB1dEhhbmRsZXJcIjtcclxuaW1wb3J0IFJlY29yZGVyIGZyb20gXCIuLi9QbGF5YmFjay9SZWNvcmRlclwiO1xyXG5pbXBvcnQgRGVidWcgZnJvbSBcIi4uL0RlYnVnL0RlYnVnXCI7XHJcbmltcG9ydCBSZXNvdXJjZU1hbmFnZXIgZnJvbSBcIi4uL1Jlc291cmNlTWFuYWdlci9SZXNvdXJjZU1hbmFnZXJcIjtcclxuaW1wb3J0IFZpZXdwb3J0IGZyb20gXCIuLi9TY2VuZUdyYXBoL1ZpZXdwb3J0XCI7XHJcbmltcG9ydCBTY2VuZU1hbmFnZXIgZnJvbSBcIi4uL1NjZW5lL1NjZW5lTWFuYWdlclwiO1xyXG5pbXBvcnQgQXVkaW9NYW5hZ2VyIGZyb20gXCIuLi9Tb3VuZC9BdWRpb01hbmFnZXJcIjtcclxuaW1wb3J0IFN0YXRzIGZyb20gXCIuLi9EZWJ1Zy9TdGF0c1wiO1xyXG5pbXBvcnQgUmVuZGVyaW5nTWFuYWdlciBmcm9tIFwiLi4vUmVuZGVyaW5nL1JlbmRlcmluZ01hbmFnZXJcIjtcclxuaW1wb3J0IENhbnZhc1JlbmRlcmVyIGZyb20gXCIuLi9SZW5kZXJpbmcvQ2FudmFzUmVuZGVyZXJcIjtcclxuaW1wb3J0IENvbG9yIGZyb20gXCIuLi9VdGlscy9Db2xvclwiO1xyXG5pbXBvcnQgR2FtZU9wdGlvbnMgZnJvbSBcIi4vR2FtZU9wdGlvbnNcIjtcclxuaW1wb3J0IEdhbWVMb29wIGZyb20gXCIuL0dhbWVMb29wXCI7XHJcbmltcG9ydCBGaXhlZFVwZGF0ZUdhbWVMb29wIGZyb20gXCIuL0ZpeGVkVXBkYXRlR2FtZUxvb3BcIjtcclxuaW1wb3J0IEVudmlyb25tZW50SW5pdGlhbGl6ZXIgZnJvbSBcIi4vRW52aXJvbm1lbnRJbml0aWFsaXplclwiO1xyXG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vRGF0YVR5cGVzL1ZlYzJcIjtcclxuaW1wb3J0IFJlZ2lzdHJ5TWFuYWdlciBmcm9tIFwiLi4vUmVnaXN0cnkvUmVnaXN0cnlNYW5hZ2VyXCI7XHJcbmltcG9ydCBXZWJHTFJlbmRlcmVyIGZyb20gXCIuLi9SZW5kZXJpbmcvV2ViR0xSZW5kZXJlclwiO1xyXG5pbXBvcnQgU2NlbmUgZnJvbSBcIi4uL1NjZW5lL1NjZW5lXCI7XHJcblxyXG4vKipcclxuICogVGhlIG1haW4gbG9vcCBvZiB0aGUgZ2FtZSBlbmdpbmUuXHJcbiAqIEhhbmRsZXMgdGhlIHVwZGF0ZSBvcmRlciwgYW5kIGluaXRpYWxpemVzIGFsbCBzdWJzeXN0ZW1zLlxyXG4gKiBUaGUgR2FtZSBtYW5hZ2VzIHRoZSB1cGRhdGUgY3ljbGUsIGFuZCByZXF1ZXN0cyBhbmltYXRpb24gZnJhbWVzIHRvIHJlbmRlciB0byB0aGUgYnJvd3Nlci5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdhbWUge1xyXG4gICAgZ2FtZU9wdGlvbnM6IEdhbWVPcHRpb25zO1xyXG4gICAgcHJpdmF0ZSBzaG93RGVidWc6IGJvb2xlYW47XHJcbiAgICBwcml2YXRlIHNob3dTdGF0czogYm9vbGVhbjtcclxuXHJcbiAgICAvLyBUaGUgZ2FtZSBsb29wXHJcbiAgICBwcml2YXRlIGxvb3A6IEdhbWVMb29wO1xyXG5cclxuICAgIC8vIEdhbWUgY2FudmFzIGFuZCBpdHMgd2lkdGggYW5kIGhlaWdodFxyXG4gICAgcmVhZG9ubHkgR0FNRV9DQU5WQVM6IEhUTUxDYW52YXNFbGVtZW50O1xyXG4gICAgcmVhZG9ubHkgREVCVUdfQ0FOVkFTOiBIVE1MQ2FudmFzRWxlbWVudDtcclxuXHRyZWFkb25seSBXSURUSDogbnVtYmVyO1xyXG4gICAgcmVhZG9ubHkgSEVJR0hUOiBudW1iZXI7XHJcbiAgICBwcml2YXRlIHZpZXdwb3J0OiBWaWV3cG9ydDtcclxuICAgIHByaXZhdGUgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQgfCBXZWJHTFJlbmRlcmluZ0NvbnRleHQ7XHJcbiAgICBwcml2YXRlIGNsZWFyQ29sb3I6IENvbG9yO1xyXG4gICAgXHJcbiAgICAvLyBBbGwgb2YgdGhlIG5lY2Vzc2FyeSBzdWJzeXN0ZW1zIHRoYXQgbmVlZCB0byBydW4gaGVyZVxyXG5cdHByaXZhdGUgZXZlbnRRdWV1ZTogRXZlbnRRdWV1ZTtcclxuXHRwcml2YXRlIGlucHV0SGFuZGxlcjogSW5wdXRIYW5kbGVyO1xyXG5cdHByaXZhdGUgcmVjb3JkZXI6IFJlY29yZGVyO1xyXG4gICAgcHJpdmF0ZSByZXNvdXJjZU1hbmFnZXI6IFJlc291cmNlTWFuYWdlcjtcclxuICAgIHByaXZhdGUgc2NlbmVNYW5hZ2VyOiBTY2VuZU1hbmFnZXI7XHJcbiAgICBwcml2YXRlIGF1ZGlvTWFuYWdlcjogQXVkaW9NYW5hZ2VyO1xyXG4gICAgcHJpdmF0ZSByZW5kZXJpbmdNYW5hZ2VyOiBSZW5kZXJpbmdNYW5hZ2VyO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBHYW1lXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgb3B0aW9ucyBmb3IgR2FtZSBpbml0aWFsaXphdGlvblxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zPzogUmVjb3JkPHN0cmluZywgYW55Pil7XHJcbiAgICAgICAgLy8gQmVmb3JlIGFueXRoaW5nIGVsc2UsIGJ1aWxkIHRoZSBlbnZpcm9ubWVudFxyXG4gICAgICAgIEVudmlyb25tZW50SW5pdGlhbGl6ZXIuc2V0dXAoKTtcclxuXHJcbiAgICAgICAgLy8gVHlwZWNhc3QgdGhlIGNvbmZpZyBvYmplY3QgdG8gYSBHYW1lQ29uZmlnIG9iamVjdFxyXG4gICAgICAgIHRoaXMuZ2FtZU9wdGlvbnMgPSBHYW1lT3B0aW9ucy5wYXJzZShvcHRpb25zKTtcclxuXHJcbiAgICAgICAgdGhpcy5zaG93RGVidWcgPSB0aGlzLmdhbWVPcHRpb25zLnNob3dEZWJ1ZztcclxuICAgICAgICB0aGlzLnNob3dTdGF0cyA9IHRoaXMuZ2FtZU9wdGlvbnMuc2hvd1N0YXRzO1xyXG5cclxuICAgICAgICAvLyBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgYSBnYW1lIGxvb3BcclxuICAgICAgICB0aGlzLmxvb3AgPSBuZXcgRml4ZWRVcGRhdGVHYW1lTG9vcCgpO1xyXG5cclxuICAgICAgICAvLyBHZXQgdGhlIGdhbWUgY2FudmFzIGFuZCBnaXZlIGl0IGEgYmFja2dyb3VuZCBjb2xvclxyXG4gICAgICAgIHRoaXMuR0FNRV9DQU5WQVMgPSA8SFRNTENhbnZhc0VsZW1lbnQ+ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJnYW1lLWNhbnZhc1wiKTtcclxuICAgICAgICB0aGlzLkRFQlVHX0NBTlZBUyA9IDxIVE1MQ2FudmFzRWxlbWVudD5kb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImRlYnVnLWNhbnZhc1wiKTtcclxuICAgIFxyXG4gICAgICAgIC8vIEdpdmUgdGhlIGNhbnZhcyBhIHNpemUgYW5kIGdldCB0aGUgcmVuZGVyaW5nIGNvbnRleHRcclxuICAgICAgICB0aGlzLldJRFRIID0gdGhpcy5nYW1lT3B0aW9ucy5jYW52YXNTaXplLng7XHJcbiAgICAgICAgdGhpcy5IRUlHSFQgPSB0aGlzLmdhbWVPcHRpb25zLmNhbnZhc1NpemUueTtcclxuXHJcbiAgICAgICAgLy8gVGhpcyBzdGVwIE1VU1QgaGFwcGVuIGJlZm9yZSB0aGUgcmVzb3VyY2UgbWFuYWdlciBkb2VzIGFueXRoaW5nXHJcbiAgICAgICAgaWYodGhpcy5nYW1lT3B0aW9ucy51c2VXZWJHTCl7XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyaW5nTWFuYWdlciA9IG5ldyBXZWJHTFJlbmRlcmVyKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJpbmdNYW5hZ2VyID0gbmV3IENhbnZhc1JlbmRlcmVyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZUdhbWVXaW5kb3coKTtcclxuICAgICAgICB0aGlzLmN0eCA9IHRoaXMucmVuZGVyaW5nTWFuYWdlci5pbml0aWFsaXplQ2FudmFzKHRoaXMuR0FNRV9DQU5WQVMsIHRoaXMuV0lEVEgsIHRoaXMuSEVJR0hUKTtcclxuICAgICAgICB0aGlzLmNsZWFyQ29sb3IgPSBuZXcgQ29sb3IodGhpcy5nYW1lT3B0aW9ucy5jbGVhckNvbG9yLnIsIHRoaXMuZ2FtZU9wdGlvbnMuY2xlYXJDb2xvci5nLCB0aGlzLmdhbWVPcHRpb25zLmNsZWFyQ29sb3IuYik7XHJcblxyXG4gICAgICAgIC8vIEluaXRpYWxpemUgZGVidWdnaW5nIGFuZCBzdGF0c1xyXG4gICAgICAgIERlYnVnLmluaXRpYWxpemVEZWJ1Z0NhbnZhcyh0aGlzLkRFQlVHX0NBTlZBUywgdGhpcy5XSURUSCwgdGhpcy5IRUlHSFQpO1xyXG4gICAgICAgIFN0YXRzLmluaXRTdGF0cygpO1xyXG5cclxuICAgICAgICBpZih0aGlzLmdhbWVPcHRpb25zLnNob3dTdGF0cykge1xyXG4gICAgICAgICAgICAvLyBGaW5kIHRoZSBzdGF0cyBvdXRwdXQgYW5kIG1ha2UgaXQgbm8gbG9uZ2VyIGhpZGRlblxyXG4gICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInN0YXRzXCIpLmhpZGRlbiA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gU2l6ZSB0aGUgdmlld3BvcnQgdG8gdGhlIGdhbWUgY2FudmFzXHJcbiAgICAgICAgY29uc3QgY2FudmFzU2l6ZSA9IG5ldyBWZWMyKHRoaXMuV0lEVEgsIHRoaXMuSEVJR0hUKTtcclxuICAgICAgICB0aGlzLnZpZXdwb3J0ID0gbmV3IFZpZXdwb3J0KGNhbnZhc1NpemUsIHRoaXMuZ2FtZU9wdGlvbnMuem9vbUxldmVsKTtcclxuXHJcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBhbGwgbmVjZXNzYXJ5IGdhbWUgc3Vic3lzdGVtc1xyXG4gICAgICAgIHRoaXMuZXZlbnRRdWV1ZSA9IEV2ZW50UXVldWUuZ2V0SW5zdGFuY2UoKTtcclxuICAgICAgICB0aGlzLmlucHV0SGFuZGxlciA9IG5ldyBJbnB1dEhhbmRsZXIodGhpcy5HQU1FX0NBTlZBUyk7XHJcbiAgICAgICAgSW5wdXQuaW5pdGlhbGl6ZSh0aGlzLnZpZXdwb3J0LCB0aGlzLmdhbWVPcHRpb25zLmlucHV0cyk7XHJcbiAgICAgICAgdGhpcy5yZWNvcmRlciA9IG5ldyBSZWNvcmRlcigpO1xyXG4gICAgICAgIHRoaXMucmVzb3VyY2VNYW5hZ2VyID0gUmVzb3VyY2VNYW5hZ2VyLmdldEluc3RhbmNlKCk7XHJcbiAgICAgICAgdGhpcy5zY2VuZU1hbmFnZXIgPSBuZXcgU2NlbmVNYW5hZ2VyKHRoaXMudmlld3BvcnQsIHRoaXMucmVuZGVyaW5nTWFuYWdlcik7XHJcbiAgICAgICAgdGhpcy5hdWRpb01hbmFnZXIgPSBBdWRpb01hbmFnZXIuZ2V0SW5zdGFuY2UoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCB1cCB0aGUgZ2FtZSB3aW5kb3cgdGhhdCBob2xkcyB0aGUgY2FudmFzZXNcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBpbml0aWFsaXplR2FtZVdpbmRvdygpOiB2b2lkIHtcclxuICAgICAgICBjb25zdCBnYW1lV2luZG93ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJnYW1lLXdpbmRvd1wiKTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBTZXQgdGhlIGhlaWdodCBvZiB0aGUgZ2FtZSB3aW5kb3dcclxuICAgICAgICBnYW1lV2luZG93LnN0eWxlLndpZHRoID0gdGhpcy5XSURUSCArIFwicHhcIjtcclxuICAgICAgICBnYW1lV2luZG93LnN0eWxlLmhlaWdodCA9IHRoaXMuSEVJR0hUICsgXCJweFwiO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0cmVpdmVzIHRoZSBTY2VuZU1hbmFnZXIgZnJvbSB0aGUgR2FtZVxyXG4gICAgICogQHJldHVybnMgVGhlIFNjZW5lTWFuYWdlclxyXG4gICAgICovXHJcbiAgICBnZXRTY2VuZU1hbmFnZXIoKTogU2NlbmVNYW5hZ2VyIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zY2VuZU1hbmFnZXI7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTdGFydHMgdGhlIGdhbWVcclxuICAgICAqL1xyXG4gICAgc3RhcnQoSW5pdGlhbFNjZW5lOiBuZXcgKC4uLmFyZ3M6IGFueSkgPT4gU2NlbmUsIG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT4pOiB2b2lkIHtcclxuICAgICAgICAvLyBTZXQgdGhlIHVwZGF0ZSBmdW5jdGlvbiBvZiB0aGUgbG9vcFxyXG4gICAgICAgIHRoaXMubG9vcC5kb1VwZGF0ZSA9IChkZWx0YVQ6IG51bWJlcikgPT4gdGhpcy51cGRhdGUoZGVsdGFUKTtcclxuXHJcbiAgICAgICAgLy8gU2V0IHRoZSByZW5kZXIgZnVuY3Rpb24gb2YgdGhlIGxvb3BcclxuICAgICAgICB0aGlzLmxvb3AuZG9SZW5kZXIgPSAoKSA9PiB0aGlzLnJlbmRlcigpO1xyXG5cclxuICAgICAgICAvLyBQcmVsb2FkIHJlZ2lzdHJ5IGl0ZW1zXHJcbiAgICAgICAgUmVnaXN0cnlNYW5hZ2VyLnByZWxvYWQoKTtcclxuXHJcbiAgICAgICAgLy8gTG9hZCB0aGUgaXRlbXMgd2l0aCB0aGUgcmVzb3VyY2UgbWFuYWdlclxyXG4gICAgICAgIHRoaXMucmVzb3VyY2VNYW5hZ2VyLmxvYWRSZXNvdXJjZXNGcm9tUXVldWUoKCkgPT4ge1xyXG4gICAgICAgICAgICAvLyBXaGVuIHdlJ3JlIGRvbmUgbG9hZGluZywgc3RhcnQgdGhlIGxvb3BcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJGaW5pc2hlZCBQcmVsb2FkIC0gbG9hZGluZyBmaXJzdCBzY2VuZVwiKTtcclxuICAgICAgICAgICAgdGhpcy5zY2VuZU1hbmFnZXIuY2hhbmdlVG9TY2VuZShJbml0aWFsU2NlbmUsIHt9LCBvcHRpb25zKTtcclxuICAgICAgICAgICAgdGhpcy5sb29wLnN0YXJ0KCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIGFsbCBuZWNlc3Nhcnkgc3Vic3lzdGVtcyBvZiB0aGUgZ2FtZS4gRGVmZXJzIHNjZW5lIHVwZGF0ZXMgdG8gdGhlIHNjZW5lTWFuYWdlclxyXG4gICAgICogQHBhcmFtIGRlbHRhVCBUaGUgdGltZSBzaW5lIHRoZSBsYXN0IHVwZGF0ZVxyXG4gICAgICovXHJcbiAgICB1cGRhdGUoZGVsdGFUOiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgICB0cnl7XHJcbiAgICAgICAgICAgIC8vIEhhbmRsZSBhbGwgZXZlbnRzIHRoYXQgaGFwcGVuZWQgc2luY2UgdGhlIHN0YXJ0IG9mIHRoZSBsYXN0IGxvb3BcclxuICAgICAgICAgICAgdGhpcy5ldmVudFF1ZXVlLnVwZGF0ZShkZWx0YVQpO1xyXG5cclxuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBpbnB1dCBkYXRhIHN0cnVjdHVyZXMgc28gZ2FtZSBvYmplY3RzIGNhbiBzZWUgdGhlIGlucHV0XHJcbiAgICAgICAgICAgIElucHV0LnVwZGF0ZShkZWx0YVQpO1xyXG5cclxuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSByZWNvcmRpbmcgb2YgdGhlIGdhbWVcclxuICAgICAgICAgICAgdGhpcy5yZWNvcmRlci51cGRhdGUoZGVsdGFUKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBhbGwgc2NlbmVzXHJcbiAgICAgICAgICAgIHRoaXMuc2NlbmVNYW5hZ2VyLnVwZGF0ZShkZWx0YVQpO1xyXG5cclxuICAgICAgICAgICAgLy8gVXBkYXRlIGFsbCBzb3VuZHNcclxuICAgICAgICAgICAgdGhpcy5hdWRpb01hbmFnZXIudXBkYXRlKGRlbHRhVCk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyBMb2FkIG9yIHVubG9hZCBhbnkgcmVzb3VyY2VzIGlmIG5lZWRlZFxyXG4gICAgICAgICAgICB0aGlzLnJlc291cmNlTWFuYWdlci51cGRhdGUoZGVsdGFUKTtcclxuICAgICAgICB9IGNhdGNoKGUpe1xyXG4gICAgICAgICAgICB0aGlzLmxvb3AucGF1c2UoKTtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVW5jYXVnaHQgRXJyb3IgaW4gVXBkYXRlIC0gQ3Jhc2hpbmcgZ3JhY2VmdWxseVwiKTtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDbGVhcnMgdGhlIGNhbnZhcyBhbmQgZGVmZXJzIHNjZW5lIHJlbmRlcmluZyB0byB0aGUgc2NlbmVNYW5hZ2VyLiBSZW5kZXJzIHRoZSBkZWJ1ZyBjYW52YXNcclxuICAgICAqL1xyXG4gICAgcmVuZGVyKCk6IHZvaWQge1xyXG4gICAgICAgIHRyeXtcclxuICAgICAgICAgICAgLy8gQ2xlYXIgdGhlIGNhbnZhc2VzXHJcbiAgICAgICAgICAgIERlYnVnLmNsZWFyQ2FudmFzKCk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnJlbmRlcmluZ01hbmFnZXIuY2xlYXIodGhpcy5jbGVhckNvbG9yKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuc2NlbmVNYW5hZ2VyLnJlbmRlcigpO1xyXG5cclxuICAgICAgICAgICAgLy8gSGFja3kgZGVidWcgbW9kZVxyXG4gICAgICAgICAgICBpZihJbnB1dC5pc0tleUp1c3RQcmVzc2VkKFwiZ1wiKSl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNob3dEZWJ1ZyA9ICF0aGlzLnNob3dEZWJ1ZztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gRGVidWcgcmVuZGVyXHJcbiAgICAgICAgICAgIGlmKHRoaXMuc2hvd0RlYnVnKXtcclxuICAgICAgICAgICAgICAgIERlYnVnLnJlbmRlcigpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZih0aGlzLnNob3dTdGF0cyl7XHJcbiAgICAgICAgICAgICAgICBTdGF0cy5yZW5kZXIoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gY2F0Y2goZSl7XHJcbiAgICAgICAgICAgIHRoaXMubG9vcC5wYXVzZSgpO1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJVbmNhdWdodCBFcnJvciBpbiBSZW5kZXIgLSBDcmFzaGluZyBncmFjZWZ1bGx5XCIpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSIsImltcG9ydCBOdWxsRnVuYyBmcm9tIFwiLi4vRGF0YVR5cGVzL0Z1bmN0aW9ucy9OdWxsRnVuY1wiO1xyXG5cclxuLyoqXHJcbiAqIFRoZSBtYWluIGdhbWUgbG9vcCBvZiB0aGUgZ2FtZS4gS2VlcHMgdHJhY2sgb2YgZnBzIGFuZCBoYW5kbGVzIHNjaGVkdWxpbmcgb2YgdXBkYXRlcyBhbmQgcmVuZGVyaW5nLlxyXG4gKiBUaGlzIGNsYXNzIGlzIGxlZnQgYWJzdHJhY3QsIHNvIHRoYXQgYSBzdWJjbGFzcyBjYW4gaGFuZGxlIGV4YWN0bHkgaG93IHRoZSBsb29wIGlzIHNjaGVkdWxlZC5cclxuICogRm9yIGFuIGV4YW1wbGUgb2YgZGlmZmVyZW50IHR5cGVzIG9mIGdhbWUgbG9vcCBzY2hlZHVsaW5nLCBjaGVjayBvdXQgQGxpbmsoR2FtZSBQcm9ncmFtbWluZyBQYXR0ZXJucykoaHR0cHM6Ly9nYW1lcHJvZ3JhbW1pbmdwYXR0ZXJucy5jb20vZ2FtZS1sb29wLmh0bWwpXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBhYnN0cmFjdCBjbGFzcyBHYW1lTG9vcCB7XHJcblxyXG5cdC8qKiBUaGUgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIGFuIHVwZGF0ZSBvY2N1cnMgKi9cclxuXHRwcm90ZWN0ZWQgX2RvVXBkYXRlOiBGdW5jdGlvbiA9IE51bGxGdW5jO1xyXG5cclxuXHRzZXQgZG9VcGRhdGUodXBkYXRlOiBGdW5jdGlvbil7XHJcblx0XHR0aGlzLl9kb1VwZGF0ZSA9IHVwZGF0ZTtcclxuXHR9XHJcblxyXG5cdC8qKiBUaGUgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIGEgcmVuZGVyIG9jY3VycyAqL1xyXG5cdHByb3RlY3RlZCBfZG9SZW5kZXI6IEZ1bmN0aW9uID0gTnVsbEZ1bmM7XHJcblxyXG5cclxuXHRzZXQgZG9SZW5kZXIocmVuZGVyOiBGdW5jdGlvbil7XHJcblx0XHR0aGlzLl9kb1JlbmRlciA9IHJlbmRlcjtcclxuXHR9XHJcblx0XHJcblx0LyoqXHJcblx0ICogUmV0cmlldmVzIHRoZSBjdXJyZW50IEZQUyBvZiB0aGUgZ2FtZVxyXG5cdCAqL1xyXG5cdGFic3RyYWN0IGdldEZQUygpOiBudW1iZXI7XHJcblxyXG5cdC8qKlxyXG4gICAgICogU3RhcnRzIHVwIHRoZSBnYW1lIGxvb3BcclxuICAgICAqL1xyXG5cdGFic3RyYWN0IHN0YXJ0KCk6IHZvaWQ7XHJcblxyXG5cdC8qKlxyXG5cdCAqIFBhdXNlcyB0aGUgZ2FtZSBsb29wLCB1c3VhbGx5IGZvciBhbiBlcnJvciBjb25kaXRpb24uXHJcblx0ICovXHJcblx0YWJzdHJhY3QgcGF1c2UoKTogdm9pZDtcclxuXHJcblx0LyoqXHJcblx0ICogUmVzdW1lcyB0aGUgZ2FtZSBsb29wLlxyXG5cdCAqL1xyXG5cdGFic3RyYWN0IHJlc3VtZSgpOiB2b2lkO1xyXG5cclxuXHQvKipcclxuXHQgKiBSdW5zIHRoZSBmaXJzdCBmcmFtZSBvZiB0aGUgZ2FtZS4gTm8gdXBkYXRlIG9jY3VycyBoZXJlLCBvbmx5IGEgcmVuZGVyLlxyXG5cdCAqIFRoaXMgaXMgbmVlZGVkIHRvIGluaXRpYWxpemUgZGVsdGEgdGltZSB2YWx1ZXNcclxuXHQgKiBAcGFyYW0gdGltZXN0YW1wIFRoZSB0aW1lc3RhbXAgb2YgdGhlIGZyYW1lLiBUaGlzIGlzIHJlY2VpdmVkIGZyb20gdGhlIGJyb3dzZXJcclxuXHQgKi9cclxuXHRwcm90ZWN0ZWQgYWJzdHJhY3QgZG9GaXJzdEZyYW1lKHRpbWVzdGFtcDogbnVtYmVyKTogdm9pZDtcclxuXHJcblx0LyoqXHJcblx0ICogUnVuIGJlZm9yZSBhbnkgdXBkYXRlcyBvciB0aGUgcmVuZGVyIG9mIGEgZnJhbWUuXHJcblx0ICogQHBhcmFtIHRpbWVzdGFtcCBUaGUgdGltZXN0YW1wIG9mIHRoZSBmcmFtZS4gVGhpcyBpcyByZWNlaXZlZCBmcm9tIHRoZSBicm93c2VyXHJcblx0ICovXHJcblx0cHJvdGVjdGVkIGFic3RyYWN0IHN0YXJ0RnJhbWUodGltZXN0YW1wOiBudW1iZXIpOiB2b2lkO1xyXG5cclxuXHQvKipcclxuXHQgKiBUaGUgY29yZSBvZiB0aGUgZnJhbWUsIHdoZXJlIGFueSBuZWNlc3NhcnkgdXBkYXRlcyBvY2N1ciwgYW5kIHdoZXJlIGEgcmVuZGVyIGhhcHBlbnNcclxuXHQgKiBAcGFyYW0gdGltZXN0YW1wIFRoZSB0aW1lc3RhbXAgb2YgdGhlIGZyYW1lLiBUaGlzIGlzIHJlY2VpdmVkIGZyb20gdGhlIGJyb3dzZXJcclxuXHQgKi9cclxuXHRwcm90ZWN0ZWQgYWJzdHJhY3QgZG9GcmFtZSh0aW1lc3RhbXA6IG51bWJlcik6IHZvaWQ7XHJcblxyXG5cdC8qKlxyXG5cdCAqIFdyYXBzIHVwIHRoZSBmcmFtZVxyXG5cdCAqIEBwYXJhbSBwYW5pYyBXaGV0aGVyIG9yIG5vdCB0aGUgdXBkYXRlIGN5Y2xlIHBhbmlja2VkLiBUaGlzIGhhcHBlbnMgd2hlbiB0b28gbWFueSB1cGRhdGVzIHRyeSB0byBoYXBwZW4gaW4gYSBzaW5nbGUgZnJhbWVcclxuXHQgKi9cclxuXHRwcm90ZWN0ZWQgYWJzdHJhY3QgZmluaXNoRnJhbWUocGFuaWM6IGJvb2xlYW4pOiB2b2lkO1xyXG59IiwiLy8gQGlnbm9yZVBhZ2VcclxuXHJcbi8qKiBUaGUgb3B0aW9ucyBmb3IgaW5pdGlhbGl6aW5nIHRoZSBAcmVmZXJlbmNlW0dhbWVMb29wXSAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHYW1lT3B0aW9ucyB7XHJcbiAgICAvKiogVGhlIHNpemUgb2YgdGhlIHZpZXdwb3J0ICovXHJcbiAgICBjYW52YXNTaXplOiB7eDogbnVtYmVyLCB5OiBudW1iZXJ9O1xyXG5cclxuICAgIC8qIFRoZSBkZWZhdWx0IGxldmVsIG9mIHpvb20gKi9cclxuICAgIHpvb21MZXZlbDogbnVtYmVyO1xyXG5cclxuICAgIC8qKiBUaGUgY29sb3IgdG8gY2xlYXIgdGhlIGNhbnZhcyB0byBlYWNoIGZyYW1lICovXHJcbiAgICBjbGVhckNvbG9yOiB7cjogbnVtYmVyLCBnOiBudW1iZXIsIGI6IG51bWJlcn1cclxuXHJcbiAgICAvKiBBIGxpc3Qgb2YgaW5wdXQgYmluZGluZ3MgKi9cclxuICAgIGlucHV0czogQXJyYXk8e25hbWU6IHN0cmluZywga2V5czogQXJyYXk8c3RyaW5nPn0+O1xyXG5cclxuICAgIC8qIFdoZXRoZXIgb3Igbm90IHRoZSBkZWJ1ZyByZW5kZXJpbmcgc2hvdWxkIG9jY3VyICovXHJcbiAgICBzaG93RGVidWc6IGJvb2xlYW47XHJcblxyXG4gICAgLyogV2hldGhlciBvciBub3QgdGhlIHN0YXRzIHJlbmRlcmluZyBzaG91bGQgb2NjdXIgKi9cclxuICAgIHNob3dTdGF0czogYm9vbGVhbjtcclxuXHJcbiAgICAvKiBXaGV0aGVyIG9yIG5vdCB0byB1c2Ugd2ViR0wgKi9cclxuICAgIHVzZVdlYkdMOiBib29sZWFuO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUGFyc2VzIHRoZSBkYXRhIGluIHRoZSByYXcgb3B0aW9ucyBvYmplY3RcclxuICAgICAqIEBwYXJhbSBvcHRpb25zIFRoZSBnYW1lIG9wdGlvbnMgYXMgYSBSZWNvcmRcclxuICAgICAqIEByZXR1cm5zIEEgdmVyc2lvbiBvZiB0aGUgb3B0aW9ucyBjb252ZXJ0ZWQgdG8gYSBHYW1lT3B0aW9ucyBvYmplY3RcclxuICAgICAqL1xyXG4gICAgc3RhdGljIHBhcnNlKG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT4pOiBHYW1lT3B0aW9ucyB7XHJcbiAgICAgICAgbGV0IGdPcHQgPSBuZXcgR2FtZU9wdGlvbnMoKTtcclxuXHJcbiAgICAgICAgZ09wdC5jYW52YXNTaXplID0gb3B0aW9ucy5jYW52YXNTaXplID8gb3B0aW9ucy5jYW52YXNTaXplIDoge3g6IDgwMCwgeTogNjAwfTtcclxuICAgICAgICBnT3B0Lnpvb21MZXZlbCA9IG9wdGlvbnMuem9vbUxldmVsID8gb3B0aW9ucy56b29tTGV2ZWwgOiAxO1xyXG4gICAgICAgIGdPcHQuY2xlYXJDb2xvciA9IG9wdGlvbnMuY2xlYXJDb2xvciA/IG9wdGlvbnMuY2xlYXJDb2xvciA6IHtyOiAyNTUsIGc6IDI1NSwgYjogMjU1fTtcclxuICAgICAgICBnT3B0LmlucHV0cyA9IG9wdGlvbnMuaW5wdXRzID8gb3B0aW9ucy5pbnB1dHMgOiBbXTtcclxuICAgICAgICBnT3B0LnNob3dEZWJ1ZyA9ICEhb3B0aW9ucy5zaG93RGVidWc7XHJcbiAgICAgICAgZ09wdC5zaG93U3RhdHMgPSAhIW9wdGlvbnMuc2hvd1N0YXRzO1xyXG4gICAgICAgIGdPcHQudXNlV2ViR0wgPSAhIW9wdGlvbnMudXNlV2ViR0w7XHJcblxyXG4gICAgICAgIHJldHVybiBnT3B0O1xyXG4gICAgfVxyXG59IiwiaW1wb3J0IEdhbWVOb2RlIGZyb20gXCIuL0dhbWVOb2RlXCI7XHJcbmltcG9ydCBWZWMyIGZyb20gXCIuLi9EYXRhVHlwZXMvVmVjMlwiO1xyXG5pbXBvcnQgUmVnaW9uIGZyb20gXCIuLi9EYXRhVHlwZXMvSW50ZXJmYWNlcy9SZWdpb25cIjtcclxuaW1wb3J0IEFBQkIgZnJvbSBcIi4uL0RhdGFUeXBlcy9TaGFwZXMvQUFCQlwiO1xyXG5pbXBvcnQgRGVidWcgZnJvbSBcIi4uL0RlYnVnL0RlYnVnXCI7XHJcbmltcG9ydCBDb2xvciBmcm9tIFwiLi4vVXRpbHMvQ29sb3JcIjtcclxuXHJcbi8qKlxyXG4gKiBUaGUgcmVwcmVzZW50YXRpb24gb2YgYW4gb2JqZWN0IGluIHRoZSBnYW1lIHdvcmxkIHRoYXQgY2FuIGJlIGRyYXduIHRvIHRoZSBzY3JlZW5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGFic3RyYWN0IGNsYXNzIENhbnZhc05vZGUgZXh0ZW5kcyBHYW1lTm9kZSBpbXBsZW1lbnRzIFJlZ2lvbiB7XHJcblx0cHJpdmF0ZSBfc2l6ZTogVmVjMjtcclxuXHRwcml2YXRlIF9zY2FsZTogVmVjMjtcclxuXHRwcml2YXRlIF9ib3VuZGFyeTogQUFCQjtcclxuXHRwcml2YXRlIF9oYXNDdXN0b21TaGFkZXI6IGJvb2xlYW47XHJcblx0cHJpdmF0ZSBfY3VzdG9tU2hhZGVyS2V5OiBzdHJpbmc7XHJcblx0cHJpdmF0ZSBfYWxwaGE6IG51bWJlcjtcclxuXHJcblx0LyoqIEEgZmxhZyBmb3Igd2hldGhlciBvciBub3QgdGhlIENhbnZhc05vZGUgaXMgdmlzaWJsZSAqL1xyXG5cdHZpc2libGU6IGJvb2xlYW4gPSB0cnVlO1xyXG5cdFxyXG5cdGNvbnN0cnVjdG9yKCl7XHJcblx0XHRzdXBlcigpO1xyXG5cdFx0dGhpcy5fc2l6ZSA9IG5ldyBWZWMyKDAsIDApO1xyXG5cdFx0dGhpcy5fc2l6ZS5zZXRPbkNoYW5nZSgoKSA9PiB0aGlzLnNpemVDaGFuZ2VkKCkpO1xyXG5cdFx0dGhpcy5fc2NhbGUgPSBuZXcgVmVjMigxLCAxKTtcclxuXHRcdHRoaXMuX3NjYWxlLnNldE9uQ2hhbmdlKCgpID0+IHRoaXMuc2NhbGVDaGFuZ2VkKCkpO1xyXG5cdFx0dGhpcy5fYm91bmRhcnkgPSBuZXcgQUFCQigpO1xyXG5cdFx0dGhpcy51cGRhdGVCb3VuZGFyeSgpO1xyXG5cclxuXHRcdHRoaXMuX2hhc0N1c3RvbVNoYWRlciA9IGZhbHNlO1xyXG5cdH1cclxuXHJcblx0Z2V0IGFscGhhKCk6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gdGhpcy5fYWxwaGE7XHJcblx0fVxyXG5cclxuXHRzZXQgYWxwaGEoYTogbnVtYmVyKSB7XHJcblx0XHR0aGlzLl9hbHBoYSA9IGE7XHJcblx0fVxyXG5cclxuXHRnZXQgc2l6ZSgpOiBWZWMyIHtcclxuXHRcdHJldHVybiB0aGlzLl9zaXplO1xyXG5cdH1cclxuXHJcblx0c2V0IHNpemUoc2l6ZTogVmVjMil7XHJcblx0XHR0aGlzLl9zaXplID0gc2l6ZTtcclxuXHRcdC8vIEVudGVyIGFzIGEgbGFtYmRhIHRvIGJpbmQgXCJ0aGlzXCJcclxuXHRcdHRoaXMuX3NpemUuc2V0T25DaGFuZ2UoKCkgPT4gdGhpcy5zaXplQ2hhbmdlZCgpKTtcclxuXHRcdHRoaXMuc2l6ZUNoYW5nZWQoKTtcclxuXHR9XHJcblxyXG5cdGdldCBzY2FsZSgpOiBWZWMyIHtcclxuXHRcdHJldHVybiB0aGlzLl9zY2FsZTtcclxuXHR9XHJcblxyXG5cdHNldCBzY2FsZShzY2FsZTogVmVjMil7XHJcblx0XHR0aGlzLl9zY2FsZSA9IHNjYWxlO1xyXG5cdFx0Ly8gRW50ZXIgYXMgYSBsYW1iZGEgdG8gYmluZCBcInRoaXNcIlxyXG5cdFx0dGhpcy5fc2NhbGUuc2V0T25DaGFuZ2UoKCkgPT4gdGhpcy5zY2FsZUNoYW5nZWQoKSk7XHJcblx0XHR0aGlzLnNjYWxlQ2hhbmdlZCgpO1xyXG5cdH1cclxuXHJcblx0c2V0IHNjYWxlWCh2YWx1ZTogbnVtYmVyKSB7XHJcblx0XHR0aGlzLnNjYWxlLnggPSB2YWx1ZTtcclxuXHR9XHJcblxyXG5cdHNldCBzY2FsZVkodmFsdWU6IG51bWJlcikge1xyXG5cdFx0dGhpcy5zY2FsZS55ID0gdmFsdWU7XHJcblx0fVxyXG5cclxuXHRnZXQgaGFzQ3VzdG9tU2hhZGVyKCk6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2hhc0N1c3RvbVNoYWRlcjtcclxuXHR9XHJcblxyXG5cdGdldCBjdXN0b21TaGFkZXJLZXkoKTogc3RyaW5nIHtcclxuXHRcdHJldHVybiB0aGlzLl9jdXN0b21TaGFkZXJLZXk7XHJcblx0fVxyXG5cclxuXHQvLyBAb3ZlcnJpZGVcclxuXHRwcm90ZWN0ZWQgcG9zaXRpb25DaGFuZ2VkKCk6IHZvaWQge1xyXG5cdFx0c3VwZXIucG9zaXRpb25DaGFuZ2VkKCk7XHJcblx0XHR0aGlzLnVwZGF0ZUJvdW5kYXJ5KCk7XHJcblx0fVxyXG5cclxuXHQvKiogQ2FsbGVkIGlmIHRoZSBzaXplIHZlY3RvciBpcyBjaGFuZ2VkIG9yIHJlcGxhY2VkLiAqL1xyXG5cdHByb3RlY3RlZCBzaXplQ2hhbmdlZCgpOiB2b2lkIHtcclxuXHRcdHRoaXMudXBkYXRlQm91bmRhcnkoKTtcclxuXHR9XHJcblxyXG5cdC8qKiBDYWxsZWQgaWYgdGhlIHNjYWxlIHZlY3RvciBpcyBjaGFuZ2VkIG9yIHJlcGxhY2VkICovXHJcblx0cHJvdGVjdGVkIHNjYWxlQ2hhbmdlZCgpOiB2b2lkIHtcclxuXHRcdHRoaXMudXBkYXRlQm91bmRhcnkoKTtcclxuXHR9XHJcblxyXG5cdC8vIEBkb2NJZ25vcmVcclxuXHQvKiogQ2FsbGVkIGlmIHRoZSBwb3NpdGlvbiwgc2l6ZSwgb3Igc2NhbGUgb2YgdGhlIENhbnZhc05vZGUgaXMgY2hhbmdlZC4gVXBkYXRlcyB0aGUgYm91bmRhcnkuICovXHJcblx0cHJpdmF0ZSB1cGRhdGVCb3VuZGFyeSgpOiB2b2lkIHtcclxuXHRcdHRoaXMuX2JvdW5kYXJ5LmNlbnRlci5zZXQodGhpcy5wb3NpdGlvbi54LCB0aGlzLnBvc2l0aW9uLnkpO1xyXG5cdFx0dGhpcy5fYm91bmRhcnkuaGFsZlNpemUuc2V0KHRoaXMuc2l6ZS54KnRoaXMuc2NhbGUueC8yLCB0aGlzLnNpemUueSp0aGlzLnNjYWxlLnkvMik7XHJcblx0fVxyXG5cclxuXHRnZXQgYm91bmRhcnkoKTogQUFCQiB7XHJcblx0XHRyZXR1cm4gdGhpcy5fYm91bmRhcnk7XHJcblx0fVxyXG5cclxuXHRnZXQgc2l6ZVdpdGhab29tKCk6IFZlYzIge1xyXG5cdFx0bGV0IHpvb20gPSB0aGlzLnNjZW5lLmdldFZpZXdTY2FsZSgpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmJvdW5kYXJ5LmhhbGZTaXplLmNsb25lKCkuc2NhbGVkKHpvb20sIHpvb20pO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQWRkcyBhIGN1c3RvbSBzaGFkZXIgdG8gdGhpcyBDYW52YXNOb2RlXHJcblx0ICogQHBhcmFtIGtleSBUaGUgcmVnaXN0cnkga2V5IG9mIHRoZSBTaGFkZXJUeXBlXHJcblx0ICovXHJcblx0dXNlQ3VzdG9tU2hhZGVyKGtleTogc3RyaW5nKTogdm9pZCB7XHJcblx0XHR0aGlzLl9oYXNDdXN0b21TaGFkZXIgPSB0cnVlO1xyXG5cdFx0dGhpcy5fY3VzdG9tU2hhZGVyS2V5ID0ga2V5O1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0cnVlIGlmIHRoZSBwb2ludCAoeCwgeSkgaXMgaW5zaWRlIG9mIHRoaXMgY2FudmFzIG9iamVjdFxyXG5cdCAqIEBwYXJhbSB4IFRoZSB4IHBvc2l0aW9uIG9mIHRoZSBwb2ludFxyXG5cdCAqIEBwYXJhbSB5IFRoZSB5IHBvc2l0aW9uIG9mIHRoZSBwb2ludFxyXG5cdCAqIEByZXR1cm5zIEEgZmxhZyByZXByZXNlbnRpbmcgd2hldGhlciBvciBub3QgdGhpcyBub2RlIGNvbnRhaW5zIHRoZSBwb2ludC5cclxuXHQgKi9cclxuXHRjb250YWlucyh4OiBudW1iZXIsIHk6IG51bWJlcik6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2JvdW5kYXJ5LmNvbnRhaW5zUG9pbnQobmV3IFZlYzIoeCwgeSkpO1xyXG5cdH1cclxuXHJcblx0Ly8gQGltcGxlbWVudGVkXHJcblx0ZGVidWdSZW5kZXIoKTogdm9pZCB7XHJcblx0XHREZWJ1Zy5kcmF3Qm94KHRoaXMucmVsYXRpdmVQb3NpdGlvbiwgdGhpcy5zaXplV2l0aFpvb20sIGZhbHNlLCBDb2xvci5CTFVFKTtcclxuXHRcdHN1cGVyLmRlYnVnUmVuZGVyKCk7XHJcblx0fVxyXG59IiwiaW1wb3J0IFZlYzIgZnJvbSBcIi4uL0RhdGFUeXBlcy9WZWMyXCI7XHJcbmltcG9ydCBSZWNlaXZlciBmcm9tIFwiLi4vRXZlbnRzL1JlY2VpdmVyXCI7XHJcbmltcG9ydCBFbWl0dGVyIGZyb20gXCIuLi9FdmVudHMvRW1pdHRlclwiO1xyXG5pbXBvcnQgU2NlbmUgZnJvbSBcIi4uL1NjZW5lL1NjZW5lXCI7XHJcbmltcG9ydCBMYXllciBmcm9tIFwiLi4vU2NlbmUvTGF5ZXJcIjtcclxuaW1wb3J0IEFJIGZyb20gXCIuLi9EYXRhVHlwZXMvSW50ZXJmYWNlcy9BSVwiO1xyXG5pbXBvcnQgUGh5c2ljYWwgZnJvbSBcIi4uL0RhdGFUeXBlcy9JbnRlcmZhY2VzL1BoeXNpY2FsXCI7XHJcbmltcG9ydCBQb3NpdGlvbmVkIGZyb20gXCIuLi9EYXRhVHlwZXMvSW50ZXJmYWNlcy9Qb3NpdGlvbmVkXCI7XHJcbmltcG9ydCB7IGlzUmVnaW9uIH0gZnJvbSBcIi4uL0RhdGFUeXBlcy9JbnRlcmZhY2VzL1JlZ2lvblwiO1xyXG5pbXBvcnQgVW5pcXVlIGZyb20gXCIuLi9EYXRhVHlwZXMvSW50ZXJmYWNlcy9VbmlxdWVcIjtcclxuaW1wb3J0IFVwZGF0ZWFibGUgZnJvbSBcIi4uL0RhdGFUeXBlcy9JbnRlcmZhY2VzL1VwZGF0ZWFibGVcIjtcclxuaW1wb3J0IERlYnVnUmVuZGVyYWJsZSBmcm9tIFwiLi4vRGF0YVR5cGVzL0ludGVyZmFjZXMvRGVidWdSZW5kZXJhYmxlXCI7XHJcbmltcG9ydCBBY3RvciBmcm9tIFwiLi4vRGF0YVR5cGVzL0ludGVyZmFjZXMvQWN0b3JcIjtcclxuaW1wb3J0IFNoYXBlIGZyb20gXCIuLi9EYXRhVHlwZXMvU2hhcGVzL1NoYXBlXCI7XHJcbmltcG9ydCBBQUJCIGZyb20gXCIuLi9EYXRhVHlwZXMvU2hhcGVzL0FBQkJcIjtcclxuaW1wb3J0IE5hdmlnYXRpb25QYXRoIGZyb20gXCIuLi9QYXRoZmluZGluZy9OYXZpZ2F0aW9uUGF0aFwiO1xyXG5pbXBvcnQgVHdlZW5Db250cm9sbGVyIGZyb20gXCIuLi9SZW5kZXJpbmcvQW5pbWF0aW9ucy9Ud2VlbkNvbnRyb2xsZXJcIjtcclxuaW1wb3J0IERlYnVnIGZyb20gXCIuLi9EZWJ1Zy9EZWJ1Z1wiO1xyXG5pbXBvcnQgQ29sb3IgZnJvbSBcIi4uL1V0aWxzL0NvbG9yXCI7XHJcbmltcG9ydCBDaXJjbGUgZnJvbSBcIi4uL0RhdGFUeXBlcy9TaGFwZXMvQ2lyY2xlXCI7XHJcbmltcG9ydCBHb2FwQUkgZnJvbSBcIi4uL0RhdGFUeXBlcy9JbnRlcmZhY2VzL0dvYXBBSVwiO1xyXG5cclxuLyoqXHJcbiAqIFRoZSByZXByZXNlbnRhdGlvbiBvZiBhbiBvYmplY3QgaW4gdGhlIGdhbWUgd29ybGQuXHJcbiAqIFRvIGNvbnN0cnVjdCBHYW1lTm9kZXMsIHNlZSB0aGUgQHJlZmVyZW5jZVtTY2VuZV0gZG9jdW1lbnRhdGlvbi5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGFic3RyYWN0IGNsYXNzIEdhbWVOb2RlIGltcGxlbWVudHMgUG9zaXRpb25lZCwgVW5pcXVlLCBVcGRhdGVhYmxlLCBQaHlzaWNhbCwgQWN0b3IsIERlYnVnUmVuZGVyYWJsZSB7XHJcblx0LyotLS0tLS0tLS0tIFBPU0lUSU9ORUQgLS0tLS0tLS0tLSovXHJcblx0cHJpdmF0ZSBfcG9zaXRpb246IFZlYzI7XHJcblxyXG5cdC8qLS0tLS0tLS0tLSBVTklRVUUgLS0tLS0tLS0tLSovXHJcblx0cHJpdmF0ZSBfaWQ6IG51bWJlcjtcclxuXHJcblx0LyotLS0tLS0tLS0tIFBIWVNJQ0FMIC0tLS0tLS0tLS0qL1xyXG5cdGhhc1BoeXNpY3M6IGJvb2xlYW4gPSBmYWxzZTtcclxuXHRtb3Zpbmc6IGJvb2xlYW4gPSBmYWxzZTtcclxuXHRmcm96ZW46IGJvb2xlYW4gPSBmYWxzZTtcclxuXHRvbkdyb3VuZDogYm9vbGVhbiA9IGZhbHNlO1xyXG5cdG9uV2FsbDogYm9vbGVhbiA9IGZhbHNlO1xyXG5cdG9uQ2VpbGluZzogYm9vbGVhbiA9IGZhbHNlO1xyXG5cdGFjdGl2ZTogYm9vbGVhbiA9IGZhbHNlO1xyXG5cdGNvbGxpc2lvblNoYXBlOiBTaGFwZTtcclxuXHRjb2xsaWRlck9mZnNldDogVmVjMjtcclxuXHRpc1N0YXRpYzogYm9vbGVhbjtcclxuXHRpc0NvbGxpZGFibGU6IGJvb2xlYW47XHJcblx0aXNUcmlnZ2VyOiBib29sZWFuO1xyXG5cdHRyaWdnZXJNYXNrOiBudW1iZXI7XHJcblx0dHJpZ2dlckVudGVyczogQXJyYXk8c3RyaW5nPjtcclxuXHR0cmlnZ2VyRXhpdHM6IEFycmF5PHN0cmluZz47XHJcblx0X3ZlbG9jaXR5OiBWZWMyO1xyXG5cdHN3ZXB0UmVjdDogQUFCQjtcclxuXHRjb2xsaWRlZFdpdGhUaWxlbWFwOiBib29sZWFuO1xyXG5cdGdyb3VwOiBudW1iZXI7XHJcblx0aXNQbGF5ZXI6IGJvb2xlYW47XHJcblx0aXNDb2xsaWRpbmc6IGJvb2xlYW4gPSBmYWxzZTtcclxuXHJcblx0LyotLS0tLS0tLS0tIEFDVE9SIC0tLS0tLS0tLS0qL1xyXG5cdF9haTogQUkgfCBHb2FwQUk7XHJcblx0YWlBY3RpdmU6IGJvb2xlYW47XHJcblx0cGF0aDogTmF2aWdhdGlvblBhdGg7XHJcblx0cGF0aGZpbmRpbmc6IGJvb2xlYW4gPSBmYWxzZTtcclxuXHJcblx0LyotLS0tLS0tLS0tIEdFTkVSQUwgLS0tLS0tLS0tLSovXHJcblx0LyoqIEFuIGV2ZW50IHJlY2VpdmVyLiAqL1xyXG5cdHByb3RlY3RlZCByZWNlaXZlcjogUmVjZWl2ZXI7XHJcblx0LyoqIEFuIGV2ZW50IGVtaXR0ZXIuICovXHJcblx0cHJvdGVjdGVkIGVtaXR0ZXI6IEVtaXR0ZXI7XHJcblx0LyoqIEEgcmVmZXJlbmNlIHRvIHRoZSBzY2VuZSB0aGlzIEdhbWVOb2RlIGlzIGEgcGFydCBvZi4gKi9cclxuXHRwcm90ZWN0ZWQgc2NlbmU6IFNjZW5lO1xyXG5cdC8qKiBUaGUgdmlzdWFsIGxheWVyIHRoaXMgR2FtZU5vZGUgcmVzaWRlcyBpbi4gKi9cclxuXHRwcm90ZWN0ZWQgbGF5ZXI6IExheWVyO1xyXG5cdC8qKiBBIHV0aWxpdHkgdGhhdCBhbGxvd3MgdGhlIHVzZSBvZiB0d2VlbnMgb24gdGhpcyBHYW1lTm9kZSAqL1xyXG5cdHR3ZWVuczogVHdlZW5Db250cm9sbGVyO1xyXG5cdC8qKiBBIHR3ZWVuYWJsZSBwcm9wZXJ0eSBmb3Igcm90YXRpb24uIERvZXMgbm90IGFmZmVjdCB0aGUgYm91bmRpbmcgYm94IG9mIHRoaXMgR2FtZU5vZGUgLSBPbmx5IHJlbmRlcmluZy4gKi9cclxuXHRyb3RhdGlvbjogbnVtYmVyO1xyXG5cdC8qKiBUaGUgb3BhY2l0eSB2YWx1ZSBvZiB0aGlzIEdhbWVOb2RlICovXHJcblx0YWJzdHJhY3Qgc2V0IGFscGhhKGE6IG51bWJlcik7XHJcblxyXG5cdGFic3RyYWN0IGdldCBhbHBoYSgpOiBudW1iZXI7XHJcblxyXG5cdC8vIENvbnN0cnVjdG9yIGRvY3MgYXJlIGlnbm9yZWQsIGFzIHRoZSB1c2VyIHNob3VsZCBOT1QgY3JlYXRlIG5ldyBHYW1lTm9kZXMgd2l0aCBhIHJhdyBjb25zdHJ1Y3RvclxyXG5cdGNvbnN0cnVjdG9yKCl7XHJcblx0XHR0aGlzLl9wb3NpdGlvbiA9IG5ldyBWZWMyKDAsIDApO1xyXG5cdFx0dGhpcy5fcG9zaXRpb24uc2V0T25DaGFuZ2UoKCkgPT4gdGhpcy5wb3NpdGlvbkNoYW5nZWQoKSk7XHJcblx0XHR0aGlzLnJlY2VpdmVyID0gbmV3IFJlY2VpdmVyKCk7XHJcblx0XHR0aGlzLmVtaXR0ZXIgPSBuZXcgRW1pdHRlcigpO1xyXG5cdFx0dGhpcy50d2VlbnMgPSBuZXcgVHdlZW5Db250cm9sbGVyKHRoaXMpO1xyXG5cdFx0dGhpcy5yb3RhdGlvbiA9IDA7XHJcblx0fVxyXG5cclxuXHRkZXN0cm95KCl7XHJcblx0XHR0aGlzLnR3ZWVucy5kZXN0cm95KCk7XHJcblx0XHR0aGlzLnJlY2VpdmVyLmRlc3Ryb3koKTtcclxuXHJcblx0XHRpZih0aGlzLmhhc1BoeXNpY3Mpe1xyXG5cdFx0XHR0aGlzLnJlbW92ZVBoeXNpY3MoKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZih0aGlzLl9haSl7XHJcblx0XHRcdHRoaXMuX2FpLmRlc3Ryb3koKTtcclxuXHRcdFx0ZGVsZXRlIHRoaXMuX2FpO1xyXG5cdFx0XHR0aGlzLnNjZW5lLmdldEFJTWFuYWdlcigpLnJlbW92ZUFjdG9yKHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuc2NlbmUucmVtb3ZlKHRoaXMpO1xyXG5cclxuXHRcdHRoaXMubGF5ZXIucmVtb3ZlTm9kZSh0aGlzKTtcclxuXHR9XHJcblxyXG5cdC8qLS0tLS0tLS0tLSBQT1NJVElPTkVEIC0tLS0tLS0tLS0qL1xyXG5cdGdldCBwb3NpdGlvbigpOiBWZWMyIHtcclxuXHRcdHJldHVybiB0aGlzLl9wb3NpdGlvbjtcclxuXHR9XHJcblxyXG5cdHNldCBwb3NpdGlvbihwb3M6IFZlYzIpIHtcclxuXHRcdHRoaXMuX3Bvc2l0aW9uID0gcG9zO1xyXG5cdFx0dGhpcy5fcG9zaXRpb24uc2V0T25DaGFuZ2UoKCkgPT4gdGhpcy5wb3NpdGlvbkNoYW5nZWQoKSk7XHJcblx0XHR0aGlzLnBvc2l0aW9uQ2hhbmdlZCgpO1xyXG5cdH1cclxuXHJcblx0Z2V0IHJlbGF0aXZlUG9zaXRpb24oKTogVmVjMiB7XHJcblx0XHRyZXR1cm4gdGhpcy5pblJlbGF0aXZlQ29vcmRpbmF0ZXModGhpcy5wb3NpdGlvbik7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBDb252ZXJ0cyBhIHBvaW50IHRvIGNvb3JkaW5hdGVzIHJlbGF0aXZlIHRvIHRoZSB6b29tIGFuZCBvcmlnaW4gb2YgdGhpcyBub2RlXHJcblx0ICogQHBhcmFtIHBvaW50IFRoZSBwb2ludCB0byBjb252ZXJcclxuXHQgKiBAcmV0dXJucyBBIG5ldyBWZWMyIHJlcHJlc2VudGluZyB0aGUgcG9pbnQgaW4gcmVsYXRpdmUgY29vcmRpbmF0ZXNcclxuXHQgKi9cclxuXHRpblJlbGF0aXZlQ29vcmRpbmF0ZXMocG9pbnQ6IFZlYzIpOiBWZWMyIHtcclxuXHRcdGxldCBvcmlnaW4gPSB0aGlzLnNjZW5lLmdldFZpZXdUcmFuc2xhdGlvbih0aGlzKTtcclxuXHRcdGxldCB6b29tID0gdGhpcy5zY2VuZS5nZXRWaWV3U2NhbGUoKTtcclxuXHRcdHJldHVybiBwb2ludC5jbG9uZSgpLnN1YihvcmlnaW4pLnNjYWxlKHpvb20pO1xyXG5cdH1cclxuXHJcblx0LyotLS0tLS0tLS0tIFVOSVFVRSAtLS0tLS0tLS0tKi9cclxuXHRnZXQgaWQoKTogbnVtYmVyIHtcclxuXHRcdHJldHVybiB0aGlzLl9pZDtcclxuXHR9XHJcblxyXG5cdHNldCBpZChpZDogbnVtYmVyKSB7XHJcblx0XHQvLyBpZCBjYW4gb25seSBiZSBzZXQgb25jZVxyXG5cdFx0aWYodGhpcy5faWQgPT09IHVuZGVmaW5lZCl7XHJcblx0XHRcdHRoaXMuX2lkID0gaWQ7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aHJvdyBcIkF0dGVtcHRlZCB0byBhc3NpZ24gaWQgdG8gb2JqZWN0IHRoYXQgYWxyZWFkeSBoYXMgaWQuXCJcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8qLS0tLS0tLS0tLSBQSFlTSUNBTCAtLS0tLS0tLS0tKi9cclxuXHQvLyBAaW1wbGVtZW50ZWRcclxuXHQvKipcclxuICAgICAqIEBwYXJhbSB2ZWxvY2l0eSBUaGUgdmVsb2NpdHkgd2l0aCB3aGljaCB0byBtb3ZlIHRoZSBvYmplY3QuXHJcbiAgICAgKi9cclxuXHRtb3ZlKHZlbG9jaXR5OiBWZWMyKTogdm9pZCB7XHJcblx0XHRpZih0aGlzLmZyb3plbikgcmV0dXJuO1xyXG5cdFx0dGhpcy5tb3ZpbmcgPSB0cnVlO1xyXG5cdFx0dGhpcy5fdmVsb2NpdHkgPSB2ZWxvY2l0eTtcclxuXHR9O1xyXG5cclxuXHRtb3ZlT25QYXRoKHNwZWVkOiBudW1iZXIsIHBhdGg6IE5hdmlnYXRpb25QYXRoKTogdm9pZCB7XHJcblx0XHRpZih0aGlzLmZyb3plbikgcmV0dXJuO1xyXG5cdFx0dGhpcy5wYXRoID0gcGF0aDtcclxuXHRcdGxldCBkaXIgPSBwYXRoLmdldE1vdmVEaXJlY3Rpb24odGhpcyk7XHJcblx0XHR0aGlzLm1vdmluZyA9IHRydWU7XHJcblx0XHR0aGlzLnBhdGhmaW5kaW5nID0gdHJ1ZTtcclxuXHRcdHRoaXMuX3ZlbG9jaXR5ID0gZGlyLnNjYWxlKHNwZWVkKTtcclxuXHR9XHJcblxyXG5cdC8vIEBpbXBsZW1lbnRlZFxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gdmVsb2NpdHkgVGhlIHZlbG9jaXR5IHdpdGggd2hpY2ggdGhlIG9iamVjdCB3aWxsIG1vdmUuXHJcbiAgICAgKi9cclxuXHRmaW5pc2hNb3ZlKCk6IHZvaWQge1xyXG5cdFx0dGhpcy5tb3ZpbmcgPSBmYWxzZTtcclxuXHRcdHRoaXMucG9zaXRpb24uYWRkKHRoaXMuX3ZlbG9jaXR5KTtcclxuXHRcdGlmKHRoaXMucGF0aGZpbmRpbmcpe1xyXG5cdFx0XHR0aGlzLnBhdGguaGFuZGxlUGF0aFByb2dyZXNzKHRoaXMpO1xyXG5cdFx0XHR0aGlzLnBhdGggPSBudWxsO1xyXG5cdFx0XHR0aGlzLnBhdGhmaW5kaW5nID0gZmFsc2U7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvLyBAaW1wbGVtZW50ZWRcclxuXHQvKipcclxuXHQgKiBAcGFyYW0gY29sbGlzaW9uU2hhcGUgVGhlIGNvbGxpZGVyIGZvciB0aGlzIG9iamVjdC4gSWYgdGhpcyBoYXMgYSByZWdpb24gKGltcGxlbWVudHMgUmVnaW9uKSxcclxuXHQgKiBpdCB3aWxsIGJlIHVzZWQgd2hlbiBubyBjb2xsaXNpb24gc2hhcGUgaXMgc3BlY2lmaWVkIChvciBpZiBjb2xsaXNpb24gc2hhcGUgaXMgbnVsbCkuXHJcblx0ICogQHBhcmFtIGlzQ29sbGlkYWJsZSBXaGV0aGVyIHRoaXMgaXMgY29sbGlkYWJsZSBvciBub3QuIFRydWUgYnkgZGVmYXVsdC5cclxuXHQgKiBAcGFyYW0gaXNTdGF0aWMgV2hldGhlciB0aGlzIGlzIHN0YXRpYyBvciBub3QuIEZhbHNlIGJ5IGRlZmF1bHRcclxuXHQgKi9cclxuXHRhZGRQaHlzaWNzKGNvbGxpc2lvblNoYXBlPzogU2hhcGUsIGNvbGxpZGVyT2Zmc2V0PzogVmVjMiwgaXNDb2xsaWRhYmxlOiBib29sZWFuID0gdHJ1ZSwgaXNTdGF0aWM6IGJvb2xlYW4gPSBmYWxzZSk6IHZvaWQge1xyXG5cdFx0Ly8gSW5pdGlhbGl6ZSB0aGUgcGh5c2ljcyB2YXJpYWJsZXNcclxuXHRcdHRoaXMuaGFzUGh5c2ljcyA9IHRydWU7XHJcblx0XHR0aGlzLm1vdmluZyA9IGZhbHNlO1xyXG5cdFx0dGhpcy5vbkdyb3VuZCA9IGZhbHNlO1xyXG5cdFx0dGhpcy5vbldhbGwgPSBmYWxzZTtcclxuXHRcdHRoaXMub25DZWlsaW5nID0gZmFsc2U7XHJcblx0XHR0aGlzLmFjdGl2ZSA9IHRydWU7XHJcblx0XHR0aGlzLmlzQ29sbGlkYWJsZSA9IGlzQ29sbGlkYWJsZTtcclxuXHRcdHRoaXMuaXNTdGF0aWMgPSBpc1N0YXRpYztcclxuXHRcdHRoaXMuaXNUcmlnZ2VyID0gZmFsc2U7XHJcblx0XHR0aGlzLnRyaWdnZXJNYXNrID0gMDtcclxuXHRcdHRoaXMudHJpZ2dlckVudGVycyA9IG5ldyBBcnJheSgzMik7XHJcblx0XHR0aGlzLnRyaWdnZXJFeGl0cyA9IG5ldyBBcnJheSgzMik7XHJcblx0XHR0aGlzLl92ZWxvY2l0eSA9IFZlYzIuWkVSTztcclxuXHRcdHRoaXMuc3dlcHRSZWN0ID0gbmV3IEFBQkIoKTtcclxuXHRcdHRoaXMuY29sbGlkZWRXaXRoVGlsZW1hcCA9IGZhbHNlO1xyXG5cdFx0dGhpcy5ncm91cCA9IC0xO1x0XHRcdFx0XHQvLyBUaGUgZGVmYXVsdCBncm91cCwgY29sbGlkZXMgd2l0aCBldmVyeXRoaW5nXHJcblxyXG5cdFx0Ly8gU2V0IHRoZSBjb2xsaXNpb24gc2hhcGUgaWYgcHJvdmlkZWQsIG9yIHNpbXBseSB1c2UgdGhlIHRoZSByZWdpb24gaWYgdGhlcmUgaXMgb25lLlxyXG5cdFx0aWYoY29sbGlzaW9uU2hhcGUpe1xyXG5cdFx0XHR0aGlzLmNvbGxpc2lvblNoYXBlID0gY29sbGlzaW9uU2hhcGU7XHJcblx0XHRcdHRoaXMuY29sbGlzaW9uU2hhcGUuY2VudGVyID0gdGhpcy5wb3NpdGlvbjtcclxuXHRcdH0gZWxzZSBpZiAoaXNSZWdpb24odGhpcykpIHtcclxuXHRcdFx0Ly8gSWYgdGhlIGdhbWVub2RlIGhhcyBhIHJlZ2lvbiBhbmQgbm8gb3RoZXIgaXMgc3BlY2lmaWVkLCB1c2UgdGhhdFxyXG5cdFx0XHR0aGlzLmNvbGxpc2lvblNoYXBlID0gKDxhbnk+dGhpcykuYm91bmRhcnkuY2xvbmUoKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRocm93IFwiTm8gY29sbGlzaW9uIHNoYXBlIHNwZWNpZmllZCBmb3IgcGh5c2ljcyBvYmplY3QuXCJcclxuXHRcdH1cclxuXHJcblx0XHQvLyBJZiB3ZSB3ZXJlIHByb3ZpZGVkIHdpdGggYSBjb2xsaWRlciBvZmZzZXQsIHNldCBpdC4gT3RoZXJ3aXNlIHRoZXJlIGlzIG5vIG9mZnNldCwgc28gdXNlIHRoZSB6ZXJvIHZlY3RvclxyXG5cdFx0aWYoY29sbGlkZXJPZmZzZXQpe1xyXG5cdFx0XHR0aGlzLmNvbGxpZGVyT2Zmc2V0ID0gY29sbGlkZXJPZmZzZXQ7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLmNvbGxpZGVyT2Zmc2V0ID0gVmVjMi5aRVJPO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEluaXRpYWxpemUgdGhlIHN3ZXB0IHJlY3RcclxuXHRcdHRoaXMuc3dlcHRSZWN0ID0gdGhpcy5jb2xsaXNpb25TaGFwZS5nZXRCb3VuZGluZ1JlY3QoKTtcclxuXHJcblx0XHQvLyBSZWdpc3RlciB0aGUgb2JqZWN0IHdpdGggcGh5c2ljc1xyXG5cdFx0dGhpcy5zY2VuZS5nZXRQaHlzaWNzTWFuYWdlcigpLnJlZ2lzdGVyT2JqZWN0KHRoaXMpO1xyXG5cdH1cclxuXHJcblx0LyoqIFJlbW92ZXMgdGhpcyBvYmplY3QgZnJvbSB0aGUgcGh5c2ljcyBzeXN0ZW0gKi9cclxuICAgIHJlbW92ZVBoeXNpY3MoKTogdm9pZCB7XHJcblx0XHQvLyBSZW1vdmUgdGhpcyBmcm9tIHRoZSBwaHlzaWNzIG1hbmFnZXJcclxuXHRcdHRoaXMuc2NlbmUuZ2V0UGh5c2ljc01hbmFnZXIoKS5kZXJlZ2lzdGVyT2JqZWN0KHRoaXMpO1xyXG5cclxuXHRcdC8vIE51bGxpZnkgYWxsIHBoeXNpY3MgZmllbGRzXHJcblx0XHR0aGlzLmhhc1BoeXNpY3MgPSBmYWxzZTtcclxuXHRcdHRoaXMubW92aW5nID0gZmFsc2U7XHJcblx0XHR0aGlzLm9uR3JvdW5kID0gZmFsc2U7XHJcblx0XHR0aGlzLm9uV2FsbCA9IGZhbHNlO1xyXG5cdFx0dGhpcy5vbkNlaWxpbmcgPSBmYWxzZTtcclxuXHRcdHRoaXMuYWN0aXZlID0gZmFsc2U7XHJcblx0XHR0aGlzLmlzQ29sbGlkYWJsZSA9IGZhbHNlO1xyXG5cdFx0dGhpcy5pc1N0YXRpYyA9IGZhbHNlO1xyXG5cdFx0dGhpcy5pc1RyaWdnZXIgPSBmYWxzZTtcclxuXHRcdHRoaXMudHJpZ2dlck1hc2sgPSAwO1xyXG5cdFx0dGhpcy50cmlnZ2VyRW50ZXJzID0gbnVsbDtcclxuXHRcdHRoaXMudHJpZ2dlckV4aXRzID0gbnVsbDtcclxuXHRcdHRoaXMuX3ZlbG9jaXR5ID0gVmVjMi5aRVJPO1xyXG5cdFx0dGhpcy5zd2VwdFJlY3QgPSBudWxsO1xyXG5cdFx0dGhpcy5jb2xsaWRlZFdpdGhUaWxlbWFwID0gZmFsc2U7XHJcblx0XHR0aGlzLmdyb3VwID0gLTE7XHJcblx0XHR0aGlzLmNvbGxpc2lvblNoYXBlID0gbnVsbDtcclxuXHRcdHRoaXMuY29sbGlkZXJPZmZzZXQgPSBWZWMyLlpFUk87XHJcblx0XHR0aGlzLnN3ZXB0UmVjdCA9IG51bGw7XHJcblx0fVxyXG5cclxuXHQvKiogRGlzYWJsZXMgcGh5c2ljcyBtb3ZlbWVudCBmb3IgdGhpcyBub2RlICovXHJcblx0ZnJlZXplKCk6IHZvaWQge1xyXG5cdFx0dGhpcy5mcm96ZW4gPSB0cnVlO1xyXG5cdH1cclxuXHJcblx0LyoqIFJlZW5hYmxlcyBwaHlzaWNzIG1vdmVtZW50IGZvciB0aGlzIG5vZGUgKi9cclxuXHR1bmZyZWV6ZSgpOiB2b2lkIHtcclxuXHRcdHRoaXMuZnJvemVuID0gZmFsc2U7XHJcblx0fVxyXG5cclxuICAgIC8qKiBQcmV2ZW50cyB0aGlzIG9iamVjdCBmcm9tIHBhcnRpY2lwYXRpbmcgaW4gYWxsIGNvbGxpc2lvbnMgYW5kIHRyaWdnZXJzLiBJdCBjYW4gc3RpbGwgbW92ZS4gKi9cclxuICAgIGRpc2FibGVQaHlzaWNzKCk6IHZvaWQge1xyXG5cdFx0dGhpcy5hY3RpdmUgPSBmYWxzZTtcclxuXHR9XHJcblxyXG4gICAgLyoqIEVuYWJsZXMgdGhpcyBvYmplY3QgdG8gcGFydGljaXBhdGUgaW4gY29sbGlzaW9ucyBhbmQgdHJpZ2dlcnMuIFRoaXMgaXMgb25seSBuZWNlc3NhcnkgaWYgZGlzYWJsZVBoeXNpY3Mgd2FzIGNhbGxlZCAqL1xyXG4gICAgZW5hYmxlUGh5c2ljcygpOiB2b2lkIHtcclxuXHRcdHRoaXMuYWN0aXZlID0gdHJ1ZTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldHMgdGhlIGNvbGxpZGVyIGZvciB0aGlzIEdhbWVOb2RlXHJcblx0ICogQHBhcmFtIGNvbGxpZGVyIFRoZSBuZXcgY29sbGlkZXIgdG8gdXNlXHJcblx0ICovXHJcblx0c2V0Q29sbGlzaW9uU2hhcGUoY29sbGlkZXI6IFNoYXBlKTogdm9pZCB7XHJcblx0XHR0aGlzLmNvbGxpc2lvblNoYXBlID0gY29sbGlkZXI7XHJcblx0XHR0aGlzLmNvbGxpc2lvblNoYXBlLmNlbnRlci5jb3B5KHRoaXMucG9zaXRpb24pO1xyXG5cdH1cclxuXHJcblx0Ly8gQGltcGxlbWVudGVkXHJcblx0LyoqXHJcbiAgICAgKiBTZXRzIHRoaXMgb2JqZWN0IHRvIGJlIGEgdHJpZ2dlciBmb3IgYSBzcGVjaWZpYyBncm91cFxyXG4gICAgICogQHBhcmFtIGdyb3VwIFRoZSBuYW1lIG9mIHRoZSBncm91cCB0aGF0IGFjdGl2YXRlcyB0aGUgdHJpZ2dlclxyXG4gICAgICogQHBhcmFtIG9uRW50ZXIgVGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIHNlbmQgd2hlbiB0aGlzIHRyaWdnZXIgaXMgYWN0aXZhdGVkXHJcbiAgICAgKiBAcGFyYW0gb25FeGl0IFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byBzZW5kIHdoZW4gdGhpcyB0cmlnZ2VyIHN0b3BzIGJlaW5nIGFjdGl2YXRlZFxyXG4gICAgICovXHJcbiAgICBzZXRUcmlnZ2VyKGdyb3VwOiBzdHJpbmcsIG9uRW50ZXI6IHN0cmluZywgb25FeGl0OiBzdHJpbmcpOiB2b2lkIHtcclxuXHRcdC8vIE1ha2UgdGhpcyBvYmplY3QgYSB0cmlnZ2VyXHJcblx0XHR0aGlzLmlzVHJpZ2dlciA9IHRydWU7XHJcblxyXG5cdFx0Ly8gR2V0IHRoZSBudW1iZXIgb2YgdGhlIHBoeXNpY3MgbGF5ZXJcclxuXHRcdGxldCBsYXllck51bWJlciA9IHRoaXMuc2NlbmUuZ2V0UGh5c2ljc01hbmFnZXIoKS5nZXRHcm91cE51bWJlcihncm91cCk7XHJcblxyXG5cdFx0aWYobGF5ZXJOdW1iZXIgPT09IDApe1xyXG5cdFx0XHRjb25zb2xlLndhcm4oYFRyaWdnZXIgZm9yIEdhbWVOb2RlICR7dGhpcy5pZH0gbm90IHNldCAtIGdyb3VwIFwiJHtncm91cH1cIiB3YXMgbm90IHJlY29nbml6ZWQgYnkgdGhlIHBoeXNpY3MgbWFuYWdlci5gKTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEFkZCB0aGlzIHRvIHRoZSB0cmlnZ2VyIG1hc2tcclxuXHRcdHRoaXMudHJpZ2dlck1hc2sgfD0gbGF5ZXJOdW1iZXI7XHJcblxyXG5cdFx0Ly8gTGF5ZXIgbnVtYmVycyBhcmUgYml0cywgc28gZ2V0IHdoaWNoIGJpdCBpdCBpc1xyXG5cdFx0bGV0IGluZGV4ID0gTWF0aC5sb2cyKGxheWVyTnVtYmVyKTtcclxuXHJcblx0XHQvLyBTZXQgdGhlIGV2ZW50IG5hbWVzXHJcblx0XHR0aGlzLnRyaWdnZXJFbnRlcnNbaW5kZXhdID0gb25FbnRlcjtcclxuXHRcdHRoaXMudHJpZ2dlckV4aXRzW2luZGV4XSA9IG9uRXhpdDtcclxuXHR9O1xyXG5cclxuXHQvLyBAaW1wbGVtZW50ZWRcclxuXHQvKipcclxuXHQgKiBAcGFyYW0gZ3JvdXAgVGhlIHBoeXNpY3MgZ3JvdXAgdGhpcyBub2RlIHNob3VsZCBiZWxvbmcgdG9cclxuXHQgKi9cclxuXHRzZXRHcm91cChncm91cDogc3RyaW5nKTogdm9pZCB7XHJcblx0XHR0aGlzLnNjZW5lLmdldFBoeXNpY3NNYW5hZ2VyKCkuc2V0R3JvdXAodGhpcywgZ3JvdXApO1xyXG5cdH1cclxuXHJcblx0Ly8gQGltcGxlbWVuZWRcclxuXHRnZXRMYXN0VmVsb2NpdHkoKTogVmVjMiB7XHJcblx0XHRyZXR1cm4gdGhpcy5fdmVsb2NpdHk7XHJcblx0fVxyXG5cclxuXHQvKi0tLS0tLS0tLS0gQUNUT1IgLS0tLS0tLS0tLSovXHJcblx0Z2V0IGFpKCk6IEFJIHwgR29hcEFJIHtcclxuXHRcdHJldHVybiB0aGlzLl9haTtcclxuXHR9XHJcblxyXG5cdHNldCBhaShhaTogQUkgfCBHb2FwQUkpIHtcclxuXHRcdGlmKCF0aGlzLl9haSl7XHJcblx0XHRcdC8vIElmIHdlIGhhdmVuJ3QgYmVlbiBwcmV2aW91c2x5IGhhZCBhbiBhaSwgcmVnaXN0ZXIgdXMgd2l0aCB0aGUgYWkgbWFuYWdlclxyXG5cdFx0XHR0aGlzLnNjZW5lLmdldEFJTWFuYWdlcigpLnJlZ2lzdGVyQWN0b3IodGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fYWkgPSBhaTtcclxuXHRcdHRoaXMuYWlBY3RpdmUgPSB0cnVlO1xyXG5cdH1cclxuXHJcblx0Ly8gQGltcGxlbWVudGVkXHJcblx0YWRkQUk8VCBleHRlbmRzIEFJIHwgR29hcEFJPihhaTogc3RyaW5nIHwgKG5ldyAoKSA9PiBUKSwgb3B0aW9ucz86IFJlY29yZDxzdHJpbmcsIGFueT4sIHR5cGU/OiBudW1iZXIpOiB2b2lkIHtcclxuXHRcdGlmKCF0aGlzLl9haSl7XHJcblx0XHRcdHRoaXMuc2NlbmUuZ2V0QUlNYW5hZ2VyKCkucmVnaXN0ZXJBY3Rvcih0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZih0eXBlb2YgYWkgPT09IFwic3RyaW5nXCIpe1xyXG5cdFx0XHR0aGlzLl9haSA9IHRoaXMuc2NlbmUuZ2V0QUlNYW5hZ2VyKCkuZ2VuZXJhdGVBSShhaSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLl9haSA9IG5ldyBhaSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFF1ZXN0aW9uLCBob3cgbXVjaCBkbyB3ZSB3YW50IGRpZmZlcmVudCB0eXBlIG9mIEFJIHRvIGJlIGhhbmRsZWQgdGhlIHNhbWUsIGkuZS4gc2hvdWxkIEdvYXBBSSBhbmQgQUkgc2ltaWxhciBtZXRob2RzIGFuZCBzaWduYXR1cmVzIGZvciB0aGUgc2FrZSBvZiB1bml0eVxyXG5cdFx0dGhpcy5fYWkuaW5pdGlhbGl6ZUFJKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuXHRcdHRoaXMuYWlBY3RpdmUgPSB0cnVlO1xyXG5cdH1cclxuXHJcblx0Ly8gQGltcGxlbWVudGVkXHJcblx0c2V0QUlBY3RpdmUoYWN0aXZlOiBib29sZWFuLCBvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogdm9pZCB7XHJcblx0XHR0aGlzLmFpQWN0aXZlID0gYWN0aXZlO1xyXG5cdFx0aWYodGhpcy5haUFjdGl2ZSl7XHJcblx0XHRcdHRoaXMuYWkuYWN0aXZhdGUob3B0aW9ucyk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvKi0tLS0tLS0tLS0gVFdFRU5BQkxFIFBST1BFUlRJRVMgLS0tLS0tLS0tLSovXHJcblx0c2V0IHBvc2l0aW9uWCh2YWx1ZTogbnVtYmVyKSB7XHJcblx0XHR0aGlzLnBvc2l0aW9uLnggPSB2YWx1ZTtcclxuXHR9XHJcblxyXG5cdHNldCBwb3NpdGlvblkodmFsdWU6IG51bWJlcikge1xyXG5cdFx0dGhpcy5wb3NpdGlvbi55ID0gdmFsdWU7XHJcblx0fVxyXG5cclxuXHRhYnN0cmFjdCBzZXQgc2NhbGVYKHZhbHVlOiBudW1iZXIpO1xyXG5cclxuXHRhYnN0cmFjdCBzZXQgc2NhbGVZKHZhbHVlOiBudW1iZXIpO1xyXG5cclxuXHQvKi0tLS0tLS0tLS0gR0FNRSBOT0RFIC0tLS0tLS0tLS0qL1xyXG5cdC8qKlxyXG5cdCAqIFNldHMgdGhlIHNjZW5lIGZvciB0aGlzIG9iamVjdC5cclxuXHQgKiBAcGFyYW0gc2NlbmUgVGhlIHNjZW5lIHRoaXMgb2JqZWN0IGJlbG9uZ3MgdG8uXHJcblx0ICovXHJcblx0c2V0U2NlbmUoc2NlbmU6IFNjZW5lKTogdm9pZCB7XHJcblx0XHR0aGlzLnNjZW5lID0gc2NlbmU7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBHZXRzIHRoZSBzY2VuZSB0aGlzIG9iamVjdCBpcyBpbi4gXHJcblx0ICogQHJldHVybnMgVGhlIHNjZW5lIHRoaXMgb2JqZWN0IGJlbG9uZ3MgdG9cclxuXHQqL1xyXG5cdGdldFNjZW5lKCk6IFNjZW5lIHtcclxuXHRcdHJldHVybiB0aGlzLnNjZW5lO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogU2V0cyB0aGUgbGF5ZXIgb2YgdGhpcyBvYmplY3QuXHJcblx0ICogQHBhcmFtIGxheWVyIFRoZSBsYXllciB0aGlzIG9iamVjdCB3aWxsIGJlIG9uLlxyXG5cdCAqL1xyXG5cdHNldExheWVyKGxheWVyOiBMYXllcik6IHZvaWQge1xyXG5cdFx0dGhpcy5sYXllciA9IGxheWVyO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0aGUgbGF5ZXIgdGhpcyBvYmplY3QgaXMgb24uXHJcblx0ICogQHJldHVybnMgVGhpcyBsYXllciB0aGlzIG9iamVjdCBpcyBvbi5cclxuXHQqL1xyXG5cdGdldExheWVyKCk6IExheWVyIHtcclxuXHRcdHJldHVybiB0aGlzLmxheWVyO1xyXG5cdH1cclxuXHJcblx0LyoqIENhbGxlZCBpZiB0aGUgcG9zaXRpb24gdmVjdG9yIGlzIG1vZGlmaWVkIG9yIHJlcGxhY2VkICovXHJcblx0cHJvdGVjdGVkIHBvc2l0aW9uQ2hhbmdlZCgpOiB2b2lkIHtcclxuXHRcdGlmKHRoaXMuY29sbGlzaW9uU2hhcGUpe1xyXG5cdFx0XHRpZih0aGlzLmNvbGxpZGVyT2Zmc2V0KXtcclxuXHRcdFx0XHR0aGlzLmNvbGxpc2lvblNoYXBlLmNlbnRlciA9IHRoaXMucG9zaXRpb24uY2xvbmUoKS5hZGQodGhpcy5jb2xsaWRlck9mZnNldCk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dGhpcy5jb2xsaXNpb25TaGFwZS5jZW50ZXIgPSB0aGlzLnBvc2l0aW9uLmNsb25lKCk7XHJcblx0XHRcdH1cclxuXHRcdFx0XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0LyoqXHJcblx0ICogVXBkYXRlcyB0aGlzIEdhbWVOb2RlXHJcblx0ICogQHBhcmFtIGRlbHRhVCBUaGUgdGltZXN0ZXAgb2YgdGhlIHVwZGF0ZS5cclxuXHQgKi9cclxuXHR1cGRhdGUoZGVsdGFUOiBudW1iZXIpOiB2b2lkIHtcclxuXHRcdC8vIERlZmVyIGV2ZW50IGhhbmRsaW5nIHRvIEFJLlxyXG5cdFx0d2hpbGUodGhpcy5yZWNlaXZlci5oYXNOZXh0RXZlbnQoKSl7XHJcblx0XHRcdHRoaXMuX2FpLmhhbmRsZUV2ZW50KHRoaXMucmVjZWl2ZXIuZ2V0TmV4dEV2ZW50KCkpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Ly8gQGltcGxlbWVudGVkXHJcblx0ZGVidWdSZW5kZXIoKTogdm9pZCB7XHJcblx0XHQvLyBEcmF3IHRoZSBwb3NpdGlvbiBvZiB0aGlzIEdhbWVOb2RlXHJcblx0XHREZWJ1Zy5kcmF3UG9pbnQodGhpcy5yZWxhdGl2ZVBvc2l0aW9uLCBDb2xvci5CTFVFKTtcclxuXHJcblx0XHQvLyBJZiB2ZWxvY2l0eSBpcyBub3QgemVybywgZHJhdyBhIHZlY3RvciBmb3IgaXRcclxuXHRcdGlmKHRoaXMuX3ZlbG9jaXR5ICYmICF0aGlzLl92ZWxvY2l0eS5pc1plcm8oKSl7XHJcblx0XHRcdERlYnVnLmRyYXdSYXkodGhpcy5yZWxhdGl2ZVBvc2l0aW9uLCB0aGlzLl92ZWxvY2l0eS5jbG9uZSgpLnNjYWxlVG8oMjApLmFkZCh0aGlzLnJlbGF0aXZlUG9zaXRpb24pLCBDb2xvci5CTFVFKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBJZiB0aGlzIGhhcyBhIGNvbGxpZGVyLCBkcmF3IGl0XHJcblx0XHRpZih0aGlzLmNvbGxpc2lvblNoYXBlKXtcclxuXHRcdFx0bGV0IGNvbG9yID0gdGhpcy5pc0NvbGxpZGluZyA/IENvbG9yLlJFRCA6IENvbG9yLkdSRUVOO1xyXG5cclxuXHRcdFx0aWYodGhpcy5pc1RyaWdnZXIpe1xyXG5cdFx0XHRcdGNvbG9yID0gQ29sb3IuTUFHRU5UQTtcclxuXHRcdFx0fVxyXG5cdFx0XHRcclxuXHRcdFx0Y29sb3IuYSA9IDAuMjtcclxuXHJcblx0XHRcdGlmKHRoaXMuY29sbGlzaW9uU2hhcGUgaW5zdGFuY2VvZiBBQUJCKXtcclxuXHRcdFx0XHREZWJ1Zy5kcmF3Qm94KHRoaXMuaW5SZWxhdGl2ZUNvb3JkaW5hdGVzKHRoaXMuY29sbGlzaW9uU2hhcGUuY2VudGVyKSwgdGhpcy5jb2xsaXNpb25TaGFwZS5oYWxmU2l6ZS5zY2FsZWQodGhpcy5zY2VuZS5nZXRWaWV3U2NhbGUoKSksIHRydWUsIGNvbG9yKTtcclxuXHRcdFx0fSBlbHNlIGlmKHRoaXMuY29sbGlzaW9uU2hhcGUgaW5zdGFuY2VvZiBDaXJjbGUpe1xyXG5cdFx0XHRcdERlYnVnLmRyYXdDaXJjbGUodGhpcy5pblJlbGF0aXZlQ29vcmRpbmF0ZXModGhpcy5jb2xsaXNpb25TaGFwZS5jZW50ZXIpLCB0aGlzLmNvbGxpc2lvblNoYXBlLmh3KnRoaXMuc2NlbmUuZ2V0Vmlld1NjYWxlKCksIHRydWUsIGNvbG9yKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxufVxyXG5cclxuZXhwb3J0IGVudW0gVHdlZW5hYmxlUHJvcGVydGllc3tcclxuXHRwb3NYID0gXCJwb3NpdGlvblhcIixcclxuXHRwb3NZID0gXCJwb3NpdGlvbllcIixcclxuXHRzY2FsZVggPSBcInNjYWxlWFwiLFxyXG5cdHNjYWxlWSA9IFwic2NhbGVZXCIsXHJcblx0cm90YXRpb24gPSBcInJvdGF0aW9uXCIsXHJcblx0YWxwaGEgPSBcImFscGhhXCJcclxufSIsImltcG9ydCBDYW52YXNOb2RlIGZyb20gXCIuL0NhbnZhc05vZGVcIjtcclxuaW1wb3J0IENvbG9yIGZyb20gXCIuLi9VdGlscy9Db2xvclwiO1xyXG5cclxuLyoqXHJcbiAqIFRoZSByZXByZXNlbnRhdGlvbiBvZiBhIGdhbWUgb2JqZWN0IHRoYXQgZG9lc24ndCByZWx5IG9uIGFueSByZXNvdXJjZXMgdG8gcmVuZGVyIC0gaXQgaXMgZHJhd24gdG8gdGhlIHNjcmVlbiBieSB0aGUgY2FudmFzXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBhYnN0cmFjdCBjbGFzcyBHcmFwaGljIGV4dGVuZHMgQ2FudmFzTm9kZSB7XHJcbiAgICAvKiogVGhlIGNvbG9yIG9mIHRoZSBHcmFwaGljICovXHJcbiAgICBjb2xvcjogQ29sb3I7XHJcblxyXG4gICAgY29uc3RydWN0b3IoKXtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuY29sb3IgPSBDb2xvci5SRUQ7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IGFscGhhKCk6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gdGhpcy5jb2xvci5hO1xyXG5cdH1cclxuXHJcblx0c2V0IGFscGhhKGE6IG51bWJlcikge1xyXG5cdFx0dGhpcy5jb2xvci5hID0gYTtcclxuXHR9XHJcblxyXG4gICAgLy8gQGRlcHJlY2F0ZWRcclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgY29sb3Igb2YgdGhlIEdyYXBoaWMuIERFUFJFQ0FURURcclxuICAgICAqIEBwYXJhbSBjb2xvciBUaGUgbmV3IGNvbG9yIG9mIHRoZSBHcmFwaGljLlxyXG4gICAgICovXHJcbiAgICBzZXRDb2xvcihjb2xvcjogQ29sb3Ipe1xyXG4gICAgICAgIHRoaXMuY29sb3IgPSBjb2xvcjtcclxuICAgIH1cclxuXHJcbiAgICBzZXQgY29sb3JSKHI6IG51bWJlcil7XHJcbiAgICAgICAgdGhpcy5jb2xvci5yID0gcjtcclxuICAgIH1cclxuXHJcbiAgICBnZXQgY29sb3JSKCk6IG51bWJlciB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sb3IucjtcclxuICAgIH1cclxuXHJcbiAgICBzZXQgY29sb3JHKGc6IG51bWJlcil7XHJcbiAgICAgICAgdGhpcy5jb2xvci5nID0gZztcclxuICAgIH1cclxuXHJcbiAgICBnZXQgY29sb3JHKCk6IG51bWJlciB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sb3IuZztcclxuICAgIH1cclxuXHJcbiAgICBzZXQgY29sb3JCKGI6IG51bWJlcil7XHJcbiAgICAgICAgdGhpcy5jb2xvci5iID0gYjtcclxuICAgIH1cclxuXHJcbiAgICBnZXQgY29sb3JCKCk6IG51bWJlciB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sb3IuYjtcclxuICAgIH1cclxufSIsImV4cG9ydCBlbnVtIEdyYXBoaWNUeXBlIHtcclxuXHRQT0lOVCA9IFwiUE9JTlRcIixcclxuXHRSRUNUID0gXCJSRUNUXCIsXHJcblx0TElORSA9IFwiTElORVwiLFxyXG5cdFBBUlRJQ0xFID0gXCJQQVJUSUNMRVwiXHJcbn0iLCJpbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL1ZlYzJcIjtcclxuaW1wb3J0IEdyYXBoaWMgZnJvbSBcIi4uL0dyYXBoaWNcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExpbmUgZXh0ZW5kcyBHcmFwaGljIHtcclxuICAgIHByb3RlY3RlZCBfZW5kOiBWZWMyO1xyXG4gICAgdGhpY2tuZXNzOiBudW1iZXI7XHJcblxyXG4gICAgY29uc3RydWN0b3Ioc3RhcnQ6IFZlYzIsIGVuZDogVmVjMil7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XHJcbiAgICAgICAgdGhpcy5lbmQgPSBlbmQ7XHJcbiAgICAgICAgdGhpcy50aGlja25lc3MgPSAyO1xyXG5cclxuICAgICAgICAvLyBEb2VzIHRoaXMgcmVhbGx5IGhhdmUgYSBtZWFuaW5nIGZvciBsaW5lcz9cclxuICAgICAgICB0aGlzLnNpemUuc2V0KDUsIDUpO1xyXG4gICAgfVxyXG5cclxuICAgIHNldCBzdGFydChwb3M6IFZlYzIpe1xyXG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBwb3M7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IHN0YXJ0KCk6IFZlYzIge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBvc2l0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIHNldCBlbmQocG9zOiBWZWMyKXtcclxuICAgICAgICB0aGlzLl9lbmQgPSBwb3M7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IGVuZCgpOiBWZWMyIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZW5kO1xyXG4gICAgfVxyXG59IiwiaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9WZWMyXCI7XHJcbmltcG9ydCBQb2ludCBmcm9tIFwiLi9Qb2ludFwiO1xyXG5cclxuLyoqXHJcbiAqIC0gUG9zaXRpb24gWFxyXG4tIFZlbG9jaXR5IChzcGVlZCBhbmQgZGlyZWN0aW9uKSBYXHJcbi0gQ29sb3IgWFxyXG4tIExpZmV0aW1lIFxyXG4tIEFnZSBjYW4gYmUgaGFuZGxlZCBhcyBsaWZldGltZVxyXG4tIFNoYXBlIFhcclxuLSBTaXplIFhcclxuLSBUcmFuc3BhcmVuY3kgWFxyXG4gKi9cclxuXHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQYXJ0aWNsZSBleHRlbmRzIFBvaW50IHtcclxuICAgIGFnZTogbnVtYmVyO1xyXG5cclxuICAgIGluVXNlOiBib29sZWFuO1xyXG5cclxuICAgIHZlbDogVmVjMjtcclxuXHJcbiAgICBtYXNzOiBudW1iZXI7XHJcblxyXG4gICAgY29uc3RydWN0b3IocG9zaXRpb246IFZlYzIsIHNpemU6IFZlYzIsIG1hc3M6IG51bWJlcikge1xyXG4gICAgICAgIC8vIEFyZSB3ZSBtYWtpbmcgdGhpcyBhIGNpcmNsZT9cclxuICAgICAgICBzdXBlcihwb3NpdGlvbik7XHJcbiAgICAgICAgdGhpcy5pblVzZSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMubWFzcyA9IG1hc3M7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0UGFydGljbGVBY3RpdmUobGlmZXRpbWU6IG51bWJlciwgcG9zaXRpb246IFZlYzIpIHtcclxuICAgICAgICB0aGlzLmFnZSA9IGxpZmV0aW1lO1xyXG4gICAgICAgIHRoaXMuaW5Vc2UgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMudmlzaWJsZSA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHBvc2l0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIGRlY3JlbWVudEFnZShkZWNheTogbnVtYmVyKSB7XHJcbiAgICAgICAgdGhpcy5hZ2UgLT0gZGVjYXk7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0UGFydGljbGVJbmFjdGl2ZSgpe1xyXG4gICAgICAgIHRoaXMuaW5Vc2UgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnZpc2libGUgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBzZXQgdmVsWSh5OiBudW1iZXIpe1xyXG4gICAgICAgIHRoaXMudmVsLnkgPSB5O1xyXG4gICAgfVxyXG5cclxuICAgIGdldCB2ZWxZKCk6IG51bWJlciB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmVsLnk7XHJcbiAgICB9XHJcblxyXG5cclxufSIsImltcG9ydCBHcmFwaGljIGZyb20gXCIuLi9HcmFwaGljXCI7XHJcbmltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvVmVjMlwiO1xyXG5cclxuLyoqIEEgYmFzaWMgcG9pbnQgdG8gYmUgZHJhd24gb24gdGhlIHNjcmVlbi4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUG9pbnQgZXh0ZW5kcyBHcmFwaGljIHtcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcihwb3NpdGlvbjogVmVjMikge1xyXG4gICAgICAgIC8vIEFyZSB3ZSBtYWtpbmcgdGhpcyBhIGNpcmNsZT9cclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBwb3NpdGlvbjtcclxuICAgICAgICB0aGlzLnNpemUuc2V0KDUsIDUpO1xyXG4gICAgfVxyXG59IiwiaW1wb3J0IEdyYXBoaWMgZnJvbSBcIi4uL0dyYXBoaWNcIjtcclxuaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9WZWMyXCI7XHJcbmltcG9ydCBDb2xvciBmcm9tIFwiLi4vLi4vVXRpbHMvQ29sb3JcIjtcclxuXHJcbi8qKiBBIGJhc2ljIHJlY3RhbmdsZSB0byBiZSBkcmF3biBvbiB0aGUgc2NyZWVuLiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZWN0IGV4dGVuZHMgR3JhcGhpYyB7XHJcblxyXG4gICAgLyoqIFRoZSBib3JkZXIgY29sb3Igb2YgdGhlIFJlY3QgKi9cclxuICAgIGJvcmRlckNvbG9yOiBDb2xvcjtcclxuXHJcbiAgICAvKiogVGhlIHdpZHRoIG9mIHRoZSBib3JkZXIgKi9cclxuICAgIGJvcmRlcldpZHRoOiBudW1iZXI7XHJcblxyXG4gICAgY29uc3RydWN0b3IocG9zaXRpb246IFZlYzIsIHNpemU6IFZlYzIpe1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHBvc2l0aW9uO1xyXG4gICAgICAgIHRoaXMuc2l6ZSA9IHNpemU7XHJcbiAgICAgICAgdGhpcy5ib3JkZXJDb2xvciA9IENvbG9yLlRSQU5TUEFSRU5UO1xyXG4gICAgICAgIHRoaXMuYm9yZGVyV2lkdGggPSAwO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgYm9yZGVyIGNvbG9yIG9mIHRoaXMgcmVjdGFuZ2xlXHJcbiAgICAgKiBAcGFyYW0gY29sb3IgVGhlIGJvcmRlciBjb2xvclxyXG4gICAgICovXHJcbiAgICBzZXRCb3JkZXJDb2xvcihjb2xvcjogQ29sb3IpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmJvcmRlckNvbG9yID0gY29sb3I7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQGRlcHJlY2F0ZWRcclxuICAgIGdldEJvcmRlckNvbG9yKCk6IENvbG9yIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ib3JkZXJDb2xvcjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGJvcmRlciB3aWR0aCBvZiB0aGlzIHJlY3RhbmdsZVxyXG4gICAgICogQHBhcmFtIHdpZHRoIFRoZSB3aWR0aCBvZiB0aGUgcmVjdGFuZ2xlIGluIHBpeGVsc1xyXG4gICAgICovXHJcbiAgICBzZXRCb3JkZXJXaWR0aCh3aWR0aDogbnVtYmVyKXtcclxuICAgICAgICB0aGlzLmJvcmRlcldpZHRoID0gd2lkdGg7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0Qm9yZGVyV2lkdGgoKTogbnVtYmVyIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ib3JkZXJXaWR0aDtcclxuICAgIH1cclxufSIsImltcG9ydCBTcHJpdGUgZnJvbSBcIi4vU3ByaXRlXCI7XHJcbmltcG9ydCBBbmltYXRpb25NYW5hZ2VyIGZyb20gXCIuLi8uLi9SZW5kZXJpbmcvQW5pbWF0aW9ucy9BbmltYXRpb25NYW5hZ2VyXCI7XHJcbmltcG9ydCBTcHJpdGVzaGVldCBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL1Nwcml0ZXNoZWV0XCI7XHJcbmltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvVmVjMlwiO1xyXG5cclxuLyoqIEFuIHNwcml0ZSB3aXRoIHNwZWNpZmllZCBhbmltYXRpb24gZnJhbWVzLiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBbmltYXRlZFNwcml0ZSBleHRlbmRzIFNwcml0ZSB7XHJcbiAgICAvKiogVGhlIG51bWJlciBvZiBjb2x1bW5zIGluIHRoaXMgc3ByaXRlIHNoZWV0ICovXHJcbiAgICBwcm90ZWN0ZWQgbnVtQ29sczogbnVtYmVyO1xyXG5cclxuICAgIGdldCBjb2xzKCk6IG51bWJlciB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubnVtQ29scztcclxuICAgIH1cclxuXHJcbiAgICAvKiogVGhlIG51bWJlciBvZiByb3dzIGluIHRoaXMgc3ByaXRlIHNoZWV0ICovXHJcbiAgICBwcm90ZWN0ZWQgbnVtUm93czogbnVtYmVyO1xyXG5cclxuICAgIGdldCByb3dzKCk6IG51bWJlciB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubnVtUm93cztcclxuICAgIH1cclxuXHJcbiAgICAvKiogVGhlIGFuaW1hdGlvbk1hbmFnZXIgZm9yIHRoaXMgc3ByaXRlICovXHJcbiAgICBhbmltYXRpb246IEFuaW1hdGlvbk1hbmFnZXI7XHJcblxyXG4gICAgY29uc3RydWN0b3Ioc3ByaXRlc2hlZXQ6IFNwcml0ZXNoZWV0KXtcclxuICAgICAgICBzdXBlcihzcHJpdGVzaGVldC5uYW1lKTtcclxuICAgICAgICB0aGlzLm51bUNvbHMgPSBzcHJpdGVzaGVldC5jb2x1bW5zO1xyXG4gICAgICAgIHRoaXMubnVtUm93cyA9IHNwcml0ZXNoZWV0LnJvd3M7XHJcblxyXG4gICAgICAgIC8vIFNldCB0aGUgc2l6ZSBvZiB0aGUgc3ByaXRlIHRvIHRoZSBzcHJpdGUgc2l6ZSBzcGVjaWZpZWQgYnkgdGhlIHNwcml0ZXNoZWV0XHJcbiAgICAgICAgdGhpcy5zaXplLnNldChzcHJpdGVzaGVldC5zcHJpdGVXaWR0aCwgc3ByaXRlc2hlZXQuc3ByaXRlSGVpZ2h0KTtcclxuXHJcbiAgICAgICAgdGhpcy5hbmltYXRpb24gPSBuZXcgQW5pbWF0aW9uTWFuYWdlcih0aGlzKTtcclxuXHJcbiAgICAgICAgLy8gQWRkIHRoZSBhbmltYXRpb25zIHRvIHRoZSBhbmltYXRlZCBzcHJpdGVcclxuICAgICAgICBmb3IobGV0IGFuaW1hdGlvbiBvZiBzcHJpdGVzaGVldC5hbmltYXRpb25zKXtcclxuICAgICAgICAgICAgdGhpcy5hbmltYXRpb24uYWRkKGFuaW1hdGlvbi5uYW1lLCBhbmltYXRpb24pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIGltYWdlIG9mZnNldCBmb3IgdGhlIGN1cnJlbnQgaW5kZXggb2YgYW5pbWF0aW9uXHJcbiAgICAgKiBAcGFyYW0gaW5kZXggVGhlIGluZGV4IHdlJ3JlIGF0IGluIHRoZSBhbmltYXRpb25cclxuICAgICAqIEByZXR1cm5zIEEgVmVjMiBjb250YWluaW5nIHRoZSBpbWFnZSBvZmZzZXRcclxuICAgICAqL1xyXG4gICAgZ2V0QW5pbWF0aW9uT2Zmc2V0KGluZGV4OiBudW1iZXIpOiBWZWMyIHtcclxuICAgICAgICByZXR1cm4gbmV3IFZlYzIoKGluZGV4ICUgdGhpcy5udW1Db2xzKSAqIHRoaXMuc2l6ZS54LCBNYXRoLmZsb29yKGluZGV4IC8gdGhpcy5udW1Db2xzKSAqIHRoaXMuc2l6ZS55KTtcclxuICAgIH1cclxufSIsImltcG9ydCBDYW52YXNOb2RlIGZyb20gXCIuLi9DYW52YXNOb2RlXCI7XHJcbmltcG9ydCBSZXNvdXJjZU1hbmFnZXIgZnJvbSBcIi4uLy4uL1Jlc291cmNlTWFuYWdlci9SZXNvdXJjZU1hbmFnZXJcIjtcclxuaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9WZWMyXCI7XHJcblxyXG4vKipcclxuICogVGhlIHJlcHJlc2VudGF0aW9uIG9mIGEgc3ByaXRlIC0gYW4gaW4tZ2FtZSBpbWFnZVxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3ByaXRlIGV4dGVuZHMgQ2FudmFzTm9kZSB7XHJcbiAgICAvKiogVGhlIGlkIG9mIHRoZSBpbWFnZSBmcm9tIHRoZSByZXNvdXJjZU1hbmFnZXIgKi9cclxuICAgIGltYWdlSWQ6IHN0cmluZztcclxuICAgIC8qKiBUaGUgb2Zmc2V0IG9mIHRoZSBzcHJpdGUgaW4gYW4gYXRsYXMgaW1hZ2UgKi9cclxuICAgIGltYWdlT2Zmc2V0OiBWZWMyO1xyXG4gICAgLyoqIFdoZXRoZXIgb3Igbm90IHRoZSB4LWF4aXMgc2hvdWxkIGJlIGludmVydGVkIG9uIHJlbmRlciAqL1xyXG4gICAgaW52ZXJ0WDogYm9vbGVhbjtcclxuICAgIC8qKiBXaGV0aGVyIG9yIG5vdCB0aGUgeS1heGlzIHNob3VsZCBiZSBpbnZlcnRlZCBvbiByZW5kZXIgKi9cclxuICAgIGludmVydFk6IGJvb2xlYW47XHJcblxyXG4gICAgY29uc3RydWN0b3IoaW1hZ2VJZDogc3RyaW5nKXtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuaW1hZ2VJZCA9IGltYWdlSWQ7XHJcbiAgICAgICAgbGV0IGltYWdlID0gUmVzb3VyY2VNYW5hZ2VyLmdldEluc3RhbmNlKCkuZ2V0SW1hZ2UodGhpcy5pbWFnZUlkKTtcclxuICAgICAgICB0aGlzLnNpemUgPSBuZXcgVmVjMihpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0KTtcclxuICAgICAgICB0aGlzLmltYWdlT2Zmc2V0ID0gVmVjMi5aRVJPO1xyXG4gICAgICAgIHRoaXMuaW52ZXJ0WCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuaW52ZXJ0WSA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgb2Zmc2V0IG9mIHRoZSBzcHJpdGUgZnJvbSAoMCwgMCkgaW4gdGhlIGltYWdlJ3MgY29vcmRpbmF0ZXNcclxuICAgICAqIEBwYXJhbSBvZmZzZXQgVGhlIG9mZnNldCBvZiB0aGUgc3ByaXRlIGZyb20gKDAsIDApIGluIGltYWdlIGNvb3JkaW5hdGVzXHJcbiAgICAgKi9cclxuICAgIHNldEltYWdlT2Zmc2V0KG9mZnNldDogVmVjMik6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuaW1hZ2VPZmZzZXQgPSBvZmZzZXQ7XHJcbiAgICB9XHJcbn0iLCJpbXBvcnQgVmVjMiBmcm9tIFwiLi4vRGF0YVR5cGVzL1ZlYzJcIjtcclxuaW1wb3J0IFRpbGVzZXQgZnJvbSBcIi4uL0RhdGFUeXBlcy9UaWxlc2V0cy9UaWxlc2V0XCI7XHJcbmltcG9ydCB7IFRpbGVkVGlsZW1hcERhdGEsIFRpbGVkTGF5ZXJEYXRhIH0gZnJvbSBcIi4uL0RhdGFUeXBlcy9UaWxlc2V0cy9UaWxlZERhdGFcIlxyXG5pbXBvcnQgQ2FudmFzTm9kZSBmcm9tIFwiLi9DYW52YXNOb2RlXCI7XHJcbmltcG9ydCBQaHlzaWNzTWFuYWdlciBmcm9tIFwiLi4vUGh5c2ljcy9QaHlzaWNzTWFuYWdlclwiO1xyXG5cclxuLyoqXHJcbiAqIFRoZSByZXByZXNlbnRhdGlvbiBvZiBhIHRpbGVtYXAgLSB0aGlzIGNhbiBjb25zaXN0IG9mIGEgY29tYmluYXRpb24gb2YgdGlsZXNldHMgaW4gb25lIGxheWVyXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBhYnN0cmFjdCBjbGFzcyBUaWxlbWFwIGV4dGVuZHMgQ2FudmFzTm9kZSB7XHJcbiAgICAvKiogQW4gYXJyYXkgb2YgdGhlIHRpbGVzZXRzIHRoYXQgdGhpcyB0aWxlbWFwIHVzZXMgKi9cclxuICAgIHByb3RlY3RlZCB0aWxlc2V0czogQXJyYXk8VGlsZXNldD47XHJcblxyXG4gICAgLyoqIFRoZSBzaXplIG9mIGEgdGlsZSBpbiB0aGlzIHRpbGVtYXAgKi9cclxuICAgIHByb3RlY3RlZCB0aWxlU2l6ZTogVmVjMjtcclxuXHJcbiAgICAvKiogQW4gYXJyYXkgb2YgdGlsZSBkYXRhICovXHJcbiAgICBwcm90ZWN0ZWQgZGF0YTogQXJyYXk8bnVtYmVyPjtcclxuXHJcbiAgICAvKiogQW4gYXJyYXkgb2YgdGlsZSBjb2xsaXNpb24gZGF0YSAqL1xyXG4gICAgcHJvdGVjdGVkIGNvbGxpc2lvbk1hcDogQXJyYXk8Ym9vbGVhbj47XHJcblxyXG4gICAgLyoqIFRoZSBuYW1lIG9mIHRoZSB0aWxlbWFwICovXHJcbiAgICBuYW1lOiBzdHJpbmc7XHJcblxyXG4gICAgLy8gVE9ETzogTWFrZSB0aGlzIG5vIGxvbmdlciBiZSBzcGVjaWZpYyB0byBUaWxlZFxyXG4gICAgY29uc3RydWN0b3IodGlsZW1hcERhdGE6IFRpbGVkVGlsZW1hcERhdGEsIGxheWVyOiBUaWxlZExheWVyRGF0YSwgdGlsZXNldHM6IEFycmF5PFRpbGVzZXQ+LCBzY2FsZTogVmVjMikge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy50aWxlc2V0cyA9IHRpbGVzZXRzO1xyXG4gICAgICAgIHRoaXMudGlsZVNpemUgPSBuZXcgVmVjMigwLCAwKTtcclxuICAgICAgICB0aGlzLm5hbWUgPSBsYXllci5uYW1lO1xyXG5cclxuICAgICAgICBsZXQgdGlsZWNvdW50ID0gMDtcclxuICAgICAgICBmb3IobGV0IHRpbGVzZXQgb2YgdGlsZXNldHMpe1xyXG4gICAgICAgICAgICB0aWxlY291bnQgKz0gdGlsZXNldC5nZXRUaWxlQ291bnQoKSArIDE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmNvbGxpc2lvbk1hcCA9IG5ldyBBcnJheSh0aWxlY291bnQpO1xyXG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCB0aGlzLmNvbGxpc2lvbk1hcC5sZW5ndGg7IGkrKyl7XHJcbiAgICAgICAgICAgIHRoaXMuY29sbGlzaW9uTWFwW2ldID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBEZWZlciBwYXJzaW5nIG9mIHRoZSBkYXRhIHRvIGNoaWxkIGNsYXNzZXMgLSB0aGlzIGFsbG93cyBmb3IgaXNvbWV0cmljIHZzLiBvcnRob2dyYXBoaWMgdGlsZW1hcHMgYW5kIGhhbmRsaW5nIG9mIFRpbGVkIGRhdGEgb3Igb3RoZXIgZGF0YVxyXG4gICAgICAgIHRoaXMucGFyc2VUaWxlbWFwRGF0YSh0aWxlbWFwRGF0YSwgbGF5ZXIpO1xyXG4gICAgICAgIHRoaXMuc2NhbGUuc2V0KHNjYWxlLngsIHNjYWxlLnkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhbiBhcnJheSBvZiB0aGUgdGlsZXNldHMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgdGlsZW1hcFxyXG4gICAgICogQHJldHVybnMgQW4gYXJyYXkgb2YgYWxsIG9mIHRoZSB0aWxlc2V0cyBhc3NvY2FpdGVkIHdpdGggdGhpcyB0aWxlbWFwLlxyXG4gICAgICovXHJcbiAgICBnZXRUaWxlc2V0cygpOiBUaWxlc2V0W10ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRpbGVzZXRzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgc2l6ZSBvZiB0aWxlcyBpbiB0aGlzIHRpbGVtYXAgYXMgdGhleSBhcHBlYXIgaW4gdGhlIGdhbWUgd29ybGQgYWZ0ZXIgc2NhbGluZ1xyXG4gICAgICogQHJldHVybnMgQSB2ZWN0b3IgY29udGFpbmluZyB0aGUgc2l6ZSBvZiB0aWxlcyBpbiB0aGlzIHRpbGVtYXAgYXMgdGhleSBhcHBlYXIgaW4gdGhlIGdhbWUgd29ybGQgYWZ0ZXIgc2NhbGluZy5cclxuICAgICAqL1xyXG4gICAgZ2V0VGlsZVNpemUoKTogVmVjMiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudGlsZVNpemUuc2NhbGVkKHRoaXMuc2NhbGUueCwgdGhpcy5zY2FsZS55KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIHRpbGUgc2l6ZSB0YWtpbmcgem9vbSBpbnRvIGFjY291bnRcclxuICAgICAqIEByZXR1cm5zIFRoZSB0aWxlIHNpemUgd2l0aCB6b29tXHJcbiAgICAqL1xyXG4gICAgZ2V0VGlsZVNpemVXaXRoWm9vbSgpOiBWZWMyIHtcclxuICAgICAgICBsZXQgem9vbSA9IHRoaXMuc2NlbmUuZ2V0Vmlld1NjYWxlKCk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLmdldFRpbGVTaXplKCkuc2NhbGUoem9vbSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIHRoaXMgdGlsZW1hcCB0byB0aGUgcGh5c2ljcyBzeXN0ZW1cclxuICAgICovXHJcbiAgICBhZGRQaHlzaWNzKCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuaGFzUGh5c2ljcyA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuZ3JvdXAgPSAtMTtcclxuICAgICAgICB0aGlzLnNjZW5lLmdldFBoeXNpY3NNYW5hZ2VyKCkucmVnaXN0ZXJUaWxlbWFwKHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIHRpbGUgYXQgdGhlIHNwZWNpZmllZCBwb3NpdGlvblxyXG4gICAgICogQHBhcmFtIHdvcmxkQ29vcmRzIFRoZSBwb3NpdGlvbiBpbiB3b3JsZCBjb29yZGluYXRlc1xyXG4gICAgICogQHJldHVybnMgQSBudW1iZXIgdGhhdCByZXByZXNlbnRzIHRoZSBkYXRhIHZhbHVlIG9mIHRoZSB0aWxlIGF0IHRoZSBzcGVjaWZpZWQgd29ybGQgcG9zaXRpb24uXHJcbiAgICAgKi9cclxuICAgIGFic3RyYWN0IGdldFRpbGVBdFdvcmxkUG9zaXRpb24od29ybGRDb29yZHM6IFZlYzIpOiBudW1iZXI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSB3b3JsZCBwb3NpdGlvbiBvZiB0aGUgdG9wIGxlZnQgY29ybmVyIG9mIHRoZSB0aWxlIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXhcclxuICAgICAqIEBwYXJhbSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIHRpbGUgaW4gdGhlIHRpbGVEYXRhIGFycmF5XHJcbiAgICAgKiBAcmV0dXJucyBUaGUgd29ybGQgcG9zaXRpb24gb2YgdGhlIHRpbGUgYXQgdGhlIHNwZWNpZmllZCBpbmRleFxyXG4gICAgICovXHJcbiAgICBhYnN0cmFjdCBnZXRUaWxlV29ybGRQb3NpdGlvbihpbmRleDogbnVtYmVyKTogVmVjMjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSB0aWxlIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXhcclxuICAgICAqIEBwYXJhbSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIHRpbGUgaW4gdGhlIHRpbGVEYXRhIGFycmF5XHJcbiAgICAgKiBAcmV0dXJucyBUaGUgdmFsdWUgb2YgdGhlIHRpbGUgaW4gdGhlIHRpbGVEYXRhIGFycmF5XHJcbiAgICAgKi9cclxuICAgIGFic3RyYWN0IGdldFRpbGUoaW5kZXg6IG51bWJlcik6IG51bWJlcjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIHRpbGUgYXQgdGhlIHNwZWNpZmllZCBpbmRleFxyXG4gICAgICogQHBhcmFtIGluZGV4IFRoZSBpbmRleCBvZiB0aGUgdGlsZVxyXG4gICAgICogQHBhcmFtIHR5cGUgVGhlIG5ldyBkYXRhIHZhbHVlIG9mIHRoZSB0aWxlXHJcbiAgICAgKi9cclxuICAgIGFic3RyYWN0IHNldFRpbGUoaW5kZXg6IG51bWJlciwgdHlwZTogbnVtYmVyKTogdm9pZDtcclxuXHJcbiAgICAvLyBUT0RPOiBUaGlzIHNob3VsZG4ndCB1c2UgdGlsZWQgZGF0YSBzcGVjaWZpY2FsbHkgLSBpdCBzaG91bGQgYmUgbW9yZSBnZW5lcmFsXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdXAgdGhlIHRpbGVzZXQgdXNpbmcgdGhlIGRhdGEgbG9hZGVkIGZyb20gZmlsZVxyXG4gICAgICogQHBhcmFtIHRpbGVtYXBEYXRhIFRoZSB0aWxlbWFwIGRhdGEgZnJvbSBmaWxlXHJcbiAgICAgKiBAcGFyYW0gbGF5ZXIgVGhlIGxheWVyIGRhdGEgZnJvbSBmaWxlXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBhYnN0cmFjdCBwYXJzZVRpbGVtYXBEYXRhKHRpbGVtYXBEYXRhOiBUaWxlZFRpbGVtYXBEYXRhLCBsYXllcjogVGlsZWRMYXllckRhdGEpOiB2b2lkO1xyXG59IiwiaW1wb3J0IFRpbGVtYXAgZnJvbSBcIi4uL1RpbGVtYXBcIjtcclxuaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9WZWMyXCI7XHJcbmltcG9ydCB7IFRpbGVkVGlsZW1hcERhdGEsIFRpbGVkTGF5ZXJEYXRhIH0gZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9UaWxlc2V0cy9UaWxlZERhdGFcIjtcclxuaW1wb3J0IERlYnVnIGZyb20gXCIuLi8uLi9EZWJ1Zy9EZWJ1Z1wiO1xyXG5pbXBvcnQgQ29sb3IgZnJvbSBcIi4uLy4uL1V0aWxzL0NvbG9yXCI7XHJcblxyXG4vKipcclxuICogVGhlIHJlcHJlc2VudGF0aW9uIG9mIGFuIG9ydGhvZ29uYWwgdGlsZW1hcCAtIGkuZS4gYSB0b3AgZG93biBvciBwbGF0Zm9ybWVyIHRpbGVtYXBcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE9ydGhvZ29uYWxUaWxlbWFwIGV4dGVuZHMgVGlsZW1hcCB7XHJcbiAgICAvKiogVGhlIG51bWJlciBvZiBjb2x1bW5zIGluIHRoZSB0aWxlbWFwICovXHJcbiAgICBwcm90ZWN0ZWQgbnVtQ29sczogbnVtYmVyO1xyXG4gICAgLyoqIFRoZSBudW1iZXIgb2Ygcm93cyBpbiB0aGUgdGlsZW1hcCAqL1xyXG4gICAgcHJvdGVjdGVkIG51bVJvd3M6IG51bWJlcjtcclxuXHJcbiAgICAvLyBAb3ZlcnJpZGVcclxuICAgIHByb3RlY3RlZCBwYXJzZVRpbGVtYXBEYXRhKHRpbGVtYXBEYXRhOiBUaWxlZFRpbGVtYXBEYXRhLCBsYXllcjogVGlsZWRMYXllckRhdGEpOiB2b2lkIHtcclxuICAgICAgICAvLyBUaGUgc2l6ZSBvZiB0aGUgdGlsZW1hcCBpbiBsb2NhbCBzcGFjZVxyXG4gICAgICAgIHRoaXMubnVtQ29scyA9IHRpbGVtYXBEYXRhLndpZHRoO1xyXG4gICAgICAgIHRoaXMubnVtUm93cyA9IHRpbGVtYXBEYXRhLmhlaWdodDtcclxuXHJcbiAgICAgICAgLy8gVGhlIHNpemUgb2YgdGlsZXNcclxuICAgICAgICB0aGlzLnRpbGVTaXplLnNldCh0aWxlbWFwRGF0YS50aWxld2lkdGgsIHRpbGVtYXBEYXRhLnRpbGVoZWlnaHQpO1xyXG5cclxuICAgICAgICAvLyBUaGUgc2l6ZSBvZiB0aGUgdGlsZW1hcCBvbiB0aGUgY2FudmFzXHJcbiAgICAgICAgdGhpcy5zaXplLnNldCh0aGlzLm51bUNvbHMgKiB0aGlzLnRpbGVTaXplLngsIHRoaXMubnVtUm93cyAqIHRoaXMudGlsZVNpemUueSk7XHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbi5jb3B5KHRoaXMuc2l6ZS5zY2FsZWQoMC41KSk7XHJcbiAgICAgICAgdGhpcy5kYXRhID0gbGF5ZXIuZGF0YTtcclxuICAgICAgICB0aGlzLnZpc2libGUgPSBsYXllci52aXNpYmxlO1xyXG5cclxuICAgICAgICAvLyBXaGV0aGVyIHRoZSB0aWxlbWFwIGlzIGNvbGxpZGFibGUgb3Igbm90XHJcbiAgICAgICAgdGhpcy5pc0NvbGxpZGFibGUgPSBmYWxzZTtcclxuICAgICAgICBpZihsYXllci5wcm9wZXJ0aWVzKXtcclxuICAgICAgICAgICAgZm9yKGxldCBpdGVtIG9mIGxheWVyLnByb3BlcnRpZXMpe1xyXG4gICAgICAgICAgICAgICAgaWYoaXRlbS5uYW1lID09PSBcIkNvbGxpZGFibGVcIil7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pc0NvbGxpZGFibGUgPSBpdGVtLnZhbHVlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBTZXQgYWxsIHRpbGVzIGJlc2lkZXMgXCJlbXB0eTogMFwiIHRvIGJlIGNvbGxpZGFibGVcclxuICAgICAgICAgICAgICAgICAgICBmb3IobGV0IGkgPSAxOyBpIDwgdGhpcy5jb2xsaXNpb25NYXAubGVuZ3RoOyBpKyspe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbGxpc2lvbk1hcFtpXSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgZGltZW5zaW9ucyBvZiB0aGUgdGlsZW1hcFxyXG4gICAgICogQHJldHVybnMgQSBWZWMyIGNvbnRhaW5pbmcgdGhlIG51bWJlciBvZiBjb2x1bW5zIGFuZCB0aGUgbnVtYmVyIG9mIHJvd3MgaW4gdGhlIHRpbGVtYXAuXHJcbiAgICAgKi9cclxuICAgIGdldERpbWVuc2lvbnMoKTogVmVjMiB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBWZWMyKHRoaXMubnVtQ29scywgdGhpcy5udW1Sb3dzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIGRhdGEgdmFsdWUgb2YgdGhlIHRpbGUgYXQgdGhlIHNwZWNpZmllZCB3b3JsZCBwb3NpdGlvblxyXG4gICAgICogQHBhcmFtIHdvcmxkQ29vcmRzIFRoZSBjb29yZGluYXRlcyBpbiB3b3JsZCBzcGFjZVxyXG4gICAgICogQHJldHVybnMgVGhlIGRhdGEgdmFsdWUgb2YgdGhlIHRpbGVcclxuICAgICAqL1xyXG4gICAgZ2V0VGlsZUF0V29ybGRQb3NpdGlvbih3b3JsZENvb3JkczogVmVjMik6IG51bWJlciB7XHJcbiAgICAgICAgbGV0IGxvY2FsQ29vcmRzID0gdGhpcy5nZXRDb2xSb3dBdCh3b3JsZENvb3Jkcyk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VGlsZUF0Um93Q29sKGxvY2FsQ29vcmRzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgdGlsZSBhdCB0aGUgc3BlY2lmaWVkIHJvdyBhbmQgY29sdW1uXHJcbiAgICAgKiBAcGFyYW0gcm93Q29sIFRoZSBjb29yZGluYXRlcyBpbiB0aWxlbWFwIHNwYWNlXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgZGF0YSB2YWx1ZSBvZiB0aGUgdGlsZVxyXG4gICAgICovXHJcbiAgICBnZXRUaWxlQXRSb3dDb2wocm93Q29sOiBWZWMyKTogbnVtYmVyIHtcclxuICAgICAgICBpZihyb3dDb2wueCA8IDAgfHwgcm93Q29sLnggPj0gdGhpcy5udW1Db2xzIHx8IHJvd0NvbC55IDwgMCB8fCByb3dDb2wueSA+PSB0aGlzLm51bVJvd3Mpe1xyXG4gICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhW3Jvd0NvbC55ICogdGhpcy5udW1Db2xzICsgcm93Q29sLnhdO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgd29ybGQgcG9zaXRpb24gb2YgdGhlIHRpbGUgYXQgdGhlIHNwZWNpZmllZCBpbmRleFxyXG4gICAgICogQHBhcmFtIGluZGV4IFRoZSBpbmRleCBvZiB0aGUgdGlsZVxyXG4gICAgICogQHJldHVybnMgQSBWZWMyIGNvbnRhaW5pbmcgdGhlIHdvcmxkIHBvc2l0aW9uIG9mIHRoZSB0aWxlXHJcbiAgICAgKi9cclxuICAgIGdldFRpbGVXb3JsZFBvc2l0aW9uKGluZGV4OiBudW1iZXIpOiBWZWMyIHtcclxuICAgICAgICAvLyBHZXQgdGhlIGxvY2FsIHBvc2l0aW9uXHJcbiAgICAgICAgbGV0IGNvbCA9IGluZGV4ICUgdGhpcy5udW1Db2xzO1xyXG4gICAgICAgIGxldCByb3cgPSBNYXRoLmZsb29yKGluZGV4IC8gdGhpcy5udW1Db2xzKTtcclxuXHJcbiAgICAgICAgLy8gR2V0IHRoZSB3b3JsZCBwb3NpdGlvblxyXG4gICAgICAgIGxldCB4ID0gY29sICogdGhpcy50aWxlU2l6ZS54O1xyXG4gICAgICAgIGxldCB5ID0gcm93ICogdGhpcy50aWxlU2l6ZS55O1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IFZlYzIoeCwgeSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBkYXRhIHZhbHVlIG9mIHRoZSB0aWxlIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXhcclxuICAgICAqIEBwYXJhbSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIHRpbGVcclxuICAgICAqIEByZXR1cm5zIFRoZSBkYXRhIHZhbHVlIG9mIHRoZSB0aWxlXHJcbiAgICAgKi9cclxuICAgIGdldFRpbGUoaW5kZXg6IG51bWJlcik6IG51bWJlciB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVtpbmRleF07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQG92ZXJyaWRlXHJcbiAgICBzZXRUaWxlKGluZGV4OiBudW1iZXIsIHR5cGU6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuZGF0YVtpbmRleF0gPSB0eXBlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgdGlsZSBhdCB0aGUgc3BlY2lmaWVkIHJvdyBhbmQgY29sdW1uXHJcbiAgICAgKiBAcGFyYW0gcm93Q29sIFRoZSBwb3NpdGlvbiBvZiB0aGUgdGlsZSBpbiB0aWxlbWFwIHNwYWNlXHJcbiAgICAgKiBAcGFyYW0gdHlwZSBUaGUgbmV3IGRhdGEgdmFsdWUgb2YgdGhlIHRpbGVcclxuICAgICAqL1xyXG4gICAgc2V0VGlsZUF0Um93Q29sKHJvd0NvbDogVmVjMiwgdHlwZTogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgICAgbGV0IGluZGV4ID0gcm93Q29sLnkgKiB0aGlzLm51bUNvbHMgKyByb3dDb2wueDtcclxuICAgICAgICB0aGlzLnNldFRpbGUoaW5kZXgsIHR5cGUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSB0aWxlIGF0IHRoZSBzcGVjaWZpZWQgcm93IGFuZCBjb2x1bW4gb2YgdGhlIHRpbGVtYXAgaXMgY29sbGlkYWJsZVxyXG4gICAgICogQHBhcmFtIGluZGV4T3JDb2wgVGhlIGluZGV4IG9mIHRoZSB0aWxlIG9yIHRoZSBjb2x1bW4gaXQgaXMgaW5cclxuICAgICAqIEBwYXJhbSByb3cgVGhlIHJvdyB0aGUgdGlsZSBpcyBpblxyXG4gICAgICogQHJldHVybnMgQSBmbGFnIHJlcHJlc2VudGluZyB3aGV0aGVyIG9yIG5vdCB0aGUgdGlsZSBpcyBjb2xsaWRhYmxlLlxyXG4gICAgICovXHJcbiAgICBpc1RpbGVDb2xsaWRhYmxlKGluZGV4T3JDb2w6IG51bWJlciwgcm93PzogbnVtYmVyKTogYm9vbGVhbiB7XHJcbiAgICAgICAgLy8gVGhlIHZhbHVlIG9mIHRoZSB0aWxlXHJcbiAgICAgICAgbGV0IHRpbGUgPSAwO1xyXG5cclxuICAgICAgICBpZihyb3cpe1xyXG4gICAgICAgICAgICAvLyBXZSBoYXZlIGEgY29sdW1uIGFuZCBhIHJvd1xyXG4gICAgICAgICAgICB0aWxlID0gdGhpcy5nZXRUaWxlQXRSb3dDb2wobmV3IFZlYzIoaW5kZXhPckNvbCwgcm93KSk7XHJcblxyXG4gICAgICAgICAgICBpZih0aWxlIDwgMCl7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZihpbmRleE9yQ29sIDwgMCB8fCBpbmRleE9yQ29sID49IHRoaXMuZGF0YS5sZW5ndGgpe1xyXG4gICAgICAgICAgICAgICAgLy8gVGlsZXMgdGhhdCBkb24ndCBleGlzdCBhcmVuJ3QgY29sbGlkYWJsZVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFdlIGhhdmUgYW4gaW5kZXhcclxuICAgICAgICAgICAgdGlsZSA9IHRoaXMuZ2V0VGlsZShpbmRleE9yQ29sKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbGxpc2lvbk1hcFt0aWxlXTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRha2VzIGluIHdvcmxkIGNvb3JkaW5hdGVzIGFuZCByZXR1cm5zIHRoZSByb3cgYW5kIGNvbHVtbiBvZiB0aGUgdGlsZSBhdCB0aGF0IHBvc2l0aW9uXHJcbiAgICAgKiBAcGFyYW0gd29ybGRDb29yZHMgVGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBwb3RlbnRpYWwgdGlsZSBpbiB3b3JsZCBzcGFjZVxyXG4gICAgICogQHJldHVybnMgQSBWZWMyIGNvbnRhaW5pbmcgdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBwb3RlbnRpYWwgdGlsZSBpbiB0aWxlbWFwIHNwYWNlXHJcbiAgICAgKi9cclxuICAgIGdldENvbFJvd0F0KHdvcmxkQ29vcmRzOiBWZWMyKTogVmVjMiB7XHJcbiAgICAgICAgbGV0IGNvbCA9IE1hdGguZmxvb3Iod29ybGRDb29yZHMueCAvIHRoaXMudGlsZVNpemUueCAvIHRoaXMuc2NhbGUueCk7XHJcbiAgICAgICAgbGV0IHJvdyA9IE1hdGguZmxvb3Iod29ybGRDb29yZHMueSAvIHRoaXMudGlsZVNpemUueSAvIHRoaXMuc2NhbGUueSk7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgVmVjMihjb2wsIHJvdyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQG92ZXJyaWRlXHJcbiAgICB1cGRhdGUoZGVsdGFUOiBudW1iZXIpOiB2b2lkIHt9XHJcblxyXG4gICAgLy8gQG92ZXJyaWRlXHJcbiAgICBkZWJ1Z1JlbmRlcigpe1xyXG4gICAgICAgIC8vIEhhbGYgb2YgdGhlIHRpbGUgc2l6ZVxyXG4gICAgICAgIGxldCB6b29tZWRIYWxmVGlsZVNpemUgPSB0aGlzLmdldFRpbGVTaXplV2l0aFpvb20oKS5zY2FsZWQoMC41KTtcclxuICAgICAgICBsZXQgaGFsZlRpbGVTaXplID0gdGhpcy5nZXRUaWxlU2l6ZSgpLnNjYWxlZCgwLjUpO1xyXG5cclxuICAgICAgICAvLyBUaGUgY2VudGVyIG9mIHRoZSB0b3AgbGVmdCB0aWxlXHJcbiAgICAgICAgbGV0IHRvcExlZnQgPSB0aGlzLnBvc2l0aW9uLmNsb25lKCkuc3ViKHRoaXMuc2l6ZS5zY2FsZWQoMC41KSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gQSB2ZWMgdG8gc3RvcmUgdGhlIGNlbnRlclxyXG4gICAgICAgIGxldCBjZW50ZXIgPSBWZWMyLlpFUk87XHJcblxyXG4gICAgICAgIGZvcihsZXQgY29sID0gMDsgY29sIDwgdGhpcy5udW1Db2xzOyBjb2wrKyl7XHJcbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgeC1wb3NpdGlvblxyXG4gICAgICAgICAgICBjZW50ZXIueCA9IHRvcExlZnQueCArIGNvbCoyKmhhbGZUaWxlU2l6ZS54ICsgaGFsZlRpbGVTaXplLng7XHJcblxyXG4gICAgICAgICAgICBmb3IobGV0IHJvdyA9IDA7IHJvdyA8IHRoaXMubnVtUm93czsgcm93Kyspe1xyXG4gICAgICAgICAgICAgICAgaWYodGhpcy5pc0NvbGxpZGFibGUgJiYgdGhpcy5pc1RpbGVDb2xsaWRhYmxlKGNvbCwgcm93KSl7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSB5LXBvc2l0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgY2VudGVyLnkgPSB0b3BMZWZ0LnkgKyByb3cqMipoYWxmVGlsZVNpemUueSArIGhhbGZUaWxlU2l6ZS55O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBEcmF3IGEgYm94IGZvciB0aGlzIHRpbGVcclxuICAgICAgICAgICAgICAgICAgICBEZWJ1Zy5kcmF3Qm94KHRoaXMuaW5SZWxhdGl2ZUNvb3JkaW5hdGVzKGNlbnRlciksIHpvb21lZEhhbGZUaWxlU2l6ZSwgZmFsc2UsIENvbG9yLkJMVUUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59IiwiaW1wb3J0IENhbnZhc05vZGUgZnJvbSBcIi4vQ2FudmFzTm9kZVwiO1xyXG5pbXBvcnQgQ29sb3IgZnJvbSBcIi4uL1V0aWxzL0NvbG9yXCI7XHJcbmltcG9ydCBWZWMyIGZyb20gXCIuLi9EYXRhVHlwZXMvVmVjMlwiO1xyXG5pbXBvcnQgSW5wdXQgZnJvbSBcIi4uL0lucHV0L0lucHV0XCI7XHJcblxyXG4vKipcclxuICogVGhlIHJlcHJlc2VudGF0aW9uIG9mIGEgVUlFbGVtZW50IC0gdGhlIHBhcmVudCBjbGFzcyBvZiB0aGluZ3MgbGlrZSBidXR0b25zXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBhYnN0cmFjdCBjbGFzcyBVSUVsZW1lbnQgZXh0ZW5kcyBDYW52YXNOb2RlIHtcclxuXHQvLyBTdHlsZSBhdHRyaWJ1dGVzIC0gVE9ETyAtIGFic3RyYWN0IHRoaXMgaW50byBhIHN0eWxlIG9iamVjdC9pbnRlcmZhY2VcclxuXHQvKiogVGhlIGJhY2tnb3VuZCBjb2xvciAqL1xyXG5cdGJhY2tncm91bmRDb2xvcjogQ29sb3I7XHJcblx0LyoqIFRoZSBib3JkZXIgY29sb3IgKi9cclxuXHRib3JkZXJDb2xvcjogQ29sb3I7XHJcblx0LyoqIFRoZSBib3JkZXIgcmFkaXVzICovXHJcblx0Ym9yZGVyUmFkaXVzOiBudW1iZXI7XHJcblx0LyoqIFRoZSBib3JkZXIgd2lkdGggKi9cclxuXHRib3JkZXJXaWR0aDogbnVtYmVyO1xyXG5cdC8qKiBUaGUgcGFkZGluZyAqL1xyXG5cdHBhZGRpbmc6IFZlYzI7XHJcblxyXG5cdC8vIEV2ZW50QXR0cmlidXRlc1xyXG5cdC8qKiBUaGUgcmVhY3Rpb24gb2YgdGhpcyBVSUVsZW1lbnQgb24gYSBjbGljayAqL1xyXG5cdG9uQ2xpY2s6IEZ1bmN0aW9uO1xyXG5cdC8qKiBUaGUgZXZlbnQgcHJvcGFnYXRlZCBvbiBjbGljayAqL1xyXG5cdG9uQ2xpY2tFdmVudElkOiBzdHJpbmc7XHJcblx0LyoqIFRoZSByZWFjdGlvbiB0byB0aGUgcmVsZWFzZSBvZiBhIGNsaWNrICovXHJcblx0b25SZWxlYXNlOiBGdW5jdGlvbjtcclxuXHQvKiogVGhlIGV2ZW50IHByb3BhZ2F0ZWQgb24gdGhlIHJlbGVhc2Ugb2YgYSBjbGljayAqL1xyXG5cdG9uUmVsZWFzZUV2ZW50SWQ6IHN0cmluZztcclxuXHQvKiogVGhlIHJlYWN0aW9uIHdoZW4gYSBtb3VzZSBlbnRlcnMgdGhpcyBVSUVsZW1lbnQgKi9cclxuXHRvbkVudGVyOiBGdW5jdGlvbjtcclxuXHQvKiogVGhlIGV2ZW50IHByb3BhZ2F0ZWQgd2hlbiBhIG1vdXNlIGVudGVycyB0aGlzIFVJRWxlbWVudCAqL1xyXG5cdG9uRW50ZXJFdmVudElkOiBzdHJpbmc7XHJcblx0LyoqIFRoZSByZWFjdGlvbiB3aGVuIGEgbW91c2UgbGVhdmVzIHRoaXMgVUlFbGVtZW50ICovXHJcblx0b25MZWF2ZTogRnVuY3Rpb247XHJcblx0LyoqIFRoZSBldmVudCBwcm9wb2dhdGVkIHdoZW4gYSBtb3VzZSBsZWF2ZXMgdGhpcyBVSUVsZW1lbnQgKi9cclxuXHRvbkxlYXZlRXZlbnRJZDogc3RyaW5nO1xyXG5cclxuXHQvKiogV2hldGhlciBvciBub3QgdGhpcyBVSUVsZW1lbnQgaXMgY3VycmVudGx5IGNsaWNrZWQgb24gKi9cclxuXHRwcm90ZWN0ZWQgaXNDbGlja2VkOiBib29sZWFuO1xyXG5cdC8qKiBXaGV0aGVyIG9yIG5vdCB0aGlzIFVJRWxlbWVudCBpcyBjdXJyZW50bHkgaG92ZXJlZCBvdmVyICovXHJcblx0cHJvdGVjdGVkIGlzRW50ZXJlZDogYm9vbGVhbjtcclxuXHJcblx0Y29uc3RydWN0b3IocG9zaXRpb246IFZlYzIpe1xyXG5cdFx0c3VwZXIoKTtcclxuXHRcdHRoaXMucG9zaXRpb24gPSBwb3NpdGlvbjtcclxuXHRcdFxyXG5cdFx0dGhpcy5iYWNrZ3JvdW5kQ29sb3IgPSBuZXcgQ29sb3IoMCwgMCwgMCwgMCk7XHJcblx0XHR0aGlzLmJvcmRlckNvbG9yID0gbmV3IENvbG9yKDAsIDAsIDAsIDApO1xyXG5cdFx0dGhpcy5ib3JkZXJSYWRpdXMgPSA1O1xyXG5cdFx0dGhpcy5ib3JkZXJXaWR0aCA9IDE7XHJcblx0XHR0aGlzLnBhZGRpbmcgPSBWZWMyLlpFUk87XHJcblxyXG5cdFx0dGhpcy5vbkNsaWNrID0gbnVsbDtcclxuXHRcdHRoaXMub25DbGlja0V2ZW50SWQgPSBudWxsO1xyXG5cdFx0dGhpcy5vblJlbGVhc2UgPSBudWxsO1xyXG5cdFx0dGhpcy5vblJlbGVhc2VFdmVudElkID0gbnVsbDtcclxuXHJcblx0XHR0aGlzLm9uRW50ZXIgPSBudWxsO1xyXG5cdFx0dGhpcy5vbkVudGVyRXZlbnRJZCA9IG51bGw7XHJcblx0XHR0aGlzLm9uTGVhdmUgPSBudWxsO1xyXG5cdFx0dGhpcy5vbkxlYXZlRXZlbnRJZCA9IG51bGw7XHJcblxyXG5cdFx0dGhpcy5pc0NsaWNrZWQgPSBmYWxzZTtcclxuXHRcdHRoaXMuaXNFbnRlcmVkID0gZmFsc2U7XHJcblx0fVxyXG5cclxuXHQvLyBAZGVwcmVjYXRlZFxyXG5cdHNldEJhY2tncm91bmRDb2xvcihjb2xvcjogQ29sb3IpOiB2b2lkIHtcclxuXHRcdHRoaXMuYmFja2dyb3VuZENvbG9yID0gY29sb3I7XHJcblx0fVxyXG5cclxuXHQvLyBAZGVwcmVjYXRlZFxyXG5cdHNldFBhZGRpbmcocGFkZGluZzogVmVjMik6IHZvaWQge1xyXG5cdFx0dGhpcy5wYWRkaW5nLmNvcHkocGFkZGluZyk7XHJcblx0fVxyXG5cclxuXHR1cGRhdGUoZGVsdGFUOiBudW1iZXIpOiB2b2lkIHtcclxuXHRcdHN1cGVyLnVwZGF0ZShkZWx0YVQpO1xyXG5cclxuXHRcdC8vIFNlZSBvZiB0aGlzIG9iamVjdCB3YXMganVzdCBjbGlja2VkXHJcblx0XHRpZihJbnB1dC5pc01vdXNlSnVzdFByZXNzZWQoKSl7XHJcblx0XHRcdGxldCBjbGlja1BvcyA9IElucHV0LmdldE1vdXNlUHJlc3NQb3NpdGlvbigpO1xyXG5cdFx0XHRpZih0aGlzLmNvbnRhaW5zKGNsaWNrUG9zLngsIGNsaWNrUG9zLnkpICYmIHRoaXMudmlzaWJsZSAmJiAhdGhpcy5sYXllci5pc0hpZGRlbigpKXtcclxuXHRcdFx0XHR0aGlzLmlzQ2xpY2tlZCA9IHRydWU7XHJcblxyXG5cdFx0XHRcdGlmKHRoaXMub25DbGljayAhPT0gbnVsbCl7XHJcblx0XHRcdFx0XHR0aGlzLm9uQ2xpY2soKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYodGhpcy5vbkNsaWNrRXZlbnRJZCAhPT0gbnVsbCl7XHJcblx0XHRcdFx0XHRsZXQgZGF0YSA9IHt9O1xyXG5cdFx0XHRcdFx0dGhpcy5lbWl0dGVyLmZpcmVFdmVudCh0aGlzLm9uQ2xpY2tFdmVudElkLCBkYXRhKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBJZiB0aGUgbW91c2Ugd2Fzbid0IGp1c3QgcHJlc3NlZCwgdGhlbiB3ZSBkZWZpbml0ZWx5IHdlcmVuJ3QgY2xpY2tlZFxyXG5cdFx0aWYoIUlucHV0LmlzTW91c2VQcmVzc2VkKCkpe1xyXG5cdFx0XHRpZih0aGlzLmlzQ2xpY2tlZCl7XHJcblx0XHRcdFx0dGhpcy5pc0NsaWNrZWQgPSBmYWxzZTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIENoZWNrIGlmIHRoZSBtb3VzZSBpcyBob3ZlcmluZyBvdmVyIHRoaXMgZWxlbWVudFxyXG5cdFx0bGV0IG1vdXNlUG9zID0gSW5wdXQuZ2V0TW91c2VQb3NpdGlvbigpO1xyXG5cdFx0aWYobW91c2VQb3MgJiYgdGhpcy5jb250YWlucyhtb3VzZVBvcy54LCBtb3VzZVBvcy55KSl7XHJcblx0XHRcdHRoaXMuaXNFbnRlcmVkID0gdHJ1ZTtcclxuXHJcblx0XHRcdGlmKHRoaXMub25FbnRlciAhPT0gbnVsbCl7XHJcblx0XHRcdFx0dGhpcy5vbkVudGVyKCk7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYodGhpcy5vbkVudGVyRXZlbnRJZCAhPT0gbnVsbCl7XHJcblx0XHRcdFx0bGV0IGRhdGEgPSB7fTtcclxuXHRcdFx0XHR0aGlzLmVtaXR0ZXIuZmlyZUV2ZW50KHRoaXMub25FbnRlckV2ZW50SWQsIGRhdGEpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIGlmKHRoaXMuaXNFbnRlcmVkKSB7XHJcblx0XHRcdHRoaXMuaXNFbnRlcmVkID0gZmFsc2U7XHJcblxyXG5cdFx0XHRpZih0aGlzLm9uTGVhdmUgIT09IG51bGwpe1xyXG5cdFx0XHRcdHRoaXMub25MZWF2ZSgpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmKHRoaXMub25MZWF2ZUV2ZW50SWQgIT09IG51bGwpe1xyXG5cdFx0XHRcdGxldCBkYXRhID0ge307XHJcblx0XHRcdFx0dGhpcy5lbWl0dGVyLmZpcmVFdmVudCh0aGlzLm9uTGVhdmVFdmVudElkLCBkYXRhKTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIGlmKHRoaXMuaXNDbGlja2VkKSB7XHJcblx0XHRcdC8vIElmIG1vdXNlIGlzIGRyYWdnZWQgb2ZmIG9mIGVsZW1lbnQgd2hpbGUgZG93biwgaXQgaXMgbm90IGNsaWNrZWQgYW55bW9yZVxyXG5cdFx0XHR0aGlzLmlzQ2xpY2tlZCA9IGZhbHNlO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogT3ZlcnJpZGFibGUgbWV0aG9kIGZvciBjYWxjdWxhdGluZyBiYWNrZ3JvdW5kIGNvbG9yIC0gdXNlZnVsIGZvciBlbGVtZW50cyB0aGF0IHdhbnQgdG8gYmUgY29sb3JlZCBvbiBkaWZmZXJlbnQgYWZ0ZXIgY2VydGFpbiBldmVudHNcclxuXHQgKiBAcmV0dXJucyBUaGUgYmFja2dyb3VuZCBjb2xvciBvZiB0aGUgVUlFbGVtZW50XHJcblx0ICovXHJcblx0Y2FsY3VsYXRlQmFja2dyb3VuZENvbG9yKCk6IENvbG9yIHtcclxuXHRcdHJldHVybiB0aGlzLmJhY2tncm91bmRDb2xvcjtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIE92ZXJyaWRhYmxlIG1ldGhvZCBmb3IgY2FsY3VsYXRpbmcgYm9yZGVyIGNvbG9yIC0gdXNlZnVsIGZvciBlbGVtZW50cyB0aGF0IHdhbnQgdG8gYmUgY29sb3JlZCBvbiBkaWZmZXJlbnQgYWZ0ZXIgY2VydGFpbiBldmVudHNcclxuXHQgKiBAcmV0dXJucyBUaGUgYm9yZGVyIGNvbG9yIG9mIHRoZSBVSUVsZW1lbnRcclxuXHQgKi9cclxuXHRjYWxjdWxhdGVCb3JkZXJDb2xvcigpOiBDb2xvciB7XHJcblx0XHRyZXR1cm4gdGhpcy5ib3JkZXJDb2xvcjtcclxuXHR9XHJcbn0iLCJpbXBvcnQgTGFiZWwgZnJvbSBcIi4vTGFiZWxcIjtcclxuaW1wb3J0IENvbG9yIGZyb20gXCIuLi8uLi9VdGlscy9Db2xvclwiO1xyXG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL1ZlYzJcIjtcclxuXHJcbi8qKiBBIGNsaWNrYWJsZSBidXR0b24gVUlFbGVtZW50ICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJ1dHRvbiBleHRlbmRzIExhYmVsIHtcclxuXHJcblx0Y29uc3RydWN0b3IocG9zaXRpb246IFZlYzIsIHRleHQ6IHN0cmluZyl7XHJcblx0XHRzdXBlcihwb3NpdGlvbiwgdGV4dCk7XHJcblx0XHRcclxuXHRcdHRoaXMuYmFja2dyb3VuZENvbG9yID0gbmV3IENvbG9yKDE1MCwgNzUsIDIwMyk7XHJcblx0XHR0aGlzLmJvcmRlckNvbG9yID0gbmV3IENvbG9yKDQxLCA0NiwgMzApO1xyXG5cdFx0dGhpcy50ZXh0Q29sb3IgPSBuZXcgQ29sb3IoMjU1LCAyNTUsIDI1NSk7XHJcblx0fVxyXG5cclxuXHQvLyBAb3ZlcnJpZGVcclxuXHRjYWxjdWxhdGVCYWNrZ3JvdW5kQ29sb3IoKTogQ29sb3Ige1xyXG5cdFx0Ly8gQ2hhbmdlIHRoZSBiYWNrZ3JvdW5kIGNvbG9yIGlmIGNsaWNrZWQgb3IgaG92ZXJlZFxyXG5cdFx0aWYodGhpcy5pc0VudGVyZWQgJiYgIXRoaXMuaXNDbGlja2VkKXtcclxuXHRcdFx0cmV0dXJuIHRoaXMuYmFja2dyb3VuZENvbG9yLmxpZ2h0ZW4oKTtcclxuXHRcdH0gZWxzZSBpZih0aGlzLmlzQ2xpY2tlZCl7XHJcblx0XHRcdHJldHVybiB0aGlzLmJhY2tncm91bmRDb2xvci5kYXJrZW4oKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHJldHVybiB0aGlzLmJhY2tncm91bmRDb2xvcjtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGNsb25lKG9yaWc6IEJ1dHRvbiwgb25DbGlja0V2ZW50SWQ6IHN0cmluZykgOiB2b2lkIHtcclxuXHRcdHRoaXMuYmFja2dyb3VuZENvbG9yID0gb3JpZy5iYWNrZ3JvdW5kQ29sb3I7XHJcblx0XHR0aGlzLmJvcmRlckNvbG9yID0gb3JpZy5ib3JkZXJDb2xvcjtcclxuXHRcdHRoaXMudGV4dENvbG9yID0gb3JpZy50ZXh0Q29sb3I7XHJcblx0XHR0aGlzLnNpemUgPSBvcmlnLnNpemU7XHJcblx0XHR0aGlzLmJvcmRlcldpZHRoID0gb3JpZy5ib3JkZXJXaWR0aDtcclxuXHJcblx0XHR0aGlzLm9uQ2xpY2tFdmVudElkID0gb25DbGlja0V2ZW50SWQ7XHJcblx0fVxyXG59IiwiaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9WZWMyXCI7XHJcbmltcG9ydCBDb2xvciBmcm9tIFwiLi4vLi4vVXRpbHMvQ29sb3JcIjtcclxuaW1wb3J0IFVJRWxlbWVudCBmcm9tIFwiLi4vVUlFbGVtZW50XCI7XHJcblxyXG4vKiogQSBiYXNpYyB0ZXh0LWNvbnRhaW5pbmcgbGFiZWwgKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGFiZWwgZXh0ZW5kcyBVSUVsZW1lbnR7XHJcblx0LyoqIFRoZSBjb2xvciBvZiB0aGUgdGV4dCBvZiB0aGlzIFVJRWxlbWVudCAqL1xyXG5cdHRleHRDb2xvcjogQ29sb3I7XHJcblx0LyoqIFRoZSB2YWx1ZSBvZiB0aGUgdGV4dCBvZiB0aGlzIFVJRWxlbWVudCAqL1xyXG5cdHRleHQ6IHN0cmluZztcclxuXHQvKiogVGhlIG5hbWUgb2YgdGhlIGZvbnQgKi9cclxuXHRmb250OiBzdHJpbmc7XHJcblx0LyoqIFRoZSBzaXplIG9mIHRoZSBmb250ICovXHJcblx0Zm9udFNpemU6IG51bWJlcjtcclxuXHQvKiogVGhlIGhvcml6b250YWwgYWxpZ25tZW50IG9mIHRoZSB0ZXh0IHdpdGhpbiB0aGUgbGFiZWwgKi9cclxuXHRwcm90ZWN0ZWQgaEFsaWduOiBzdHJpbmc7XHJcblx0LyoqIFRoZSB2ZXJ0aWNhbCBhbGlnbm1lbnQgb2YgdGV4dCB3aXRoaW4gdGhlIGxhYmVsICovXHJcblx0cHJvdGVjdGVkIHZBbGlnbjogc3RyaW5nO1xyXG5cclxuXHQvKiogQSBmbGFnIGZvciBpZiB0aGUgd2lkdGggb2YgdGhlIHRleHQgaGFzIGJlZW4gbWVhc3VyZWQgb24gdGhlIGNhbnZhcyBmb3IgYXV0byB3aWR0aCBhc3NpZ25tZW50ICovXHJcblx0cHJvdGVjdGVkIHNpemVBc3NpZ25lZDogYm9vbGVhbjtcclxuXHJcblx0Y29uc3RydWN0b3IocG9zaXRpb246IFZlYzIsIHRleHQ6IHN0cmluZyl7XHJcblx0XHRzdXBlcihwb3NpdGlvbik7XHJcblx0XHR0aGlzLnRleHQgPSB0ZXh0O1xyXG5cdFx0dGhpcy50ZXh0Q29sb3IgPSBuZXcgQ29sb3IoMCwgMCwgMCwgMSk7XHJcblx0XHR0aGlzLmZvbnQgPSBcIkFyaWFsXCI7XHJcblx0XHR0aGlzLmZvbnRTaXplID0gMzA7XHJcblx0XHR0aGlzLmhBbGlnbiA9IFwiY2VudGVyXCI7XHJcblx0XHR0aGlzLnZBbGlnbiA9IFwiY2VudGVyXCI7XHJcblxyXG5cdFx0dGhpcy5zaXplQXNzaWduZWQgPSBmYWxzZTtcclxuXHR9XHJcblxyXG5cdC8vIEBkZXByZWNhdGVkXHJcblx0c2V0VGV4dCh0ZXh0OiBzdHJpbmcpOiB2b2lkIHtcclxuXHRcdHRoaXMudGV4dCA9IHRleHQ7XHJcblx0fVxyXG5cclxuXHQvLyBAZGVwcmVjYXRlZFxyXG5cdHNldFRleHRDb2xvcihjb2xvcjogQ29sb3IpOiB2b2lkIHtcclxuXHRcdHRoaXMudGV4dENvbG9yID0gY29sb3I7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBHZXRzIGEgc3RyaW5nIGNvbnRhaW5nIHRoZSBmb250IGRldGFpbHMgZm9yIHJlbmRlcmluZ1xyXG5cdCAqIEByZXR1cm5zIEEgc3RyaW5nIGNvbnRhaW5pbmcgdGhlIGZvbnQgZGV0YWlsc1xyXG5cdCAqL1xyXG5cdGdldEZvbnRTdHJpbmcoKTogc3RyaW5nIHtcclxuXHRcdHJldHVybiB0aGlzLmZvbnRTaXplICsgXCJweCBcIiArIHRoaXMuZm9udDtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIE92ZXJyaWRhYmxlIG1ldGhvZCBmb3IgY2FsY3VsYXRpbmcgdGV4dCBjb2xvciAtIHVzZWZ1bCBmb3IgZWxlbWVudHMgdGhhdCB3YW50IHRvIGJlIGNvbG9yZWQgb24gZGlmZmVyZW50IGFmdGVyIGNlcnRhaW4gZXZlbnRzXHJcblx0ICogQHJldHVybnMgYSBzdHJpbmcgY29udGFpbmcgdGhlIHRleHQgY29sb3JcclxuXHQgKi9cclxuXHRjYWxjdWxhdGVUZXh0Q29sb3IoKTogc3RyaW5nIHtcclxuXHRcdHJldHVybiB0aGlzLnRleHRDb2xvci50b1N0cmluZ1JHQkEoKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFVzZXMgdGhlIGNhbnZhcyB0byBjYWxjdWxhdGUgdGhlIHdpZHRoIG9mIHRoZSB0ZXh0XHJcblx0ICogQHBhcmFtIGN0eCBUaGUgcmVuZGVyaW5nIGNvbnRleHRcclxuXHQgKiBAcmV0dXJucyBBIG51bWJlciByZXByZXNlbnRpbmcgdGhlIHJlbmRlcmVkIHRleHQgd2lkdGhcclxuXHQgKi9cclxuXHRwcm90ZWN0ZWQgY2FsY3VsYXRlVGV4dFdpZHRoKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKTogbnVtYmVyIHtcclxuXHRcdGN0eC5mb250ID0gdGhpcy5mb250U2l6ZSArIFwicHggXCIgKyB0aGlzLmZvbnQ7XHJcblx0XHRyZXR1cm4gY3R4Lm1lYXN1cmVUZXh0KHRoaXMudGV4dCkud2lkdGg7XHJcblx0fVxyXG5cclxuXHRzZXRIQWxpZ24oYWxpZ246IHN0cmluZyk6IHZvaWQge1xyXG5cdFx0dGhpcy5oQWxpZ24gPSBhbGlnbjtcclxuXHR9XHJcblxyXG5cdHNldFZBbGlnbihhbGlnbjogc3RyaW5nKTogdm9pZCB7XHJcblx0XHR0aGlzLnZBbGlnbiA9IGFsaWduO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQ2FsY3VsYXRlIHRoZSBvZmZzZXQgb2YgdGhlIHRleHQgLSB0aGlzIGlzIHVzZWQgZm9yIHJlbmRlcmluZyB0ZXh0IHdpdGggZGlmZmVyZW50IGFsaWdubWVudHNcclxuXHQgKiBAcGFyYW0gY3R4IFRoZSByZW5kZXJpbmcgY29udGV4dFxyXG5cdCAqIEByZXR1cm5zIFRoZSBvZmZzZXQgb2YgdGhlIHRleHQgaW4gYSBWZWMyXHJcblx0ICovXHJcblx0Y2FsY3VsYXRlVGV4dE9mZnNldChjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCk6IFZlYzIge1xyXG5cdFx0bGV0IHRleHRXaWR0aCA9IHRoaXMuY2FsY3VsYXRlVGV4dFdpZHRoKGN0eCk7XHJcblxyXG5cdFx0bGV0IG9mZnNldCA9IG5ldyBWZWMyKDAsIDApO1xyXG5cclxuXHRcdGxldCBoRGlmZiA9IHRoaXMuc2l6ZS54IC0gdGV4dFdpZHRoO1xyXG5cdFx0aWYodGhpcy5oQWxpZ24gPT09IEhBbGlnbi5DRU5URVIpe1xyXG5cdFx0XHRvZmZzZXQueCA9IGhEaWZmLzI7XHJcblx0XHR9IGVsc2UgaWYgKHRoaXMuaEFsaWduID09PSBIQWxpZ24uUklHSFQpe1xyXG5cdFx0XHRvZmZzZXQueCA9IGhEaWZmO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmKHRoaXMudkFsaWduID09PSBWQWxpZ24uVE9QKXtcclxuXHRcdFx0Y3R4LnRleHRCYXNlbGluZSA9IFwidG9wXCI7XHJcblx0XHRcdG9mZnNldC55ID0gMDtcclxuXHRcdH0gZWxzZSBpZiAodGhpcy52QWxpZ24gPT09IFZBbGlnbi5CT1RUT00pe1xyXG5cdFx0XHRjdHgudGV4dEJhc2VsaW5lID0gXCJib3R0b21cIjtcclxuXHRcdFx0b2Zmc2V0LnkgPSB0aGlzLnNpemUueTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGN0eC50ZXh0QmFzZWxpbmUgPSBcIm1pZGRsZVwiO1xyXG5cdFx0XHRvZmZzZXQueSA9IHRoaXMuc2l6ZS55LzI7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG9mZnNldDtcclxuXHR9XHJcblxyXG5cdHByb3RlY3RlZCBzaXplQ2hhbmdlZCgpOiB2b2lkIHtcclxuXHRcdHN1cGVyLnNpemVDaGFuZ2VkKCk7XHJcblx0XHR0aGlzLnNpemVBc3NpZ25lZCA9IHRydWU7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBBdXRvbWF0aWNhbGx5IHNpemVzIHRoZSBlbGVtZW50IHRvIHRoZSB0ZXh0IHdpdGhpbiBpdFxyXG5cdCAqIEBwYXJhbSBjdHggVGhlIHJlbmRlcmluZyBjb250ZXh0XHJcblx0ICovXHJcblx0cHJvdGVjdGVkIGF1dG9TaXplKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKTogdm9pZCB7XHJcblx0XHRsZXQgd2lkdGggPSB0aGlzLmNhbGN1bGF0ZVRleHRXaWR0aChjdHgpO1xyXG5cdFx0bGV0IGhlaWdodCA9IHRoaXMuZm9udFNpemU7XHJcblx0XHR0aGlzLnNpemUuc2V0KHdpZHRoICsgdGhpcy5wYWRkaW5nLngqMiwgaGVpZ2h0ICsgdGhpcy5wYWRkaW5nLnkqMik7XHJcblx0XHR0aGlzLnNpemVBc3NpZ25lZCA9IHRydWU7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBJbml0aWFsbHkgYXNzaWducyBhIHNpemUgdG8gdGhlIFVJRWxlbWVudCBpZiBub25lIGlzIHByb3ZpZGVkXHJcblx0ICogQHBhcmFtIGN0eCBUaGUgcmVuZGVyaW5nIGNvbnRleHRcclxuXHQgKi9cclxuXHRoYW5kbGVJbml0aWFsU2l6aW5nKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKTogdm9pZCB7XHJcblx0XHRpZighdGhpcy5zaXplQXNzaWduZWQpe1xyXG5cdFx0XHR0aGlzLmF1dG9TaXplKGN0eCk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvKiogT24gdGhlIG5leHQgcmVuZGVyLCBzaXplIHRoaXMgZWxlbWVudCB0byBpdCdzIGN1cnJlbnQgdGV4dCB1c2luZyBpdHMgY3VycmVudCBmb250IHNpemUgKi9cclxuXHRzaXplVG9UZXh0KCk6IHZvaWQge1xyXG5cdFx0dGhpcy5zaXplQXNzaWduZWQgPSBmYWxzZTtcclxuXHR9XHJcblxyXG5cdGdldCB0ZXh0QWxwaGEoKTogbnVtYmVyIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50ZXh0Q29sb3IuYTtcclxuICAgIH1cclxuXHJcbiAgICBzZXQgdGV4dEFscGhhKGE6IG51bWJlcikge1xyXG4gICAgICAgIHRoaXMudGV4dENvbG9yLmEgPSBhO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZW51bSBWQWxpZ24ge1xyXG5cdFRPUCA9IFwidG9wXCIsXHJcblx0Q0VOVEVSID0gXCJjZW50ZXJcIixcclxuXHRCT1RUT00gPSBcImJvdHRvbVwiXHJcbn1cclxuXHJcbmV4cG9ydCBlbnVtIEhBbGlnbiB7XHJcblx0TEVGVCA9IFwibGVmdFwiLFxyXG5cdENFTlRFUiA9IFwiY2VudGVyXCIsXHJcblx0UklHSFQgPSBcInJpZ2h0XCJcclxufSIsImltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvVmVjMlwiO1xyXG5pbXBvcnQgSW5wdXQgZnJvbSBcIi4uLy4uL0lucHV0L0lucHV0XCI7XHJcbmltcG9ydCBDb2xvciBmcm9tIFwiLi4vLi4vVXRpbHMvQ29sb3JcIjtcclxuaW1wb3J0IE1hdGhVdGlscyBmcm9tIFwiLi4vLi4vVXRpbHMvTWF0aFV0aWxzXCI7XHJcbmltcG9ydCBVSUVsZW1lbnQgZnJvbSBcIi4uL1VJRWxlbWVudFwiO1xyXG5cclxuLyoqIEEgc2xpZGVyIFVJRWxlbWVudCAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTbGlkZXIgZXh0ZW5kcyBVSUVsZW1lbnQge1xyXG4gICAgLyoqIFRoZSB2YWx1ZSBvZiB0aGUgc2xpZGVyIGZyb20gWzAsIDFdICovXHJcbiAgICBwcm90ZWN0ZWQgdmFsdWU6IG51bWJlcjtcclxuICAgIC8qKiBUaGUgY29sb3Igb2YgdGhlIHNsaWRlciBuaWIgKi9cclxuICAgIHB1YmxpYyBuaWJDb2xvcjogQ29sb3I7XHJcbiAgICAvKiogVGhlIHNpemUgb2YgdGhlIG5pYiAqL1xyXG4gICAgcHVibGljIG5pYlNpemU6IFZlYzI7XHJcbiAgICAvKiogVGhlIGNvbG9yIG9mIHRoZSBzbGlkZXIgdHJhY2sgKi9cclxuICAgIHB1YmxpYyBzbGlkZXJDb2xvcjogQ29sb3I7XHJcbiAgICAvKiogVGhlIHJlYWN0aW9uIG9mIHRoaXMgVUlFbGVtZW50IHRvIGEgdmFsdWUgY2hhbmdlICovXHJcbiAgICBwdWJsaWMgb25WYWx1ZUNoYW5nZTogRnVuY3Rpb247XHJcbiAgICAvKiogVGhlIGV2ZW50IHByb3BhZ2F0ZWQgYnkgdGhpcyBVSUVsZW1lbnQgd2hlbiB2YWx1ZSBjaGFuZ2VzICovXHJcbiAgICBwdWJsaWMgb25WYWx1ZUNoYW5nZUV2ZW50SWQ6IHN0cmluZztcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcihwb3NpdGlvbjogVmVjMiwgaW5pdFZhbHVlOiBudW1iZXIpe1xyXG4gICAgICAgIHN1cGVyKHBvc2l0aW9uKTtcclxuXHJcbiAgICAgICAgdGhpcy52YWx1ZSA9IGluaXRWYWx1ZTtcclxuICAgICAgICB0aGlzLm5pYkNvbG9yID0gQ29sb3IuUkVEO1xyXG4gICAgICAgIHRoaXMuc2xpZGVyQ29sb3IgPSBDb2xvci5CTEFDSztcclxuICAgICAgICB0aGlzLmJhY2tncm91bmRDb2xvciA9IENvbG9yLlRSQU5TUEFSRU5UO1xyXG4gICAgICAgIHRoaXMuYm9yZGVyQ29sb3IgPSBDb2xvci5UUkFOU1BBUkVOVDtcclxuICAgICAgICB0aGlzLm5pYlNpemUgPSBuZXcgVmVjMigxMCwgMjApO1xyXG5cclxuICAgICAgICAvLyBTZXQgYSBkZWZhdWx0IHNpemVcclxuICAgICAgICB0aGlzLnNpemUuc2V0KDIwMCwgMjApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0cmlldmVzIHRoZSB2YWx1ZSBvZiB0aGUgc2xpZGVyXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgdmFsdWUgb2YgdGhlIHNsaWRlclxyXG4gICAgICovXHJcbiAgICBnZXRWYWx1ZSgpOiBudW1iZXIge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBBIG1ldGhvZCBjYWxsZWQgaW4gcmVzcG9uc2UgdG8gdGhlIHZhbHVlIGNoYW5naW5nICovXHJcbiAgICBwcm90ZWN0ZWQgdmFsdWVDaGFuZ2VkKCk6IHZvaWQge1xyXG4gICAgICAgIGlmKHRoaXMub25WYWx1ZUNoYW5nZSl7XHJcbiAgICAgICAgICAgIHRoaXMub25WYWx1ZUNoYW5nZSh0aGlzLnZhbHVlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmKHRoaXMub25WYWx1ZUNoYW5nZUV2ZW50SWQpe1xyXG4gICAgICAgICAgICB0aGlzLmVtaXR0ZXIuZmlyZUV2ZW50KHRoaXMub25WYWx1ZUNoYW5nZUV2ZW50SWQsIHt0YXJnZXQ6IHRoaXMsIHZhbHVlOiB0aGlzLnZhbHVlfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHVwZGF0ZShkZWx0YVQ6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICAgIHN1cGVyLnVwZGF0ZShkZWx0YVQpO1xyXG5cclxuICAgICAgICBpZih0aGlzLmlzQ2xpY2tlZCl7XHJcbiAgICAgICAgICAgIGxldCB2YWwgPSBNYXRoVXRpbHMuaW52TGVycCh0aGlzLnBvc2l0aW9uLnggLSB0aGlzLnNpemUueC8yLCB0aGlzLnBvc2l0aW9uLnggKyB0aGlzLnNpemUueC8yLCBJbnB1dC5nZXRNb3VzZVBvc2l0aW9uKCkueCk7XHJcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBNYXRoVXRpbHMuY2xhbXAwMSh2YWwpO1xyXG4gICAgICAgICAgICB0aGlzLnZhbHVlQ2hhbmdlZCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSIsImltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvVmVjMlwiO1xyXG5pbXBvcnQgQ29sb3IgZnJvbSBcIi4uLy4uL1V0aWxzL0NvbG9yXCI7XHJcbmltcG9ydCBMYWJlbCBmcm9tIFwiLi9MYWJlbFwiO1xyXG5pbXBvcnQgSW5wdXQgZnJvbSBcIi4uLy4uL0lucHV0L0lucHV0XCI7XHJcblxyXG4vKiogQSB0ZXh0IGlucHV0IFVJRWxlbWVudCAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUZXh0SW5wdXQgZXh0ZW5kcyBMYWJlbCB7XHJcbiAgICAvKiogQSBmbGFnIHRoZSByZXByZXNlbnRzIHdoZXRoZXIgdGhlIHVzZXIgY2FuIHR5cGUgaW4gdGhpcyBUZXh0SW5wdXQgKi9cclxuICAgIGZvY3VzZWQ6IGJvb2xlYW47XHJcbiAgICAvKiogVGhlIHBvc2l0aW9uIG9mIHRoZSBjdXJzb3IgaW4gdGhpcyBUZXh0SW5wdXQgKi9cclxuICAgIGN1cnNvckNvdW50ZXI6IG51bWJlcjtcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcihwb3NpdGlvbjogVmVjMil7XHJcbiAgICAgICAgc3VwZXIocG9zaXRpb24sIFwiXCIpO1xyXG5cclxuICAgICAgICB0aGlzLmZvY3VzZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmN1cnNvckNvdW50ZXIgPSAwO1xyXG5cclxuICAgICAgICAvLyBHaXZlIGEgZGVmYXVsdCBzaXplIHRvIHRoZSB4IG9ubHlcclxuICAgICAgICB0aGlzLnNpemUuc2V0KDIwMCwgdGhpcy5mb250U2l6ZSk7XHJcbiAgICAgICAgdGhpcy5oQWxpZ24gPSBcImxlZnRcIjtcclxuXHJcbiAgICAgICAgdGhpcy5ib3JkZXJDb2xvciA9IENvbG9yLkJMQUNLO1xyXG4gICAgICAgIHRoaXMuYmFja2dyb3VuZENvbG9yID0gQ29sb3IuV0hJVEU7XHJcbiAgICB9XHJcblxyXG4gICAgdXBkYXRlKGRlbHRhVDogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgICAgc3VwZXIudXBkYXRlKGRlbHRhVCk7XHJcblxyXG4gICAgICAgIGlmKElucHV0LmlzTW91c2VKdXN0UHJlc3NlZCgpKXtcclxuXHRcdFx0bGV0IGNsaWNrUG9zID0gSW5wdXQuZ2V0TW91c2VQcmVzc1Bvc2l0aW9uKCk7XHJcblx0XHRcdGlmKHRoaXMuY29udGFpbnMoY2xpY2tQb3MueCwgY2xpY2tQb3MueSkpe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5mb2N1c2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY3Vyc29yQ291bnRlciA9IDMwO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5mb2N1c2VkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmKHRoaXMuZm9jdXNlZCl7XHJcbiAgICAgICAgICAgIGxldCBrZXlzID0gSW5wdXQuZ2V0S2V5c0p1c3RQcmVzc2VkKCk7XHJcbiAgICAgICAgICAgIGxldCBudW1zID0gXCIxMjM0NTY3ODkwXCI7XHJcbiAgICAgICAgICAgIGxldCBzcGVjaWFsQ2hhcnMgPSBcImB+IUAjJCVeJiooKS1fPStbe119XFxcXHw7OidcXFwiLDwuPi8/XCI7XHJcbiAgICAgICAgICAgIGxldCBsZXR0ZXJzID0gXCJxd2VydHl1aW9wYXNkZmdoamtsenhjdmJubVwiO1xyXG4gICAgICAgICAgICBsZXQgbWFzayA9IG51bXMgKyBzcGVjaWFsQ2hhcnMgKyBsZXR0ZXJzO1xyXG4gICAgICAgICAgICBrZXlzID0ga2V5cy5maWx0ZXIoa2V5ID0+IG1hc2suaW5jbHVkZXMoa2V5KSk7XHJcbiAgICAgICAgICAgIGxldCBzaGlmdFByZXNzZWQgPSBJbnB1dC5pc0tleVByZXNzZWQoXCJzaGlmdFwiKTtcclxuICAgICAgICAgICAgbGV0IGJhY2tzcGFjZVByZXNzZWQgPSBJbnB1dC5pc0tleUp1c3RQcmVzc2VkKFwiYmFja3NwYWNlXCIpO1xyXG4gICAgICAgICAgICBsZXQgc3BhY2VQcmVzc2VkID0gSW5wdXQuaXNLZXlKdXN0UHJlc3NlZChcInNwYWNlXCIpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYoYmFja3NwYWNlUHJlc3NlZCl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRleHQgPSB0aGlzLnRleHQuc3Vic3RyaW5nKDAsIHRoaXMudGV4dC5sZW5ndGggLSAxKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmKHNwYWNlUHJlc3NlZCl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRleHQgKz0gXCIgXCI7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZihrZXlzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIGlmKHNoaWZ0UHJlc3NlZCl7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50ZXh0ICs9IGtleXNbMF0udG9VcHBlckNhc2UoKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50ZXh0ICs9IGtleXNbMF07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0iLCJleHBvcnQgZW51bSBVSUVsZW1lbnRUeXBlIHtcclxuXHRCVVRUT04gPSBcIkJVVFRPTlwiLFxyXG5cdExBQkVMID0gXCJMQUJFTFwiLFxyXG5cdFNMSURFUiA9IFwiU0xJREVSXCIsXHJcblx0VEVYVF9JTlBVVCA9IFwiVEVYVElOUFVUXCJcclxufSIsImltcG9ydCBOYXZpZ2FibGUgZnJvbSBcIi4uL0RhdGFUeXBlcy9JbnRlcmZhY2VzL05hdmlnYWJsZVwiO1xyXG5pbXBvcnQgTWFwIGZyb20gXCIuLi9EYXRhVHlwZXMvTWFwXCI7XHJcbmltcG9ydCBWZWMyIGZyb20gXCIuLi9EYXRhVHlwZXMvVmVjMlwiO1xyXG5pbXBvcnQgTmF2aWdhdGlvblBhdGggZnJvbSBcIi4vTmF2aWdhdGlvblBhdGhcIjtcclxuXHJcbi8qKlxyXG4gKiBUaGUgbWFuYWdlciBjbGFzcyBmb3IgbmF2aWdhdGlvbi5cclxuICogSGFuZGxlcyBhbGwgbmF2aWdhYmxlIGVudGl0aWVzLCBzdWNoIGFuZCBhbGxvd3MgdGhlbSB0byBiZSBhY2Nlc3NlZCBieSBvdXRzaWRlIHN5c3RlbXMgYnkgcmVxdWVzdGluZyBhIHBhdGhcclxuICogZnJvbSBvbmUgcG9zaXRpb24gdG8gYW5vdGhlci5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE5hdmlnYXRpb25NYW5hZ2VyIHtcclxuXHQvKiogVGhlIGxpc3Qgb2YgYWxsIG5hdmlnYWJsZSBlbnRpdGllcyAqL1xyXG5cdHByb3RlY3RlZCBuYXZpZ2FibGVFbnRpdGllczogTWFwPE5hdmlnYWJsZT47XHJcblxyXG5cdGNvbnN0cnVjdG9yKCl7XHJcblx0XHR0aGlzLm5hdmlnYWJsZUVudGl0aWVzID0gbmV3IE1hcCgpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQWRkcyBhIG5hdmlnYWJsZSBlbnRpdHkgdG8gdGhlIE5hdmlnYXRpb25NYW5hZ2VyXHJcblx0ICogQHBhcmFtIG5hdk5hbWUgVGhlIG5hbWUgb2YgdGhlIG5hdmlnYWJsZSBlbnRpdHJ5XHJcblx0ICogQHBhcmFtIG5hdiBUaGUgYWN0dWFsIE5hdmlnYWJsZSBpbnN0YW5jZVxyXG5cdCAqL1xyXG5cdGFkZE5hdmlnYWJsZUVudGl0eShuYXZOYW1lOiBzdHJpbmcsIG5hdjogTmF2aWdhYmxlKTogdm9pZCB7XHJcblx0XHR0aGlzLm5hdmlnYWJsZUVudGl0aWVzLmFkZChuYXZOYW1lLCBuYXYpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogR2V0cyBhIHBhdGggZnJvbWUgb25lIHBvaW50IHRvIGFub3RoZXIgdXNpbmcgYSBzcGVjaWZpZWQgTmF2aWdhYmxlIG9iamVjdFxyXG5cdCAqIEBwYXJhbSBuYXZOYW1lIFRoZSBuYW1lIG9mIHRoZSByZWdpc3RlcmVkIE5hdmlnYWJsZSBvYmplY3RcclxuXHQgKiBAcGFyYW0gZnJvbVBvc2l0aW9uIFRoZSBzdGFydGluZyBwb3NpdGlvbiBvZiBuYXZpZ2F0aW9uXHJcblx0ICogQHBhcmFtIHRvUG9zaXRpb24gVGhlIGVuZGluZyBwb3NpdGlvbiBvZiBOYXZpZ2F0aW9uXHJcblx0ICogQHBhcmFtIGRpcmVjdCBJZiB0cnVlLCBnbyBkaXJlY3QgZnJvbSBmcm9tUG9zaXRpb24gdG8gdG9Qb3NpdGlvbiwgZG9uJ3QgdXNlIE5hdk1lc2hcclxuXHQgKiBAcmV0dXJucyBBIE5hdmlnYXRpb25QYXRoIGNvbnRhaW5pbmcgdGhlIHJvdXRlIHRvIHRha2Ugb3ZlciB0aGUgTmF2aWdhYmxlIGVudGl0eSB0byBnZXQgYmV0d2VlbiB0aGUgcHJvdmlkZWQgcG9zaXRpb25zLlxyXG5cdCAqL1xyXG5cdGdldFBhdGgobmF2TmFtZTogc3RyaW5nLCBmcm9tUG9zaXRpb246IFZlYzIsIHRvUG9zaXRpb246IFZlYzIsIGRpcmVjdD86IGJvb2xlYW4pOiBOYXZpZ2F0aW9uUGF0aCB7XHJcblx0XHRsZXQgbmF2ID0gdGhpcy5uYXZpZ2FibGVFbnRpdGllcy5nZXQobmF2TmFtZSk7XHJcblx0XHRyZXR1cm4gbmF2LmdldE5hdmlnYXRpb25QYXRoKGZyb21Qb3NpdGlvbi5jbG9uZSgpLCB0b1Bvc2l0aW9uLmNsb25lKCksIGRpcmVjdCk7XHJcblx0fVxyXG59IiwiaW1wb3J0IFN0YWNrIGZyb20gXCIuLi9EYXRhVHlwZXMvU3RhY2tcIjtcclxuaW1wb3J0IFZlYzIgZnJvbSBcIi4uL0RhdGFUeXBlcy9WZWMyXCI7XHJcbmltcG9ydCBHYW1lTm9kZSBmcm9tIFwiLi4vTm9kZXMvR2FtZU5vZGVcIjtcclxuXHJcbi8qKlxyXG4gKiBBIHBhdGggdGhhdCBBSXMgY2FuIGZvbGxvdy4gVXNlcyBmaW5pc2hNb3ZlKCkgaW4gUGh5c2ljYWwgdG8gZGV0ZXJtaW5lIHByb2dyZXNzIG9uIHRoZSByb3V0ZVxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTmF2aWdhdGlvblBhdGgge1xyXG5cdC8qKiBUaGUgbmF2aWdhdGlvbiBwYXRoLCBzdG9yZWQgYXMgYSBzdGFjayBvZiBuZXh0IHBvc2l0aW9ucyAqL1xyXG5cdHByb3RlY3RlZCBwYXRoOiBTdGFjazxWZWMyPjtcclxuXHQvKiogVGhlIGN1cnJlbnQgZGlyZWN0aW9uIG9mIG1vdmVtZW50ICovXHJcblx0cHJvdGVjdGVkIGN1cnJlbnRNb3ZlRGlyZWN0aW9uOiBWZWMyO1xyXG5cdC8qKiBUaGUgZGlzdGFuY2UgYSBub2RlIG11c3QgYmUgdG8gYSBwb2ludCB0byBjb25zaWRlciBpdCBhcyBoYXZpbmcgYXJyaXZlZCAqL1xyXG5cdHByb3RlY3RlZCBkaXN0YW5jZVRocmVzaG9sZDogbnVtYmVyO1xyXG5cclxuXHQvKipcclxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IE5hdmlnYXRpb25QYXRoXHJcblx0ICogQHBhcmFtIHBhdGggVGhlIHBhdGggb2Ygbm9kZXMgdG8gdGFrZVxyXG5cdCAqL1xyXG5cdGNvbnN0cnVjdG9yKHBhdGg6IFN0YWNrPFZlYzI+KXtcclxuXHRcdHRoaXMucGF0aCA9IHBhdGg7XHJcblx0XHR0aGlzLmN1cnJlbnRNb3ZlRGlyZWN0aW9uID0gVmVjMi5aRVJPO1xyXG5cdFx0dGhpcy5kaXN0YW5jZVRocmVzaG9sZCA9IDQ7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRoZSBzdGF0dXMgb2YgbmF2aWdhdGlvbiBhbG9uZyB0aGlzIE5hdmlnYXRpb25QYXRoXHJcblx0ICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgbm9kZSBoYXMgcmVhY2hlZCB0aGUgZW5kIG9mIHRoZSBwYXRoLCBmYWxzZSBvdGhlcndpc2VcclxuXHQgKi9cclxuXHRpc0RvbmUoKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gdGhpcy5wYXRoLmlzRW1wdHkoKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldHMgdGhlIG1vdmVtZW50IGRpcmVjdGlvbiBpbiB0aGUgY3VycmVudCBwb3NpdGlvbiBhbG9uZyB0aGUgcGF0aFxyXG5cdCAqIEBwYXJhbSBub2RlIFRoZSBub2RlIHRvIG1vdmUgYWxvbmcgdGhlIHBhdGhcclxuXHQgKiBAcmV0dXJucyBUaGUgbW92ZW1lbnQgZGlyZWN0aW9uIGFzIGEgVmVjMlxyXG5cdCAqL1xyXG5cdGdldE1vdmVEaXJlY3Rpb24obm9kZTogR2FtZU5vZGUpOiBWZWMyIHtcclxuXHRcdC8vIFJldHVybiBkaXJlY3Rpb24gdG8gbmV4dCBwb2ludCBpbiB0aGUgbmF2XHJcblx0XHRyZXR1cm4gbm9kZS5wb3NpdGlvbi5kaXJUbyh0aGlzLnBhdGgucGVlaygpKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFVwZGF0ZXMgdGhpcyBOYXZpZ2F0aW9uUGF0aCB0byB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgR2FtZU5vZGVcclxuXHQgKiBAcGFyYW0gbm9kZSBUaGUgbm9kZSBtb3ZpbmcgYWxvbmcgdGhlIHBhdGhcclxuXHQgKi9cclxuXHRoYW5kbGVQYXRoUHJvZ3Jlc3Mobm9kZTogR2FtZU5vZGUpOiB2b2lkIHtcclxuXHRcdGlmKG5vZGUucG9zaXRpb24uZGlzdGFuY2VTcVRvKHRoaXMucGF0aC5wZWVrKCkpIDwgdGhpcy5kaXN0YW5jZVRocmVzaG9sZCp0aGlzLmRpc3RhbmNlVGhyZXNob2xkKXtcclxuXHRcdFx0Ly8gV2UndmUgcmVhY2hlZCBvdXIgbm9kZSwgbW92ZSBvbiB0byB0aGUgbmV4dCBkZXN0aW5hdGlvblxyXG5cdFx0XHR0aGlzLnBhdGgucG9wKCk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHR0b1N0cmluZygpOiBzdHJpbmcge1xyXG5cdFx0cmV0dXJuIHRoaXMucGF0aC50b1N0cmluZygpXHJcblx0fVxyXG59IiwiaW1wb3J0IFBvc2l0aW9uR3JhcGggZnJvbSBcIi4uL0RhdGFUeXBlcy9HcmFwaHMvUG9zaXRpb25HcmFwaFwiO1xyXG5pbXBvcnQgTmF2aWdhYmxlIGZyb20gXCIuLi9EYXRhVHlwZXMvSW50ZXJmYWNlcy9OYXZpZ2FibGVcIjtcclxuaW1wb3J0IFN0YWNrIGZyb20gXCIuLi9EYXRhVHlwZXMvU3RhY2tcIjtcclxuaW1wb3J0IFZlYzIgZnJvbSBcIi4uL0RhdGFUeXBlcy9WZWMyXCI7XHJcbmltcG9ydCBHcmFwaFV0aWxzIGZyb20gXCIuLi9VdGlscy9HcmFwaFV0aWxzXCI7XHJcbmltcG9ydCBOYXZpZ2F0aW9uUGF0aCBmcm9tIFwiLi9OYXZpZ2F0aW9uUGF0aFwiO1xyXG5cclxuLyoqXHJcbiAqIEFuIGltcGxlbWVudGF0aW9uIG9mIGEgTmF2bWVzaC4gTmF2bWVzaGVzIGFyZSBncmFwaHMgaW4gdGhlIGdhbWUgd29ybGQgYWxvbmcgd2hpY2ggbm9kZXMgY2FuIG1vdmUuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBOYXZtZXNoIGltcGxlbWVudHMgTmF2aWdhYmxlIHtcclxuXHQvKiogVGhlIGdyYXBoIG9mIHBvaW50cyBpbiB0aGUgTmF2TWVzaCAqL1xyXG5cdHByb3RlY3RlZCBncmFwaDogUG9zaXRpb25HcmFwaDtcclxuXHJcblx0LyoqXHJcblx0ICogQ3JlYXRlcyBhIG5ldyBOYXZtZXNoIGZyb20gdGhlIHBvaW50cyBpbiB0aGUgc3BlZWNpZmllZCBncmFwaFxyXG5cdCAqIEBwYXJhbSBncmFwaCBUaGUgZ3JhcGggdG8gY29uc3RydWN0IGEgbmF2bWVzaCBmcm9tXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3IoZ3JhcGg6IFBvc2l0aW9uR3JhcGgpe1xyXG5cdFx0dGhpcy5ncmFwaCA9IGdyYXBoO1xyXG5cdH1cclxuXHJcblx0Ly8gQGltcGxlbWVudGVkXHJcblx0Z2V0TmF2aWdhdGlvblBhdGgoZnJvbVBvc2l0aW9uOiBWZWMyLCB0b1Bvc2l0aW9uOiBWZWMyLCBkaXJlY3Q6IGJvb2xlYW4pOiBOYXZpZ2F0aW9uUGF0aCB7XHJcblx0XHRsZXQgc3RhcnQgPSB0aGlzLmdldENsb3Nlc3ROb2RlKGZyb21Qb3NpdGlvbik7XHJcblx0XHRsZXQgZW5kID0gdGhpcy5nZXRDbG9zZXN0Tm9kZSh0b1Bvc2l0aW9uKTtcclxuXHJcblx0XHRsZXQgcGF0aFN0YWNrID0gbmV3IFN0YWNrPFZlYzI+KHRoaXMuZ3JhcGgubnVtVmVydGljZXMpO1xyXG5cdFx0XHJcblx0XHQvLyBQdXNoIHRoZSBmaW5hbCBwb3NpdGlvbiBhbmQgdGhlIGZpbmFsIHBvc2l0aW9uIGluIHRoZSBncmFwaFxyXG5cdFx0cGF0aFN0YWNrLnB1c2godG9Qb3NpdGlvbi5jbG9uZSgpKTtcclxuXHJcblx0XHRpZiAoZGlyZWN0KSB7XHJcblx0XHRcdHJldHVybiBuZXcgTmF2aWdhdGlvblBhdGgocGF0aFN0YWNrKTtcclxuXHRcdH1cclxuXHJcblx0XHRwYXRoU3RhY2sucHVzaCh0aGlzLmdyYXBoLnBvc2l0aW9uc1tlbmRdKTtcclxuXHJcblx0XHRsZXQgcGFyZW50ID0gR3JhcGhVdGlscy5kamlrc3RyYSh0aGlzLmdyYXBoLCBzdGFydCk7XHJcblxyXG5cdFx0Ly8gQWRkIGFsbCBwYXJlbnRzIGFsb25nIHRoZSBwYXRoXHJcblx0XHRsZXQgaSA9IGVuZDtcclxuXHRcdHdoaWxlKHBhcmVudFtpXSAhPT0gLTEpe1xyXG5cdFx0XHRwYXRoU3RhY2sucHVzaCh0aGlzLmdyYXBoLnBvc2l0aW9uc1twYXJlbnRbaV1dKTtcclxuXHRcdFx0aSA9IHBhcmVudFtpXTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbmV3IE5hdmlnYXRpb25QYXRoKHBhdGhTdGFjayk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBHZXRzIHRoZSBjbG9zZXN0IG5vZGUgaW4gdGhpcyBOYXZtZXNoIHRvIHRoZSBzcGVjaWZpZWQgcG9zaXRpb25cclxuXHQgKiBAcGFyYW0gcG9zaXRpb24gVGhlIHBvc2l0aW9uIHRvIHF1ZXJ5XHJcblx0ICogQHJldHVybnMgVGhlIGluZGV4IG9mIHRoZSBjbG9zZXN0IG5vZGUgaW4gdGhlIE5hdm1lc2ggdG8gdGhlIHBvc2l0aW9uXHJcblx0ICovXHJcblx0cHJvdGVjdGVkIGdldENsb3Nlc3ROb2RlKHBvc2l0aW9uOiBWZWMyKTogbnVtYmVyIHtcclxuXHRcdGxldCBuID0gdGhpcy5ncmFwaC5udW1WZXJ0aWNlcztcclxuXHRcdGxldCBpID0gMTtcclxuXHRcdGxldCBpbmRleCA9IDA7XHJcblx0XHRsZXQgZGlzdCA9IHBvc2l0aW9uLmRpc3RhbmNlU3FUbyh0aGlzLmdyYXBoLnBvc2l0aW9uc1swXSk7XHJcblx0XHR3aGlsZShpIDwgbil7XHJcblx0XHRcdGxldCBkID0gcG9zaXRpb24uZGlzdGFuY2VTcVRvKHRoaXMuZ3JhcGgucG9zaXRpb25zW2ldKTtcclxuXHRcdFx0aWYoZCA8IGRpc3Qpe1xyXG5cdFx0XHRcdGRpc3QgPSBkO1xyXG5cdFx0XHRcdGluZGV4ID0gaTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpKys7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGluZGV4O1xyXG5cdH1cclxufSIsImltcG9ydCBHYW1lTm9kZSBmcm9tIFwiLi4vTm9kZXMvR2FtZU5vZGVcIjtcclxuaW1wb3J0IFBoeXNpY2FsIGZyb20gXCIuLi9EYXRhVHlwZXMvSW50ZXJmYWNlcy9QaHlzaWNhbFwiO1xyXG5pbXBvcnQgVGlsZW1hcCBmcm9tIFwiLi4vTm9kZXMvVGlsZW1hcFwiO1xyXG5pbXBvcnQgUGh5c2ljc01hbmFnZXIgZnJvbSBcIi4vUGh5c2ljc01hbmFnZXJcIjtcclxuaW1wb3J0IFZlYzIgZnJvbSBcIi4uL0RhdGFUeXBlcy9WZWMyXCI7XHJcbmltcG9ydCBBQUJCIGZyb20gXCIuLi9EYXRhVHlwZXMvU2hhcGVzL0FBQkJcIjtcclxuaW1wb3J0IE9ydGhvZ29uYWxUaWxlbWFwIGZyb20gXCIuLi9Ob2Rlcy9UaWxlbWFwcy9PcnRob2dvbmFsVGlsZW1hcFwiO1xyXG5pbXBvcnQgQXJlYUNvbGxpc2lvbiBmcm9tIFwiLi4vRGF0YVR5cGVzL1BoeXNpY3MvQXJlYUNvbGxpc2lvblwiO1xyXG5pbXBvcnQgVW5pcXVlIGZyb20gXCIuLi9EYXRhVHlwZXMvSW50ZXJmYWNlcy9VbmlxdWVcIjtcclxuXHJcbi8qKlxyXG4gKiBBTEdPUklUSE06XHJcbiAqIFx0SW4gYW4gZWZmb3J0IHRvIGtlZXAgdGhpbmdzIHNpbXBsZSBhbmQgd29ya2luZyBlZmZlY3RpdmVseSwgZWFjaCBkeW5hbWljIG5vZGUgd2lsbCByZXNvbHZlIGl0c1xyXG4gKiBcdGNvbGxpc2lvbnMgY29uc2lkZXJpbmcgdGhlIHJlc3Qgb2YgdGhlIHdvcmxkIGFzIHN0YXRpYy5cclxuICogXHJcbiAqIFx0Q29sbGlzaW9uIGRldGVjdGluZyB3aWxsIGhhcHBlbiBmaXJzdC4gVGhpcyBjYW4gYmUgY29uc2lkZXJlZCBhIGJyb2FkIHBoYXNlLCBidXQgaXQgaXMgbm90IGVzcGVjaWFsbHlcclxuICogXHRlZmZpY2llbnQsIGFzIGl0IGRvZXMgbm90IG5lZWQgdG8gYmUgZm9yIHRoaXMgZ2FtZSBlbmdpbmUuIEV2ZXJ5IGR5bmFtaWMgbm9kZSBpcyBjaGVja2VkIGFnYWluc3QgZXZlcnlcclxuICogXHRvdGhlciBub2RlIGZvciBjb2xsaXNpb24gYXJlYS4gSWYgY29sbGlzaW9uIGFyZWEgaXMgbm9uLXplcm8gKG1lYW5pbmcgdGhlIGN1cnJlbnQgbm9kZSBzd2VlcHMgaW50byBhbm90aGVyKSxcclxuICogXHRpdCBpcyBhZGRlZCB0byBhIGxpc3Qgb2YgaGl0cy5cclxuICogXHJcbiAqIFx0SU5JVElBTElaQVRJT046XHJcbiAqIFx0XHQtIFBoeXNpY3MgY29uc3RhbnRzIGFyZSByZXNldFxyXG4gKiBcdFx0LSBTd2VwdCBzaGFwZXMgYXJlIHJlY2FsY3VsYXRlZC4gSWYgYSBub2RlIGlzbid0IG1vdmluZywgaXQgaXMgc2tpcHBlZC5cclxuICogXHJcbiAqIFx0Q09MTElTSU9OIERFVEVDVElPTjpcclxuICogXHRcdC0gRm9yIGEgbm9kZSwgY29sbGlzaW9uIGFyZWEgd2lsbCBiZSBjYWxjdWxhdGVkIHVzaW5nIHRoZSBzd2VwdCBBQUJCIG9mIHRoZSBub2RlIGFnYWluc3QgZXZlcnkgb3RoZXIgQUFCQiBpbiBhIHN0YXRpYyBzdGF0ZVxyXG4gKiBcdFx0LSBUaGVzZSBjb2xsaXNpb25zIHdpbGwgYmUgc29ydGVkIGJ5IGFyZWEgaW4gZGVzY2VuZGluZyBvcmRlclxyXG4gKiBcdFxyXG4gKiBcdENPTExJU0lPTiBSRVNPTFVUSU9OOlxyXG4gKiBcdFx0LSBGb3IgZWFjaCBoaXQsIHRpbWUgb2YgY29sbGlzaW9uIGlzIGNhbGN1bGF0ZWQgdXNpbmcgYSBzd2VwdCBsaW5lIHRocm91Z2ggdGhlIEFBQkIgb2YgdGhlIHN0YXRpYyBub2RlIGV4cGFuZGVkXHJcbiAqIFx0XHRcdHdpdGggbWlua293c2tpIHN1bXMgKGRpc2NyZXRlbHksIGJ1dCB0aGUgY29uY2VwdCBpcyB0aGVyZSlcclxuICogXHRcdC0gVGhlIGNvbGxpc2lvbiBpcyByZXNvbHZlZCBiYXNlZCBvbiB0aGUgbmVhciB0aW1lIG9mIHRoZSBjb2xsaXNpb24gKGZyb20gbWV0aG9kIG9mIHNlcGFyYXRlZCBheGVzKVxyXG4gKiBcdFx0XHQtIFggaXMgcmVzb2x2ZWQgYnkgbmVhciB4LCBZIGJ5IG5lYXIgeS5cclxuICogXHRcdFx0LSBUaGVyZSBpcyBzb21lIGZ1ZGdpbmcgdG8gYWxsb3cgZm9yIHNsaWRpbmcgYWxvbmcgd2FsbHMgb2Ygc2VwYXJhdGUgY29sbGlkZXJzLiBTb3J0aW5nIGJ5IGFyZWEgYWxzbyBoZWxwcyB3aXRoIHRoaXMuXHJcbiAqIFx0XHRcdC0gQ29ybmVyIHRvIGNvcm5lciBjb2xsaXNpb25zIGFyZSByZXNvbHZlIHRvIGZhdm9yIHgtbW92ZW1lbnQuIFRoaXMgaXMgaW4gY29uc2lkZXJhdGlvbiBvZiBwbGF0Zm9ybWVycywgdG8gZ2l2ZVxyXG4gKiBcdFx0XHRcdHRoZSBwbGF5ZXIgc29tZSBoZWxwIHdpdGgganVtcHNcclxuICogXHJcbiAqIFx0UHJvczpcclxuICogXHRcdC0gRXZlcnl0aGluZyBoYXBwZW5zIHdpdGggYSBjb25zaXN0ZW50IHRpbWUuIFRoZXJlIGlzIGEgZGlzdGluY3QgYmVmb3JlIGFuZCBhZnRlciBmb3IgZWFjaCByZXNvbHV0aW9uLlxyXG4gKiBcdFx0LSBObyBiYWNrLXRyYWNraW5nIG5lZWRzIHRvIGJlIGRvbmUuIE9uY2Ugd2UgcmVzb2x2ZSBhIG5vZGUsIGl0IGlzIGRlZmluaXRpdmVseSByZXNvbHZlZC5cclxuICogXHRcclxuICogXHRDb25zOlxyXG4gKiBcdFx0LSBOb2RlcyB0aGF0IGFyZSBwcm9jZXNzZWQgZWFybHkgaGF2ZSBtb3ZlbWVudCBwcmlvcml0eSBvdmVyIG90aGVyIG5vZGVzLiBUaGlzIGNhbiBsZWFkIHRvIHNvbWUgdW5kZXNpcmFibGUgaW50ZXJhY3Rpb25zLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQmFzaWNQaHlzaWNzTWFuYWdlciBleHRlbmRzIFBoeXNpY3NNYW5hZ2VyIHtcclxuXHJcblx0LyoqIFRoZSBhcnJheSBvZiBzdGF0aWMgbm9kZXMgKi9cclxuXHRwcm90ZWN0ZWQgc3RhdGljTm9kZXM6IEFycmF5PFBoeXNpY2FsPjtcclxuXHJcblx0LyoqIFRoZSBhcnJheSBvZiBkeW5hbWljIG5vZGVzICovXHJcblx0cHJvdGVjdGVkIGR5bmFtaWNOb2RlczogQXJyYXk8UGh5c2ljYWw+O1xyXG5cclxuXHQvKiogVGhlIGFycmF5IG9mIHRpbGVtYXBzICovXHJcblx0cHJvdGVjdGVkIHRpbGVtYXBzOiBBcnJheTxUaWxlbWFwPjtcclxuXHJcblx0LyoqIEFuIGFycmF5IG9mIHRoZSBjb2xsaXNpb24gbWFza3MgZm9yIGVhY2ggZ3JvdXAgKi9cclxuXHRwcm90ZWN0ZWQgY29sbGlzaW9uTWFza3M6IEFycmF5PG51bWJlcj47XHJcblxyXG5cdGNvbnN0cnVjdG9yKG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT4pe1xyXG5cdFx0c3VwZXIoKTtcclxuXHRcdHRoaXMuc3RhdGljTm9kZXMgPSBuZXcgQXJyYXkoKTtcclxuXHRcdHRoaXMuZHluYW1pY05vZGVzID0gbmV3IEFycmF5KCk7XHJcblx0XHR0aGlzLnRpbGVtYXBzID0gbmV3IEFycmF5KCk7XHJcblx0XHR0aGlzLmNvbGxpc2lvbk1hc2tzID0gbmV3IEFycmF5KDMyKTtcclxuXHJcblx0XHQvLyBQYXJzZSBvcHRpb25zXHJcblx0XHR0aGlzLnBhcnNlT3B0aW9ucyhvcHRpb25zKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFBhcnNlcyB0aGUgb3B0aW9ucyBmb3IgY29uc3RydWN0aW5nIHRoZSBwaHlzaWNzIG1hbmFnZXJcclxuXHQgKiBAcGFyYW0gb3B0aW9ucyBBIHJlY29yZCBvZiBvcHRpb25zXHJcblx0ICovXHJcblx0cHJvdGVjdGVkIHBhcnNlT3B0aW9ucyhvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogdm9pZCB7XHJcblx0XHRpZihvcHRpb25zLmdyb3VwTmFtZXMgIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLmNvbGxpc2lvbnMgIT09IHVuZGVmaW5lZCl7XHJcblx0XHRcdGZvcihsZXQgaSA9IDA7IGkgPCBvcHRpb25zLmdyb3VwTmFtZXMubGVuZ3RoOyBpKyspe1xyXG5cdFx0XHRcdGxldCBncm91cCA9IG9wdGlvbnMuZ3JvdXBOYW1lc1tpXTtcclxuXHJcblx0XHRcdFx0Ly8gUmVnaXN0ZXIgdGhlIGdyb3VwIG5hbWUgYW5kIG51bWJlclxyXG5cdFx0XHRcdHRoaXMuZ3JvdXBOYW1lc1tpXSA9IGdyb3VwO1xyXG5cclxuXHRcdFx0XHR0aGlzLmdyb3VwTWFwLnNldChncm91cCwgMSA8PCBpKTtcclxuXHJcblx0XHRcdFx0bGV0IGNvbGxpc2lvbk1hc2sgPSAwO1xyXG5cclxuXHRcdFx0XHRmb3IobGV0IGogPSAwOyBqIDwgb3B0aW9ucy5jb2xsaXNpb25zW2ldLmxlbmd0aDsgaisrKXtcclxuXHRcdFx0XHRcdGlmKG9wdGlvbnMuY29sbGlzaW9uc1tpXVtqXSl7XHJcblx0XHRcdFx0XHRcdGNvbGxpc2lvbk1hc2sgfD0gMSA8PCBqO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dGhpcy5jb2xsaXNpb25NYXNrc1tpXSA9IGNvbGxpc2lvbk1hc2s7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8vIEBvdmVycmlkZVxyXG5cdHJlZ2lzdGVyT2JqZWN0KG5vZGU6IFBoeXNpY2FsKTogdm9pZCB7XHJcblx0XHRpZihub2RlLmlzU3RhdGljKXtcclxuXHRcdFx0Ly8gU3RhdGljIGFuZCBub3QgY29sbGlkYWJsZVxyXG5cdFx0XHR0aGlzLnN0YXRpY05vZGVzLnB1c2gobm9kZSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHQvLyBEeW5hbWljIGFuZCBub3QgY29sbGlkYWJsZVxyXG5cdFx0XHR0aGlzLmR5bmFtaWNOb2Rlcy5wdXNoKG5vZGUpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Ly8gQG92ZXJyaWRlXHJcblx0ZGVyZWdpc3Rlck9iamVjdChub2RlOiBQaHlzaWNhbCk6IHZvaWQge1xyXG5cdFx0aWYobm9kZS5pc1N0YXRpYyl7XHJcblx0XHRcdC8vIFJlbW92ZSB0aGUgbm9kZSBmcm9tIHRoZSBzdGF0aWMgbGlzdFxyXG5cdFx0XHRjb25zdCBpbmRleCA9IHRoaXMuc3RhdGljTm9kZXMuaW5kZXhPZihub2RlKTtcclxuXHRcdFx0dGhpcy5zdGF0aWNOb2Rlcy5zcGxpY2UoaW5kZXgsIDEpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Ly8gUmVtb3ZlIHRoZSBub2RlIGZyb20gdGhlIGR5bmFtaWMgbGlzdFxyXG5cdFx0XHRjb25zdCBpbmRleCA9IHRoaXMuZHluYW1pY05vZGVzLmluZGV4T2Yobm9kZSk7XHJcblx0XHRcdHRoaXMuZHluYW1pY05vZGVzLnNwbGljZShpbmRleCwgMSk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvLyBAb3ZlcnJpZGVcclxuXHRyZWdpc3RlclRpbGVtYXAodGlsZW1hcDogVGlsZW1hcCk6IHZvaWQge1xyXG5cdFx0dGhpcy50aWxlbWFwcy5wdXNoKHRpbGVtYXApO1xyXG5cdH1cclxuXHJcblx0Ly8gQG92ZXJyaWRlXHJcblx0ZGVyZWdpc3RlclRpbGVtYXAodGlsZW1hcDogVGlsZW1hcCk6IHZvaWQge1xyXG5cdFx0Y29uc3QgaW5kZXggPSB0aGlzLnRpbGVtYXBzLmluZGV4T2YodGlsZW1hcCk7XHJcblx0XHR0aGlzLnRpbGVtYXBzLnNwbGljZShpbmRleCwgMSk7XHJcblx0fVxyXG5cclxuXHQvLyBAb3ZlcnJpZGVcclxuXHR1cGRhdGUoZGVsdGFUOiBudW1iZXIpOiB2b2lkIHtcclxuXHRcdGZvcihsZXQgbm9kZSBvZiB0aGlzLmR5bmFtaWNOb2Rlcyl7XHJcblx0XHRcdC8qLS0tLS0tLS0tLSBJTklUSUFMSVpBVElPTiBQSEFTRSAtLS0tLS0tLS0tKi9cclxuXHRcdFx0Ly8gQ2xlYXIgZnJhbWUgZGVwZW5kZW50IGJvb2xlYW4gdmFsdWVzIGZvciBlYWNoIG5vZGVcclxuXHRcdFx0bm9kZS5vbkdyb3VuZCA9IGZhbHNlO1xyXG5cdFx0XHRub2RlLm9uQ2VpbGluZyA9IGZhbHNlO1xyXG5cdFx0XHRub2RlLm9uV2FsbCA9IGZhbHNlO1xyXG5cdFx0XHRub2RlLmNvbGxpZGVkV2l0aFRpbGVtYXAgPSBmYWxzZTtcclxuXHRcdFx0bm9kZS5pc0NvbGxpZGluZyA9IGZhbHNlO1xyXG5cclxuXHRcdFx0Ly8gSWYgdGhpcyBub2RlIGlzIG5vdCBhY3RpdmUsIGRvbid0IHByb2Nlc3MgaXRcclxuXHRcdFx0aWYoIW5vZGUuYWN0aXZlKXtcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gVXBkYXRlIHRoZSBzd2VwdCBzaGFwZXMgb2YgZWFjaCBub2RlXHJcblx0XHRcdGlmKG5vZGUubW92aW5nKXtcclxuXHRcdFx0XHQvLyBJZiBtb3ZpbmcsIHJlZmxlY3QgdGhhdCBpbiB0aGUgc3dlcHQgc2hhcGVcclxuXHRcdFx0XHRub2RlLnN3ZXB0UmVjdC5zd2VlcChub2RlLl92ZWxvY2l0eSwgbm9kZS5jb2xsaXNpb25TaGFwZS5jZW50ZXIsIG5vZGUuY29sbGlzaW9uU2hhcGUuaGFsZlNpemUpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdC8vIElmIG91ciBub2RlIGlzbid0IG1vdmluZywgZG9uJ3QgYm90aGVyIHRvIGNoZWNrIGl0IChvdGhlciBub2RlcyB3aWxsIGRldGVjdCBpZiB0aGV5IHJ1biBpbnRvIGl0KVxyXG5cdFx0XHRcdG5vZGUuX3ZlbG9jaXR5Lnplcm8oKTtcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0LyotLS0tLS0tLS0tIERFVEVDVElPTiBQSEFTRSAtLS0tLS0tLS0tKi9cclxuXHRcdFx0Ly8gR2F0aGVyIGEgc2V0IG9mIG92ZXJsYXBzXHJcblx0XHRcdGxldCBvdmVybGFwcyA9IG5ldyBBcnJheTxBcmVhQ29sbGlzaW9uPigpO1xyXG5cclxuXHRcdFx0bGV0IGdyb3VwSW5kZXggPSBub2RlLmdyb3VwID09PSAtMSA/IC0xIDogTWF0aC5sb2cyKG5vZGUuZ3JvdXApO1xyXG5cclxuXHRcdFx0Ly8gRmlyc3QsIGNoZWNrIHRoaXMgbm9kZSBhZ2FpbnN0IGV2ZXJ5IHN0YXRpYyBub2RlIChvcmRlciBkb2Vzbid0IGFjdHVhbGx5IG1hdHRlciBoZXJlLCBzaW5jZSB3ZSBzb3J0IGFueXdheXMpXHJcblx0XHRcdGZvcihsZXQgb3RoZXIgb2YgdGhpcy5zdGF0aWNOb2Rlcyl7XHJcblx0XHRcdFx0Ly8gSWdub3JlIGluYWN0aXZlIG5vZGVzXHJcblx0XHRcdFx0aWYoIW90aGVyLmFjdGl2ZSkgY29udGludWU7XHJcblxyXG5cdFx0XHRcdGxldCBjb2xsaWRlciA9IG90aGVyLmNvbGxpc2lvblNoYXBlLmdldEJvdW5kaW5nUmVjdCgpO1xyXG5cdFx0XHRcdGxldCBhcmVhID0gbm9kZS5zd2VwdFJlY3Qub3ZlcmxhcEFyZWEoY29sbGlkZXIpO1xyXG5cdFx0XHRcdGlmKGFyZWEgPiAwKXtcclxuXHRcdFx0XHRcdC8vIFdlIGhhZCBhIGNvbGxpc2lvblxyXG5cdFx0XHRcdFx0b3ZlcmxhcHMucHVzaChuZXcgQXJlYUNvbGxpc2lvbihhcmVhLCBjb2xsaWRlciwgb3RoZXIsIFwiR2FtZU5vZGVcIiwgbnVsbCkpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gVGhlbiwgY2hlY2sgaXQgYWdhaW5zdCBldmVyeSBkeW5hbWljIG5vZGVcclxuXHRcdFx0Zm9yKGxldCBvdGhlciBvZiB0aGlzLmR5bmFtaWNOb2Rlcyl7XHJcblx0XHRcdFx0Ly8gSWdub3JlIG91cnNlbHZlc1xyXG5cdFx0XHRcdGlmKG5vZGUgPT09IG90aGVyKSBjb250aW51ZTtcclxuXHJcblx0XHRcdFx0Ly8gSWdub3JlIGluYWN0aXZlIG5vZGVzXHJcblx0XHRcdFx0aWYoIW90aGVyLmFjdGl2ZSkgY29udGludWU7XHJcblxyXG5cdFx0XHRcdGxldCBjb2xsaWRlciA9IG90aGVyLmNvbGxpc2lvblNoYXBlLmdldEJvdW5kaW5nUmVjdCgpO1xyXG5cdFx0XHRcdGxldCBhcmVhID0gbm9kZS5zd2VwdFJlY3Qub3ZlcmxhcEFyZWEoY29sbGlkZXIpO1xyXG5cdFx0XHRcdGlmKGFyZWEgPiAwKXtcclxuXHRcdFx0XHRcdC8vIFdlIGhhZCBhIGNvbGxpc2lvblxyXG5cdFx0XHRcdFx0b3ZlcmxhcHMucHVzaChuZXcgQXJlYUNvbGxpc2lvbihhcmVhLCBjb2xsaWRlciwgb3RoZXIsIFwiR2FtZU5vZGVcIiwgbnVsbCkpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gTGFzdGx5LCBnYXRoZXIgYSBzZXQgb2YgQUFCQnMgZnJvbSB0aGUgdGlsZW1hcC5cclxuXHRcdFx0Ly8gVGhpcyBzdGVwIGludm9sdmVzIHRoZSBtb3N0IGV4dHJhIHdvcmssIHNvIGl0IGlzIGFic3RyYWN0ZWQgaW50byBhIG1ldGhvZFxyXG5cdFx0XHRmb3IobGV0IHRpbGVtYXAgb2YgdGhpcy50aWxlbWFwcyl7XHJcblx0XHRcdFx0Ly8gSWdub3JlIGluYWN0aXZlIHRpbGVtYXBzXHJcblx0XHRcdFx0aWYoIXRpbGVtYXAuYWN0aXZlKSBjb250aW51ZTtcclxuXHJcblx0XHRcdFx0aWYodGlsZW1hcCBpbnN0YW5jZW9mIE9ydGhvZ29uYWxUaWxlbWFwKXtcclxuXHRcdFx0XHRcdHRoaXMuY29sbGlkZVdpdGhPcnRob2dvbmFsVGlsZW1hcChub2RlLCB0aWxlbWFwLCBvdmVybGFwcyk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBTb3J0IHRoZSBvdmVybGFwcyBieSBhcmVhXHJcblx0XHRcdG92ZXJsYXBzID0gb3ZlcmxhcHMuc29ydCgoYSwgYikgPT4gYi5hcmVhIC0gYS5hcmVhKTtcclxuXHJcblx0XHRcdC8vIEtlZXAgdHJhY2sgb2YgaGl0cyB0byB1c2UgbGF0ZXJcclxuXHRcdFx0bGV0IGhpdHMgPSBbXTtcclxuXHJcblx0XHRcdC8qLS0tLS0tLS0tLSBSRVNPTFVUSU9OIFBIQVNFIC0tLS0tLS0tLS0qL1xyXG5cdFx0XHQvLyBGb3IgZXZlcnkgb3ZlcmxhcCwgZGV0ZXJtaW5lIGlmIHdlIG5lZWQgdG8gY29sbGlkZSB3aXRoIGl0IGFuZCB3aGVuXHJcblx0XHRcdGZvcihsZXQgb3ZlcmxhcCBvZiBvdmVybGFwcyl7XHJcblx0XHRcdFx0Ly8gSWdub3JlIG5vZGVzIHdlIGRvbid0IGludGVyYWN0IHdpdGhcclxuXHRcdFx0XHRpZiggZ3JvdXBJbmRleCAhPT0gLTEgJiYgb3ZlcmxhcC5vdGhlci5ncm91cCAhPT0gLTEgJiYgKCh0aGlzLmNvbGxpc2lvbk1hc2tzW2dyb3VwSW5kZXhdICYgb3ZlcmxhcC5vdGhlci5ncm91cCkgPT09IDApICkgY29udGludWU7XHJcblxyXG5cdFx0XHRcdC8vIERvIGEgc3dlcHQgbGluZSB0ZXN0IG9uIHRoZSBzdGF0aWMgQUFCQiB3aXRoIHRoaXMgQUFCQiBzaXplIGFzIHBhZGRpbmcgKHRoaXMgaXMgYmFzaWNhbGx5IHVzaW5nIGEgbWlua293c2tpIHN1bSEpXHJcblx0XHRcdFx0Ly8gU3RhcnQgdGhlIHN3ZWVwIGF0IHRoZSBwb3NpdGlvbiBvZiB0aGlzIG5vZGUgd2l0aCBhIGRlbHRhIG9mIF92ZWxvY2l0eVxyXG5cdFx0XHRcdGNvbnN0IHBvaW50ID0gbm9kZS5jb2xsaXNpb25TaGFwZS5jZW50ZXI7XHJcblx0XHRcdFx0Y29uc3QgZGVsdGEgPSBub2RlLl92ZWxvY2l0eTtcclxuXHRcdFx0XHRjb25zdCBwYWRkaW5nID0gbm9kZS5jb2xsaXNpb25TaGFwZS5oYWxmU2l6ZTtcclxuXHRcdFx0XHRjb25zdCBvdGhlckFBQkIgPSBvdmVybGFwLmNvbGxpZGVyO1xyXG5cclxuXHJcblx0XHRcdFx0Y29uc3QgaGl0ID0gb3RoZXJBQUJCLmludGVyc2VjdFNlZ21lbnQobm9kZS5jb2xsaXNpb25TaGFwZS5jZW50ZXIsIG5vZGUuX3ZlbG9jaXR5LCBub2RlLmNvbGxpc2lvblNoYXBlLmhhbGZTaXplKTtcclxuXHJcblx0XHRcdFx0b3ZlcmxhcC5oaXQgPSBoaXQ7XHJcblxyXG5cdFx0XHRcdGlmKGhpdCAhPT0gbnVsbCl7XHJcblx0XHRcdFx0XHRoaXRzLnB1c2goaGl0KTtcclxuXHJcblx0XHRcdFx0XHQvLyBXZSBnb3QgYSBoaXQsIHJlc29sdmUgd2l0aCB0aGUgdGltZSBpbnNpZGUgb2YgdGhlIGhpdFxyXG5cdFx0XHRcdFx0bGV0IHRuZWFyeCA9IGhpdC5uZWFyVGltZXMueDtcclxuXHRcdFx0XHRcdGxldCB0bmVhcnkgPSBoaXQubmVhclRpbWVzLnk7XHJcblxyXG5cdFx0XHRcdFx0Ly8gQWxsb3cgZWRnZSBjbGlwcGluZyAoZWRnZSBvdmVybGFwcyBkb24ndCBjb3VudCwgb25seSBhcmVhIG92ZXJsYXBzKVxyXG5cdFx0XHRcdFx0Ly8gSW1wb3J0YW50bHkgZG9uJ3QgYWxsb3cgYm90aCBjYXNlcyB0byBiZSB0cnVlLiBUaGVuIHdlIGNsaXAgdGhyb3VnaCBjb3JuZXJzLiBGYXZvciB4IHRvIGhlbHAgcGxheWVycyBsYW5kIGp1bXBzXHJcblx0XHRcdFx0XHRpZih0bmVhcnggPCAxLjAgJiYgKHBvaW50LnkgPT09IG90aGVyQUFCQi50b3AgLSBwYWRkaW5nLnkgfHwgcG9pbnQueSA9PT0gb3RoZXJBQUJCLmJvdHRvbSArIHBhZGRpbmcueSkgJiYgZGVsdGEueCAhPT0gMCkge1xyXG5cdFx0XHRcdFx0XHR0bmVhcnggPSAxLjA7XHJcblx0XHRcdFx0XHR9IGVsc2UgaWYodG5lYXJ5IDwgMS4wICYmIChwb2ludC54ID09PSBvdGhlckFBQkIubGVmdCAtIHBhZGRpbmcueCB8fCBwb2ludC54ID09PSBvdGhlckFBQkIucmlnaHQgKyBwYWRkaW5nLngpICYmIGRlbHRhLnkgIT09IDApIHtcclxuXHRcdFx0XHRcdFx0dG5lYXJ5ID0gMS4wO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHJcblx0XHRcdFx0XHRpZihoaXQubmVhclRpbWVzLnggPj0gMCAmJiBoaXQubmVhclRpbWVzLnggPCAxKXtcclxuXHRcdFx0XHRcdFx0Ly8gQW55IHRpbGVtYXAgb2JqZWN0cyB0aGF0IG1hZGUgaXQgaGVyZSBhcmUgY29sbGlkYWJsZVxyXG5cdFx0XHRcdFx0XHRpZihvdmVybGFwLnR5cGUgPT09IFwiVGlsZW1hcFwiIHx8IG92ZXJsYXAub3RoZXIuaXNDb2xsaWRhYmxlKXtcclxuXHRcdFx0XHRcdFx0XHRub2RlLl92ZWxvY2l0eS54ID0gbm9kZS5fdmVsb2NpdHkueCAqIHRuZWFyeDtcclxuXHRcdFx0XHRcdFx0XHRub2RlLmlzQ29sbGlkaW5nID0gdHJ1ZTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGlmKGhpdC5uZWFyVGltZXMueSA+PSAwICYmIGhpdC5uZWFyVGltZXMueSA8IDEpe1xyXG5cdFx0XHRcdFx0XHQvLyBBbnkgdGlsZW1hcCBvYmplY3RzIHRoYXQgbWFkZSBpdCBoZXJlIGFyZSBjb2xsaWRhYmxlXHJcblx0XHRcdFx0XHRcdGlmKG92ZXJsYXAudHlwZSA9PT0gXCJUaWxlbWFwXCIgfHwgb3ZlcmxhcC5vdGhlci5pc0NvbGxpZGFibGUpe1xyXG5cdFx0XHRcdFx0XHRcdG5vZGUuX3ZlbG9jaXR5LnkgPSBub2RlLl92ZWxvY2l0eS55ICogdG5lYXJ5O1xyXG5cdFx0XHRcdFx0XHRcdG5vZGUuaXNDb2xsaWRpbmcgPSB0cnVlO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdFxyXG5cdFx0XHQvKi0tLS0tLS0tLS0gSU5GT1JNQVRJT04vVFJJR0dFUiBQSEFTRSAtLS0tLS0tLS0tKi9cclxuXHRcdFx0Ly8gQ2hlY2sgaWYgd2UgZW5kZWQgdXAgb24gdGhlIGdyb3VuZCwgY2VpbGluZyBvciB3YWxsXHJcblx0XHRcdC8vIEFsc28gY2hlY2sgZm9yIHRyaWdnZXJzXHJcblx0XHRcdGZvcihsZXQgb3ZlcmxhcCBvZiBvdmVybGFwcyl7XHJcblx0XHRcdFx0Ly8gQ2hlY2sgZm9yIGEgdHJpZ2dlci4gSWYgd2UgY2FyZSBhYm91dCB0aGUgdHJpZ2dlciwgcmVhY3RcclxuXHRcdFx0XHRpZihvdmVybGFwLm90aGVyLmlzVHJpZ2dlciAmJiAob3ZlcmxhcC5vdGhlci50cmlnZ2VyTWFzayAmIG5vZGUuZ3JvdXApKXtcclxuXHRcdFx0XHRcdC8vIEdldCB0aGUgYml0IHRoYXQgdGhpcyBncm91cCBpcyByZXByZXNlbnRlZCBieVxyXG5cdFx0XHRcdFx0bGV0IGluZGV4ID0gTWF0aC5mbG9vcihNYXRoLmxvZzIobm9kZS5ncm91cCkpO1xyXG5cclxuXHRcdFx0XHRcdC8vIEV4dHJhY3QgdGhlIHRyaWdnZXJFbnRlciBldmVudCBuYW1lXHJcblx0XHRcdFx0XHR0aGlzLmVtaXR0ZXIuZmlyZUV2ZW50KG92ZXJsYXAub3RoZXIudHJpZ2dlckVudGVyc1tpbmRleF0sIHtcclxuXHRcdFx0XHRcdFx0bm9kZTogKDxHYW1lTm9kZT5ub2RlKS5pZCxcclxuXHRcdFx0XHRcdFx0b3RoZXI6ICg8R2FtZU5vZGU+b3ZlcmxhcC5vdGhlcikuaWRcclxuXHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly8gSWdub3JlIGNvbGxpc2lvbiBzaWRlcyBmb3Igbm9kZXMgd2UgZG9uJ3QgaW50ZXJhY3Qgd2l0aFxyXG5cdFx0XHRcdGlmKCBncm91cEluZGV4ICE9PSAtMSAmJiBvdmVybGFwLm90aGVyLmdyb3VwICE9PSAtMSAmJiAoKHRoaXMuY29sbGlzaW9uTWFza3NbZ3JvdXBJbmRleF0gJiBvdmVybGFwLm90aGVyLmdyb3VwKSA9PT0gMCkpIGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0XHQvLyBPbmx5IGNoZWNrIGZvciBkaXJlY3Rpb24gaWYgdGhlIG92ZXJsYXAgd2FzIGNvbGxpZGFibGVcclxuXHRcdFx0XHRpZihvdmVybGFwLnR5cGUgPT09IFwiVGlsZW1hcFwiIHx8IG92ZXJsYXAub3RoZXIuaXNDb2xsaWRhYmxlKXtcclxuXHRcdFx0XHRcdGxldCBjb2xsaXNpb25TaWRlID0gb3ZlcmxhcC5jb2xsaWRlci50b3VjaGVzQUFCQldpdGhvdXRDb3JuZXJzKG5vZGUuY29sbGlzaW9uU2hhcGUuZ2V0Qm91bmRpbmdSZWN0KCkpO1xyXG5cdFx0XHRcdFx0aWYoY29sbGlzaW9uU2lkZSAhPT0gbnVsbCl7XHJcblx0XHRcdFx0XHRcdC8vIElmIHdlIHRvdWNoLCBub3QgaW5jbHVkaW5nIGNvcm5lciBjYXNlcywgY2hlY2sgdGhlIGNvbGxpc2lvbiBub3JtYWxcclxuXHRcdFx0XHRcdFx0aWYob3ZlcmxhcC5oaXQgIT09IG51bGwpe1xyXG5cdFx0XHRcdFx0XHRcdC8vIElmIHdlIGhpdCBhIHRpbGVtYXAsIGtlZXAgdHJhY2sgb2YgaXRcclxuXHRcdFx0XHRcdFx0XHRpZihvdmVybGFwLnR5cGUgPT0gXCJUaWxlbWFwXCIpe1xyXG5cdFx0XHRcdFx0XHRcdFx0bm9kZS5jb2xsaWRlZFdpdGhUaWxlbWFwID0gdHJ1ZTtcclxuXHRcdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRcdGlmKGNvbGxpc2lvblNpZGUueSA9PT0gLTEpe1xyXG5cdFx0XHRcdFx0XHRcdFx0Ly8gTm9kZSBpcyBvbiB0b3Agb2Ygb3ZlcmxhcCwgc28gb25Hcm91bmRcclxuXHRcdFx0XHRcdFx0XHRcdG5vZGUub25Hcm91bmQgPSB0cnVlO1xyXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZihjb2xsaXNpb25TaWRlLnkgPT09IDEpe1xyXG5cdFx0XHRcdFx0XHRcdFx0Ly8gTm9kZSBpcyBvbiBib3R0b20gb2Ygb3ZlcmxhcCwgc28gb25DZWlsaW5nXHJcblx0XHRcdFx0XHRcdFx0XHRub2RlLm9uQ2VpbGluZyA9IHRydWU7XHJcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0XHRcdC8vIE5vZGUgd2Fzbid0IHRvdWNoaW5nIG9uIHksIHNvIGl0IGlzIHRvdWNoaW5nIG9uIHhcclxuXHRcdFx0XHRcdFx0XHRcdG5vZGUub25XYWxsID0gdHJ1ZTtcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIFJlc29sdmUgdGhlIGNvbGxpc2lvbiB3aXRoIHRoZSBub2RlLCBhbmQgbW92ZSBpdFxyXG5cdFx0XHRub2RlLmZpbmlzaE1vdmUoKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEhhbmRsZXMgYSBjb2xsaXNpb24gYmV0d2VlbiB0aGlzIG5vZGUgYW5kIGFuIG9ydGhvZ29uYWwgdGlsZW1hcFxyXG5cdCAqIEBwYXJhbSBub2RlIFRoZSBub2RlXHJcblx0ICogQHBhcmFtIHRpbGVtYXAgVGhlIHRpbGVtYXAgdGhlIG5vZGUgbWF5IGJlIGNvbGxpZGluZyB3aXRoXHJcblx0ICogQHBhcmFtIG92ZXJsYXBzIFRoZSBsaXN0IG9mIG92ZXJsYXBzXHJcblx0ICovXHJcblx0cHJvdGVjdGVkIGNvbGxpZGVXaXRoT3J0aG9nb25hbFRpbGVtYXAobm9kZTogUGh5c2ljYWwsIHRpbGVtYXA6IE9ydGhvZ29uYWxUaWxlbWFwLCBvdmVybGFwczogQXJyYXk8QXJlYUNvbGxpc2lvbj4pOiB2b2lkIHtcclxuXHRcdC8vIEdldCB0aGUgbWluIGFuZCBtYXggeCBhbmQgeSBjb29yZGluYXRlcyBvZiB0aGUgbW92aW5nIG5vZGVcclxuXHRcdGxldCBtaW4gPSBuZXcgVmVjMihub2RlLnN3ZXB0UmVjdC5sZWZ0LCBub2RlLnN3ZXB0UmVjdC50b3ApO1xyXG5cdFx0bGV0IG1heCA9IG5ldyBWZWMyKG5vZGUuc3dlcHRSZWN0LnJpZ2h0LCBub2RlLnN3ZXB0UmVjdC5ib3R0b20pO1xyXG5cclxuXHRcdC8vIENvbnZlcnQgdGhlIG1pbi9tYXggeC95IHRvIHRoZSBtaW4gYW5kIG1heCByb3cvY29sIGluIHRoZSB0aWxlbWFwIGFycmF5XHJcblx0XHRsZXQgbWluSW5kZXggPSB0aWxlbWFwLmdldENvbFJvd0F0KG1pbik7XHJcblx0XHRsZXQgbWF4SW5kZXggPSB0aWxlbWFwLmdldENvbFJvd0F0KG1heCk7XHJcblxyXG5cdFx0bGV0IHRpbGVTaXplID0gdGlsZW1hcC5nZXRUaWxlU2l6ZSgpO1xyXG5cclxuXHRcdC8vIExvb3Agb3ZlciBhbGwgcG9zc2libGUgdGlsZXMgKHdoaWNoIGlzbid0IG1hbnkgaW4gdGhlIHNjb3BlIG9mIHRoZSB2ZWxvY2l0eSBwZXIgZnJhbWUpXHJcblx0XHRmb3IobGV0IGNvbCA9IG1pbkluZGV4Lng7IGNvbCA8PSBtYXhJbmRleC54OyBjb2wrKyl7XHJcblx0XHRcdGZvcihsZXQgcm93ID0gbWluSW5kZXgueTsgcm93IDw9IG1heEluZGV4Lnk7IHJvdysrKXtcclxuXHRcdFx0XHRpZih0aWxlbWFwLmlzVGlsZUNvbGxpZGFibGUoY29sLCByb3cpKXtcclxuXHRcdFx0XHRcdC8vIEdldCB0aGUgcG9zaXRpb24gb2YgdGhpcyB0aWxlXHJcblx0XHRcdFx0XHRsZXQgdGlsZVBvcyA9IG5ldyBWZWMyKGNvbCAqIHRpbGVTaXplLnggKyB0aWxlU2l6ZS54LzIsIHJvdyAqIHRpbGVTaXplLnkgKyB0aWxlU2l6ZS55LzIpO1xyXG5cclxuXHRcdFx0XHRcdC8vIENyZWF0ZSBhIG5ldyBjb2xsaWRlciBmb3IgdGhpcyB0aWxlXHJcblx0XHRcdFx0XHRsZXQgY29sbGlkZXIgPSBuZXcgQUFCQih0aWxlUG9zLCB0aWxlU2l6ZS5zY2FsZWQoMS8yKSk7XHJcblxyXG5cdFx0XHRcdFx0Ly8gQ2FsY3VsYXRlIGNvbGxpc2lvbiBhcmVhIGJldHdlZW4gdGhlIG5vZGUgYW5kIHRoZSB0aWxlXHJcblx0XHRcdFx0XHRsZXQgYXJlYSA9IG5vZGUuc3dlcHRSZWN0Lm92ZXJsYXBBcmVhKGNvbGxpZGVyKTtcclxuXHRcdFx0XHRcdGlmKGFyZWEgPiAwKXtcclxuXHRcdFx0XHRcdFx0Ly8gV2UgaGFkIGEgY29sbGlzaW9uXHJcblx0XHRcdFx0XHRcdG92ZXJsYXBzLnB1c2gobmV3IEFyZWFDb2xsaXNpb24oYXJlYSwgY29sbGlkZXIsIHRpbGVtYXAsIFwiVGlsZW1hcFwiLCBuZXcgVmVjMihjb2wsIHJvdykpKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcbn0iLCJpbXBvcnQgVXBkYXRlYWJsZSBmcm9tIFwiLi4vRGF0YVR5cGVzL0ludGVyZmFjZXMvVXBkYXRlYWJsZVwiO1xyXG5pbXBvcnQgVGlsZW1hcCBmcm9tIFwiLi4vTm9kZXMvVGlsZW1hcFwiO1xyXG5pbXBvcnQgUmVjZWl2ZXIgZnJvbSBcIi4uL0V2ZW50cy9SZWNlaXZlclwiO1xyXG5pbXBvcnQgRW1pdHRlciBmcm9tIFwiLi4vRXZlbnRzL0VtaXR0ZXJcIjtcclxuaW1wb3J0IE1hcCBmcm9tIFwiLi4vRGF0YVR5cGVzL01hcFwiO1xyXG5pbXBvcnQgUGh5c2ljYWwgZnJvbSBcIi4uL0RhdGFUeXBlcy9JbnRlcmZhY2VzL1BoeXNpY2FsXCI7XHJcblxyXG4vKipcclxuICogQW4gYWJzdHJhY3QgcGh5c2ljcyBtYW5hZ2VyLlxyXG4gKiBUaGlzIGNsYXNzIGV4cG9zZXMgZnVuY3Rpb25zIGZvciBzdWJjbGFzc2VzIHRvIGltcGxlbWVudCB0aGF0IHNob3VsZCBhbGxvdyBmb3IgYSB3b3JraW5nIHBoeXNpY3Mgc3lzdGVtIHRvIGJlIGNyZWF0ZWQuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBhYnN0cmFjdCBjbGFzcyBQaHlzaWNzTWFuYWdlciBpbXBsZW1lbnRzIFVwZGF0ZWFibGUge1xyXG5cdC8qKiBUaGUgZXZlbnQgcmVjZWl2ZXIgZm9yIHRoZSBwaHlzaWNzIHN5c3RlbSAqL1xyXG5cdHByb3RlY3RlZCByZWNlaXZlcjogUmVjZWl2ZXI7XHJcblx0LyoqIFRoZSBldmVudCBlbWl0dGVyIGZvciB0aGUgcGh5c2ljcyBzeXN0ZW0gKi9cclxuXHRwcm90ZWN0ZWQgZW1pdHRlcjogRW1pdHRlcjtcclxuXHJcblx0LyoqIE1hcHMgbGF5ZXIgbmFtZXMgdG8gbnVtYmVycyAqL1xyXG5cdHByb3RlY3RlZCBncm91cE1hcDogTWFwPG51bWJlcj47XHJcblxyXG5cdC8qKiBNYXBzIGxheWVyIG51bWJlcnMgdG8gbmFtZXMgKi9cclxuXHRwcm90ZWN0ZWQgZ3JvdXBOYW1lczogQXJyYXk8c3RyaW5nPjtcclxuXHJcblx0LyoqIFRoZSBkZWZhdWx0IGdyb3VwIG5hbWUgKi9cclxuXHRwcm90ZWN0ZWQgc3RhdGljIHJlYWRvbmx5IERFRkFVTFRfR1JPVVA6IHN0cmluZyA9IFwiRGVmYXVsdFwiO1xyXG5cclxuXHRjb25zdHJ1Y3Rvcigpe1xyXG5cdFx0dGhpcy5yZWNlaXZlciA9IG5ldyBSZWNlaXZlcigpO1xyXG5cdFx0dGhpcy5lbWl0dGVyID0gbmV3IEVtaXR0ZXIoKTtcclxuXHJcblx0XHQvLyBUaGUgY3JlYXRpb24gYW5kIGltcGxlbWVudGF0aW9uIG9mIGxheWVycyBpcyBkZWZlcnJlZCB0byB0aGUgc3ViY2xhc3NcclxuXHRcdHRoaXMuZ3JvdXBNYXAgPSBuZXcgTWFwKCk7XHJcblx0XHR0aGlzLmdyb3VwTmFtZXMgPSBuZXcgQXJyYXkoKTtcclxuXHR9XHJcblxyXG5cdGRlc3Ryb3koKTogdm9pZCB7XHJcblx0XHR0aGlzLnJlY2VpdmVyLmRlc3Ryb3koKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJlZ2lzdGVycyBhIGdhbWVub2RlIHdpdGggdGhpcyBwaHlzaWNzIG1hbmFnZXJcclxuXHQgKiBAcGFyYW0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcmVnaXN0ZXJcclxuXHQgKi9cclxuXHRhYnN0cmFjdCByZWdpc3Rlck9iamVjdChvYmplY3Q6IFBoeXNpY2FsKTogdm9pZDtcclxuXHJcblxyXG5cdC8qKlxyXG5cdCAqIFJlbW92ZXMgcmVmZXJlbmNlcyB0byB0aGlzIG9iamVjdCBmcm9tIHRoZSBwaHlzaWNzIG1hbmFnZXJyXHJcblx0ICogQHBhcmFtIG9iamVjdCBUaGUgb2JqZWN0IHRvIGRlcmVnaXN0ZXJcclxuXHQgKi9cclxuXHRhYnN0cmFjdCBkZXJlZ2lzdGVyT2JqZWN0KG9iamVjdDogUGh5c2ljYWwpOiB2b2lkO1xyXG5cclxuXHQvKipcclxuXHQgKiBSZWdpc3RlcnMgYSB0aWxlbWFwIHdpdGggdGhpcyBwaHlzaWNzIG1hbmFnZXJcclxuXHQgKiBAcGFyYW0gdGlsZW1hcCBUaGUgdGlsZW1hcCB0byByZWdpc3RlclxyXG5cdCAqL1xyXG5cdGFic3RyYWN0IHJlZ2lzdGVyVGlsZW1hcCh0aWxlbWFwOiBUaWxlbWFwKTogdm9pZDtcclxuXHJcblx0LyoqXHJcblx0ICogUmVtb3ZlcyByZWZlcmVuY2VzIHRvIHRoaXMgdGlsZW1hcCBmcm9tIHRoZSBwaHlzaWNzIG1hbmFnZXJyXHJcblx0ICogQHBhcmFtIHRpbGVtYXAgVGhlIG9iamVjdCB0byBkZXJlZ2lzdGVyXHJcblx0ICovXHJcblx0YWJzdHJhY3QgZGVyZWdpc3RlclRpbGVtYXAodGlsZW1hcDogVGlsZW1hcCk6IHZvaWQ7XHJcblxyXG5cdGFic3RyYWN0IHVwZGF0ZShkZWx0YVQ6IG51bWJlcik6IHZvaWQ7XHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldHMgdGhlIHBoeXNpY3MgbGF5ZXIgb2YgdGhlIEdhbWVOb2RlXHJcblx0ICogQHBhcmFtIG5vZGUgVGhlIEdhbWVOb2RlXHJcblx0ICogQHBhcmFtIGdyb3VwIFRoZSBncm91cCB0aGF0IHRoZSBHYW1lTm9kZSBzaG91bGQgYmUgb25cclxuXHQgKi9cclxuXHRzZXRHcm91cChub2RlOiBQaHlzaWNhbCwgZ3JvdXA6IHN0cmluZyk6IHZvaWQge1xyXG5cdFx0bm9kZS5ncm91cCA9IHRoaXMuZ3JvdXBNYXAuZ2V0KGdyb3VwKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHJpZXZlcyB0aGUgbGF5ZXIgbnVtYmVyIGFzc29jaWF0ZWQgd2l0aCB0aGUgcHJvdmlkZWQgbmFtZVxyXG5cdCAqIEBwYXJhbSBsYXllciBUaGUgbmFtZSBvZiB0aGUgbGF5ZXJcclxuXHQgKiBAcmV0dXJucyBUaGUgbGF5ZXIgbnVtYmVyLCBvciAwIGlmIHRoZXJlIGlzIG5vdCBhIGxheWVyIHdpdGggdGhhdCBuYW1lIHJlZ2lzdGVyZWRcclxuXHQgKi9cclxuXHRnZXRHcm91cE51bWJlcihncm91cDogc3RyaW5nKTogbnVtYmVyIHtcclxuXHRcdGlmKHRoaXMuZ3JvdXBNYXAuaGFzKGdyb3VwKSl7XHJcblx0XHRcdHJldHVybiB0aGlzLmdyb3VwTWFwLmdldChncm91cCk7XHJcblx0XHR9IGVsc2V7XHJcblx0XHRcdHJldHVybiAwO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogR2V0cyBhbGwgZ3JvdXAgbmFtZXMgYXNzb2NpYXRlZCB3aXRoIHRoZSBudW1iZXIgcHJvdmlkZWRcclxuXHQgKiBAcGFyYW0gZ3JvdXBzIEEgbWFzayBvZiBncm91cHNcclxuXHQgKiBAcmV0dXJucyBBbGwgZ3JvdXBzIGNvbnRhaW5lZCBpbiB0aGUgbWFza1xyXG5cdCAqL1xyXG5cdGdldEdyb3VwTmFtZXMoZ3JvdXBzOiBudW1iZXIpOiBBcnJheTxzdHJpbmc+IHtcclxuXHRcdGlmKGdyb3VwcyA9PT0gLTEpe1xyXG5cdFx0XHRyZXR1cm4gW1BoeXNpY3NNYW5hZ2VyLkRFRkFVTFRfR1JPVVBdO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0bGV0IGcgPSAxO1xyXG5cdFx0XHRsZXQgbmFtZXMgPSBbXTtcclxuXHJcblx0XHRcdGZvcihsZXQgaSA9IDA7IGkgPCAzMjsgaSsrKXtcclxuXHRcdFx0XHRpZihnICYgZ3JvdXBzKXtcclxuXHRcdFx0XHRcdC8vIFRoaXMgZ3JvdXAgaXMgaW4gdGhlIGdyb3VwcyBudW1iZXJcclxuXHRcdFx0XHRcdG5hbWVzLnB1c2godGhpcy5ncm91cE5hbWVzW2ldKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdC8vIFNoaWZ0IHRoZSBiaXQgb3ZlclxyXG5cdFx0XHRcdGcgPSBnIDw8IDE7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcbn0iLCJpbXBvcnQgUXVldWUgZnJvbSBcIi4uL0RhdGFUeXBlcy9RdWV1ZVwiO1xyXG5pbXBvcnQgUmVjZWl2ZXIgZnJvbSBcIi4uL0V2ZW50cy9SZWNlaXZlclwiO1xyXG5pbXBvcnQgR2FtZUV2ZW50IGZyb20gXCIuLi9FdmVudHMvR2FtZUV2ZW50XCI7XHJcbmltcG9ydCBFdmVudFF1ZXVlIGZyb20gXCIuLi9FdmVudHMvRXZlbnRRdWV1ZVwiO1xyXG5pbXBvcnQgeyBHYW1lRXZlbnRUeXBlIH0gZnJvbSBcIi4uL0V2ZW50cy9HYW1lRXZlbnRUeXBlXCI7XHJcblxyXG4vLyBAaWdub3JlUGFnZVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVjb3JkZXIge1xyXG5cdHByaXZhdGUgcmVjZWl2ZXI6IFJlY2VpdmVyO1xyXG5cdHByaXZhdGUgbG9nOiBRdWV1ZTxMb2dJdGVtPjtcclxuXHRwcml2YXRlIHJlY29yZGluZzogYm9vbGVhbjtcclxuXHRwcml2YXRlIGV2ZW50UXVldWU6IEV2ZW50UXVldWU7XHJcblx0cHJpdmF0ZSBmcmFtZTogbnVtYmVyO1xyXG5cdHByaXZhdGUgcGxheWluZzogYm9vbGVhbjtcclxuXHJcblx0Y29uc3RydWN0b3IoKXtcclxuXHRcdHRoaXMucmVjZWl2ZXIgPSBuZXcgUmVjZWl2ZXIoKTtcclxuXHRcdHRoaXMubG9nID0gbmV3IFF1ZXVlKDEwMDApO1xyXG5cdFx0dGhpcy5yZWNvcmRpbmcgPSBmYWxzZTtcclxuXHRcdHRoaXMucGxheWluZyA9IGZhbHNlO1xyXG5cdFx0dGhpcy5mcmFtZSA9IDA7XHJcblxyXG5cdFx0dGhpcy5ldmVudFF1ZXVlID0gRXZlbnRRdWV1ZS5nZXRJbnN0YW5jZSgpO1xyXG5cdFx0dGhpcy5ldmVudFF1ZXVlLnN1YnNjcmliZSh0aGlzLnJlY2VpdmVyLCBcImFsbFwiKTtcclxuXHR9XHJcblxyXG5cdHVwZGF0ZShkZWx0YVQ6IG51bWJlcik6IHZvaWQge1xyXG5cdFx0aWYodGhpcy5yZWNvcmRpbmcpe1xyXG5cdFx0XHR0aGlzLmZyYW1lICs9IDE7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYodGhpcy5wbGF5aW5nKXtcclxuXHRcdFx0Ly8gSWYgcGxheWluZywgaWdub3JlIGV2ZW50cywganVzdCBmZWVkIHRoZSByZWNvcmQgdG8gdGhlIGV2ZW50IHF1ZXVlXHJcblx0XHRcdHRoaXMucmVjZWl2ZXIuaWdub3JlRXZlbnRzKCk7XHJcblxyXG5cdFx0XHQvKlxyXG5cdFx0XHRcdFdoaWxlIHRoZXJlIGlzIGEgbmV4dCBpdGVtLCBhbmQgd2hpbGUgaXQgc2hvdWxkIG9jY3VyIGluIHRoaXMgZnJhbWUsXHJcblx0XHRcdFx0c2VuZCB0aGUgZXZlbnQuIGkuZS4sIHdoaWxlIGN1cnJlbnRfZnJhbWUgKiBjdXJyZW50X2RlbHRhX3QgaXMgZ3JlYXRlclxyXG5cdFx0XHRcdHRoYW4gcmVjb3JkZWRfZnJhbWUgKiByZWNvcmRlZF9kZWx0YV90XHJcblx0XHRcdCovXHJcblx0XHRcdHdoaWxlKHRoaXMubG9nLmhhc0l0ZW1zKClcclxuXHRcdFx0XHRcdCYmIHRoaXMubG9nLnBlZWtOZXh0KCkuZnJhbWUgKiB0aGlzLmxvZy5wZWVrTmV4dCgpLmRlbHRhIDwgdGhpcy5mcmFtZSAqIGRlbHRhVCl7XHJcblx0XHRcdFx0bGV0IGV2ZW50ID0gdGhpcy5sb2cuZGVxdWV1ZSgpLmV2ZW50O1xyXG5cdFx0XHRcdGNvbnNvbGUubG9nKGV2ZW50KTtcclxuXHRcdFx0XHR0aGlzLmV2ZW50UXVldWUuYWRkRXZlbnQoZXZlbnQpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZighdGhpcy5sb2cuaGFzSXRlbXMoKSl7XHJcblx0XHRcdFx0dGhpcy5wbGF5aW5nID0gZmFsc2U7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuZnJhbWUgKz0gMTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdC8vIElmIG5vdCBwbGF5aW5nLCBoYW5kbGUgZXZlbnRzXHJcblx0XHRcdHdoaWxlKHRoaXMucmVjZWl2ZXIuaGFzTmV4dEV2ZW50KCkpe1xyXG5cdFx0XHRcdGxldCBldmVudCA9IHRoaXMucmVjZWl2ZXIuZ2V0TmV4dEV2ZW50KCk7XHJcblxyXG5cdFx0XHRcdGlmKGV2ZW50LnR5cGUgPT09IEdhbWVFdmVudFR5cGUuU1RPUF9SRUNPUkRJTkcpe1xyXG5cdFx0XHRcdFx0dGhpcy5yZWNvcmRpbmcgPSBmYWxzZTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmKHRoaXMucmVjb3JkaW5nKXtcclxuXHRcdFx0XHRcdHRoaXMubG9nLmVucXVldWUobmV3IExvZ0l0ZW0odGhpcy5mcmFtZSwgZGVsdGFULCBldmVudCkpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYoZXZlbnQudHlwZSA9PT0gR2FtZUV2ZW50VHlwZS5TVEFSVF9SRUNPUkRJTkcpe1xyXG5cdFx0XHRcdFx0dGhpcy5sb2cuY2xlYXIoKTtcclxuXHRcdFx0XHRcdHRoaXMucmVjb3JkaW5nID0gdHJ1ZTtcclxuXHRcdFx0XHRcdHRoaXMuZnJhbWUgPSAwXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZihldmVudC50eXBlID09PSBHYW1lRXZlbnRUeXBlLlBMQVlfUkVDT1JESU5HKXtcclxuXHRcdFx0XHRcdHRoaXMuZnJhbWUgPSAwO1xyXG5cdFx0XHRcdFx0dGhpcy5yZWNvcmRpbmcgPSBmYWxzZTtcclxuXHRcdFx0XHRcdHRoaXMucGxheWluZyA9IHRydWU7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG59XHJcblxyXG5jbGFzcyBMb2dJdGVtIHtcclxuXHRmcmFtZTogbnVtYmVyO1xyXG5cdGRlbHRhOiBudW1iZXI7XHJcblx0ZXZlbnQ6IEdhbWVFdmVudDtcclxuXHJcblx0Y29uc3RydWN0b3IoZnJhbWU6IG51bWJlciwgZGVsdGFUOiBudW1iZXIsIGV2ZW50OiBHYW1lRXZlbnQpe1xyXG5cdFx0dGhpcy5mcmFtZSA9IGZyYW1lO1xyXG5cdFx0dGhpcy5kZWx0YSA9IGRlbHRhVDtcclxuXHRcdHRoaXMuZXZlbnQgPSBldmVudDtcclxuXHR9XHJcbn0iLCJpbXBvcnQgTWFwIGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvTWFwXCI7XHJcblxyXG4vKiogKi9cclxuZXhwb3J0IGRlZmF1bHQgYWJzdHJhY3QgY2xhc3MgUmVnaXN0cnk8VD4gZXh0ZW5kcyBNYXA8VD57XHJcblxyXG4gICAgLyoqIFByZWxvYWRzIHJlZ2lzdHJ5IGRhdGEgKi9cclxuICAgIHB1YmxpYyBhYnN0cmFjdCBwcmVsb2FkKCk6IHZvaWQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWdpc3RlcnMgYW4gaXRlbSBhbmQgcHJlbG9hZHMgYW55IG5lY2Vzc2FyeSBmaWxlc1xyXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IHRvIHJlZ2lzdGVyIHRoaXMgaXRlbSB3aXRoXHJcbiAgICAgKiBAcGFyYW0gYXJncyBBbnkgYWRkaXRpb25hbCBhcmd1bWVudHMgbmVlZGVkIGZvciByZWdpc3RyYXRpb25cclxuICAgICAqL1xyXG4gICAgcHVibGljIGFic3RyYWN0IHJlZ2lzdGVyQW5kUHJlbG9hZEl0ZW0oa2V5OiBzdHJpbmcsIC4uLmFyZ3M6IGFueSk6IHZvaWQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWdpc3RlcnMgYW4gaXRlbSBhbmQgcHJlbG9hZHMgYW55IG5lY2Vzc2FyeSBmaWxlc1xyXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IHRvIHJlZ2lzdGVyIHRoaXMgaXRlbSB3aXRoXHJcbiAgICAgKiBAcGFyYW0gYXJncyBBbnkgYWRpdGlvbmFsIGFyZ3VtZW50cyBuZWVkZWQgZm9yIHJlZ2lzdHJhdGlvblxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgcmVnaXN0ZXJJdGVtKGtleTogc3RyaW5nLCAuLi5hcmdzOiBhbnkpOiB2b2lkO1xyXG59IiwiaW1wb3J0IE1hcCBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL01hcFwiO1xyXG5pbXBvcnQgU2hhZGVyVHlwZSBmcm9tIFwiLi4vLi4vUmVuZGVyaW5nL1dlYkdMUmVuZGVyaW5nL1NoYWRlclR5cGVcIjtcclxuaW1wb3J0IExhYmVsU2hhZGVyVHlwZSBmcm9tIFwiLi4vLi4vUmVuZGVyaW5nL1dlYkdMUmVuZGVyaW5nL1NoYWRlclR5cGVzL0xhYmVsU2hhZGVyVHlwZVwiO1xyXG5pbXBvcnQgUG9pbnRTaGFkZXJUeXBlIGZyb20gXCIuLi8uLi9SZW5kZXJpbmcvV2ViR0xSZW5kZXJpbmcvU2hhZGVyVHlwZXMvUG9pbnRTaGFkZXJUeXBlXCI7XHJcbmltcG9ydCBSZWN0U2hhZGVyVHlwZSBmcm9tIFwiLi4vLi4vUmVuZGVyaW5nL1dlYkdMUmVuZGVyaW5nL1NoYWRlclR5cGVzL1JlY3RTaGFkZXJUeXBlXCI7XHJcbmltcG9ydCBTcHJpdGVTaGFkZXJUeXBlIGZyb20gXCIuLi8uLi9SZW5kZXJpbmcvV2ViR0xSZW5kZXJpbmcvU2hhZGVyVHlwZXMvU3ByaXRlU2hhZGVyVHlwZVwiO1xyXG5pbXBvcnQgUmVzb3VyY2VNYW5hZ2VyIGZyb20gXCIuLi8uLi9SZXNvdXJjZU1hbmFnZXIvUmVzb3VyY2VNYW5hZ2VyXCI7XHJcbmltcG9ydCBSZWdpc3RyeSBmcm9tIFwiLi9SZWdpc3RyeVwiO1xyXG5cclxuLyoqXHJcbiAqIEEgcmVnaXN0cnkgdGhhdCBoYW5kbGVzIHNoYWRlcnNcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNoYWRlclJlZ2lzdHJ5IGV4dGVuZHMgUmVnaXN0cnk8U2hhZGVyVHlwZT4ge1xyXG5cclxuXHQvLyBTaGFkZXIgbmFtZXNcclxuXHRwdWJsaWMgc3RhdGljIFBPSU5UX1NIQURFUiA9IFwicG9pbnRcIjtcclxuXHRwdWJsaWMgc3RhdGljIFJFQ1RfU0hBREVSID0gXCJyZWN0XCI7XHJcblx0cHVibGljIHN0YXRpYyBTUFJJVEVfU0hBREVSID0gXCJzcHJpdGVcIjtcclxuXHRwdWJsaWMgc3RhdGljIExBQkVMX1NIQURFUiA9IFwibGFiZWxcIjtcclxuXHJcblx0cHJpdmF0ZSByZWdpc3RyeUl0ZW1zOiBBcnJheTxTaGFkZXJSZWdpc3RyeUl0ZW0+ID0gbmV3IEFycmF5KCk7XHJcblxyXG5cdC8qKlxyXG5cdCAqIFByZWxvYWRzIGFsbCBidWlsdC1pbiBzaGFkZXJzXHJcblx0ICovXHJcblx0cHVibGljIHByZWxvYWQoKXtcclxuXHRcdC8vIEdldCB0aGUgcmVzb3VyY2VNYW5hZ2VyIGFuZCBxdWV1ZSBhbGwgYnVpbHQtaW4gc2hhZGVycyBmb3IgcHJlbG9hZGluZ1xyXG5cdFx0Y29uc3Qgcm0gPSBSZXNvdXJjZU1hbmFnZXIuZ2V0SW5zdGFuY2UoKTtcclxuXHJcblx0XHQvLyBRdWV1ZSBhIGxvYWQgZm9yIHRoZSBwb2ludCBzaGFkZXJcclxuXHRcdHRoaXMucmVnaXN0ZXJBbmRQcmVsb2FkSXRlbShTaGFkZXJSZWdpc3RyeS5QT0lOVF9TSEFERVIsIFBvaW50U2hhZGVyVHlwZSwgXCJidWlsdGluL3NoYWRlcnMvcG9pbnQudnNoYWRlclwiLCBcImJ1aWx0aW4vc2hhZGVycy9wb2ludC5mc2hhZGVyXCIpO1xyXG5cclxuXHRcdC8vIFF1ZXVlIGEgbG9hZCBmb3IgdGhlIHJlY3Qgc2hhZGVyXHJcblx0XHR0aGlzLnJlZ2lzdGVyQW5kUHJlbG9hZEl0ZW0oU2hhZGVyUmVnaXN0cnkuUkVDVF9TSEFERVIsIFJlY3RTaGFkZXJUeXBlLCBcImJ1aWx0aW4vc2hhZGVycy9yZWN0LnZzaGFkZXJcIiwgXCJidWlsdGluL3NoYWRlcnMvcmVjdC5mc2hhZGVyXCIpO1xyXG5cclxuXHRcdC8vIFF1ZXVlIGEgbG9hZCBmb3IgdGhlIHNwcml0ZSBzaGFkZXJcclxuXHRcdHRoaXMucmVnaXN0ZXJBbmRQcmVsb2FkSXRlbShTaGFkZXJSZWdpc3RyeS5TUFJJVEVfU0hBREVSLCBTcHJpdGVTaGFkZXJUeXBlLCBcImJ1aWx0aW4vc2hhZGVycy9zcHJpdGUudnNoYWRlclwiLCBcImJ1aWx0aW4vc2hhZGVycy9zcHJpdGUuZnNoYWRlclwiKTtcclxuXHRcclxuXHRcdC8vIFF1ZXVlIGEgbG9hZCBmb3IgdGhlIGxhYmVsIHNoYWRlclxyXG5cdFx0dGhpcy5yZWdpc3RlckFuZFByZWxvYWRJdGVtKFNoYWRlclJlZ2lzdHJ5LkxBQkVMX1NIQURFUiwgTGFiZWxTaGFkZXJUeXBlLCBcImJ1aWx0aW4vc2hhZGVycy9sYWJlbC52c2hhZGVyXCIsIFwiYnVpbHRpbi9zaGFkZXJzL2xhYmVsLmZzaGFkZXJcIik7XHJcblxyXG5cdFx0Ly8gUXVldWUgYSBsb2FkIGZvciBhbnkgcHJlbG9hZGVkIGl0ZW1zXHJcblx0XHRmb3IobGV0IGl0ZW0gb2YgdGhpcy5yZWdpc3RyeUl0ZW1zKXtcclxuXHRcdFx0Y29uc3Qgc2hhZGVyID0gbmV3IGl0ZW0uY29uc3RyKGl0ZW0ua2V5KTtcclxuXHRcdFx0c2hhZGVyLmluaXRCdWZmZXJPYmplY3QoKTtcclxuXHRcdFx0dGhpcy5hZGQoaXRlbS5rZXksIHNoYWRlcik7XHJcblxyXG5cdFx0XHQvLyBMb2FkIGlmIGRlc2lyZWRcclxuXHRcdFx0aWYoaXRlbS5wcmVsb2FkICE9PSB1bmRlZmluZWQpe1xyXG5cdFx0XHRcdHJtLnNoYWRlcihpdGVtLmtleSwgaXRlbS5wcmVsb2FkLnZzaGFkZXJMb2NhdGlvbiwgaXRlbS5wcmVsb2FkLmZzaGFkZXJMb2NhdGlvbik7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJlZ2lzdGVycyBhIHNoYWRlciBpbiB0aGUgcmVnaXN0cnkgYW5kIGxvYWRzIGl0IGJlZm9yZSB0aGUgZ2FtZSBiZWdpbnNcclxuXHQgKiBAcGFyYW0ga2V5IFRoZSBrZXkgeW91IHdpc2ggdG8gYXNzaWduIHRvIHRoZSBzaGFkZXJcclxuXHQgKiBAcGFyYW0gY29uc3RyIFRoZSBjb25zdHJ1Y3RvciBvZiB0aGUgU2hhZGVyVHlwZVxyXG5cdCAqIEBwYXJhbSB2c2hhZGVyTG9jYXRpb24gVGhlIGxvY2F0aW9uIG9mIHRoZSB2ZXJ0ZXggc2hhZGVyXHJcblx0ICogQHBhcmFtIGZzaGFkZXJMb2NhdGlvbiB0aGUgbG9jYXRpb24gb2YgdGhlIGZyYWdtZW50IHNoYWRlclxyXG5cdCAqL1xyXG5cdHB1YmxpYyByZWdpc3RlckFuZFByZWxvYWRJdGVtKGtleTogc3RyaW5nLCBjb25zdHI6IG5ldyAocHJvZ3JhbUtleTogc3RyaW5nKSA9PiBTaGFkZXJUeXBlLCB2c2hhZGVyTG9jYXRpb246IHN0cmluZywgZnNoYWRlckxvY2F0aW9uOiBzdHJpbmcpOiB2b2lkIHtcclxuXHRcdGxldCBzaGFkZXJQcmVsb2FkID0gbmV3IFNoYWRlclByZWxvYWQoKTtcclxuXHRcdHNoYWRlclByZWxvYWQudnNoYWRlckxvY2F0aW9uID0gdnNoYWRlckxvY2F0aW9uO1xyXG5cdFx0c2hhZGVyUHJlbG9hZC5mc2hhZGVyTG9jYXRpb24gPSBmc2hhZGVyTG9jYXRpb247XHJcblxyXG5cdFx0bGV0IHJlZ2lzdHJ5SXRlbSA9IG5ldyBTaGFkZXJSZWdpc3RyeUl0ZW0oKTtcclxuXHRcdHJlZ2lzdHJ5SXRlbS5rZXkgPSBrZXk7XHJcblx0XHRyZWdpc3RyeUl0ZW0uY29uc3RyID0gY29uc3RyO1xyXG5cdFx0cmVnaXN0cnlJdGVtLnByZWxvYWQgPSBzaGFkZXJQcmVsb2FkO1xyXG5cclxuXHRcdHRoaXMucmVnaXN0cnlJdGVtcy5wdXNoKHJlZ2lzdHJ5SXRlbSk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZWdpc3RlcnMgYSBzaGFkZXIgaW4gdGhlIHJlZ2lzdHJ5LiBOT1RFOiBJZiB5b3UgdXNlIHRoaXMsIHlvdSBNVVNUIGxvYWQgdGhlIHNoYWRlciBiZWZvcmUgdXNlLlxyXG5cdCAqIElmIHlvdSB3aXNoIHRvIHByZWxvYWQgdGhlIHNoYWRlciwgdXNlIHJlZ2lzdGVyQW5kUHJlbG9hZEl0ZW0oKVxyXG5cdCAqIEBwYXJhbSBrZXkgVGhlIGtleSB5b3Ugd2lzaCB0byBhc3NpZ24gdG8gdGhlIHNoYWRlclxyXG5cdCAqIEBwYXJhbSBjb25zdHIgVGhlIGNvbnN0cnVjdG9yIG9mIHRoZSBTaGFkZXJUeXBlXHJcblx0ICovXHJcblx0cHVibGljIHJlZ2lzdGVySXRlbShrZXk6IHN0cmluZywgY29uc3RyOiBuZXcgKHByb2dyYW1LZXk6IHN0cmluZykgPT4gU2hhZGVyVHlwZSk6IHZvaWQge1xyXG5cdFx0bGV0IHJlZ2lzdHJ5SXRlbSA9IG5ldyBTaGFkZXJSZWdpc3RyeUl0ZW0oKTtcclxuXHRcdHJlZ2lzdHJ5SXRlbS5rZXkgPSBrZXk7XHJcblx0XHRyZWdpc3RyeUl0ZW0uY29uc3RyID0gY29uc3RyO1xyXG5cclxuXHRcdHRoaXMucmVnaXN0cnlJdGVtcy5wdXNoKHJlZ2lzdHJ5SXRlbSk7XHJcblx0fVxyXG59XHJcblxyXG5jbGFzcyBTaGFkZXJSZWdpc3RyeUl0ZW0ge1xyXG5cdGtleTogc3RyaW5nO1xyXG5cdGNvbnN0cjogbmV3IChwcm9ncmFtS2V5OiBzdHJpbmcpID0+IFNoYWRlclR5cGU7XHJcblx0cHJlbG9hZDogU2hhZGVyUHJlbG9hZDtcclxufVxyXG5cclxuY2xhc3MgU2hhZGVyUHJlbG9hZCB7XHJcblx0dnNoYWRlckxvY2F0aW9uOiBzdHJpbmc7XHJcblx0ZnNoYWRlckxvY2F0aW9uOiBzdHJpbmc7XHJcbn0iLCJpbXBvcnQgTWFwIGZyb20gXCIuLi9EYXRhVHlwZXMvTWFwXCI7XHJcbmltcG9ydCBSZWdpc3RyeSBmcm9tIFwiLi9SZWdpc3RyaWVzL1JlZ2lzdHJ5XCI7XHJcbmltcG9ydCBTaGFkZXJSZWdpc3RyeSBmcm9tIFwiLi9SZWdpc3RyaWVzL1NoYWRlclJlZ2lzdHJ5XCI7XHJcblxyXG4vKipcclxuICogVGhlIFJlZ2lzdHJ5IGlzIHRoZSBzeXN0ZW0ncyB3YXkgb2YgY29udmVydGluZyBjbGFzc2VzIGFuZCB0eXBlcyBpbnRvIHN0cmluZ1xyXG4gKiByZXByZXNlbnRhdGlvbnMgZm9yIHVzZSBlbHNld2hlcmUgaW4gdGhlIGFwcGxpY2F0aW9uLlxyXG4gKiBJdCBhbGxvd3MgY2xhc3NlcyB0byBiZSBhY2Nlc3NlZCB3aXRob3V0IGV4cGxpY2l0bHkgdXNpbmcgY29uc3RydWN0b3JzIGluIGNvZGUsXHJcbiAqIGFuZCBmb3IgcmVzb3VyY2VzIHRvIGJlIGxvYWRlZCBhdCBHYW1lIGNyZWF0aW9uIHRpbWUuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZWdpc3RyeU1hbmFnZXIge1xyXG5cclxuXHRwdWJsaWMgc3RhdGljIHNoYWRlcnMgPSBuZXcgU2hhZGVyUmVnaXN0cnkoKTtcclxuXHJcblx0LyoqIEFkZGl0aW9uYWwgY3VzdG9tIHJlZ2lzdHJpZXMgdG8gYWRkIHRvIHRoZSByZWdpc3RyeSBtYW5hZ2VyICovXHJcblx0cHJvdGVjdGVkIHN0YXRpYyByZWdpc3RyaWVzOiBNYXA8UmVnaXN0cnk8YW55Pj4gPSBuZXcgTWFwKCk7XHJcblxyXG5cdHN0YXRpYyBwcmVsb2FkKCl7XHJcblx0XHR0aGlzLnNoYWRlcnMucHJlbG9hZCgpO1xyXG5cclxuXHRcdHRoaXMucmVnaXN0cmllcy5mb3JFYWNoKChrZXk6IHN0cmluZykgPT4gdGhpcy5yZWdpc3RyaWVzLmdldChrZXkpLnByZWxvYWQoKSk7XHJcblx0fVxyXG5cclxuXHRzdGF0aWMgYWRkQ3VzdG9tUmVnaXN0cnkobmFtZTogc3RyaW5nLCByZWdpc3RyeTogUmVnaXN0cnk8YW55Pil7XHJcblx0XHR0aGlzLnJlZ2lzdHJpZXMuYWRkKG5hbWUsIHJlZ2lzdHJ5KTtcclxuXHR9XHJcblxyXG5cdHN0YXRpYyBnZXRSZWdpc3RyeShrZXk6IHN0cmluZyl7XHJcblx0XHRyZXR1cm4gdGhpcy5yZWdpc3RyaWVzLmdldChrZXkpO1xyXG5cdH1cclxufSIsImltcG9ydCBNYXAgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9NYXBcIjtcclxuaW1wb3J0IEVtaXR0ZXIgZnJvbSBcIi4uLy4uL0V2ZW50cy9FbWl0dGVyXCI7XHJcbmltcG9ydCBDYW52YXNOb2RlIGZyb20gXCIuLi8uLi9Ob2Rlcy9DYW52YXNOb2RlXCI7XHJcbmltcG9ydCB7IEFuaW1hdGlvbkRhdGEsIEFuaW1hdGlvblN0YXRlIH0gZnJvbSBcIi4vQW5pbWF0aW9uVHlwZXNcIjtcclxuXHJcbi8qKlxyXG4gKiBBbiBhbmltYXRpb24gbWFuYWdlciBjbGFzcyBmb3IgYW4gYW5pbWF0ZWQgQ2FudmFzTm9kZS5cclxuICogVGhpcyBjbGFzcyBrZWVwcyB0cmFjayBvZiB0aGUgcG9zc2libGUgYW5pbWF0aW9ucywgYXMgd2VsbCBhcyB0aGUgY3VycmVudCBhbmltYXRpb24gc3RhdGUsXHJcbiAqIGFuZCBhYnN0cmFjdHMgYWxsIGludGVyYWN0aW9ucyB3aXRoIHBsYXlpbmcsIHBhdXNpbmcsIGFuZCBzdG9wcGluZyBhbmltYXRpb25zIGFzIHdlbGwgYXMgXHJcbiAqIGNyZWF0aW5nIG5ldyBhbmltYXRpb25zIGZyb20gdGhlIENhbnZhc05vZGUuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBbmltYXRpb25NYW5hZ2VyIHtcclxuICAgIC8qKiBUaGUgb3duZXIgb2YgdGhpcyBhbmltYXRpb24gbWFuYWdlciAqL1xyXG4gICAgcHJvdGVjdGVkIG93bmVyOiBDYW52YXNOb2RlO1xyXG4gICAgXHJcbiAgICAvKiogVGhlIGN1cnJlbnQgYW5pbWF0aW9uIHN0YXRlIG9mIHRoaXMgc3ByaXRlICovXHJcbiAgICBwcm90ZWN0ZWQgYW5pbWF0aW9uU3RhdGU6IEFuaW1hdGlvblN0YXRlO1xyXG5cclxuICAgIC8qKiBUaGUgbmFtZSBvZiB0aGUgY3VycmVudCBhbmltYXRpb24gb2YgdGhpcyBzcHJpdGUgKi9cclxuICAgIHByb3RlY3RlZCBjdXJyZW50QW5pbWF0aW9uOiBzdHJpbmc7XHJcblxyXG4gICAgLyoqIFRoZSBjdXJyZW50IGZyYW1lIG9mIHRoaXMgYW5pbWF0aW9uICovXHJcbiAgICBwcm90ZWN0ZWQgY3VycmVudEZyYW1lOiBudW1iZXI7XHJcblxyXG4gICAgLyoqIFRoZSBwcm9ncmVzcyBvZiB0aGUgY3VycmVudCBhbmltYXRpb24gdGhyb3VnaCB0aGUgY3VycmVudCBmcmFtZSAqL1xyXG4gICAgcHJvdGVjdGVkIGZyYW1lUHJvZ3Jlc3M6IG51bWJlcjtcclxuXHJcbiAgICAvKiogV2hldGhlciB0aGUgY3VycmVudCBhbmltYXRpb24gaXMgbG9vcGluZyBvciBub3QgKi9cclxuICAgIHByb3RlY3RlZCBsb29wOiBib29sZWFuO1xyXG5cclxuICAgIC8qKiBUaGUgbWFwIG9mIGFuaW1hdGlvbnMgKi9cclxuICAgIHByb3RlY3RlZCBhbmltYXRpb25zOiBNYXA8QW5pbWF0aW9uRGF0YT47XHJcblxyXG4gICAgLyoqIFRoZSBuYW1lIG9mIHRoZSBldmVudCAoaWYgYW55KSB0byBzZW5kIHdoZW4gdGhlIGN1cnJlbnQgYW5pbWF0aW9uIHN0b3BzIHBsYXlpbmcuICovXHJcbiAgICBwcm90ZWN0ZWQgb25FbmRFdmVudDogc3RyaW5nO1xyXG5cclxuICAgIC8qKiBUaGUgZXZlbnQgZW1pdHRlciBmb3IgdGhpcyBhbmltYXRpb24gbWFuYWdlciAqL1xyXG4gICAgcHJvdGVjdGVkIGVtaXR0ZXI6IEVtaXR0ZXI7XHJcblxyXG4gICAgLyoqIEEgcXVldWVkIGFuaW1hdGlvbiAqL1xyXG4gICAgcHJvdGVjdGVkIHBlbmRpbmdBbmltYXRpb246IHN0cmluZztcclxuXHJcbiAgICAvKiogVGhlIGxvb3Agc3RhdHVzIG9mIGEgcGVuZGluZyBhbmltYXRpb24gKi9cclxuICAgIHByb3RlY3RlZCBwZW5kaW5nTG9vcDogYm9vbGVhbjtcclxuXHJcbiAgICAvKiogVGhlIG9uRW5kIGV2ZW50IG9mIGEgcGVuZGluZyBhbmltYXRpb24gKi9cclxuICAgIHByb3RlY3RlZCBwZW5kaW5nT25FbmQ6IHN0cmluZztcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgQW5pbWF0aW9uTWFuYWdlclxyXG4gICAgICogQHBhcmFtIG93bmVyIFRoZSBvd25lciBvZiB0aGUgQW5pbWF0aW9uTWFuYWdlclxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihvd25lcjogQ2FudmFzTm9kZSl7XHJcbiAgICAgICAgdGhpcy5vd25lciA9IG93bmVyO1xyXG4gICAgICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUgPSBBbmltYXRpb25TdGF0ZS5TVE9QUEVEO1xyXG4gICAgICAgIHRoaXMuY3VycmVudEFuaW1hdGlvbiA9IFwiXCI7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50RnJhbWUgPSAwO1xyXG4gICAgICAgIHRoaXMuZnJhbWVQcm9ncmVzcyA9IDA7XHJcbiAgICAgICAgdGhpcy5sb29wID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5hbmltYXRpb25zID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRoaXMub25FbmRFdmVudCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5lbWl0dGVyID0gbmV3IEVtaXR0ZXIoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZCBhbiBhbmltYXRpb24gdG8gdGhpcyBzcHJpdGVcclxuICAgICAqIEBwYXJhbSBrZXkgVGhlIHVuaXF1ZSBrZXkgb2YgdGhlIGFuaW1hdGlvblxyXG4gICAgICogQHBhcmFtIGFuaW1hdGlvbiBUaGUgYW5pbWF0aW9uIGRhdGFcclxuICAgICAqL1xyXG4gICAgYWRkKGtleTogc3RyaW5nLCBhbmltYXRpb246IEFuaW1hdGlvbkRhdGEpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmFuaW1hdGlvbnMuYWRkKGtleSwgYW5pbWF0aW9uKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIGluZGV4IHNwZWNpZmllZCBieSB0aGUgY3VycmVudCBhbmltYXRpb24gYW5kIGN1cnJlbnQgZnJhbWVcclxuICAgICAqIEByZXR1cm5zIFRoZSBpbmRleCBpbiB0aGUgY3VycmVudCBhbmltYXRpb25cclxuICAgICAqL1xyXG4gICAgZ2V0SW5kZXgoKTogbnVtYmVyIHtcclxuICAgICAgICBpZih0aGlzLmFuaW1hdGlvbnMuaGFzKHRoaXMuY3VycmVudEFuaW1hdGlvbikpe1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hbmltYXRpb25zLmdldCh0aGlzLmN1cnJlbnRBbmltYXRpb24pLmZyYW1lc1t0aGlzLmN1cnJlbnRGcmFtZV0uaW5kZXg7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gTm8gY3VycmVudCBhbmltYXRpb24sIHdhcm4gdGhlIHVzZXJcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKGBBbmltYXRpb24gaW5kZXggd2FzIHJlcXVlc3RlZCwgYnV0IHRoZSBjdXJyZW50IGFuaW1hdGlvbjogJHt0aGlzLmN1cnJlbnRBbmltYXRpb259IHdhcyBpbnZhbGlkYCk7XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERldGVybWluZXMgd2hldGhlciB0aGUgc3BlY2lmaWVkIGFuaW1hdGlvbiBpcyBjdXJyZW50bHkgcGxheWluZ1xyXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBhbmltYXRpb24gdG8gY2hlY2tcclxuICAgICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIHNwZWNpZmllZCBhbmltYXRpb24gaXMgcGxheWluZywgZmFsc2Ugb3RoZXJ3aXNlXHJcbiAgICAgKi9cclxuICAgIGlzUGxheWluZyhrZXk6IHN0cmluZyk6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRBbmltYXRpb24gPT09IGtleSAmJiB0aGlzLmFuaW1hdGlvblN0YXRlID09PSBBbmltYXRpb25TdGF0ZS5QTEFZSU5HO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0cmlldmVzIHRoZSBjdXJyZW50IGFuaW1hdGlvbiBpbmRleCBhbmQgYWR2YW5jZXMgdGhlIGFuaW1hdGlvbiBmcmFtZVxyXG4gICAgICogQHJldHVybnMgVGhlIGluZGV4IG9mIHRoZSBhbmltYXRpb24gZnJhbWVcclxuICAgICAqL1xyXG4gICAgZ2V0SW5kZXhBbmRBZHZhbmNlQW5pbWF0aW9uKCk6IG51bWJlciB7XHJcbiAgICAgICAgLy8gSWYgd2UgYXJlbid0IHBsYXlpbmcsIHdlIHdvbid0IGJlIGFkdmFuY2luZyB0aGUgYW5pbWF0aW9uXHJcbiAgICAgICAgaWYoISh0aGlzLmFuaW1hdGlvblN0YXRlID09PSBBbmltYXRpb25TdGF0ZS5QTEFZSU5HKSl7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEluZGV4KCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZih0aGlzLmFuaW1hdGlvbnMuaGFzKHRoaXMuY3VycmVudEFuaW1hdGlvbikpe1xyXG4gICAgICAgICAgICBsZXQgY3VycmVudEFuaW1hdGlvbiA9IHRoaXMuYW5pbWF0aW9ucy5nZXQodGhpcy5jdXJyZW50QW5pbWF0aW9uKTtcclxuICAgICAgICAgICAgbGV0IGluZGV4ID0gY3VycmVudEFuaW1hdGlvbi5mcmFtZXNbdGhpcy5jdXJyZW50RnJhbWVdLmluZGV4O1xyXG5cclxuICAgICAgICAgICAgLy8gQWR2YW5jZSB0aGUgYW5pbWF0aW9uXHJcbiAgICAgICAgICAgIHRoaXMuZnJhbWVQcm9ncmVzcyArPSAxO1xyXG4gICAgICAgICAgICBpZih0aGlzLmZyYW1lUHJvZ3Jlc3MgPj0gY3VycmVudEFuaW1hdGlvbi5mcmFtZXNbdGhpcy5jdXJyZW50RnJhbWVdLmR1cmF0aW9uKXtcclxuICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgYmVlbiBvbiB0aGlzIGZyYW1lIGZvciBpdHMgd2hvbGUgZHVyYXRpb24sIGdvIHRvIHRoZSBuZXh0IG9uZVxyXG4gICAgICAgICAgICAgICAgdGhpcy5mcmFtZVByb2dyZXNzID0gMDtcclxuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudEZyYW1lICs9IDE7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYodGhpcy5jdXJyZW50RnJhbWUgPj0gY3VycmVudEFuaW1hdGlvbi5mcmFtZXMubGVuZ3RoKXtcclxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBoYXZlIHJlYWNoZWQgdGhlIGVuZCBvZiB0aGlzIGFuaW1hdGlvblxyXG4gICAgICAgICAgICAgICAgICAgIGlmKHRoaXMubG9vcCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudEZyYW1lID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5mcmFtZVByb2dyZXNzID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVuZEN1cnJlbnRBbmltYXRpb24oKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFJldHVybiB0aGUgY3VycmVudCBpbmRleFxyXG4gICAgICAgICAgICByZXR1cm4gaW5kZXg7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gTm8gY3VycmVudCBhbmltYXRpb24sIGNhbid0IGFkdmFuY2UuIFdhcm4gdGhlIHVzZXJcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKGBBbmltYXRpb24gaW5kZXggYW5kIGFkdmFuY2Ugd2FzIHJlcXVlc3RlZCwgYnV0IHRoZSBjdXJyZW50IGFuaW1hdGlvbiAoJHt0aGlzLmN1cnJlbnRBbmltYXRpb259KSBpbiBub2RlIHdpdGggaWQ6ICR7dGhpcy5vd25lci5pZH0gd2FzIGludmFsaWRgKTtcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKiBFbmRzIHRoZSBjdXJyZW50IGFuaW1hdGlvbiBhbmQgZmlyZXMgYW55IG5lY2Vzc2FyeSBldmVudHMsIGFzIHdlbGwgYXMgc3RhcnRpbmcgYW55IG5ldyBhbmltYXRpb25zICovXHJcbiAgICBwcm90ZWN0ZWQgZW5kQ3VycmVudEFuaW1hdGlvbigpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmN1cnJlbnRGcmFtZSA9IDA7XHJcbiAgICAgICAgdGhpcy5hbmltYXRpb25TdGF0ZSA9IEFuaW1hdGlvblN0YXRlLlNUT1BQRUQ7XHJcblxyXG4gICAgICAgIGlmKHRoaXMub25FbmRFdmVudCAhPT0gbnVsbCl7XHJcbiAgICAgICAgICAgIHRoaXMuZW1pdHRlci5maXJlRXZlbnQodGhpcy5vbkVuZEV2ZW50LCB7b3duZXI6IHRoaXMub3duZXIuaWQsIGFuaW1hdGlvbjogdGhpcy5jdXJyZW50QW5pbWF0aW9ufSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBJZiB0aGVyZSBpcyBhIHBlbmRpbmcgYW5pbWF0aW9uLCBwbGF5IGl0XHJcbiAgICAgICAgaWYodGhpcy5wZW5kaW5nQW5pbWF0aW9uICE9PSBudWxsKXtcclxuICAgICAgICAgICAgdGhpcy5wbGF5KHRoaXMucGVuZGluZ0FuaW1hdGlvbiwgdGhpcy5wZW5kaW5nTG9vcCwgdGhpcy5wZW5kaW5nT25FbmQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFBsYXlzIHRoZSBzcGVjaWZpZWQgYW5pbWF0aW9uLiBEb2VzIG5vdCByZXN0YXJ0IGl0IGlmIGl0IGlzIGFscmVhZHkgcGxheWluZ1xyXG4gICAgICogQHBhcmFtIGFuaW1hdGlvbiBUaGUgbmFtZSBvZiB0aGUgYW5pbWF0aW9uIHRvIHBsYXlcclxuICAgICAqIEBwYXJhbSBsb29wIFdoZXRoZXIgb3Igbm90IHRvIGxvb3AgdGhlIGFuaW1hdGlvbi4gRmFsc2UgYnkgZGVmYXVsdFxyXG4gICAgICogQHBhcmFtIG9uRW5kIFRoZSBuYW1lIG9mIGFuIGV2ZW50IHRvIHNlbmQgd2hlbiB0aGlzIGFuaW1hdGlvbiBuYXR1cmFsbHkgc3RvcHMgcGxheWluZy4gVGhpcyBvbmx5IG1hdHRlcnMgaWYgbG9vcCBpcyBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgcGxheUlmTm90QWxyZWFkeShhbmltYXRpb246IHN0cmluZywgbG9vcD86IGJvb2xlYW4sIG9uRW5kPzogc3RyaW5nKTogdm9pZCB7XHJcbiAgICAgICAgaWYodGhpcy5jdXJyZW50QW5pbWF0aW9uICE9PSBhbmltYXRpb24pe1xyXG4gICAgICAgICAgICB0aGlzLnBsYXkoYW5pbWF0aW9uLCBsb29wLCBvbkVuZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUGxheXMgdGhlIHNwZWNpZmllZCBhbmltYXRpb25cclxuICAgICAqIEBwYXJhbSBhbmltYXRpb24gVGhlIG5hbWUgb2YgdGhlIGFuaW1hdGlvbiB0byBwbGF5XHJcbiAgICAgKiBAcGFyYW0gbG9vcCBXaGV0aGVyIG9yIG5vdCB0byBsb29wIHRoZSBhbmltYXRpb24uIEZhbHNlIGJ5IGRlZmF1bHRcclxuICAgICAqIEBwYXJhbSBvbkVuZCBUaGUgbmFtZSBvZiBhbiBldmVudCB0byBzZW5kIHdoZW4gdGhpcyBhbmltYXRpb24gbmF0dXJhbGx5IHN0b3BzIHBsYXlpbmcuIFRoaXMgb25seSBtYXR0ZXJzIGlmIGxvb3AgaXMgZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIHBsYXkoYW5pbWF0aW9uOiBzdHJpbmcsIGxvb3A/OiBib29sZWFuLCBvbkVuZD86IHN0cmluZyk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuY3VycmVudEFuaW1hdGlvbiA9IGFuaW1hdGlvbjtcclxuICAgICAgICB0aGlzLmN1cnJlbnRGcmFtZSA9IDA7XHJcbiAgICAgICAgdGhpcy5mcmFtZVByb2dyZXNzID0gMDtcclxuICAgICAgICB0aGlzLmFuaW1hdGlvblN0YXRlID0gQW5pbWF0aW9uU3RhdGUuUExBWUlORztcclxuXHJcbiAgICAgICAgLy8gSWYgbG9vcCBhcmcgd2FzIHByb3ZpZGVkLCB1c2UgdGhhdFxyXG4gICAgICAgIGlmKGxvb3AgIT09IHVuZGVmaW5lZCl7XHJcbiAgICAgICAgICAgIHRoaXMubG9vcCA9IGxvb3A7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCB1c2Ugd2hhdCB0aGUganNvbiBmaWxlIHNwZWNpZmllZFxyXG4gICAgICAgICAgICB0aGlzLmxvb3AgPSB0aGlzLmFuaW1hdGlvbnMuZ2V0KGFuaW1hdGlvbikucmVwZWF0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYob25FbmQgIT09IHVuZGVmaW5lZCl7XHJcbiAgICAgICAgICAgIHRoaXMub25FbmRFdmVudCA9IG9uRW5kO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMub25FbmRFdmVudCA9IG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBSZXNldCBwZW5kaW5nIGFuaW1hdGlvblxyXG4gICAgICAgIHRoaXMucGVuZGluZ0FuaW1hdGlvbiA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBRdWV1ZXMgYSBzaW5nbGUgYW5pbWF0aW9uIHRvIGJlIHBsYXllZCBhZnRlciB0aGUgY3VycmVudCBvbmUuIERvZXMgTk9UIHN0YWNrLlxyXG4gICAgICogUXVldWVpbmcgYWRkaXRpb25hbCBhbmltYXRpb25zIHBhc3QgMSB3aWxsIGp1c3QgcmVwbGFjZSB0aGUgcXVldWVkIGFuaW1hdGlvblxyXG4gICAgICogQHBhcmFtIGFuaW1hdGlvbiBUaGUgYW5pbWF0aW9uIHRvIHF1ZXVlXHJcbiAgICAgKiBAcGFyYW0gbG9vcCBXaGV0aGVyIG9yIG5vdCB0aGUgbG9vcCB0aGUgcXVldWVkIGFuaW1hdGlvblxyXG4gICAgICogQHBhcmFtIG9uRW5kIFRoZSBldmVudCB0byBmaXJlIHdoZW4gdGhlIHF1ZXVlZCBhbmltYXRpb24gZW5kc1xyXG4gICAgICovXHJcbiAgICBxdWV1ZShhbmltYXRpb246IHN0cmluZywgbG9vcDogYm9vbGVhbiA9IGZhbHNlLCBvbkVuZD86IHN0cmluZyk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMucGVuZGluZ0FuaW1hdGlvbiA9IGFuaW1hdGlvbjtcclxuICAgICAgICB0aGlzLnBlbmRpbmdMb29wID0gbG9vcDtcclxuICAgICAgICBpZihvbkVuZCAhPT0gdW5kZWZpbmVkKXtcclxuICAgICAgICAgICAgdGhpcy5wZW5kaW5nT25FbmQgPSBvbkVuZDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdPbkVuZCA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKiBQYXVzZXMgdGhlIGN1cnJlbnQgYW5pbWF0aW9uICovXHJcbiAgICBwYXVzZSgpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmFuaW1hdGlvblN0YXRlID0gQW5pbWF0aW9uU3RhdGUuUEFVU0VEO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBSZXN1bWVzIHRoZSBjdXJyZW50IGFuaW1hdGlvbiBpZiBwb3NzaWJsZSAqL1xyXG4gICAgcmVzdW1lKCk6IHZvaWQge1xyXG4gICAgICAgIGlmKHRoaXMuYW5pbWF0aW9uU3RhdGUgPT09IEFuaW1hdGlvblN0YXRlLlBBVVNFRCl7XHJcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUgPSBBbmltYXRpb25TdGF0ZS5QTEFZSU5HO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKiogU3RvcHMgdGhlIGN1cnJlbnQgYW5pbWF0aW9uLiBUaGUgYW5pbWF0aW9uIGNhbm5vdCBiZSByZXN1bWVkIGFmdGVyIHRoaXMuICovXHJcbiAgICBzdG9wKCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUgPSBBbmltYXRpb25TdGF0ZS5TVE9QUEVEO1xyXG4gICAgfVxyXG59IiwiaW1wb3J0IHsgVHdlZW5hYmxlUHJvcGVydGllcyB9IGZyb20gXCIuLi8uLi9Ob2Rlcy9HYW1lTm9kZVwiO1xyXG5pbXBvcnQgeyBFYXNlRnVuY3Rpb25UeXBlIH0gZnJvbSBcIi4uLy4uL1V0aWxzL0Vhc2VGdW5jdGlvbnNcIjtcclxuXHJcbi8vIEBpZ25vcmVQYWdlXHJcblxyXG5leHBvcnQgZW51bSBBbmltYXRpb25TdGF0ZSB7XHJcbiAgICBTVE9QUEVEID0gMCxcclxuICAgIFBBVVNFRCA9IDEsXHJcbiAgICBQTEFZSU5HID0gMixcclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIEFuaW1hdGlvbkRhdGEge1xyXG4gICAgbmFtZTogc3RyaW5nO1xyXG4gICAgZnJhbWVzOiBBcnJheTx7aW5kZXg6IG51bWJlciwgZHVyYXRpb246IG51bWJlcn0+O1xyXG4gICAgcmVwZWF0OiBib29sZWFuID0gZmFsc2U7XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBUd2VlbkVmZmVjdCB7XHJcbiAgICAvKiogVGhlIHByb3BlcnR5IHRvIHR3ZWVuICovXHJcbiAgICBwcm9wZXJ0eTogVHdlZW5hYmxlUHJvcGVydGllcztcclxuXHJcbiAgICAvKiogV2hldGhlciBvciBub3QgdGhlIFR3ZWVuIHNob3VsZCByZXNldCB0aGUgcHJvcGVydHkgdG8gaXRzIG9yaWdpbmFsIHZhbHVlIGFmdGVyIHBsYXlpbmcgKi9cclxuICAgIHJlc2V0T25Db21wbGV0ZTogYm9vbGVhbjtcclxuXHJcbiAgICAvKiogVGhlIHN0YXJ0aW5nIHZhbHVlIGZvciB0aGUgdHdlZW4gKi9cclxuICAgIHN0YXJ0OiBhbnk7XHJcblxyXG4gICAgLyoqIFRoZSBlbmRpbmcgdmFsdWUgZm9yIHRoZSB0d2VlbiAqL1xyXG4gICAgZW5kOiBhbnk7XHJcblxyXG4gICAgLyoqIFRoZSBlYXNlIGZ1bmN0aW9uIHRvIHVzZSAqL1xyXG4gICAgZWFzZTogRWFzZUZ1bmN0aW9uVHlwZTtcclxuXHJcbiAgICAvKiogRE8gTk9UIE1PRElGWSAtIFRoZSBvcmlnaW5hbCB2YWx1ZSBvZiB0aGUgcHJvcGVydHkgLSBzZXQgYXV0b21hdGljYWxseSAqL1xyXG4gICAgaW5pdGlhbFZhbHVlOiBudW1iZXI7XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBUd2VlbkRhdGEge1xyXG4gICAgLy8gTWVtYmVycyBmb3IgaW5pdGlhbGl6YXRpb24gYnkgdGhlIHVzZXJcclxuICAgIC8qKiBUaGUgYW1vdW50IG9mIHRpbWUgaW4gbXMgdG8gd2FpdCBiZWZvcmUgZXhlY3V0aW5nIHRoZSB0d2VlbiAqL1xyXG4gICAgc3RhcnREZWxheTogbnVtYmVyO1xyXG4gICAgLyoqIFRoZSBkdXJhdGlvbiBvZiB0aW1lIG92ZXIgd2hpY2ggdGhlIHZhbHVlIHdpdGggY2hhbmdlIGZyb20gc3RhcnQgdG8gZW5kICovXHJcbiAgICBkdXJhdGlvbjogbnVtYmVyO1xyXG4gICAgLyoqIEFuIGFycmF5IG9mIHRoZSBlZmZlY3RzIG9uIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBvYmplY3QgKi9cclxuICAgIGVmZmVjdHM6IEFycmF5PFR3ZWVuRWZmZWN0PjtcclxuICAgIC8qKiBXaGV0aGVyIG9yIG5vdCB0aGlzIHR3ZWVuIHNob3VsZCByZXZlcnNlIGZyb20gZW5kIHRvIHN0YXJ0IGZvciBlYWNoIHByb3BlcnR5IHdoZW4gaXQgZmluaXNoZXMgKi9cclxuICAgIHJldmVyc2VPbkNvbXBsZXRlOiBib29sZWFuO1xyXG4gICAgLyoqIFdoZXRoZXIgb3Igbm90IHRoaXMgdHdlZW4gc2hvdWxkIGxvb3Agd2hlbiBpdCBjb21wbGV0ZXMgKi9cclxuICAgIGxvb3A6IGJvb2xlYW47XHJcbiAgICAvKiogVGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIHNlbmQgKGlmIGFueSkgd2hlbiB0aGUgdHdlZW4gZmluaXNoZXMgcGxheWluZyAqL1xyXG4gICAgb25FbmQ6IHN0cmluZ1xyXG4gICAgXHJcbiAgICAvLyBNZW1iZXJzIGZvciBtYW5hZ2VtZW50IGJ5IHRoZSB0d2VlbiBtYW5hZ2VyXHJcbiAgICAvKiogVGhlIHByb2dyZXNzIG9mIHRoaXMgdHdlZW4gdGhyb3VnaCBpdHMgZWZmZWN0cyAqL1xyXG4gICAgcHJvZ3Jlc3M6IG51bWJlcjtcclxuXHJcbiAgICAvKiogVGhlIGFtb3VudCBvZiB0aW1lIGluIG1zIHRoYXQgaGFzIHBhc3NlZCBmcm9tIHdoZW4gdGhpcyB0d2VlbiBzdGFydGVkIHJ1bm5pbmcgKi9cclxuICAgIGVsYXBzZWRUaW1lOiBudW1iZXI7XHJcblxyXG4gICAgLyoqIFRoZSBzdGF0ZSBvZiB0aGlzIHR3ZWVuICovXHJcbiAgICBhbmltYXRpb25TdGF0ZTogQW5pbWF0aW9uU3RhdGU7XHJcblxyXG4gICAgLyoqIFdoZXRoZXIgb3Igbm90IHRoaXMgdHdlZW4gaXMgY3VycmVudGx5IHJldmVyc2luZyAqL1xyXG4gICAgcmV2ZXJzaW5nOiBib29sZWFuO1xyXG59IiwiaW1wb3J0IFVwZGF0ZWFibGUgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9JbnRlcmZhY2VzL1VwZGF0ZWFibGVcIjtcclxuaW1wb3J0IFBhcnRpY2xlU3lzdGVtIGZyb20gXCIuL1BhcnRpY2xlU3lzdGVtXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQYXJ0aWNsZVN5c3RlbU1hbmFnZXIgaW1wbGVtZW50cyBVcGRhdGVhYmxlIHtcclxuXHJcbiAgICBwcml2YXRlIHN0YXRpYyBpbnN0YW5jZTogUGFydGljbGVTeXN0ZW1NYW5hZ2VyID0gbnVsbDtcclxuICAgIFxyXG4gICAgcHJvdGVjdGVkIHBhcnRpY2xlU3lzdGVtczogQXJyYXk8UGFydGljbGVTeXN0ZW0+O1xyXG5cclxuICAgIHByaXZhdGUgY29uc3RydWN0b3IoKXtcclxuICAgICAgICB0aGlzLnBhcnRpY2xlU3lzdGVtcyA9IG5ldyBBcnJheSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBnZXRJbnN0YW5jZSgpOiBQYXJ0aWNsZVN5c3RlbU1hbmFnZXIge1xyXG4gICAgICAgIGlmKFBhcnRpY2xlU3lzdGVtTWFuYWdlci5pbnN0YW5jZSA9PT0gbnVsbCl7XHJcbiAgICAgICAgICAgIFBhcnRpY2xlU3lzdGVtTWFuYWdlci5pbnN0YW5jZSA9IG5ldyBQYXJ0aWNsZVN5c3RlbU1hbmFnZXIoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBQYXJ0aWNsZVN5c3RlbU1hbmFnZXIuaW5zdGFuY2U7XHJcbiAgICB9XHJcblxyXG4gICAgcmVnaXN0ZXJQYXJ0aWNsZVN5c3RlbShzeXN0ZW06IFBhcnRpY2xlU3lzdGVtKXtcclxuICAgICAgICB0aGlzLnBhcnRpY2xlU3lzdGVtcy5wdXNoKHN5c3RlbSk7XHJcbiAgICB9XHJcblxyXG4gICAgZGVyZWdpc3RlclBhcnRpY2xlU3lzdGVtKHN5c3RlbTogUGFydGljbGVTeXN0ZW0pe1xyXG4gICAgICAgIGxldCBpbmRleCA9IHRoaXMucGFydGljbGVTeXN0ZW1zLmluZGV4T2Yoc3lzdGVtKTtcclxuICAgICAgICB0aGlzLnBhcnRpY2xlU3lzdGVtcy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgfVxyXG5cclxuICAgIGNsZWFyUGFydGljbGVTeXN0ZW1zKCl7XHJcbiAgICAgICAgdGhpcy5wYXJ0aWNsZVN5c3RlbXMgPSBuZXcgQXJyYXkoKTtcclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGUoZGVsdGFUOiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgICBmb3IobGV0IHBhcnRpY2xlU3lzdGVtIG9mIHRoaXMucGFydGljbGVTeXN0ZW1zKXtcclxuICAgICAgICAgICAgcGFydGljbGVTeXN0ZW0udXBkYXRlKGRlbHRhVCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59IiwiaW1wb3J0IE1hcCBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL01hcFwiO1xyXG5pbXBvcnQgR2FtZU5vZGUgZnJvbSBcIi4uLy4uL05vZGVzL0dhbWVOb2RlXCI7XHJcbmltcG9ydCB7IEFuaW1hdGlvblN0YXRlLCBUd2VlbkRhdGEgfSBmcm9tIFwiLi9BbmltYXRpb25UeXBlc1wiO1xyXG5pbXBvcnQgRWFzZUZ1bmN0aW9ucyBmcm9tIFwiLi4vLi4vVXRpbHMvRWFzZUZ1bmN0aW9uc1wiO1xyXG5pbXBvcnQgTWF0aFV0aWxzIGZyb20gXCIuLi8uLi9VdGlscy9NYXRoVXRpbHNcIjtcclxuaW1wb3J0IFR3ZWVuTWFuYWdlciBmcm9tIFwiLi9Ud2Vlbk1hbmFnZXJcIjtcclxuaW1wb3J0IEVtaXR0ZXIgZnJvbSBcIi4uLy4uL0V2ZW50cy9FbWl0dGVyXCI7XHJcblxyXG4vKipcclxuICogQSBtYW5hZ2VyIGZvciB0aGUgdHdlZW5zIG9mIGEgR2FtZU5vZGUuXHJcbiAqIFR3ZWVucyBhcmUgc2hvcnQgYW5pbWF0aW9ucyBwbGF5ZWQgYnkgaW50ZXJwb2xhdGluZyBiZXR3ZWVuIHR3byBwcm9wZXJ0aWVzIHVzaW5nIGFuIGVhc2luZyBmdW5jdGlvbi5cclxuICogRm9yIGEgZ29vZCB2aXN1YWwgcmVwcmVzZW50YXRpb24gb2YgZWFzaW5nIGZ1bmN0aW9ucywgY2hlY2sgb3V0IEBsaW5rKGh0dHBzOi8vZWFzaW5ncy5uZXQvKShodHRwczovL2Vhc2luZ3MubmV0LykuXHJcbiAqIE11bHRpcGxlIHR3ZWVuIGNhbiBiZSBwbGF5ZWQgYXQgdGhlIHNhbWUgdGltZSwgYXMgbG9uZyBhcyB0aGV5IGRvbid0IGNoYW5nZSB0aGUgc2FtZSBwcm9wZXJ0eS5cclxuICogVGhpcyBhbGxvd3MgZm9yIHNvbWUgaW50ZXJlc3RpbmcgcG9saXNoZXMgb3IgYW5pbWF0aW9ucyB0aGF0IG1heSBiZSB2ZXJ5IGRpZmZpY3VsdCB0byBkbyB3aXRoIHNwcml0ZSB3b3JrIGFsb25lXHJcbiAqIC0gZXNwZWNpYWxseSBwaXhlbCBhcnQgKHN1Y2ggYXMgcm90YXRpb25zIG9yIHNjYWxpbmcpLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVHdlZW5Db250cm9sbGVyIHtcclxuICAgIC8qKiBUaGUgR2FtZU5vZGUgdGhpcyBUd2VlbkNvbnRyb2xsZXIgYWN0cyB1cG9uICovXHJcbiAgICBwcm90ZWN0ZWQgb3duZXI6IEdhbWVOb2RlO1xyXG4gICAgLyoqIFRoZSBsaXN0IG9mIGNyZWF0ZWQgdHdlZW5zICovXHJcbiAgICBwcm90ZWN0ZWQgdHdlZW5zOiBNYXA8VHdlZW5EYXRhPjtcclxuICAgIC8qKiBBbiBldmVudCBlbWl0dGVyICovXHJcbiAgICBwcm90ZWN0ZWQgZW1pdHRlcjogRW1pdHRlcjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgVHdlZW5Db250cm9sbGVyXHJcbiAgICAgKiBAcGFyYW0gb3duZXIgVGhlIG93bmVyIG9mIHRoZSBUd2VlbkNvbnRyb2xsZXJcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3Iob3duZXI6IEdhbWVOb2RlKXtcclxuICAgICAgICB0aGlzLm93bmVyID0gb3duZXI7XHJcbiAgICAgICAgdGhpcy50d2VlbnMgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy5lbWl0dGVyID0gbmV3IEVtaXR0ZXIoKTtcclxuXHJcbiAgICAgICAgLy8gR2l2ZSBvdXJzZWx2ZXMgdG8gdGhlIFR3ZWVuTWFuYWdlclxyXG4gICAgICAgIFR3ZWVuTWFuYWdlci5nZXRJbnN0YW5jZSgpLnJlZ2lzdGVyVHdlZW5Db250cm9sbGVyKHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVzdHJveXMgdGhpcyBUd2VlbkNvbnRyb2xsZXJcclxuICAgICAqL1xyXG4gICAgZGVzdHJveSgpe1xyXG4gICAgICAgIC8vIE9ubHkgdGhlIGdhbWVub2RlIGFuZCB0aGUgdHdlZW4gbWFuYWdlciBzaG91bGQgaGF2ZSBhIHJlZmVyZW5jZSB0byB0aGlzXHJcbiAgICAgICAgZGVsZXRlIHRoaXMub3duZXIudHdlZW5zO1xyXG4gICAgICAgIFR3ZWVuTWFuYWdlci5nZXRJbnN0YW5jZSgpLmRlcmVnaXN0ZXJUd2VlbkNvbnRyb2xsZXIodGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGQgYSB0d2VlbiB0byB0aGlzIGdhbWUgbm9kZVxyXG4gICAgICogQHBhcmFtIGtleSBUaGUgbmFtZSBvZiB0aGUgdHdlZW5cclxuICAgICAqIEBwYXJhbSB0d2VlbiBUaGUgZGF0YSBvZiB0aGUgdHdlZW5cclxuICAgICAqL1xyXG4gICAgYWRkKGtleTogc3RyaW5nLCB0d2VlbjogUmVjb3JkPHN0cmluZywgYW55PiB8IFR3ZWVuRGF0YSk6IHZvaWQge1xyXG4gICAgICAgIGxldCB0eXBlZFR3ZWVuID0gPFR3ZWVuRGF0YT50d2VlbjtcclxuXHJcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBtZW1iZXJzIHRoYXQgd2UgbmVlZCAoYW5kIHRoZSB1c2VyIGRpZG4ndCBwcm92aWRlKVxyXG4gICAgICAgIHR5cGVkVHdlZW4ucHJvZ3Jlc3MgPSAwO1xyXG4gICAgICAgIHR5cGVkVHdlZW4uZWxhcHNlZFRpbWUgPSAwO1xyXG4gICAgICAgIHR5cGVkVHdlZW4uYW5pbWF0aW9uU3RhdGUgPSBBbmltYXRpb25TdGF0ZS5TVE9QUEVEO1xyXG5cclxuICAgICAgICB0aGlzLnR3ZWVucy5hZGQoa2V5LCB0eXBlZFR3ZWVuKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFBsYXkgYSB0d2VlbiB3aXRoIGEgY2VydGFpbiBuYW1lXHJcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBuYW1lIG9mIHRoZSB0d2VlbiB0byBwbGF5XHJcbiAgICAgKiBAcGFyYW0gbG9vcCBXaGV0aGVyIG9yIG5vdCB0aGUgdHdlZW4gc2hvdWxkIGxvb3BcclxuICAgICAqL1xyXG4gICAgcGxheShrZXk6IHN0cmluZywgbG9vcD86IGJvb2xlYW4pOiB2b2lkIHtcclxuICAgICAgICBpZih0aGlzLnR3ZWVucy5oYXMoa2V5KSl7XHJcbiAgICAgICAgICAgIGxldCB0d2VlbiA9IHRoaXMudHdlZW5zLmdldChrZXkpO1xyXG5cclxuICAgICAgICAgICAgLy8gU2V0IGxvb3AgaWYgbmVlZGVkXHJcbiAgICAgICAgICAgIGlmKGxvb3AgIT09IHVuZGVmaW5lZCl7XHJcbiAgICAgICAgICAgICAgICB0d2Vlbi5sb29wID0gbG9vcDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gU2V0IHRoZSBpbml0aWFsIHZhbHVlc1xyXG4gICAgICAgICAgICBmb3IobGV0IGVmZmVjdCBvZiB0d2Vlbi5lZmZlY3RzKXtcclxuICAgICAgICAgICAgICAgIGlmKGVmZmVjdC5yZXNldE9uQ29tcGxldGUpe1xyXG4gICAgICAgICAgICAgICAgICAgIGVmZmVjdC5pbml0aWFsVmFsdWUgPSB0aGlzLm93bmVyW2VmZmVjdC5wcm9wZXJ0eV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFN0YXJ0IHRoZSB0d2VlbiBydW5uaW5nXHJcbiAgICAgICAgICAgIHR3ZWVuLmFuaW1hdGlvblN0YXRlID0gQW5pbWF0aW9uU3RhdGUuUExBWUlORztcclxuICAgICAgICAgICAgdHdlZW4uZWxhcHNlZFRpbWUgPSAwO1xyXG4gICAgICAgICAgICB0d2Vlbi5wcm9ncmVzcyA9IDA7XHJcbiAgICAgICAgICAgIHR3ZWVuLnJldmVyc2luZyA9IGZhbHNlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgVHJpZWQgdG8gcGxheSB0d2VlbiBcIiR7a2V5fVwiIG9uIG5vZGUgd2l0aCBpZCAke3RoaXMub3duZXIuaWR9LCBidXQgbm8gc3VjaCB0d2VlbiBleGlzdHNgKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQYXVzZXMgYSBwbGF5aW5nIHR3ZWVuLiBEb2VzIG5vdCBhZmZlY3QgdHdlZW5zIHRoYXQgYXJlIHN0b3BwZWQuXHJcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBuYW1lIG9mIHRoZSB0d2VlbiB0byBwYXVzZS5cclxuICAgICAqL1xyXG4gICAgcGF1c2Uoa2V5OiBzdHJpbmcpOiB2b2lkIHtcclxuICAgICAgICBpZih0aGlzLnR3ZWVucy5oYXMoa2V5KSl7XHJcbiAgICAgICAgICAgIHRoaXMudHdlZW5zLmdldChrZXkpLmFuaW1hdGlvblN0YXRlID0gQW5pbWF0aW9uU3RhdGUuUEFVU0VEO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlc3VtZXMgYSBwYXVzZWQgdHdlZW4uXHJcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBuYW1lIG9mIHRoZSB0d2VlbiB0byByZXN1bWVcclxuICAgICAqL1xyXG4gICAgcmVzdW1lKGtleTogc3RyaW5nKTogdm9pZCB7XHJcbiAgICAgICAgaWYodGhpcy50d2VlbnMuaGFzKGtleSkpe1xyXG4gICAgICAgICAgICBsZXQgdHdlZW4gPSB0aGlzLnR3ZWVucy5nZXQoa2V5KTtcclxuICAgICAgICAgICAgaWYodHdlZW4uYW5pbWF0aW9uU3RhdGUgPT09IEFuaW1hdGlvblN0YXRlLlBBVVNFRClcclxuICAgICAgICAgICAgICAgIHR3ZWVuLmFuaW1hdGlvblN0YXRlID0gQW5pbWF0aW9uU3RhdGUuUExBWUlORztcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTdG9wcyBhIGN1cnJlbnRseSBwbGF5aW5nIHR3ZWVuXHJcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIHR3ZWVuXHJcbiAgICAgKi9cclxuICAgIHN0b3Aoa2V5OiBzdHJpbmcpOiB2b2lkIHtcclxuICAgICAgICBpZih0aGlzLnR3ZWVucy5oYXMoa2V5KSl7XHJcbiAgICAgICAgICAgIGxldCB0d2VlbiA9IHRoaXMudHdlZW5zLmdldChrZXkpO1xyXG4gICAgICAgICAgICB0d2Vlbi5hbmltYXRpb25TdGF0ZSA9IEFuaW1hdGlvblN0YXRlLlNUT1BQRUQ7XHJcblxyXG4gICAgICAgICAgICAvLyBSZXR1cm4gdG8gdGhlIGluaXRpYWwgdmFsdWVzXHJcbiAgICAgICAgICAgIGZvcihsZXQgZWZmZWN0IG9mIHR3ZWVuLmVmZmVjdHMpe1xyXG4gICAgICAgICAgICAgICAgaWYoZWZmZWN0LnJlc2V0T25Db21wbGV0ZSl7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vd25lcltlZmZlY3QucHJvcGVydHldID0gZWZmZWN0LmluaXRpYWxWYWx1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBuYXR1cmFsIHN0b3Agb2YgYSBjdXJyZW50bHkgcGxheWluZyB0d2VlblxyXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSB0d2VlblxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgZW5kKGtleTogc3RyaW5nKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5zdG9wKGtleSk7XHJcbiAgICAgICAgaWYodGhpcy50d2VlbnMuaGFzKGtleSkpe1xyXG4gICAgICAgICAgICAvLyBHZXQgdGhlIHR3ZWVuXHJcbiAgICAgICAgICAgIGxldCB0d2VlbiA9IHRoaXMudHdlZW5zLmdldChrZXkpO1xyXG5cclxuICAgICAgICAgICAgLy8gSWYgaXQgaGFzIGFuIG9uRW5kLCBzZW5kIGFuIGV2ZW50XHJcbiAgICAgICAgICAgIGlmKHR3ZWVuLm9uRW5kKXtcclxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdHRlci5maXJlRXZlbnQodHdlZW4ub25FbmQsIHtrZXk6IGtleSwgbm9kZTogdGhpcy5vd25lci5pZH0pOyBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFN0b3BzIGFsbCBjdXJyZW50bHkgcGxheWluZyB0d2VlbnNcclxuICAgICAqL1xyXG4gICAgc3RvcEFsbCgpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLnR3ZWVucy5mb3JFYWNoKGtleSA9PiB0aGlzLnN0b3Aoa2V5KSk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHVwZGF0ZShkZWx0YVQ6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICAgIHRoaXMudHdlZW5zLmZvckVhY2goa2V5ID0+IHtcclxuICAgICAgICAgICAgbGV0IHR3ZWVuID0gdGhpcy50d2VlbnMuZ2V0KGtleSk7XHJcbiAgICAgICAgICAgIGlmKHR3ZWVuLmFuaW1hdGlvblN0YXRlID09PSBBbmltYXRpb25TdGF0ZS5QTEFZSU5HKXtcclxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgcHJvZ3Jlc3Mgb2YgdGhlIHR3ZWVuXHJcbiAgICAgICAgICAgICAgICB0d2Vlbi5lbGFwc2VkVGltZSArPSBkZWx0YVQqMTAwMDtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSdyZSBwYXN0IHRoZSBzdGFydERlbGF5LCBkbyB0aGUgdHdlZW5cclxuICAgICAgICAgICAgICAgIGlmKHR3ZWVuLmVsYXBzZWRUaW1lID49IHR3ZWVuLnN0YXJ0RGVsYXkpe1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKCF0d2Vlbi5yZXZlcnNpbmcgJiYgdHdlZW4uZWxhcHNlZFRpbWUgPj0gdHdlZW4uc3RhcnREZWxheSArIHR3ZWVuLmR1cmF0aW9uKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UncmUgb3ZlciB0aW1lLCBzdG9wIHRoZSB0d2VlbiwgbG9vcCwgb3IgcmV2ZXJzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZih0d2Vlbi5yZXZlcnNlT25Db21wbGV0ZSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSdyZSBvdmVyIHRpbWUgYW5kIGNhbiByZXZlcnNlLCBkbyBzb1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHdlZW4ucmV2ZXJzaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmKHR3ZWVuLmxvb3Ape1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UgY2FuJ3QgcmV2ZXJzZSBhbmQgY2FuIGxvb3AsIGRvIHNvXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0d2Vlbi5lbGFwc2VkVGltZSAtPSB0d2Vlbi5kdXJhdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGFyZW4ndCBsb29waW5nIGFuZCBjYW4ndCByZXZlcnNlLCBzbyBzdG9wXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVuZChrZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBmb3IgdGhlIGVuZCBvZiByZXZlcnNpbmdcclxuICAgICAgICAgICAgICAgICAgICBpZih0d2Vlbi5yZXZlcnNpbmcgJiYgdHdlZW4uZWxhcHNlZFRpbWUgPj0gdHdlZW4uc3RhcnREZWxheSArIDIqdHdlZW4uZHVyYXRpb24pe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZih0d2Vlbi5sb29wKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR3ZWVuLnJldmVyc2luZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHdlZW4uZWxhcHNlZFRpbWUgLT0gMip0d2Vlbi5kdXJhdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW5kKGtleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgcHJvZ3Jlc3MsIG1ha2Ugc3VyZSBpdCBpcyBiZXR3ZWVuIDAgYW5kIDEuIEVycm9ycyBmcm9tIHRoaXMgc2hvdWxkIG5ldmVyIGJlIGxhcmdlXHJcbiAgICAgICAgICAgICAgICAgICAgaWYodHdlZW4ucmV2ZXJzaW5nKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHdlZW4ucHJvZ3Jlc3MgPSBNYXRoVXRpbHMuY2xhbXAwMSgoMip0d2Vlbi5kdXJhdGlvbiAtICh0d2Vlbi5lbGFwc2VkVGltZS0gdHdlZW4uc3RhcnREZWxheSkpL3R3ZWVuLmR1cmF0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0d2Vlbi5wcm9ncmVzcyA9IE1hdGhVdGlscy5jbGFtcDAxKCh0d2Vlbi5lbGFwc2VkVGltZSAtIHR3ZWVuLnN0YXJ0RGVsYXkpL3R3ZWVuLmR1cmF0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZvcihsZXQgZWZmZWN0IG9mIHR3ZWVuLmVmZmVjdHMpe1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSB2YWx1ZSBmcm9tIHRoZSBlYXNlIGZ1bmN0aW9uIHRoYXQgY29ycmVzcG9uZHMgdG8gb3VyIHByb2dyZXNzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBlYXNlID0gRWFzZUZ1bmN0aW9uc1tlZmZlY3QuZWFzZV0odHdlZW4ucHJvZ3Jlc3MpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXNlIHRoZSB2YWx1ZSB0byBsZXJwIHRoZSBwcm9wZXJ0eVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSBNYXRoVXRpbHMubGVycChlZmZlY3Quc3RhcnQsIGVmZmVjdC5lbmQsIGVhc2UpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXNzaWduIHRoZSB2YWx1ZSBvZiB0aGUgcHJvcGVydHlcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vd25lcltlZmZlY3QucHJvcGVydHldID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn0iLCJpbXBvcnQgVXBkYXRlYWJsZSBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL0ludGVyZmFjZXMvVXBkYXRlYWJsZVwiO1xyXG5pbXBvcnQgVHdlZW5Db250cm9sbGVyIGZyb20gXCIuL1R3ZWVuQ29udHJvbGxlclwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVHdlZW5NYW5hZ2VyIGltcGxlbWVudHMgVXBkYXRlYWJsZSB7XHJcblxyXG4gICAgcHJpdmF0ZSBzdGF0aWMgaW5zdGFuY2U6IFR3ZWVuTWFuYWdlciA9IG51bGw7XHJcbiAgICBcclxuICAgIHByb3RlY3RlZCB0d2VlbkNvbnRyb2xsZXJzOiBBcnJheTxUd2VlbkNvbnRyb2xsZXI+O1xyXG5cclxuICAgIHByaXZhdGUgY29uc3RydWN0b3IoKXtcclxuICAgICAgICB0aGlzLnR3ZWVuQ29udHJvbGxlcnMgPSBuZXcgQXJyYXkoKTtcclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgZ2V0SW5zdGFuY2UoKTogVHdlZW5NYW5hZ2VyIHtcclxuICAgICAgICBpZihUd2Vlbk1hbmFnZXIuaW5zdGFuY2UgPT09IG51bGwpe1xyXG4gICAgICAgICAgICBUd2Vlbk1hbmFnZXIuaW5zdGFuY2UgPSBuZXcgVHdlZW5NYW5hZ2VyKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gVHdlZW5NYW5hZ2VyLmluc3RhbmNlO1xyXG4gICAgfVxyXG5cclxuICAgIHJlZ2lzdGVyVHdlZW5Db250cm9sbGVyKGNvbnRyb2xsZXI6IFR3ZWVuQ29udHJvbGxlcil7XHJcbiAgICAgICAgdGhpcy50d2VlbkNvbnRyb2xsZXJzLnB1c2goY29udHJvbGxlcik7XHJcbiAgICB9XHJcblxyXG4gICAgZGVyZWdpc3RlclR3ZWVuQ29udHJvbGxlcihjb250cm9sbGVyOiBUd2VlbkNvbnRyb2xsZXIpe1xyXG4gICAgICAgIGxldCBpbmRleCA9IHRoaXMudHdlZW5Db250cm9sbGVycy5pbmRleE9mKGNvbnRyb2xsZXIpO1xyXG4gICAgICAgIHRoaXMudHdlZW5Db250cm9sbGVycy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgfVxyXG5cclxuICAgIGNsZWFyVHdlZW5Db250cm9sbGVycygpe1xyXG4gICAgICAgIHRoaXMudHdlZW5Db250cm9sbGVycyA9IG5ldyBBcnJheSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHVwZGF0ZShkZWx0YVQ6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICAgIGZvcihsZXQgdHdlZW5Db250cm9sbGVyIG9mIHRoaXMudHdlZW5Db250cm9sbGVycyl7XHJcbiAgICAgICAgICAgIHR3ZWVuQ29udHJvbGxlci51cGRhdGUoZGVsdGFUKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0iLCJpbXBvcnQgTWFwIGZyb20gXCIuLi9EYXRhVHlwZXMvTWFwXCI7XHJcbmltcG9ydCBDYW52YXNOb2RlIGZyb20gXCIuLi9Ob2Rlcy9DYW52YXNOb2RlXCI7XHJcbmltcG9ydCBHcmFwaGljIGZyb20gXCIuLi9Ob2Rlcy9HcmFwaGljXCI7XHJcbmltcG9ydCBQb2ludCBmcm9tIFwiLi4vTm9kZXMvR3JhcGhpY3MvUG9pbnRcIjtcclxuaW1wb3J0IFJlY3QgZnJvbSBcIi4uL05vZGVzL0dyYXBoaWNzL1JlY3RcIjtcclxuaW1wb3J0IFNwcml0ZSBmcm9tIFwiLi4vTm9kZXMvU3ByaXRlcy9TcHJpdGVcIjtcclxuaW1wb3J0IFRpbGVtYXAgZnJvbSBcIi4uL05vZGVzL1RpbGVtYXBcIjtcclxuaW1wb3J0IE9ydGhvZ29uYWxUaWxlbWFwIGZyb20gXCIuLi9Ob2Rlcy9UaWxlbWFwcy9PcnRob2dvbmFsVGlsZW1hcFwiO1xyXG5pbXBvcnQgVUlFbGVtZW50IGZyb20gXCIuLi9Ob2Rlcy9VSUVsZW1lbnRcIjtcclxuaW1wb3J0IFVJTGF5ZXIgZnJvbSBcIi4uL1NjZW5lL0xheWVycy9VSUxheWVyXCI7XHJcbmltcG9ydCBTY2VuZSBmcm9tIFwiLi4vU2NlbmUvU2NlbmVcIjtcclxuaW1wb3J0IEdyYXBoaWNSZW5kZXJlciBmcm9tIFwiLi9DYW52YXNSZW5kZXJpbmcvR3JhcGhpY1JlbmRlcmVyXCI7XHJcbmltcG9ydCBSZW5kZXJpbmdNYW5hZ2VyIGZyb20gXCIuL1JlbmRlcmluZ01hbmFnZXJcIlxyXG5pbXBvcnQgVGlsZW1hcFJlbmRlcmVyIGZyb20gXCIuL0NhbnZhc1JlbmRlcmluZy9UaWxlbWFwUmVuZGVyZXJcIjtcclxuaW1wb3J0IFVJRWxlbWVudFJlbmRlcmVyIGZyb20gXCIuL0NhbnZhc1JlbmRlcmluZy9VSUVsZW1lbnRSZW5kZXJlclwiO1xyXG5pbXBvcnQgTGFiZWwgZnJvbSBcIi4uL05vZGVzL1VJRWxlbWVudHMvTGFiZWxcIjtcclxuaW1wb3J0IEJ1dHRvbiBmcm9tIFwiLi4vTm9kZXMvVUlFbGVtZW50cy9CdXR0b25cIjtcclxuaW1wb3J0IFNsaWRlciBmcm9tIFwiLi4vTm9kZXMvVUlFbGVtZW50cy9TbGlkZXJcIjtcclxuaW1wb3J0IFRleHRJbnB1dCBmcm9tIFwiLi4vTm9kZXMvVUlFbGVtZW50cy9UZXh0SW5wdXRcIjtcclxuaW1wb3J0IEFuaW1hdGVkU3ByaXRlIGZyb20gXCIuLi9Ob2Rlcy9TcHJpdGVzL0FuaW1hdGVkU3ByaXRlXCI7XHJcbmltcG9ydCBWZWMyIGZyb20gXCIuLi9EYXRhVHlwZXMvVmVjMlwiO1xyXG5pbXBvcnQgQ29sb3IgZnJvbSBcIi4uL1V0aWxzL0NvbG9yXCI7XHJcbmltcG9ydCBMaW5lIGZyb20gXCIuLi9Ob2Rlcy9HcmFwaGljcy9MaW5lXCI7XHJcbmltcG9ydCBEZWJ1ZyBmcm9tIFwiLi4vRGVidWcvRGVidWdcIjtcclxuXHJcbi8qKlxyXG4gKiBBbiBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgUmVuZGVyaW5nTWFuYWdlciBjbGFzcyB1c2luZyBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDYW52YXNSZW5kZXJlciBleHRlbmRzIFJlbmRlcmluZ01hbmFnZXIge1xyXG4gICAgcHJvdGVjdGVkIGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEO1xyXG4gICAgcHJvdGVjdGVkIGdyYXBoaWNSZW5kZXJlcjogR3JhcGhpY1JlbmRlcmVyO1xyXG4gICAgcHJvdGVjdGVkIHRpbGVtYXBSZW5kZXJlcjogVGlsZW1hcFJlbmRlcmVyO1xyXG4gICAgcHJvdGVjdGVkIHVpRWxlbWVudFJlbmRlcmVyOiBVSUVsZW1lbnRSZW5kZXJlcjtcclxuXHJcbiAgICBwcm90ZWN0ZWQgb3JpZ2luOiBWZWMyO1xyXG4gICAgcHJvdGVjdGVkIHpvb206IG51bWJlcjtcclxuXHJcbiAgICBwcm90ZWN0ZWQgd29ybGRTaXplOiBWZWMyO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKCl7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBAb3ZlcnJpZGVcclxuICAgIHNldFNjZW5lKHNjZW5lOiBTY2VuZSl7XHJcbiAgICAgICAgdGhpcy5zY2VuZSA9IHNjZW5lO1xyXG4gICAgICAgIHRoaXMuZ3JhcGhpY1JlbmRlcmVyLnNldFNjZW5lKHNjZW5lKTtcclxuICAgICAgICB0aGlzLnRpbGVtYXBSZW5kZXJlci5zZXRTY2VuZShzY2VuZSk7XHJcbiAgICAgICAgdGhpcy51aUVsZW1lbnRSZW5kZXJlci5zZXRTY2VuZShzY2VuZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQG92ZXJyaWRlXHJcbiAgICBpbml0aWFsaXplQ2FudmFzKGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyKTogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEIHtcclxuICAgICAgICBjYW52YXMud2lkdGggPSB3aWR0aDtcclxuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG5cclxuICAgICAgICB0aGlzLndvcmxkU2l6ZSA9IG5ldyBWZWMyKHdpZHRoLCBoZWlnaHQpO1xyXG5cclxuICAgICAgICB0aGlzLmN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XHJcblxyXG4gICAgICAgIHRoaXMuZ3JhcGhpY1JlbmRlcmVyID0gbmV3IEdyYXBoaWNSZW5kZXJlcih0aGlzLmN0eCk7XHJcbiAgICAgICAgdGhpcy50aWxlbWFwUmVuZGVyZXIgPSBuZXcgVGlsZW1hcFJlbmRlcmVyKHRoaXMuY3R4KTtcclxuICAgICAgICB0aGlzLnVpRWxlbWVudFJlbmRlcmVyID0gbmV3IFVJRWxlbWVudFJlbmRlcmVyKHRoaXMuY3R4KVxyXG5cclxuICAgICAgICAvLyBGb3IgY3Jpc3AgcGl4ZWwgYXJ0XHJcbiAgICAgICAgdGhpcy5jdHguaW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gZmFsc2U7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLmN0eDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBAb3ZlcnJpZGVcclxuICAgIHJlbmRlcih2aXNpYmxlU2V0OiBDYW52YXNOb2RlW10sIHRpbGVtYXBzOiBUaWxlbWFwW10sIHVpTGF5ZXJzOiBNYXA8VUlMYXllcj4pOiB2b2lkIHtcclxuICAgICAgICAvLyBTb3J0IGJ5IGRlcHRoLCB0aGVuIGJ5IHZpc2libGUgc2V0IGJ5IHktdmFsdWVcclxuICAgICAgICB2aXNpYmxlU2V0LnNvcnQoKGEsIGIpID0+IHtcclxuICAgICAgICAgICAgaWYoYS5nZXRMYXllcigpLmdldERlcHRoKCkgPT09IGIuZ2V0TGF5ZXIoKS5nZXREZXB0aCgpKXtcclxuICAgICAgICAgICAgICAgIHJldHVybiAoYS5ib3VuZGFyeS5ib3R0b20pIC0gKGIuYm91bmRhcnkuYm90dG9tKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhLmdldExheWVyKCkuZ2V0RGVwdGgoKSAtIGIuZ2V0TGF5ZXIoKS5nZXREZXB0aCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGxldCB0aWxlbWFwSW5kZXggPSAwO1xyXG4gICAgICAgIGxldCB0aWxlbWFwTGVuZ3RoID0gdGlsZW1hcHMubGVuZ3RoO1xyXG5cclxuICAgICAgICBsZXQgdmlzaWJsZVNldEluZGV4ID0gMDtcclxuICAgICAgICBsZXQgdmlzaWJsZVNldExlbmd0aCA9IHZpc2libGVTZXQubGVuZ3RoO1xyXG5cclxuICAgICAgICB3aGlsZSh0aWxlbWFwSW5kZXggPCB0aWxlbWFwTGVuZ3RoIHx8IHZpc2libGVTZXRJbmRleCA8IHZpc2libGVTZXRMZW5ndGgpe1xyXG4gICAgICAgICAgICAvLyBDaGVjayBjb25kaXRpb25zIHdoZXJlIHdlJ3ZlIGFscmVhZHkgcmVhY2hlZCB0aGUgZWRnZSBvZiBvbmUgbGlzdFxyXG4gICAgICAgICAgICBpZih0aWxlbWFwSW5kZXggPj0gdGlsZW1hcExlbmd0aCl7XHJcbiAgICAgICAgICAgICAgICAvLyBPbmx5IHJlbmRlciB0aGUgcmVtYWluaW5nIHZpc2libGUgc2V0XHJcbiAgICAgICAgICAgICAgICBsZXQgbm9kZSA9IHZpc2libGVTZXRbdmlzaWJsZVNldEluZGV4KytdO1xyXG4gICAgICAgICAgICAgICAgaWYobm9kZS52aXNpYmxlKXtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlck5vZGUobm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYodmlzaWJsZVNldEluZGV4ID49IHZpc2libGVTZXRMZW5ndGgpe1xyXG4gICAgICAgICAgICAgICAgLy8gT25seSByZW5kZXIgdGlsZW1hcHNcclxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyVGlsZW1hcCh0aWxlbWFwc1t0aWxlbWFwSW5kZXgrK10pO1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFJlbmRlciB3aGljaGV2ZXIgaXMgZnVydGhlciBkb3duXHJcbiAgICAgICAgICAgIGlmKHRpbGVtYXBzW3RpbGVtYXBJbmRleF0uZ2V0TGF5ZXIoKS5nZXREZXB0aCgpIDw9IHZpc2libGVTZXRbdmlzaWJsZVNldEluZGV4XS5nZXRMYXllcigpLmdldERlcHRoKCkpe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJUaWxlbWFwKHRpbGVtYXBzW3RpbGVtYXBJbmRleCsrXSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgbm9kZSA9IHZpc2libGVTZXRbdmlzaWJsZVNldEluZGV4KytdO1xyXG4gICAgICAgICAgICAgICAgaWYobm9kZS52aXNpYmxlKXtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlck5vZGUobm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFJlbmRlciB0aGUgdWlMYXllcnMgb24gdG9wIG9mIGV2ZXJ5dGhpbmcgZWxzZVxyXG4gICAgICAgIGxldCBzb3J0ZWRVSUxheWVycyA9IG5ldyBBcnJheTxVSUxheWVyPigpO1xyXG5cclxuICAgICAgICB1aUxheWVycy5mb3JFYWNoKGtleSA9PiBzb3J0ZWRVSUxheWVycy5wdXNoKHVpTGF5ZXJzLmdldChrZXkpKSk7XHJcblxyXG4gICAgICAgIHNvcnRlZFVJTGF5ZXJzID0gc29ydGVkVUlMYXllcnMuc29ydCgodWkxLCB1aTIpID0+IHVpMS5nZXREZXB0aCgpIC0gdWkyLmdldERlcHRoKCkpO1xyXG5cclxuICAgICAgICBzb3J0ZWRVSUxheWVycy5mb3JFYWNoKHVpTGF5ZXIgPT4ge1xyXG5cdFx0XHRpZighdWlMYXllci5pc0hpZGRlbigpKVxyXG5cdFx0XHRcdHVpTGF5ZXIuZ2V0SXRlbXMoKS5mb3JFYWNoKG5vZGUgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKCg8Q2FudmFzTm9kZT5ub2RlKS52aXNpYmxlKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJOb2RlKDxDYW52YXNOb2RlPm5vZGUpXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSlcclxuXHRcdH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVuZGVycyBhIHNwZWNpZmllZCBDYW52YXNOb2RlXHJcbiAgICAgKiBAcGFyYW0gbm9kZSBUaGUgQ2FudmFzTm9kZSB0byByZW5kZXJcclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIHJlbmRlck5vZGUobm9kZTogQ2FudmFzTm9kZSk6IHZvaWQge1xyXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgb3JpZ2luIG9mIHRoZSB2aWV3cG9ydCBhY2NvcmRpbmcgdG8gdGhpcyBzcHJpdGVcclxuICAgICAgICB0aGlzLm9yaWdpbiA9IHRoaXMuc2NlbmUuZ2V0Vmlld1RyYW5zbGF0aW9uKG5vZGUpO1xyXG5cclxuICAgICAgICAvLyBHZXQgdGhlIHpvb20gbGV2ZWwgb2YgdGhlIHNjZW5lXHJcbiAgICAgICAgdGhpcy56b29tID0gdGhpcy5zY2VuZS5nZXRWaWV3U2NhbGUoKTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBNb3ZlIHRoZSBjYW52YXMgdG8gdGhlIHBvc2l0aW9uIG9mIHRoZSBub2RlIGFuZCByb3RhdGVcclxuICAgICAgICBsZXQgeFNjYWxlID0gMTtcclxuICAgICAgICBsZXQgeVNjYWxlID0gMTtcclxuICAgICAgICBcclxuICAgICAgICBpZihub2RlIGluc3RhbmNlb2YgU3ByaXRlKXtcclxuICAgICAgICAgICAgeFNjYWxlID0gbm9kZS5pbnZlcnRYID8gLTEgOiAxO1xyXG4gICAgICAgICAgICB5U2NhbGUgPSBub2RlLmludmVydFkgPyAtMSA6IDE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmN0eC5zZXRUcmFuc2Zvcm0oeFNjYWxlLCAwLCAwLCB5U2NhbGUsIChub2RlLnBvc2l0aW9uLnggLSB0aGlzLm9yaWdpbi54KSp0aGlzLnpvb20sIChub2RlLnBvc2l0aW9uLnkgLSB0aGlzLm9yaWdpbi55KSp0aGlzLnpvb20pO1xyXG4gICAgICAgIHRoaXMuY3R4LnJvdGF0ZSgtbm9kZS5yb3RhdGlvbik7XHJcbiAgICAgICAgbGV0IGdsb2JhbEFscGhhID0gdGhpcy5jdHguZ2xvYmFsQWxwaGE7XHJcbiAgICAgICAgaWYobm9kZSBpbnN0YW5jZW9mIFJlY3Qpe1xyXG4gICAgICAgICAgICBEZWJ1Zy5sb2coXCJub2RlXCIgKyBub2RlLmlkLCBcIk5vZGVcIiArIG5vZGUuaWQgKyBcIiBBbHBoYTogXCIgKyBub2RlLmFscGhhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jdHguZ2xvYmFsQWxwaGEgPSBub2RlLmFscGhhO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmKG5vZGUgaW5zdGFuY2VvZiBBbmltYXRlZFNwcml0ZSl7XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyQW5pbWF0ZWRTcHJpdGUoPEFuaW1hdGVkU3ByaXRlPm5vZGUpO1xyXG4gICAgICAgIH0gZWxzZSBpZihub2RlIGluc3RhbmNlb2YgU3ByaXRlKXtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJTcHJpdGUoPFNwcml0ZT5ub2RlKTtcclxuICAgICAgICB9IGVsc2UgaWYobm9kZSBpbnN0YW5jZW9mIEdyYXBoaWMpe1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlckdyYXBoaWMoPEdyYXBoaWM+bm9kZSk7XHJcbiAgICAgICAgfSBlbHNlIGlmKG5vZGUgaW5zdGFuY2VvZiBVSUVsZW1lbnQpe1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlclVJRWxlbWVudCg8VUlFbGVtZW50Pm5vZGUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5jdHguZ2xvYmFsQWxwaGEgPSBnbG9iYWxBbHBoYTtcclxuICAgICAgICB0aGlzLmN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQG92ZXJyaWRlXHJcbiAgICBwcm90ZWN0ZWQgcmVuZGVyU3ByaXRlKHNwcml0ZTogU3ByaXRlKTogdm9pZCB7XHJcbiAgICAgICAgLy8gR2V0IHRoZSBpbWFnZSBmcm9tIHRoZSByZXNvdXJjZSBtYW5hZ2VyXHJcbiAgICAgICAgbGV0IGltYWdlID0gdGhpcy5yZXNvdXJjZU1hbmFnZXIuZ2V0SW1hZ2Uoc3ByaXRlLmltYWdlSWQpO1xyXG5cclxuICAgICAgICAvKlxyXG4gICAgICAgICAgICBDb29yZGluYXRlcyBpbiB0aGUgc3BhY2Ugb2YgdGhlIGltYWdlOlxyXG4gICAgICAgICAgICAgICAgaW1hZ2UgY3JvcCBzdGFydCAtPiB4LCB5XHJcbiAgICAgICAgICAgICAgICBpbWFnZSBjcm9wIHNpemUgIC0+IHcsIGhcclxuICAgICAgICAgICAgQ29vcmRpbmF0ZXMgaW4gdGhlIHNwYWNlIG9mIHRoZSB3b3JsZFxyXG4gICAgICAgICAgICAgICAgaW1hZ2UgZHJhdyBzdGFydCAtPiB4LCB5XHJcbiAgICAgICAgICAgICAgICBpbWFnZSBkcmF3IHNpemUgIC0+IHcsIGhcclxuICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY3R4LmRyYXdJbWFnZShpbWFnZSxcclxuICAgICAgICAgICAgc3ByaXRlLmltYWdlT2Zmc2V0LngsIHNwcml0ZS5pbWFnZU9mZnNldC55LFxyXG4gICAgICAgICAgICBzcHJpdGUuc2l6ZS54LCBzcHJpdGUuc2l6ZS55LFxyXG4gICAgICAgICAgICAoLXNwcml0ZS5zaXplLngqc3ByaXRlLnNjYWxlLngvMikqdGhpcy56b29tLCAoLXNwcml0ZS5zaXplLnkqc3ByaXRlLnNjYWxlLnkvMikqdGhpcy56b29tLFxyXG4gICAgICAgICAgICBzcHJpdGUuc2l6ZS54ICogc3ByaXRlLnNjYWxlLngqdGhpcy56b29tLCBzcHJpdGUuc2l6ZS55ICogc3ByaXRlLnNjYWxlLnkqdGhpcy56b29tKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBAb3ZlcnJpZGVcclxuICAgIHByb3RlY3RlZCByZW5kZXJBbmltYXRlZFNwcml0ZShzcHJpdGU6IEFuaW1hdGVkU3ByaXRlKTogdm9pZCB7XHJcbiAgICAgICAgLy8gR2V0IHRoZSBpbWFnZSBmcm9tIHRoZSByZXNvdXJjZSBtYW5hZ2VyXHJcbiAgICAgICAgbGV0IGltYWdlID0gdGhpcy5yZXNvdXJjZU1hbmFnZXIuZ2V0SW1hZ2Uoc3ByaXRlLmltYWdlSWQpO1xyXG5cclxuICAgICAgICBsZXQgYW5pbWF0aW9uSW5kZXggPSBzcHJpdGUuYW5pbWF0aW9uLmdldEluZGV4QW5kQWR2YW5jZUFuaW1hdGlvbigpO1xyXG5cclxuICAgICAgICBsZXQgYW5pbWF0aW9uT2Zmc2V0ID0gc3ByaXRlLmdldEFuaW1hdGlvbk9mZnNldChhbmltYXRpb25JbmRleCk7XHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICAgIENvb3JkaW5hdGVzIGluIHRoZSBzcGFjZSBvZiB0aGUgaW1hZ2U6XHJcbiAgICAgICAgICAgICAgICBpbWFnZSBjcm9wIHN0YXJ0IC0+IHgsIHlcclxuICAgICAgICAgICAgICAgIGltYWdlIGNyb3Agc2l6ZSAgLT4gdywgaFxyXG4gICAgICAgICAgICBDb29yZGluYXRlcyBpbiB0aGUgc3BhY2Ugb2YgdGhlIHdvcmxkIChnaXZlbiB3ZSBtb3ZlZClcclxuICAgICAgICAgICAgICAgIGltYWdlIGRyYXcgc3RhcnQgLT4gLXcvMiwgLWgvMlxyXG4gICAgICAgICAgICAgICAgaW1hZ2UgZHJhdyBzaXplICAtPiB3LCBoXHJcbiAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmN0eC5kcmF3SW1hZ2UoaW1hZ2UsXHJcbiAgICAgICAgICAgIHNwcml0ZS5pbWFnZU9mZnNldC54ICsgYW5pbWF0aW9uT2Zmc2V0LngsIHNwcml0ZS5pbWFnZU9mZnNldC55ICsgYW5pbWF0aW9uT2Zmc2V0LnksXHJcbiAgICAgICAgICAgIHNwcml0ZS5zaXplLngsIHNwcml0ZS5zaXplLnksXHJcbiAgICAgICAgICAgICgtc3ByaXRlLnNpemUueCpzcHJpdGUuc2NhbGUueC8yKSp0aGlzLnpvb20sICgtc3ByaXRlLnNpemUueSpzcHJpdGUuc2NhbGUueS8yKSp0aGlzLnpvb20sXHJcbiAgICAgICAgICAgIHNwcml0ZS5zaXplLnggKiBzcHJpdGUuc2NhbGUueCp0aGlzLnpvb20sIHNwcml0ZS5zaXplLnkgKiBzcHJpdGUuc2NhbGUueSp0aGlzLnpvb20pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEBvdmVycmlkZVxyXG4gICAgcHJvdGVjdGVkIHJlbmRlckdyYXBoaWMoZ3JhcGhpYzogR3JhcGhpYyk6IHZvaWQge1xyXG4gICAgICAgIGlmKGdyYXBoaWMgaW5zdGFuY2VvZiBQb2ludCl7XHJcbiAgICAgICAgICAgIHRoaXMuZ3JhcGhpY1JlbmRlcmVyLnJlbmRlclBvaW50KDxQb2ludD5ncmFwaGljLCB0aGlzLnpvb20pO1xyXG4gICAgICAgIH0gZWxzZSBpZihncmFwaGljIGluc3RhbmNlb2YgTGluZSl7XHJcbiAgICAgICAgICAgIHRoaXMuZ3JhcGhpY1JlbmRlcmVyLnJlbmRlckxpbmUoPExpbmU+Z3JhcGhpYywgdGhpcy5vcmlnaW4sIHRoaXMuem9vbSk7XHJcbiAgICAgICAgfSBlbHNlIGlmKGdyYXBoaWMgaW5zdGFuY2VvZiBSZWN0KXtcclxuICAgICAgICAgICAgdGhpcy5ncmFwaGljUmVuZGVyZXIucmVuZGVyUmVjdCg8UmVjdD5ncmFwaGljLCB0aGlzLnpvb20pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBAb3ZlcnJpZGVcclxuICAgIHByb3RlY3RlZCByZW5kZXJUaWxlbWFwKHRpbGVtYXA6IFRpbGVtYXApOiB2b2lkIHtcclxuICAgICAgICBpZih0aWxlbWFwIGluc3RhbmNlb2YgT3J0aG9nb25hbFRpbGVtYXApe1xyXG4gICAgICAgICAgICB0aGlzLnRpbGVtYXBSZW5kZXJlci5yZW5kZXJPcnRob2dvbmFsVGlsZW1hcCg8T3J0aG9nb25hbFRpbGVtYXA+dGlsZW1hcCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIEBvdmVycmlkZVxyXG4gICAgcHJvdGVjdGVkIHJlbmRlclVJRWxlbWVudCh1aUVsZW1lbnQ6IFVJRWxlbWVudCk6IHZvaWQge1xyXG4gICAgICAgIGlmKHVpRWxlbWVudCBpbnN0YW5jZW9mIExhYmVsKXtcclxuICAgICAgICAgICAgdGhpcy51aUVsZW1lbnRSZW5kZXJlci5yZW5kZXJMYWJlbCh1aUVsZW1lbnQpO1xyXG4gICAgICAgIH0gZWxzZSBpZih1aUVsZW1lbnQgaW5zdGFuY2VvZiBCdXR0b24pe1xyXG4gICAgICAgICAgICB0aGlzLnVpRWxlbWVudFJlbmRlcmVyLnJlbmRlckJ1dHRvbih1aUVsZW1lbnQpO1xyXG4gICAgICAgIH0gZWxzZSBpZih1aUVsZW1lbnQgaW5zdGFuY2VvZiBTbGlkZXIpe1xyXG4gICAgICAgICAgICB0aGlzLnVpRWxlbWVudFJlbmRlcmVyLnJlbmRlclNsaWRlcih1aUVsZW1lbnQpO1xyXG4gICAgICAgIH0gZWxzZSBpZih1aUVsZW1lbnQgaW5zdGFuY2VvZiBUZXh0SW5wdXQpe1xyXG4gICAgICAgICAgICB0aGlzLnVpRWxlbWVudFJlbmRlcmVyLnJlbmRlclRleHRJbnB1dCh1aUVsZW1lbnQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjbGVhcihjbGVhckNvbG9yOiBDb2xvcik6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuY3R4LmNsZWFyUmVjdCgwLCAwLCB0aGlzLndvcmxkU2l6ZS54LCB0aGlzLndvcmxkU2l6ZS55KTtcclxuICAgICAgICB0aGlzLmN0eC5maWxsU3R5bGUgPSBjbGVhckNvbG9yLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgdGhpcy5jdHguZmlsbFJlY3QoMCwgMCwgdGhpcy53b3JsZFNpemUueCwgdGhpcy53b3JsZFNpemUueSk7XHJcbiAgICB9XHJcbn0iLCJpbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL1ZlYzJcIjtcclxuaW1wb3J0IExpbmUgZnJvbSBcIi4uLy4uL05vZGVzL0dyYXBoaWNzL0xpbmVcIjtcclxuaW1wb3J0IFBvaW50IGZyb20gXCIuLi8uLi9Ob2Rlcy9HcmFwaGljcy9Qb2ludFwiO1xyXG5pbXBvcnQgUmVjdCBmcm9tIFwiLi4vLi4vTm9kZXMvR3JhcGhpY3MvUmVjdFwiO1xyXG5pbXBvcnQgUmVzb3VyY2VNYW5hZ2VyIGZyb20gXCIuLi8uLi9SZXNvdXJjZU1hbmFnZXIvUmVzb3VyY2VNYW5hZ2VyXCI7XHJcbmltcG9ydCBTY2VuZSBmcm9tIFwiLi4vLi4vU2NlbmUvU2NlbmVcIjtcclxuXHJcbi8qKlxyXG4gKiBBIHV0aWxpdHkgY2xhc3MgdG8gaGVscCB0aGUgQHJlZmVyZW5jZVtDYW52YXNSZW5kZXJlcl0gcmVuZGVyIEByZWZlcmVuY2VbR3JhcGhpY11zXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHcmFwaGljUmVuZGVyZXIge1xyXG4gICAgLyoqIFRoZSByZXNvdXJjZSBtYW5hZ2VyIG9mIHRoZSBnYW1lIGVuZ2luZSAqL1xyXG4gICAgcHJvdGVjdGVkIHJlc291cmNlTWFuYWdlcjogUmVzb3VyY2VNYW5hZ2VyO1xyXG4gICAgLyoqIFRoZSBjdXJyZW50IHNjZW5lICovXHJcbiAgICBwcm90ZWN0ZWQgc2NlbmU6IFNjZW5lO1xyXG4gICAgLyoqIFRoZSByZW5kZXJpbmcgY29udGV4dCAqL1xyXG4gICAgcHJvdGVjdGVkIGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKXtcclxuICAgICAgICB0aGlzLnJlc291cmNlTWFuYWdlciA9IFJlc291cmNlTWFuYWdlci5nZXRJbnN0YW5jZSgpO1xyXG4gICAgICAgIHRoaXMuY3R4ID0gY3R4O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgc2NlbmUgb2YgdGhpcyBHcmFwaGljUmVuZGVyZXJcclxuICAgICAqIEBwYXJhbSBzY2VuZSBUaGUgY3VycmVudCBzY2VuZVxyXG4gICAgICovXHJcbiAgICBzZXRTY2VuZShzY2VuZTogU2NlbmUpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLnNjZW5lID0gc2NlbmU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW5kZXJzIGEgcG9pbnRcclxuICAgICAqIEBwYXJhbSBwb2ludCBUaGUgcG9pbnQgdG8gcmVuZGVyXHJcbiAgICAgKiBAcGFyYW0gem9vbSBUaGUgem9vbSBsZXZlbFxyXG4gICAgICovXHJcbiAgICByZW5kZXJQb2ludChwb2ludDogUG9pbnQsIHpvb206IG51bWJlcik6IHZvaWQge1xyXG5cdFx0dGhpcy5jdHguZmlsbFN0eWxlID0gcG9pbnQuY29sb3IudG9TdHJpbmdSR0JBKCk7XHJcbiAgICAgICAgdGhpcy5jdHguZmlsbFJlY3QoKC1wb2ludC5zaXplLngvMikqem9vbSwgKC1wb2ludC5zaXplLnkvMikqem9vbSxcclxuICAgICAgICBwb2ludC5zaXplLngqem9vbSwgcG9pbnQuc2l6ZS55Knpvb20pO1xyXG4gICAgfVxyXG5cclxuICAgIHJlbmRlckxpbmUobGluZTogTGluZSwgb3JpZ2luOiBWZWMyLCB6b29tOiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmN0eC5zdHJva2VTdHlsZSA9IGxpbmUuY29sb3IudG9TdHJpbmdSR0JBKCk7XHJcbiAgICAgICAgdGhpcy5jdHgubGluZVdpZHRoID0gbGluZS50aGlja25lc3M7XHJcbiAgICAgICAgdGhpcy5jdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgdGhpcy5jdHgubW92ZVRvKDAsIDApO1xyXG4gICAgICAgIHRoaXMuY3R4LmxpbmVUbygobGluZS5lbmQueCAtIGxpbmUuc3RhcnQueCkqem9vbSwgKGxpbmUuZW5kLnkgLSBsaW5lLnN0YXJ0LnkpKnpvb20pO1xyXG4gICAgICAgIHRoaXMuY3R4LmNsb3NlUGF0aCgpO1xyXG4gICAgICAgIHRoaXMuY3R4LnN0cm9rZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVuZGVycyBhIHJlY3RcclxuICAgICAqIEBwYXJhbSByZWN0IFRoZSByZWN0IHRvIHJlbmRlclxyXG4gICAgICogQHBhcmFtIHpvb20gVGhlIHpvb20gbGV2ZWxcclxuICAgICAqL1xyXG4gICAgcmVuZGVyUmVjdChyZWN0OiBSZWN0LCB6b29tOiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgICAvLyBEcmF3IHRoZSBpbnRlcmlvciBvZiB0aGUgcmVjdFxyXG4gICAgICAgIGlmKHJlY3QuY29sb3IuYSAhPT0gMCl7XHJcbiAgICAgICAgICAgIHRoaXMuY3R4LmZpbGxTdHlsZSA9IHJlY3QuY29sb3IudG9TdHJpbmdSR0IoKTtcclxuICAgICAgICAgICAgdGhpcy5jdHguZmlsbFJlY3QoKC1yZWN0LnNpemUueC8yKSp6b29tLCAoLXJlY3Quc2l6ZS55LzIpKnpvb20sIHJlY3Quc2l6ZS54Knpvb20sIHJlY3Quc2l6ZS55Knpvb20pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRHJhdyB0aGUgYm9yZGVyIG9mIHRoZSByZWN0IGlmIGl0IGlzbid0IHRyYW5zcGFyZW50XHJcbiAgICAgICAgaWYocmVjdC5ib3JkZXJDb2xvci5hICE9PSAwKXtcclxuICAgICAgICAgICAgdGhpcy5jdHguc3Ryb2tlU3R5bGUgPSByZWN0LmdldEJvcmRlckNvbG9yKCkudG9TdHJpbmdSR0IoKTtcclxuICAgICAgICAgICAgdGhpcy5jdHgubGluZVdpZHRoID0gcmVjdC5nZXRCb3JkZXJXaWR0aCgpO1xyXG4gICAgICAgICAgICB0aGlzLmN0eC5zdHJva2VSZWN0KCgtcmVjdC5zaXplLngvMikqem9vbSwgKC1yZWN0LnNpemUueS8yKSp6b29tLCByZWN0LnNpemUueCp6b29tLCByZWN0LnNpemUueSp6b29tKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0iLCJpbXBvcnQgUmVzb3VyY2VNYW5hZ2VyIGZyb20gXCIuLi8uLi9SZXNvdXJjZU1hbmFnZXIvUmVzb3VyY2VNYW5hZ2VyXCI7XHJcbmltcG9ydCBTY2VuZSBmcm9tIFwiLi4vLi4vU2NlbmUvU2NlbmVcIjtcclxuaW1wb3J0IE9ydGhvZ29uYWxUaWxlbWFwIGZyb20gXCIuLi8uLi9Ob2Rlcy9UaWxlbWFwcy9PcnRob2dvbmFsVGlsZW1hcFwiO1xyXG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL1ZlYzJcIjtcclxuaW1wb3J0IFRpbGVzZXQgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9UaWxlc2V0cy9UaWxlc2V0XCI7XHJcblxyXG4vKipcclxuICogQSB1dGlsaXR5IGNsYXNzIGZvciB0aGUgQHJlZmVyZW5jZVtDYW52YXNSZW5kZXJlcl0gdG8gcmVuZGVyIEByZWZlcmVuY2VbVGlsZW1hcF1zXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUaWxlbWFwUmVuZGVyZXIge1xyXG4gICAgcHJvdGVjdGVkIHJlc291cmNlTWFuYWdlcjogUmVzb3VyY2VNYW5hZ2VyO1xyXG4gICAgcHJvdGVjdGVkIHNjZW5lOiBTY2VuZTtcclxuICAgIHByb3RlY3RlZCBjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRDtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCl7XHJcbiAgICAgICAgdGhpcy5yZXNvdXJjZU1hbmFnZXIgPSBSZXNvdXJjZU1hbmFnZXIuZ2V0SW5zdGFuY2UoKTtcclxuICAgICAgICB0aGlzLmN0eCA9IGN0eDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIHNjZW5lIG9mIHRoaXMgVGlsZW1hcFJlbmRlcmVyXHJcbiAgICAgKiBAcGFyYW0gc2NlbmUgVGhlIGN1cnJlbnQgc2NlbmVcclxuICAgICAqL1xyXG4gICAgc2V0U2NlbmUoc2NlbmU6IFNjZW5lKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5zY2VuZSA9IHNjZW5lO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVuZGVycyBhbiBvcnRob2dvbmFsIHRpbGVtYXBcclxuICAgICAqIEBwYXJhbSB0aWxlbWFwIFRoZSB0aWxlbWFwIHRvIHJlbmRlclxyXG4gICAgICovXHJcbiAgICByZW5kZXJPcnRob2dvbmFsVGlsZW1hcCh0aWxlbWFwOiBPcnRob2dvbmFsVGlsZW1hcCk6IHZvaWQge1xyXG4gICAgICAgIGxldCBwcmV2aW91c0FscGhhID0gdGhpcy5jdHguZ2xvYmFsQWxwaGE7XHJcbiAgICAgICAgdGhpcy5jdHguZ2xvYmFsQWxwaGEgPSB0aWxlbWFwLmdldExheWVyKCkuZ2V0QWxwaGEoKTtcclxuICAgICAgICBcclxuICAgICAgICBsZXQgb3JpZ2luID0gdGhpcy5zY2VuZS5nZXRWaWV3VHJhbnNsYXRpb24odGlsZW1hcCk7XHJcbiAgICAgICAgbGV0IHNpemUgPSB0aGlzLnNjZW5lLmdldFZpZXdwb3J0KCkuZ2V0SGFsZlNpemUoKTtcclxuICAgICAgICBsZXQgem9vbSA9IHRoaXMuc2NlbmUuZ2V0Vmlld1NjYWxlKCk7XHJcbiAgICAgICAgbGV0IGJvdHRvbVJpZ2h0ID0gb3JpZ2luLmNsb25lKCkuYWRkKHNpemUuc2NhbGVkKDIqem9vbSkpO1xyXG5cclxuICAgICAgICBpZih0aWxlbWFwLnZpc2libGUpe1xyXG4gICAgICAgICAgICBsZXQgbWluQ29sUm93ID0gdGlsZW1hcC5nZXRDb2xSb3dBdChvcmlnaW4pO1xyXG4gICAgICAgICAgICBsZXQgbWF4Q29sUm93ID0gdGlsZW1hcC5nZXRDb2xSb3dBdChib3R0b21SaWdodCk7XHJcblxyXG4gICAgICAgICAgICBmb3IobGV0IHggPSBtaW5Db2xSb3cueDsgeCA8PSBtYXhDb2xSb3cueDsgeCsrKXtcclxuICAgICAgICAgICAgICAgIGZvcihsZXQgeSA9IG1pbkNvbFJvdy55OyB5IDw9IG1heENvbFJvdy55OyB5Kyspe1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgdGlsZSBhdCB0aGlzIHBvc2l0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRpbGUgPSB0aWxlbWFwLmdldFRpbGVBdFJvd0NvbChuZXcgVmVjMih4LCB5KSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgdGhlIHJvdC9mbGlwIHBhcmFtZXRlcnMgaWYgdGhlcmUgYXJlIGFueVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1hc2sgPSAoMHhFIDw8IDI4KTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCByb3RGbGlwID0gKChtYXNrICYgdGlsZSkgPj4gMjgpICYgMHhGO1xyXG4gICAgICAgICAgICAgICAgICAgIHRpbGUgPSB0aWxlICYgfm1hc2s7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEZpbmQgdGhlIHRpbGVzZXQgdGhhdCBvd25zIHRoaXMgdGlsZSBpbmRleCBhbmQgcmVuZGVyXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yKGxldCB0aWxlc2V0IG9mIHRpbGVtYXAuZ2V0VGlsZXNldHMoKSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHRpbGVzZXQuaGFzVGlsZSh0aWxlKSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlclRpbGUodGlsZXNldCwgdGlsZSwgeCwgeSwgb3JpZ2luLCB0aWxlbWFwLnNjYWxlLCB6b29tLCByb3RGbGlwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5jdHguZ2xvYmFsQWxwaGEgPSBwcmV2aW91c0FscGhhO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVuZGVycyBhIHRpbGVcclxuICAgICAqIEBwYXJhbSB0aWxlc2V0IFRoZSB0aWxlc2V0IHRoaXMgdGlsZSBiZWxvbmdzIHRvIFxyXG4gICAgICogQHBhcmFtIHRpbGVJbmRleCBUaGUgaW5kZXggb2YgdGhlIHRpbGVcclxuICAgICAqIEBwYXJhbSB0aWxlbWFwUm93IFRoZSByb3cgb2YgdGhlIHRpbGUgaW4gdGhlIHRpbGVtYXBcclxuICAgICAqIEBwYXJhbSB0aWxlbWFwQ29sIFRoZSBjb2x1bW4gb2YgdGhlIHRpbGUgaW4gdGhlIHRpbGVtYXBcclxuICAgICAqIEBwYXJhbSBvcmlnaW4gVGhlIG9yaWdpbiBvZiB0aGUgdmlld3BvcnRcclxuICAgICAqIEBwYXJhbSBzY2FsZSBUaGUgc2NhbGUgb2YgdGhlIHRpbGVtYXBcclxuICAgICAqIEBwYXJhbSB6b29tIFRoZSB6b29tIGxldmVsIG9mIHRoZSB2aWV3cG9ydFxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgcmVuZGVyVGlsZSh0aWxlc2V0OiBUaWxlc2V0LCB0aWxlSW5kZXg6IG51bWJlciwgdGlsZW1hcFJvdzogbnVtYmVyLCB0aWxlbWFwQ29sOiBudW1iZXIsIG9yaWdpbjogVmVjMiwgc2NhbGU6IFZlYzIsIHpvb206IG51bWJlciwgcm90RmxpcDogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgICAgbGV0IGltYWdlID0gdGhpcy5yZXNvdXJjZU1hbmFnZXIuZ2V0SW1hZ2UodGlsZXNldC5nZXRJbWFnZUtleSgpKTtcclxuXHJcbiAgICAgICAgLy8gR2V0IHRoZSB0cnVlIGluZGV4XHJcbiAgICAgICAgbGV0IGluZGV4ID0gdGlsZUluZGV4IC0gdGlsZXNldC5nZXRTdGFydEluZGV4KCk7XHJcblxyXG4gICAgICAgIC8vIEdldCB0aGUgcm93IGFuZCBjb2wgb2YgdGhlIHRpbGUgaW4gaW1hZ2Ugc3BhY2VcclxuICAgICAgICBsZXQgcm93ID0gTWF0aC5mbG9vcihpbmRleCAvIHRpbGVzZXQuZ2V0TnVtQ29scygpKTtcclxuICAgICAgICBsZXQgY29sID0gaW5kZXggJSB0aWxlc2V0LmdldE51bUNvbHMoKTtcclxuICAgICAgICBsZXQgd2lkdGggPSB0aWxlc2V0LmdldFRpbGVTaXplKCkueDtcclxuICAgICAgICBsZXQgaGVpZ2h0ID0gdGlsZXNldC5nZXRUaWxlU2l6ZSgpLnk7XHJcblxyXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgcG9zaXRpb24gdG8gc3RhcnQgYSBjcm9wIGluIHRoZSB0aWxlc2V0IGltYWdlXHJcbiAgICAgICAgbGV0IGxlZnQgPSBjb2wgKiB3aWR0aDtcclxuICAgICAgICBsZXQgdG9wID0gcm93ICogaGVpZ2h0O1xyXG5cclxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIHBvc2l0aW9uIGluIHRoZSB3b3JsZCB0byByZW5kZXIgdGhlIHRpbGVcclxuICAgICAgICBsZXQgeCA9IE1hdGguZmxvb3IodGlsZW1hcFJvdyAqIHdpZHRoICogc2NhbGUueCk7XHJcbiAgICAgICAgbGV0IHkgPSBNYXRoLmZsb29yKHRpbGVtYXBDb2wgKiBoZWlnaHQgKiBzY2FsZS55KTtcclxuXHJcbiAgICAgICAgbGV0IHdvcmxkWCA9IE1hdGguZmxvb3IoKHggLSBvcmlnaW4ueCkqem9vbSk7XHJcbiAgICAgICAgbGV0IHdvcmxkWSA9IE1hdGguZmxvb3IoKHkgLSBvcmlnaW4ueSkqem9vbSk7XHJcbiAgICAgICAgbGV0IHdvcmxkV2lkdGggPSBNYXRoLmNlaWwod2lkdGggKiBzY2FsZS54ICogem9vbSk7XHJcbiAgICAgICAgbGV0IHdvcmxkSGVpZ2h0ID0gTWF0aC5jZWlsKGhlaWdodCAqIHNjYWxlLnkgKiB6b29tKTtcclxuXHJcbiAgICAgICAgaWYocm90RmxpcCAhPT0gMCl7XHJcbiAgICAgICAgICAgIGxldCBzY2FsZVggPSAxO1xyXG4gICAgICAgICAgICBsZXQgc2NhbGVZID0gMTtcclxuICAgICAgICAgICAgbGV0IHNoZWFyWCA9IDA7XHJcbiAgICAgICAgICAgIGxldCBzaGVhclkgPSAwO1xyXG5cclxuICAgICAgICAgICAgLy8gRmxpcCBvbiB0aGUgeC1heGlzXHJcbiAgICAgICAgICAgIGlmKHJvdEZsaXAgJiA4KXtcclxuICAgICAgICAgICAgICAgIHNjYWxlWCA9IC0xO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBGbGlwIG9uIHRoZSB5LWF4aXNcclxuICAgICAgICAgICAgaWYocm90RmxpcCAmIDQpe1xyXG4gICAgICAgICAgICAgICAgc2NhbGVZID0gLTE7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEZsaXAgb3ZlciB0aGUgbGluZSB5PXhcclxuICAgICAgICAgICAgaWYocm90RmxpcCAmIDIpe1xyXG4gICAgICAgICAgICAgICAgc2hlYXJYID0gc2NhbGVZO1xyXG4gICAgICAgICAgICAgICAgc2hlYXJZID0gc2NhbGVYO1xyXG4gICAgICAgICAgICAgICAgc2NhbGVYID0gMDtcclxuICAgICAgICAgICAgICAgIHNjYWxlWSA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMuY3R4LnNldFRyYW5zZm9ybShzY2FsZVgsIHNoZWFyWCwgc2hlYXJZLCBzY2FsZVksIHdvcmxkWCArIHdvcmxkV2lkdGgvMiwgd29ybGRZICsgd29ybGRIZWlnaHQvMik7XHJcbiAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIFJlbmRlciB0aGUgdGlsZVxyXG4gICAgICAgICAgICB0aGlzLmN0eC5kcmF3SW1hZ2UoaW1hZ2UsXHJcbiAgICAgICAgICAgICAgICBsZWZ0LCB0b3AsXHJcbiAgICAgICAgICAgICAgICB3aWR0aCwgaGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgLXdvcmxkV2lkdGgvMiwgLXdvcmxkSGVpZ2h0LzIsXHJcbiAgICAgICAgICAgICAgICB3b3JsZFdpZHRoLCB3b3JsZEhlaWdodCk7XHJcblxyXG4gICAgICAgICAgICBpZihyb3RGbGlwICE9PSAwKXtcclxuICAgICAgICAgICAgICAgIHRoaXMuY3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIE5vIHJvdGF0aW9ucywgZG9uJ3QgZG8gdGhlIGNhbGN1bGF0aW9ucywganVzdCByZW5kZXIgdGhlIHRpbGVcclxuICAgICAgICAgICAgLy8gUmVuZGVyIHRoZSB0aWxlXHJcbiAgICAgICAgICAgIHRoaXMuY3R4LmRyYXdJbWFnZShpbWFnZSxcclxuICAgICAgICAgICAgICAgIGxlZnQsIHRvcCxcclxuICAgICAgICAgICAgICAgIHdpZHRoLCBoZWlnaHQsXHJcbiAgICAgICAgICAgICAgICB3b3JsZFgsIHdvcmxkWSxcclxuICAgICAgICAgICAgICAgIHdvcmxkV2lkdGgsIHdvcmxkSGVpZ2h0KTtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgIH1cclxufSIsImltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi9EYXRhVHlwZXMvVmVjMlwiO1xyXG5pbXBvcnQgQnV0dG9uIGZyb20gXCIuLi8uLi9Ob2Rlcy9VSUVsZW1lbnRzL0J1dHRvblwiO1xyXG5pbXBvcnQgTGFiZWwgZnJvbSBcIi4uLy4uL05vZGVzL1VJRWxlbWVudHMvTGFiZWxcIjtcclxuaW1wb3J0IFNsaWRlciBmcm9tIFwiLi4vLi4vTm9kZXMvVUlFbGVtZW50cy9TbGlkZXJcIjtcclxuaW1wb3J0IFRleHRJbnB1dCBmcm9tIFwiLi4vLi4vTm9kZXMvVUlFbGVtZW50cy9UZXh0SW5wdXRcIjtcclxuaW1wb3J0IFJlc291cmNlTWFuYWdlciBmcm9tIFwiLi4vLi4vUmVzb3VyY2VNYW5hZ2VyL1Jlc291cmNlTWFuYWdlclwiO1xyXG5pbXBvcnQgU2NlbmUgZnJvbSBcIi4uLy4uL1NjZW5lL1NjZW5lXCI7XHJcbmltcG9ydCBNYXRoVXRpbHMgZnJvbSBcIi4uLy4uL1V0aWxzL01hdGhVdGlsc1wiO1xyXG5cclxuLyoqXHJcbiAqIEEgdXRpbGl0eSBjbGFzcyB0byBoZWxwIHRoZSBAcmVmZXJlbmNlW0NhbnZhc1JlbmRlcmVyXSByZW5kZXIgQHJlZmVyZW5jZVtVSUVsZW1lbnRdc1xyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVUlFbGVtZW50UmVuZGVyZXIge1xyXG4gICAgcHJvdGVjdGVkIHJlc291cmNlTWFuYWdlcjogUmVzb3VyY2VNYW5hZ2VyO1xyXG4gICAgcHJvdGVjdGVkIHNjZW5lOiBTY2VuZTtcclxuICAgIHByb3RlY3RlZCBjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRDtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCl7XHJcbiAgICAgICAgdGhpcy5yZXNvdXJjZU1hbmFnZXIgPSBSZXNvdXJjZU1hbmFnZXIuZ2V0SW5zdGFuY2UoKTtcclxuICAgICAgICB0aGlzLmN0eCA9IGN0eDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIHNjZW5lIG9mIHRoaXMgVUlFbGVtZW50UmVuZGVyZXJcclxuICAgICAqIEBwYXJhbSBzY2VuZSBUaGUgY3VycmVudCBzY2VuZVxyXG4gICAgICovXHJcbiAgICBzZXRTY2VuZShzY2VuZTogU2NlbmUpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLnNjZW5lID0gc2NlbmU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW5kZXJzIGEgbGFiZWxcclxuICAgICAqIEBwYXJhbSBsYWJlbCBUaGUgbGFiZWwgdG8gcmVuZGVyXHJcbiAgICAgKi9cclxuICAgIHJlbmRlckxhYmVsKGxhYmVsOiBMYWJlbCk6IHZvaWQge1xyXG4gICAgICAgIC8vIElmIHRoZSBzaXplIGlzIHVuYXNzaWduZWQgKGJ5IHRoZSB1c2VyIG9yIGF1dG9tYXRpY2FsbHkpIGFzc2lnbiBpdFxyXG4gICAgICAgIGxhYmVsLmhhbmRsZUluaXRpYWxTaXppbmcodGhpcy5jdHgpO1xyXG5cdFx0XHJcblx0XHQvLyBHcmFiIHRoZSBnbG9iYWwgYWxwaGEgc28gd2UgY2FuIGFkanVzdCBpdCBmb3IgdGhpcyByZW5kZXJcclxuXHRcdGxldCBwcmV2aW91c0FscGhhID0gdGhpcy5jdHguZ2xvYmFsQWxwaGE7XHJcblxyXG4gICAgICAgIC8vIEdldCB0aGUgZm9udCBhbmQgdGV4dCBwb3NpdGlvbiBpbiBsYWJlbFxyXG5cdFx0dGhpcy5jdHguZm9udCA9IGxhYmVsLmdldEZvbnRTdHJpbmcoKTtcclxuXHRcdGxldCBvZmZzZXQgPSBsYWJlbC5jYWxjdWxhdGVUZXh0T2Zmc2V0KHRoaXMuY3R4KTtcclxuXHJcblx0XHQvLyBTdHJva2UgYW5kIGZpbGwgYSByb3VuZGVkIHJlY3QgYW5kIGdpdmUgaXQgdGV4dFxyXG5cdFx0dGhpcy5jdHguZ2xvYmFsQWxwaGEgPSBsYWJlbC5iYWNrZ3JvdW5kQ29sb3IuYTtcclxuXHRcdHRoaXMuY3R4LmZpbGxTdHlsZSA9IGxhYmVsLmNhbGN1bGF0ZUJhY2tncm91bmRDb2xvcigpLnRvU3RyaW5nUkdCQSgpO1xyXG5cdFx0dGhpcy5jdHguZmlsbFJvdW5kZWRSZWN0KC1sYWJlbC5zaXplLngvMiwgLWxhYmVsLnNpemUueS8yLFxyXG5cdFx0XHRsYWJlbC5zaXplLngsIGxhYmVsLnNpemUueSwgbGFiZWwuYm9yZGVyUmFkaXVzKTtcclxuXHRcdFxyXG5cdFx0dGhpcy5jdHguc3Ryb2tlU3R5bGUgPSBsYWJlbC5jYWxjdWxhdGVCb3JkZXJDb2xvcigpLnRvU3RyaW5nUkdCQSgpO1xyXG5cdFx0dGhpcy5jdHguZ2xvYmFsQWxwaGEgPSBsYWJlbC5ib3JkZXJDb2xvci5hO1xyXG5cdFx0dGhpcy5jdHgubGluZVdpZHRoID0gbGFiZWwuYm9yZGVyV2lkdGg7XHJcblx0XHR0aGlzLmN0eC5zdHJva2VSb3VuZGVkUmVjdCgtbGFiZWwuc2l6ZS54LzIsIC1sYWJlbC5zaXplLnkvMixcclxuXHRcdFx0bGFiZWwuc2l6ZS54LCBsYWJlbC5zaXplLnksIGxhYmVsLmJvcmRlclJhZGl1cyk7XHJcblxyXG5cdFx0dGhpcy5jdHguZmlsbFN0eWxlID0gbGFiZWwuY2FsY3VsYXRlVGV4dENvbG9yKCk7XHJcblx0XHR0aGlzLmN0eC5nbG9iYWxBbHBoYSA9IGxhYmVsLnRleHRDb2xvci5hO1xyXG5cdFx0dGhpcy5jdHguZmlsbFRleHQobGFiZWwudGV4dCwgb2Zmc2V0LnggLSBsYWJlbC5zaXplLngvMiwgb2Zmc2V0LnkgLSBsYWJlbC5zaXplLnkvMik7XHJcblx0XHJcblx0XHR0aGlzLmN0eC5nbG9iYWxBbHBoYSA9IHByZXZpb3VzQWxwaGE7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW5kZXJzIGEgYnV0dG9uXHJcbiAgICAgKiBAcGFyYW0gYnV0dG9uIFRoZSBidXR0b24gdG8gcmVuZGVyXHJcbiAgICAgKi9cclxuICAgIHJlbmRlckJ1dHRvbihidXR0b246IEJ1dHRvbik6IHZvaWQge1xyXG4gICAgICAgIHRoaXMucmVuZGVyTGFiZWwoYnV0dG9uKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbmRlcnMgYSBzbGlkZXJcclxuICAgICAqIEBwYXJhbSBzbGlkZXIgVGhlIHNsaWRlciB0byByZW5kZXJcclxuICAgICAqL1xyXG4gICAgcmVuZGVyU2xpZGVyKHNsaWRlcjogU2xpZGVyKTogdm9pZCB7XHJcblx0XHQvLyBHcmFiIHRoZSBnbG9iYWwgYWxwaGEgc28gd2UgY2FuIGFkanVzdCBpdCBmb3IgdGhpcyByZW5kZXJcclxuXHRcdGxldCBwcmV2aW91c0FscGhhID0gdGhpcy5jdHguZ2xvYmFsQWxwaGE7XHJcblx0XHR0aGlzLmN0eC5nbG9iYWxBbHBoYSA9IHNsaWRlci5nZXRMYXllcigpLmdldEFscGhhKCk7XHJcblxyXG4gICAgICAgIC8vIENhbGN1YWxhdGUgdGhlIHNsaWRlciBzaXplXHJcbiAgICAgICAgbGV0IHNsaWRlclNpemUgPSBuZXcgVmVjMihzbGlkZXIuc2l6ZS54LCAyKTtcclxuXHJcbiAgICAgICAgLy8gRHJhdyB0aGUgc2xpZGVyXHJcblx0XHR0aGlzLmN0eC5maWxsU3R5bGUgPSBzbGlkZXIuc2xpZGVyQ29sb3IudG9TdHJpbmcoKTtcclxuXHRcdHRoaXMuY3R4LmZpbGxSb3VuZGVkUmVjdCgtc2xpZGVyU2l6ZS54LzIsIC1zbGlkZXJTaXplLnkvMixcclxuICAgICAgICAgICAgc2xpZGVyU2l6ZS54LCBzbGlkZXJTaXplLnksIHNsaWRlci5ib3JkZXJSYWRpdXMpO1xyXG5cclxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIG5pYiBzaXplIGFuZCBwb3NpdGlvblxyXG4gICAgICAgIGxldCB4ID0gTWF0aFV0aWxzLmxlcnAoLXNsaWRlci5zaXplLngvMiwgc2xpZGVyLnNpemUueC8yLCBzbGlkZXIuZ2V0VmFsdWUoKSk7XHJcblxyXG4gICAgICAgIC8vIERyYXcgdGhlIG5pYlxyXG5cdFx0dGhpcy5jdHguZmlsbFN0eWxlID0gc2xpZGVyLm5pYkNvbG9yLnRvU3RyaW5nKCk7XHJcblx0XHR0aGlzLmN0eC5maWxsUm91bmRlZFJlY3QoeC1zbGlkZXIubmliU2l6ZS54LzIsIC1zbGlkZXIubmliU2l6ZS55LzIsXHJcbiAgICAgICAgICAgIHNsaWRlci5uaWJTaXplLngsIHNsaWRlci5uaWJTaXplLnksIHNsaWRlci5ib3JkZXJSYWRpdXMpO1xyXG5cclxuICAgICAgICAvLyBSZXNldCB0aGUgYWxwaGFcclxuICAgICAgICB0aGlzLmN0eC5nbG9iYWxBbHBoYSA9IHByZXZpb3VzQWxwaGE7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW5kZXJzIGEgdGV4dElucHV0XHJcbiAgICAgKiBAcGFyYW0gdGV4dElucHV0IFRoZSB0ZXh0SW5wdXQgdG8gcmVuZGVyXHJcbiAgICAgKi9cclxuICAgIHJlbmRlclRleHRJbnB1dCh0ZXh0SW5wdXQ6IFRleHRJbnB1dCk6IHZvaWQge1xyXG4gICAgICAgIC8vIFNob3cgYSBjdXJzb3Igc29tZXRpbWVzXHJcbiAgICAgICAgaWYodGV4dElucHV0LmZvY3VzZWQgJiYgdGV4dElucHV0LmN1cnNvckNvdW50ZXIgJSA2MCA+IDMwKXtcclxuICAgICAgICAgICAgdGV4dElucHV0LnRleHQgKz0gXCJ8XCI7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnJlbmRlckxhYmVsKHRleHRJbnB1dCk7XHJcblxyXG4gICAgICAgIGlmKHRleHRJbnB1dC5mb2N1c2VkKXtcclxuICAgICAgICAgICAgaWYodGV4dElucHV0LmN1cnNvckNvdW50ZXIgJSA2MCA+IDMwKXtcclxuICAgICAgICAgICAgICAgIHRleHRJbnB1dC50ZXh0ID0gdGV4dElucHV0LnRleHQuc3Vic3RyaW5nKDAsIHRleHRJbnB1dC50ZXh0Lmxlbmd0aCAtIDEpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0ZXh0SW5wdXQuY3Vyc29yQ291bnRlciArPSAxO1xyXG4gICAgICAgICAgICBpZih0ZXh0SW5wdXQuY3Vyc29yQ291bnRlciA+PSA2MCl7XHJcbiAgICAgICAgICAgICAgICB0ZXh0SW5wdXQuY3Vyc29yQ291bnRlciA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG59IiwiaW1wb3J0IE1hcCBmcm9tIFwiLi4vRGF0YVR5cGVzL01hcFwiO1xyXG5pbXBvcnQgQ2FudmFzTm9kZSBmcm9tIFwiLi4vTm9kZXMvQ2FudmFzTm9kZVwiO1xyXG5pbXBvcnQgR3JhcGhpYyBmcm9tIFwiLi4vTm9kZXMvR3JhcGhpY1wiO1xyXG5pbXBvcnQgQW5pbWF0ZWRTcHJpdGUgZnJvbSBcIi4uL05vZGVzL1Nwcml0ZXMvQW5pbWF0ZWRTcHJpdGVcIjtcclxuaW1wb3J0IFNwcml0ZSBmcm9tIFwiLi4vTm9kZXMvU3ByaXRlcy9TcHJpdGVcIjtcclxuaW1wb3J0IFRpbGVtYXAgZnJvbSBcIi4uL05vZGVzL1RpbGVtYXBcIjtcclxuaW1wb3J0IFVJRWxlbWVudCBmcm9tIFwiLi4vTm9kZXMvVUlFbGVtZW50XCI7XHJcbmltcG9ydCBSZXNvdXJjZU1hbmFnZXIgZnJvbSBcIi4uL1Jlc291cmNlTWFuYWdlci9SZXNvdXJjZU1hbmFnZXJcIjtcclxuaW1wb3J0IFVJTGF5ZXIgZnJvbSBcIi4uL1NjZW5lL0xheWVycy9VSUxheWVyXCI7XHJcbmltcG9ydCBTY2VuZSBmcm9tIFwiLi4vU2NlbmUvU2NlbmVcIjtcclxuaW1wb3J0IENvbG9yIGZyb20gXCIuLi9VdGlscy9Db2xvclwiO1xyXG5cclxuLyoqXHJcbiAqIEFuIGFic3RyYWN0IGZyYW1ld29yayB0byBwdXQgYWxsIHJlbmRlcmluZyBpbiBvbmNlIHBsYWNlIGluIHRoZSBhcHBsaWNhdGlvblxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgYWJzdHJhY3QgY2xhc3MgUmVuZGVyaW5nTWFuYWdlciB7XHJcbiAgICAvKiogVGhlIFJlc291cmNlTWFuYWdlciAqL1xyXG4gICAgcHJvdGVjdGVkIHJlc291cmNlTWFuYWdlcjogUmVzb3VyY2VNYW5hZ2VyO1xyXG5cclxuICAgIC8qKiBUaGUgc2NlbmUgY3VycmVudGx5IGJlaW5nIHJlbmRlcmVkICovXHJcbiAgICBwcm90ZWN0ZWQgc2NlbmU6IFNjZW5lO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKCl7XHJcbiAgICAgICAgdGhpcy5yZXNvdXJjZU1hbmFnZXIgPSBSZXNvdXJjZU1hbmFnZXIuZ2V0SW5zdGFuY2UoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIHNjZW5lIGN1cnJlbnRseSBiZWluZyByZW5kZXJlZFxyXG4gICAgICogQHBhcmFtIHNjZW5lIFRoZSBjdXJyZW50IFNjZW5lXHJcbiAgICAgKi9cclxuICAgIHNldFNjZW5lKHNjZW5lOiBTY2VuZSk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuc2NlbmUgPSBzY2VuZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEluaXRpYWxpemUgdGhlIGNhbnZhcyBmb3IgdGhlIGdhbWVcclxuICAgICAqIEBwYXJhbSBjYW52YXMgVGhlIGNhbnZhcyBlbGVtZW50XHJcbiAgICAgKiBAcGFyYW0gd2lkdGggVGhlIGRlc2lyZWQgd2lkdGggb2YgdGhlIGNhbnZhc1xyXG4gICAgICogQHBhcmFtIGhlaWdodCBUaGUgZGVzaXJlZCBoZWlnaHQgb2YgdGhlIGNhbnZhc1xyXG4gICAgICogQHJldHVybnMgVGhlIHJlbmRlcmluZyBjb250ZXh0IG9mIHRoZSBjYW52YXNcclxuICAgICAqL1xyXG4gICAgYWJzdHJhY3QgaW5pdGlhbGl6ZUNhbnZhcyhjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50LCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcik6IGFueTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbmRlcnMgdGhlIHZpc2libGUgc2V0IG9mIENhbnZhc05vZGVzIGFuZCB2aXNpYmxlIHBvcnRpb25zIG9mIHRpbGVtYXBzLCBhcyB3ZWxsIGFzIGFueSBVSUVsZW1lbnQgaW4gVUlMYXllcnNcclxuICAgICAqIEBwYXJhbSB2aXNpYmxlU2V0IFRoZSB2aXNpYmxlIHNldCBvZiBDYW52YXNOb2Rlc1xyXG4gICAgICogQHBhcmFtIHRpbGVtYXBzIFRoZSB0aWxlbWFwcyB1c2VkIGluIHRoZSBhcHBsaWNhdGlvblxyXG4gICAgICogQHBhcmFtIHVpTGF5ZXJzIFRoZSB1c2VyIGludGVyZmFjZSBsYXllcnNcclxuICAgICAqL1xyXG4gICAgYWJzdHJhY3QgcmVuZGVyKHZpc2libGVTZXQ6IEFycmF5PENhbnZhc05vZGU+LCB0aWxlbWFwczogQXJyYXk8VGlsZW1hcD4sIHVpTGF5ZXJzOiBNYXA8VUlMYXllcj4pOiB2b2lkO1xyXG5cclxuICAgIC8qKiBDbGVhcnMgdGhlIGNhbnZhcyAqL1xyXG4gICAgYWJzdHJhY3QgY2xlYXIoY29sb3I6IENvbG9yKTogdm9pZDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbmRlcnMgYSBzcHJpdGVcclxuICAgICAqIEBwYXJhbSBzcHJpdGUgVGhlIHNwcml0ZSB0byByZW5kZXJcclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGFic3RyYWN0IHJlbmRlclNwcml0ZShzcHJpdGU6IFNwcml0ZSk6IHZvaWQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW5kZXJzIGFuIGFuaW1hdGVkIHNwcml0ZVxyXG4gICAgICogQHBhcmFtIHNwcml0ZSBUaGUgYW5pbWF0ZWQgc3ByaXRlIHRvIHJlbmRlclxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgYWJzdHJhY3QgcmVuZGVyQW5pbWF0ZWRTcHJpdGUoc3ByaXRlOiBBbmltYXRlZFNwcml0ZSk6IHZvaWQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW5kZXJzIGEgZ3JhcGhpY1xyXG4gICAgICogQHBhcmFtIGdyYXBoaWMgVGhlIGdyYXBoaWMgdG8gcmVuZGVyXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBhYnN0cmFjdCByZW5kZXJHcmFwaGljKGdyYXBoaWM6IEdyYXBoaWMpOiB2b2lkO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVuZGVycyBhIHRpbGVtYXBcclxuICAgICAqIEBwYXJhbSB0aWxlbWFwIFRoZSB0aWxlbWFwIHRvIHJlbmRlclxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgYWJzdHJhY3QgcmVuZGVyVGlsZW1hcCh0aWxlbWFwOiBUaWxlbWFwKTogdm9pZDtcclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW5kZXJzIGEgVUlFbGVtZW50XHJcbiAgICAgKiBAcGFyYW0gdWlFbGVtZW50IFRoZSBVSUVsZW1lbnQgdG8gcmVuZGVyXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBhYnN0cmFjdCByZW5kZXJVSUVsZW1lbnQodWlFbGVtZW50OiBVSUVsZW1lbnQpOiB2b2lkO1xyXG59IiwiaW1wb3J0IEdyYXBoIGZyb20gXCIuLi9EYXRhVHlwZXMvR3JhcGhzL0dyYXBoXCI7XHJcbmltcG9ydCBNYXAgZnJvbSBcIi4uL0RhdGFUeXBlcy9NYXBcIjtcclxuaW1wb3J0IFZlYzIgZnJvbSBcIi4uL0RhdGFUeXBlcy9WZWMyXCI7XHJcbmltcG9ydCBEZWJ1ZyBmcm9tIFwiLi4vRGVidWcvRGVidWdcIjtcclxuaW1wb3J0IENhbnZhc05vZGUgZnJvbSBcIi4uL05vZGVzL0NhbnZhc05vZGVcIjtcclxuaW1wb3J0IEdyYXBoaWMgZnJvbSBcIi4uL05vZGVzL0dyYXBoaWNcIjtcclxuaW1wb3J0IHsgR3JhcGhpY1R5cGUgfSBmcm9tIFwiLi4vTm9kZXMvR3JhcGhpY3MvR3JhcGhpY1R5cGVzXCI7XHJcbmltcG9ydCBQb2ludCBmcm9tIFwiLi4vTm9kZXMvR3JhcGhpY3MvUG9pbnRcIjtcclxuaW1wb3J0IFJlY3QgZnJvbSBcIi4uL05vZGVzL0dyYXBoaWNzL1JlY3RcIjtcclxuaW1wb3J0IEFuaW1hdGVkU3ByaXRlIGZyb20gXCIuLi9Ob2Rlcy9TcHJpdGVzL0FuaW1hdGVkU3ByaXRlXCI7XHJcbmltcG9ydCBTcHJpdGUgZnJvbSBcIi4uL05vZGVzL1Nwcml0ZXMvU3ByaXRlXCI7XHJcbmltcG9ydCBUaWxlbWFwIGZyb20gXCIuLi9Ob2Rlcy9UaWxlbWFwXCI7XHJcbmltcG9ydCBVSUVsZW1lbnQgZnJvbSBcIi4uL05vZGVzL1VJRWxlbWVudFwiO1xyXG5pbXBvcnQgTGFiZWwgZnJvbSBcIi4uL05vZGVzL1VJRWxlbWVudHMvTGFiZWxcIjtcclxuaW1wb3J0IFNoYWRlclJlZ2lzdHJ5IGZyb20gXCIuLi9SZWdpc3RyeS9SZWdpc3RyaWVzL1NoYWRlclJlZ2lzdHJ5XCI7XHJcbmltcG9ydCBSZWdpc3RyeU1hbmFnZXIgZnJvbSBcIi4uL1JlZ2lzdHJ5L1JlZ2lzdHJ5TWFuYWdlclwiO1xyXG5pbXBvcnQgUmVzb3VyY2VNYW5hZ2VyIGZyb20gXCIuLi9SZXNvdXJjZU1hbmFnZXIvUmVzb3VyY2VNYW5hZ2VyXCI7XHJcbmltcG9ydCBQYXJhbGxheExheWVyIGZyb20gXCIuLi9TY2VuZS9MYXllcnMvUGFyYWxsYXhMYXllclwiO1xyXG5pbXBvcnQgVUlMYXllciBmcm9tIFwiLi4vU2NlbmUvTGF5ZXJzL1VJTGF5ZXJcIjtcclxuaW1wb3J0IENvbG9yIGZyb20gXCIuLi9VdGlscy9Db2xvclwiO1xyXG5pbXBvcnQgUmVuZGVyaW5nVXRpbHMgZnJvbSBcIi4uL1V0aWxzL1JlbmRlcmluZ1V0aWxzXCI7XHJcbmltcG9ydCBSZW5kZXJpbmdNYW5hZ2VyIGZyb20gXCIuL1JlbmRlcmluZ01hbmFnZXJcIjtcclxuaW1wb3J0IFNoYWRlclR5cGUgZnJvbSBcIi4vV2ViR0xSZW5kZXJpbmcvU2hhZGVyVHlwZVwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgV2ViR0xSZW5kZXJlciBleHRlbmRzIFJlbmRlcmluZ01hbmFnZXIge1xyXG5cclxuXHRwcm90ZWN0ZWQgb3JpZ2luOiBWZWMyO1xyXG5cdHByb3RlY3RlZCB6b29tOiBudW1iZXI7XHJcblx0cHJvdGVjdGVkIHdvcmxkU2l6ZTogVmVjMjtcclxuXHJcblx0cHJvdGVjdGVkIGdsOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQ7XHJcblx0cHJvdGVjdGVkIHRleHRDdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRDtcclxuXHJcblx0aW5pdGlhbGl6ZUNhbnZhcyhjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50LCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcik6IFdlYkdMUmVuZGVyaW5nQ29udGV4dCB7XHJcblx0XHRjYW52YXMud2lkdGggPSB3aWR0aDtcclxuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG5cclxuXHRcdHRoaXMud29ybGRTaXplID0gVmVjMi5aRVJPO1xyXG5cdFx0dGhpcy53b3JsZFNpemUueCA9IHdpZHRoO1xyXG5cdFx0dGhpcy53b3JsZFNpemUueSA9IGhlaWdodDtcclxuXHJcblx0XHQvLyBHZXQgdGhlIFdlYkdMIGNvbnRleHRcclxuICAgICAgICB0aGlzLmdsID0gY2FudmFzLmdldENvbnRleHQoXCJ3ZWJnbFwiKTtcclxuXHJcblx0XHR0aGlzLmdsLnZpZXdwb3J0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XHJcblxyXG5cdFx0dGhpcy5nbC5kaXNhYmxlKHRoaXMuZ2wuREVQVEhfVEVTVCk7XHJcbiAgICAgICAgdGhpcy5nbC5lbmFibGUodGhpcy5nbC5CTEVORCk7XHJcbiAgICAgICAgdGhpcy5nbC5ibGVuZEZ1bmModGhpcy5nbC5TUkNfQUxQSEEsIHRoaXMuZ2wuT05FX01JTlVTX1NSQ19BTFBIQSk7XHJcbiAgICAgICAgdGhpcy5nbC5lbmFibGUodGhpcy5nbC5DVUxMX0ZBQ0UpO1xyXG5cclxuXHRcdC8vIFRlbGwgdGhlIHJlc291cmNlIG1hbmFnZXIgd2UncmUgdXNpbmcgV2ViR0xcclxuXHRcdFJlc291cmNlTWFuYWdlci5nZXRJbnN0YW5jZSgpLnVzZVdlYkdMKHRydWUsIHRoaXMuZ2wpO1xyXG5cclxuXHRcdC8vIFNob3cgdGhlIHRleHQgY2FudmFzIGFuZCBnZXQgaXRzIGNvbnRleHRcclxuXHRcdGxldCB0ZXh0Q2FudmFzID0gPEhUTUxDYW52YXNFbGVtZW50PmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwidGV4dC1jYW52YXNcIik7XHJcblx0XHR0ZXh0Q2FudmFzLmhpZGRlbiA9IGZhbHNlO1xyXG5cdFx0dGhpcy50ZXh0Q3R4ID0gdGV4dENhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XHJcblxyXG5cdFx0Ly8gU2l6ZSB0aGUgdGV4dCBjYW52YXMgdG8gYmUgdGhlIHNhbWUgYXMgdGhlIGdhbWUgY2FudmFzXHJcblx0XHR0ZXh0Q2FudmFzLmhlaWdodCA9IGhlaWdodDtcclxuXHRcdHRleHRDYW52YXMud2lkdGggPSB3aWR0aDtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2w7XHJcblx0fVxyXG5cclxuXHRyZW5kZXIodmlzaWJsZVNldDogQ2FudmFzTm9kZVtdLCB0aWxlbWFwczogVGlsZW1hcFtdLCB1aUxheWVyczogTWFwPFVJTGF5ZXI+KTogdm9pZCB7XHJcblx0XHRmb3IobGV0IG5vZGUgb2YgdmlzaWJsZVNldCl7XHJcblx0XHRcdHRoaXMucmVuZGVyTm9kZShub2RlKTtcclxuXHRcdH1cclxuXHJcblx0XHR1aUxheWVycy5mb3JFYWNoKGtleSA9PiB7XHJcblx0XHRcdGlmKCF1aUxheWVycy5nZXQoa2V5KS5pc0hpZGRlbigpKVxyXG5cdFx0XHRcdHVpTGF5ZXJzLmdldChrZXkpLmdldEl0ZW1zKCkuZm9yRWFjaChub2RlID0+IHRoaXMucmVuZGVyTm9kZSg8Q2FudmFzTm9kZT5ub2RlKSlcclxuXHRcdH0pO1xyXG5cdH1cclxuXHJcblx0Y2xlYXIoY29sb3I6IENvbG9yKTogdm9pZCB7XHJcblx0XHR0aGlzLmdsLmNsZWFyQ29sb3IoY29sb3IuciwgY29sb3IuZywgY29sb3IuYiwgY29sb3IuYSk7XHJcblx0XHR0aGlzLmdsLmNsZWFyKHRoaXMuZ2wuQ09MT1JfQlVGRkVSX0JJVCB8IHRoaXMuZ2wuREVQVEhfQlVGRkVSX0JJVCk7XHJcblxyXG5cdFx0dGhpcy50ZXh0Q3R4LmNsZWFyUmVjdCgwLCAwLCB0aGlzLndvcmxkU2l6ZS54LCB0aGlzLndvcmxkU2l6ZS55KTtcclxuXHR9XHJcblxyXG5cdHByb3RlY3RlZCByZW5kZXJOb2RlKG5vZGU6IENhbnZhc05vZGUpOiB2b2lkIHtcclxuXHRcdC8vIENhbGN1bGF0ZSB0aGUgb3JpZ2luIG9mIHRoZSB2aWV3cG9ydCBhY2NvcmRpbmcgdG8gdGhpcyBzcHJpdGVcclxuICAgICAgICB0aGlzLm9yaWdpbiA9IHRoaXMuc2NlbmUuZ2V0Vmlld1RyYW5zbGF0aW9uKG5vZGUpO1xyXG5cclxuICAgICAgICAvLyBHZXQgdGhlIHpvb20gbGV2ZWwgb2YgdGhlIHNjZW5lXHJcbiAgICAgICAgdGhpcy56b29tID0gdGhpcy5zY2VuZS5nZXRWaWV3U2NhbGUoKTtcclxuXHRcdFxyXG5cdFx0aWYobm9kZS5oYXNDdXN0b21TaGFkZXIpe1xyXG5cdFx0XHQvLyBJZiB0aGUgbm9kZSBoYXMgYSBjdXN0b20gc2hhZGVyLCByZW5kZXIgdXNpbmcgdGhhdFxyXG5cdFx0XHR0aGlzLnJlbmRlckN1c3RvbShub2RlKTtcclxuXHRcdH0gZWxzZSBpZihub2RlIGluc3RhbmNlb2YgR3JhcGhpYyl7XHJcblx0XHRcdHRoaXMucmVuZGVyR3JhcGhpYyhub2RlKTtcclxuXHRcdH0gZWxzZSBpZihub2RlIGluc3RhbmNlb2YgU3ByaXRlKXtcclxuXHRcdFx0aWYobm9kZSBpbnN0YW5jZW9mIEFuaW1hdGVkU3ByaXRlKXtcclxuXHRcdFx0XHR0aGlzLnJlbmRlckFuaW1hdGVkU3ByaXRlKG5vZGUpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHRoaXMucmVuZGVyU3ByaXRlKG5vZGUpO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2UgaWYobm9kZSBpbnN0YW5jZW9mIFVJRWxlbWVudCl7XHJcblx0XHRcdHRoaXMucmVuZGVyVUlFbGVtZW50KG5vZGUpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cHJvdGVjdGVkIHJlbmRlclNwcml0ZShzcHJpdGU6IFNwcml0ZSk6IHZvaWQge1xyXG5cdFx0bGV0IHNoYWRlciA9IFJlZ2lzdHJ5TWFuYWdlci5zaGFkZXJzLmdldChTaGFkZXJSZWdpc3RyeS5TUFJJVEVfU0hBREVSKTtcclxuXHRcdGxldCBvcHRpb25zID0gdGhpcy5hZGRPcHRpb25zKHNoYWRlci5nZXRPcHRpb25zKHNwcml0ZSksIHNwcml0ZSk7XHJcblx0XHRzaGFkZXIucmVuZGVyKHRoaXMuZ2wsIG9wdGlvbnMpO1xyXG5cdH1cclxuXHJcblx0cHJvdGVjdGVkIHJlbmRlckFuaW1hdGVkU3ByaXRlKHNwcml0ZTogQW5pbWF0ZWRTcHJpdGUpOiB2b2lkIHtcclxuXHRcdGxldCBzaGFkZXIgPSBSZWdpc3RyeU1hbmFnZXIuc2hhZGVycy5nZXQoU2hhZGVyUmVnaXN0cnkuU1BSSVRFX1NIQURFUik7XHJcblx0XHRsZXQgb3B0aW9ucyA9IHRoaXMuYWRkT3B0aW9ucyhzaGFkZXIuZ2V0T3B0aW9ucyhzcHJpdGUpLCBzcHJpdGUpO1xyXG5cdFx0c2hhZGVyLnJlbmRlcih0aGlzLmdsLCBvcHRpb25zKTtcclxuXHR9XHJcblxyXG5cdHByb3RlY3RlZCByZW5kZXJHcmFwaGljKGdyYXBoaWM6IEdyYXBoaWMpOiB2b2lkIHtcclxuXHJcblx0XHRpZihncmFwaGljIGluc3RhbmNlb2YgUG9pbnQpe1xyXG5cdFx0XHRsZXQgc2hhZGVyID0gUmVnaXN0cnlNYW5hZ2VyLnNoYWRlcnMuZ2V0KFNoYWRlclJlZ2lzdHJ5LlBPSU5UX1NIQURFUik7XHJcblx0XHRcdGxldCBvcHRpb25zID0gdGhpcy5hZGRPcHRpb25zKHNoYWRlci5nZXRPcHRpb25zKGdyYXBoaWMpLCBncmFwaGljKTtcclxuXHRcdFx0c2hhZGVyLnJlbmRlcih0aGlzLmdsLCBvcHRpb25zKTtcclxuXHRcdH0gZWxzZSBpZihncmFwaGljIGluc3RhbmNlb2YgUmVjdCkge1xyXG5cdFx0XHRsZXQgc2hhZGVyID0gUmVnaXN0cnlNYW5hZ2VyLnNoYWRlcnMuZ2V0KFNoYWRlclJlZ2lzdHJ5LlJFQ1RfU0hBREVSKTtcclxuXHRcdFx0bGV0IG9wdGlvbnMgPSB0aGlzLmFkZE9wdGlvbnMoc2hhZGVyLmdldE9wdGlvbnMoZ3JhcGhpYyksIGdyYXBoaWMpO1xyXG5cdFx0XHRzaGFkZXIucmVuZGVyKHRoaXMuZ2wsIG9wdGlvbnMpO1xyXG5cdFx0fSBcclxuXHR9XHJcblxyXG5cdHByb3RlY3RlZCByZW5kZXJUaWxlbWFwKHRpbGVtYXA6IFRpbGVtYXApOiB2b2lkIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcihcIk1ldGhvZCBub3QgaW1wbGVtZW50ZWQuXCIpO1xyXG5cdH1cclxuXHJcblx0cHJvdGVjdGVkIHJlbmRlclVJRWxlbWVudCh1aUVsZW1lbnQ6IFVJRWxlbWVudCk6IHZvaWQge1xyXG5cdFx0aWYodWlFbGVtZW50IGluc3RhbmNlb2YgTGFiZWwpe1xyXG5cdFx0XHRsZXQgc2hhZGVyID0gUmVnaXN0cnlNYW5hZ2VyLnNoYWRlcnMuZ2V0KFNoYWRlclJlZ2lzdHJ5LkxBQkVMX1NIQURFUik7XHJcblx0XHRcdGxldCBvcHRpb25zID0gdGhpcy5hZGRPcHRpb25zKHNoYWRlci5nZXRPcHRpb25zKHVpRWxlbWVudCksIHVpRWxlbWVudCk7XHJcblx0XHRcdHNoYWRlci5yZW5kZXIodGhpcy5nbCwgb3B0aW9ucyk7XHJcblxyXG5cdFx0XHR0aGlzLnRleHRDdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsICh1aUVsZW1lbnQucG9zaXRpb24ueCAtIHRoaXMub3JpZ2luLngpKnRoaXMuem9vbSwgKHVpRWxlbWVudC5wb3NpdGlvbi55IC0gdGhpcy5vcmlnaW4ueSkqdGhpcy56b29tKTtcclxuXHRcdFx0dGhpcy50ZXh0Q3R4LnJvdGF0ZSgtdWlFbGVtZW50LnJvdGF0aW9uKTtcclxuXHRcdFx0bGV0IGdsb2JhbEFscGhhID0gdGhpcy50ZXh0Q3R4Lmdsb2JhbEFscGhhO1xyXG5cdFx0XHR0aGlzLnRleHRDdHguZ2xvYmFsQWxwaGEgPSB1aUVsZW1lbnQuYWxwaGE7XHJcblxyXG5cdFx0XHQvLyBSZW5kZXIgdGV4dFxyXG5cdFx0XHR0aGlzLnRleHRDdHguZm9udCA9IHVpRWxlbWVudC5nZXRGb250U3RyaW5nKCk7XHJcblx0XHRcdGxldCBvZmZzZXQgPSB1aUVsZW1lbnQuY2FsY3VsYXRlVGV4dE9mZnNldCh0aGlzLnRleHRDdHgpO1xyXG5cdFx0XHR0aGlzLnRleHRDdHguZmlsbFN0eWxlID0gdWlFbGVtZW50LmNhbGN1bGF0ZVRleHRDb2xvcigpO1xyXG5cdFx0XHR0aGlzLnRleHRDdHguZ2xvYmFsQWxwaGEgPSB1aUVsZW1lbnQudGV4dENvbG9yLmE7XHJcblx0XHRcdHRoaXMudGV4dEN0eC5maWxsVGV4dCh1aUVsZW1lbnQudGV4dCwgb2Zmc2V0LnggLSB1aUVsZW1lbnQuc2l6ZS54LzIsIG9mZnNldC55IC0gdWlFbGVtZW50LnNpemUueS8yKTtcclxuXHJcblx0XHRcdHRoaXMudGV4dEN0eC5nbG9iYWxBbHBoYSA9IGdsb2JhbEFscGhhO1xyXG4gICAgICAgIFx0dGhpcy50ZXh0Q3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHByb3RlY3RlZCByZW5kZXJDdXN0b20obm9kZTogQ2FudmFzTm9kZSk6IHZvaWQge1xyXG5cdFx0bGV0IHNoYWRlciA9IFJlZ2lzdHJ5TWFuYWdlci5zaGFkZXJzLmdldChub2RlLmN1c3RvbVNoYWRlcktleSk7XHJcblx0XHRsZXQgb3B0aW9ucyA9IHRoaXMuYWRkT3B0aW9ucyhzaGFkZXIuZ2V0T3B0aW9ucyhub2RlKSwgbm9kZSk7XHJcblx0XHRzaGFkZXIucmVuZGVyKHRoaXMuZ2wsIG9wdGlvbnMpO1xyXG5cdH1cclxuXHJcblx0cHJvdGVjdGVkIGFkZE9wdGlvbnMob3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55Piwgbm9kZTogQ2FudmFzTm9kZSk6IFJlY29yZDxzdHJpbmcsIGFueT4ge1xyXG5cdFx0Ly8gR2l2ZSB0aGUgc2hhZGVyIGFjY2VzcyB0byB0aGUgd29ybGQgc2l6ZVxyXG5cdFx0b3B0aW9ucy53b3JsZFNpemUgPSB0aGlzLndvcmxkU2l6ZTtcclxuXHJcblx0XHQvLyBBZGp1c3QgdGhlIG9yaWdpbiBwb3NpdGlvbiB0byB0aGUgcGFyYWxsYXhcclxuXHRcdGxldCBsYXllciA9IG5vZGUuZ2V0TGF5ZXIoKTtcclxuXHRcdGxldCBwYXJhbGxheCA9IG5ldyBWZWMyKDEsIDEpO1xyXG5cdFx0aWYobGF5ZXIgaW5zdGFuY2VvZiBQYXJhbGxheExheWVyKXtcclxuXHRcdFx0cGFyYWxsYXggPSAoPFBhcmFsbGF4TGF5ZXI+bGF5ZXIpLnBhcmFsbGF4O1xyXG5cdFx0fVxyXG5cclxuXHRcdG9wdGlvbnMub3JpZ2luID0gdGhpcy5vcmlnaW4uY2xvbmUoKS5tdWx0KHBhcmFsbGF4KTtcclxuXHJcblx0XHRyZXR1cm4gb3B0aW9ucztcclxuXHR9XHJcblxyXG59IiwiaW1wb3J0IE1hcCBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL01hcFwiO1xyXG5pbXBvcnQgQ2FudmFzTm9kZSBmcm9tIFwiLi4vLi4vTm9kZXMvQ2FudmFzTm9kZVwiO1xyXG5pbXBvcnQgUmVzb3VyY2VNYW5hZ2VyIGZyb20gXCIuLi8uLi9SZXNvdXJjZU1hbmFnZXIvUmVzb3VyY2VNYW5hZ2VyXCI7XHJcblxyXG4vKipcclxuICogQSB3cmFwcGVyIGNsYXNzIGZvciBXZWJHTCBzaGFkZXJzLlxyXG4gKiBUaGlzIGNsYXNzIGlzIGEgc2luZ2xldG9uLCBhbmQgdGhlcmUgaXMgb25seSBvbmUgZm9yIGVhY2ggc2hhZGVyIHR5cGUuXHJcbiAqIEFsbCBvYmplY3RzIHRoYXQgdXNlIHRoaXMgc2hhZGVyIHR5cGUgd2lsbCByZWZlciB0byBhbmQgbW9kaWZ5IHRoaXMgc2FtZSB0eXBlLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgYWJzdHJhY3QgY2xhc3MgU2hhZGVyVHlwZSB7XHJcblx0LyoqIFRoZSBuYW1lIG9mIHRoaXMgc2hhZGVyICovXHJcblx0cHJvdGVjdGVkIG5hbWU6IHN0cmluZztcclxuXHJcblx0LyoqIFRoZSBrZXkgdG8gdGhlIFdlYkdMUHJvZ3JhbSBpbiB0aGUgUmVzb3VyY2VNYW5hZ2VyICovXHJcblx0cHJvdGVjdGVkIHByb2dyYW1LZXk6IHN0cmluZztcclxuXHJcblx0LyoqIEEgcmVmZXJlbmNlIHRvIHRoZSByZXNvdXJjZSBtYW5hZ2VyICovXHJcblx0cHJvdGVjdGVkIHJlc291cmNlTWFuYWdlcjogUmVzb3VyY2VNYW5hZ2VyO1xyXG5cclxuXHRjb25zdHJ1Y3Rvcihwcm9ncmFtS2V5OiBzdHJpbmcpe1xyXG5cdFx0dGhpcy5wcm9ncmFtS2V5ID0gcHJvZ3JhbUtleTtcclxuXHRcdHRoaXMucmVzb3VyY2VNYW5hZ2VyID0gUmVzb3VyY2VNYW5hZ2VyLmdldEluc3RhbmNlKCk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBJbml0aWFsaXplcyBhbnkgYnVmZmVyIG9iamVjdHMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgc2hhZGVyIHR5cGUuXHJcblx0ICogQHBhcmFtIGdsIFRoZSBXZWJHTCByZW5kZXJpbmcgY29udGV4dFxyXG5cdCAqL1xyXG5cdGFic3RyYWN0IGluaXRCdWZmZXJPYmplY3QoKTogdm9pZDtcclxuXHJcblx0LyoqXHJcblx0ICogTG9hZHMgYW55IHVuaWZvcm1zXHJcblx0ICogQHBhcmFtIGdsIFRoZSBXZWJHTCByZW5kZXJpbmcgY29udGV4dFxyXG5cdCAqIEBwYXJhbSBvcHRpb25zIEluZm9ybWF0aW9uIGFib3V0IHRoZSBvYmplY3Qgd2UncmUgY3VycmVudGx5IHJlbmRlcmluZ1xyXG5cdCAqL1xyXG5cdGFic3RyYWN0IHJlbmRlcihnbDogV2ViR0xSZW5kZXJpbmdDb250ZXh0LCBvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogdm9pZDtcclxuXHJcblx0LyoqXHJcblx0ICogRXh0cmFjdHMgdGhlIG9wdGlvbnMgZnJvbSB0aGUgQ2FudmFzTm9kZSBhbmQgZ2l2ZXMgdGhlbSB0byB0aGUgcmVuZGVyIGZ1bmN0aW9uXHJcblx0ICogQHBhcmFtIG5vZGUgVGhlIG5vZGUgdG8gZ2V0IG9wdGlvbnMgZnJvbVxyXG5cdCAqIEByZXR1cm5zIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBvcHRpb25zIHRoYXQgc2hvdWxkIGJlIHBhc3NlZCB0byB0aGUgcmVuZGVyIGZ1bmN0aW9uXHJcblx0ICovXHJcblx0Z2V0T3B0aW9ucyhub2RlOiBDYW52YXNOb2RlKTogUmVjb3JkPHN0cmluZywgYW55PiB7cmV0dXJuIHt9O31cclxufSIsImltcG9ydCBNYXQ0eDQgZnJvbSBcIi4uLy4uLy4uL0RhdGFUeXBlcy9NYXQ0eDRcIjtcclxuaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uLy4uL0RhdGFUeXBlcy9WZWMyXCI7XHJcbmltcG9ydCBEZWJ1ZyBmcm9tIFwiLi4vLi4vLi4vRGVidWcvRGVidWdcIjtcclxuaW1wb3J0IFJlY3QgZnJvbSBcIi4uLy4uLy4uL05vZGVzL0dyYXBoaWNzL1JlY3RcIjtcclxuaW1wb3J0IExhYmVsIGZyb20gXCIuLi8uLi8uLi9Ob2Rlcy9VSUVsZW1lbnRzL0xhYmVsXCI7XHJcbmltcG9ydCBSZXNvdXJjZU1hbmFnZXIgZnJvbSBcIi4uLy4uLy4uL1Jlc291cmNlTWFuYWdlci9SZXNvdXJjZU1hbmFnZXJcIjtcclxuaW1wb3J0IFF1YWRTaGFkZXJUeXBlIGZyb20gXCIuL1F1YWRTaGFkZXJUeXBlXCI7XHJcblxyXG4vKiogKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGFiZWxTaGFkZXJUeXBlIGV4dGVuZHMgUXVhZFNoYWRlclR5cGUge1xyXG5cclxuXHRjb25zdHJ1Y3Rvcihwcm9ncmFtS2V5OiBzdHJpbmcpe1xyXG5cdFx0c3VwZXIocHJvZ3JhbUtleSk7XHJcblx0XHR0aGlzLnJlc291cmNlTWFuYWdlciA9IFJlc291cmNlTWFuYWdlci5nZXRJbnN0YW5jZSgpO1xyXG5cdH1cclxuXHJcblx0aW5pdEJ1ZmZlck9iamVjdCgpOiB2b2lkIHtcclxuXHRcdHRoaXMuYnVmZmVyT2JqZWN0S2V5ID0gXCJsYWJlbFwiO1xyXG5cdFx0dGhpcy5yZXNvdXJjZU1hbmFnZXIuY3JlYXRlQnVmZmVyKHRoaXMuYnVmZmVyT2JqZWN0S2V5KTtcclxuXHR9XHJcblxyXG5cdHJlbmRlcihnbDogV2ViR0xSZW5kZXJpbmdDb250ZXh0LCBvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogdm9pZCB7XHJcblx0XHRjb25zdCBiYWNrZ3JvdW5kQ29sb3IgPSBvcHRpb25zLmJhY2tncm91bmRDb2xvci50b1dlYkdMKCk7XHJcblx0XHRjb25zdCBib3JkZXJDb2xvciA9IG9wdGlvbnMuYm9yZGVyQ29sb3IudG9XZWJHTCgpO1xyXG5cclxuXHRcdGNvbnN0IHByb2dyYW0gPSB0aGlzLnJlc291cmNlTWFuYWdlci5nZXRTaGFkZXJQcm9ncmFtKHRoaXMucHJvZ3JhbUtleSk7XHJcblx0XHRjb25zdCBidWZmZXIgPSB0aGlzLnJlc291cmNlTWFuYWdlci5nZXRCdWZmZXIodGhpcy5idWZmZXJPYmplY3RLZXkpO1xyXG5cclxuXHRcdGdsLnVzZVByb2dyYW0ocHJvZ3JhbSk7XHJcblxyXG5cdFx0Y29uc3QgdmVydGV4RGF0YSA9IHRoaXMuZ2V0VmVydGljZXMob3B0aW9ucy5zaXplLngsIG9wdGlvbnMuc2l6ZS55KTtcclxuXHJcblx0XHRjb25zdCBGU0laRSA9IHZlcnRleERhdGEuQllURVNfUEVSX0VMRU1FTlQ7XHJcblxyXG5cdFx0Ly8gQmluZCB0aGUgYnVmZmVyXHJcblx0XHRnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYnVmZmVyKTtcclxuXHRcdGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCB2ZXJ0ZXhEYXRhLCBnbC5TVEFUSUNfRFJBVyk7XHJcblxyXG5cdFx0Ly8gQXR0cmlidXRlc1xyXG5cdFx0Y29uc3QgYV9Qb3NpdGlvbiA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sIFwiYV9Qb3NpdGlvblwiKTtcclxuXHRcdGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoYV9Qb3NpdGlvbiwgMiwgZ2wuRkxPQVQsIGZhbHNlLCAyICogRlNJWkUsIDAgKiBGU0laRSk7XHJcblx0XHRnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShhX1Bvc2l0aW9uKTtcclxuXHJcblx0XHQvLyBVbmlmb3Jtc1xyXG5cdFx0Y29uc3QgdV9CYWNrZ3JvdW5kQ29sb3IgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgXCJ1X0JhY2tncm91bmRDb2xvclwiKTtcclxuXHRcdGdsLnVuaWZvcm00ZnYodV9CYWNrZ3JvdW5kQ29sb3IsIGJhY2tncm91bmRDb2xvcik7XHJcblxyXG4gICAgICAgIGNvbnN0IHVfQm9yZGVyQ29sb3IgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgXCJ1X0JvcmRlckNvbG9yXCIpO1xyXG5cdFx0Z2wudW5pZm9ybTRmdih1X0JvcmRlckNvbG9yLCBib3JkZXJDb2xvcik7XHJcblxyXG4gICAgICAgIGNvbnN0IHVfTWF4U2l6ZSA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCBcInVfTWF4U2l6ZVwiKTtcclxuICAgICAgICBnbC51bmlmb3JtMmYodV9NYXhTaXplLCAtdmVydGV4RGF0YVswXSwgdmVydGV4RGF0YVsxXSk7XHJcblxyXG5cdFx0Ly8gR2V0IHRyYW5zZm9ybWF0aW9uIG1hdHJpeFxyXG5cdFx0Ly8gV2Ugd2FudCBhIHNxdWFyZSBmb3Igb3VyIHJlbmRlcmluZyBzcGFjZSwgc28gZ2V0IHRoZSBtYXhpbXVtIGRpbWVuc2lvbiBvZiBvdXIgcXVhZFxyXG5cdFx0bGV0IG1heERpbWVuc2lvbiA9IE1hdGgubWF4KG9wdGlvbnMuc2l6ZS54LCBvcHRpb25zLnNpemUueSk7XHJcblxyXG4gICAgICAgIGNvbnN0IHVfQm9yZGVyV2lkdGggPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgXCJ1X0JvcmRlcldpZHRoXCIpO1xyXG5cdFx0Z2wudW5pZm9ybTFmKHVfQm9yZGVyV2lkdGgsIG9wdGlvbnMuYm9yZGVyV2lkdGgvbWF4RGltZW5zaW9uKTtcclxuXHJcbiAgICAgICAgY29uc3QgdV9Cb3JkZXJSYWRpdXMgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgXCJ1X0JvcmRlclJhZGl1c1wiKTtcclxuXHRcdGdsLnVuaWZvcm0xZih1X0JvcmRlclJhZGl1cywgb3B0aW9ucy5ib3JkZXJSYWRpdXMvbWF4RGltZW5zaW9uKTtcclxuXHJcblx0XHQvLyBUaGUgc2l6ZSBvZiB0aGUgcmVuZGVyaW5nIHNwYWNlIHdpbGwgYmUgYSBzcXVhcmUgd2l0aCB0aGlzIG1heGltdW0gZGltZW5zaW9uXHJcblx0XHRsZXQgc2l6ZSA9IG5ldyBWZWMyKG1heERpbWVuc2lvbiwgbWF4RGltZW5zaW9uKS5zY2FsZSgyL29wdGlvbnMud29ybGRTaXplLngsIDIvb3B0aW9ucy53b3JsZFNpemUueSk7XHJcblxyXG5cdFx0Ly8gQ2VudGVyIG91ciB0cmFuc2xhdGlvbnMgYXJvdW5kICgwLCAwKVxyXG5cdFx0Y29uc3QgdHJhbnNsYXRlWCA9IChvcHRpb25zLnBvc2l0aW9uLnggLSBvcHRpb25zLm9yaWdpbi54IC0gb3B0aW9ucy53b3JsZFNpemUueC8yKS9tYXhEaW1lbnNpb247XHJcblx0XHRjb25zdCB0cmFuc2xhdGVZID0gLShvcHRpb25zLnBvc2l0aW9uLnkgLSBvcHRpb25zLm9yaWdpbi55IC0gb3B0aW9ucy53b3JsZFNpemUueS8yKS9tYXhEaW1lbnNpb247XHJcblxyXG5cdFx0Ly8gQ3JlYXRlIG91ciB0cmFuc2Zvcm1hdGlvbiBtYXRyaXhcclxuXHRcdHRoaXMudHJhbnNsYXRpb24udHJhbnNsYXRlKG5ldyBGbG9hdDMyQXJyYXkoW3RyYW5zbGF0ZVgsIHRyYW5zbGF0ZVldKSk7XHJcblx0XHR0aGlzLnNjYWxlLnNjYWxlKHNpemUpO1xyXG5cdFx0dGhpcy5yb3RhdGlvbi5yb3RhdGUob3B0aW9ucy5yb3RhdGlvbik7XHJcblx0XHRsZXQgdHJhbnNmb3JtYXRpb24gPSBNYXQ0eDQuTVVMVCh0aGlzLnRyYW5zbGF0aW9uLCB0aGlzLnNjYWxlLCB0aGlzLnJvdGF0aW9uKTtcclxuXHJcblx0XHQvLyBQYXNzIHRoZSB0cmFuc2xhdGlvbiBtYXRyaXggdG8gb3VyIHNoYWRlclxyXG5cdFx0Y29uc3QgdV9UcmFuc2Zvcm0gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgXCJ1X1RyYW5zZm9ybVwiKTtcclxuXHRcdGdsLnVuaWZvcm1NYXRyaXg0ZnYodV9UcmFuc2Zvcm0sIGZhbHNlLCB0cmFuc2Zvcm1hdGlvbi50b0FycmF5KCkpO1xyXG5cclxuXHRcdC8vIERyYXcgdGhlIHF1YWRcclxuXHRcdGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVfU1RSSVAsIDAsIDQpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogVGhlIHJlbmRlcmluZyBzcGFjZSBhbHdheXMgaGFzIHRvIGJlIGEgc3F1YXJlLCBzbyBtYWtlIHN1cmUgaXRzIHNxdWFyZSB3LnIudCB0byB0aGUgbGFyZ2VzdCBkaW1lbnNpb25cclxuXHQgKiBAcGFyYW0gdyBUaGUgd2lkdGggb2YgdGhlIHF1YWQgaW4gcGl4ZWxzXHJcblx0ICogQHBhcmFtIGggVGhlIGhlaWdodCBvZiB0aGUgcXVhZCBpbiBwaXhlbHNcclxuXHQgKiBAcmV0dXJucyBBbiBhcnJheSBvZiB0aGUgdmVydGljZXMgb2YgdGhlIHF1YWRcclxuXHQgKi9cclxuXHRnZXRWZXJ0aWNlcyh3OiBudW1iZXIsIGg6IG51bWJlcik6IEZsb2F0MzJBcnJheSB7XHJcblx0XHRsZXQgeCwgeTtcclxuXHJcblx0XHRpZihoID4gdyl7XHJcblx0XHRcdHkgPSAwLjU7XHJcblx0XHRcdHggPSB3LygyKmgpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0eCA9IDAuNTtcclxuXHRcdFx0eSA9IGgvKDIqdyk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoW1xyXG5cdFx0XHQteCwgIHksXHJcblx0XHRcdC14LCAteSxcclxuXHRcdFx0IHgsICB5LFxyXG5cdFx0XHQgeCwgLXlcclxuXHRcdF0pO1xyXG5cdH1cclxuXHJcblx0Z2V0T3B0aW9ucyhyZWN0OiBMYWJlbCk6IFJlY29yZDxzdHJpbmcsIGFueT4ge1xyXG5cdFx0bGV0IG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT4gPSB7XHJcblx0XHRcdHBvc2l0aW9uOiByZWN0LnBvc2l0aW9uLFxyXG5cdFx0XHRiYWNrZ3JvdW5kQ29sb3I6IHJlY3QuY2FsY3VsYXRlQmFja2dyb3VuZENvbG9yKCksXHJcbiAgICAgICAgICAgIGJvcmRlckNvbG9yOiByZWN0LmNhbGN1bGF0ZUJvcmRlckNvbG9yKCksXHJcbiAgICAgICAgICAgIGJvcmRlcldpZHRoOiByZWN0LmJvcmRlcldpZHRoLFxyXG4gICAgICAgICAgICBib3JkZXJSYWRpdXM6IHJlY3QuYm9yZGVyUmFkaXVzLFxyXG5cdFx0XHRzaXplOiByZWN0LnNpemUsXHJcblx0XHRcdHJvdGF0aW9uOiByZWN0LnJvdGF0aW9uXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG9wdGlvbnM7XHJcblx0fVxyXG59IiwiaW1wb3J0IERlYnVnIGZyb20gXCIuLi8uLi8uLi9EZWJ1Zy9EZWJ1Z1wiO1xyXG5pbXBvcnQgUG9pbnQgZnJvbSBcIi4uLy4uLy4uL05vZGVzL0dyYXBoaWNzL1BvaW50XCI7XHJcbmltcG9ydCBSZXNvdXJjZU1hbmFnZXIgZnJvbSBcIi4uLy4uLy4uL1Jlc291cmNlTWFuYWdlci9SZXNvdXJjZU1hbmFnZXJcIjtcclxuaW1wb3J0IFJlbmRlcmluZ1V0aWxzIGZyb20gXCIuLi8uLi8uLi9VdGlscy9SZW5kZXJpbmdVdGlsc1wiO1xyXG5pbXBvcnQgU2hhZGVyVHlwZSBmcm9tIFwiLi4vU2hhZGVyVHlwZVwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUG9pbnRTaGFkZXJUeXBlIGV4dGVuZHMgU2hhZGVyVHlwZSB7XHJcblxyXG5cdHByb3RlY3RlZCBidWZmZXJPYmplY3RLZXk6IHN0cmluZztcclxuXHJcblx0Y29uc3RydWN0b3IocHJvZ3JhbUtleTogc3RyaW5nKXtcclxuXHRcdHN1cGVyKHByb2dyYW1LZXkpO1xyXG5cdH1cclxuXHJcblx0aW5pdEJ1ZmZlck9iamVjdCgpOiB2b2lkIHtcclxuXHRcdHRoaXMuYnVmZmVyT2JqZWN0S2V5ID0gXCJwb2ludFwiO1xyXG5cdFx0dGhpcy5yZXNvdXJjZU1hbmFnZXIuY3JlYXRlQnVmZmVyKHRoaXMuYnVmZmVyT2JqZWN0S2V5KTtcclxuXHR9XHJcblxyXG5cdHJlbmRlcihnbDogV2ViR0xSZW5kZXJpbmdDb250ZXh0LCBvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogdm9pZCB7XHJcblx0XHRsZXQgcG9zaXRpb24gPSBSZW5kZXJpbmdVdGlscy50b1dlYkdMQ29vcmRzKG9wdGlvbnMucG9zaXRpb24sIG9wdGlvbnMub3JpZ2luLCBvcHRpb25zLndvcmxkU2l6ZSk7XHJcblx0XHRsZXQgY29sb3IgPSBSZW5kZXJpbmdVdGlscy50b1dlYkdMQ29sb3Iob3B0aW9ucy5jb2xvcik7XHJcblxyXG5cdFx0Y29uc3QgcHJvZ3JhbSA9IHRoaXMucmVzb3VyY2VNYW5hZ2VyLmdldFNoYWRlclByb2dyYW0odGhpcy5wcm9ncmFtS2V5KTtcclxuXHRcdGNvbnN0IGJ1ZmZlciA9IHRoaXMucmVzb3VyY2VNYW5hZ2VyLmdldEJ1ZmZlcih0aGlzLmJ1ZmZlck9iamVjdEtleSk7XHJcblxyXG5cdFx0Z2wudXNlUHJvZ3JhbShwcm9ncmFtKTtcclxuXHJcblx0XHRjb25zdCB2ZXJ0ZXhEYXRhID0gcG9zaXRpb247XHJcblxyXG5cdFx0Y29uc3QgRlNJWkUgPSB2ZXJ0ZXhEYXRhLkJZVEVTX1BFUl9FTEVNRU5UO1xyXG5cclxuXHRcdC8vIEJpbmQgdGhlIGJ1ZmZlclxyXG5cdFx0Z2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcik7XHJcblx0XHRnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgdmVydGV4RGF0YSwgZ2wuU1RBVElDX0RSQVcpO1xyXG5cclxuXHRcdC8vIEF0dHJpYnV0ZXNcclxuXHRcdGNvbnN0IGFfUG9zaXRpb24gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCBcImFfUG9zaXRpb25cIik7XHJcblx0XHRnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGFfUG9zaXRpb24sIDIsIGdsLkZMT0FULCBmYWxzZSwgMiAqIEZTSVpFLCAwICogRlNJWkUpO1xyXG5cdFx0Z2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoYV9Qb3NpdGlvbik7XHJcblxyXG5cdFx0Ly8gVW5pZm9ybXNcclxuXHRcdGNvbnN0IHVfQ29sb3IgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgXCJ1X0NvbG9yXCIpO1xyXG5cdFx0Z2wudW5pZm9ybTRmdih1X0NvbG9yLCBjb2xvcik7XHJcblxyXG5cdFx0Y29uc3QgdV9Qb2ludFNpemUgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgXCJ1X1BvaW50U2l6ZVwiKTtcclxuXHRcdGdsLnVuaWZvcm0xZih1X1BvaW50U2l6ZSwgb3B0aW9ucy5wb2ludFNpemUpO1xyXG5cclxuXHRcdGdsLmRyYXdBcnJheXMoZ2wuUE9JTlRTLCAwLCAxKTtcclxuXHR9XHJcblxyXG5cdGdldE9wdGlvbnMocG9pbnQ6IFBvaW50KTogUmVjb3JkPHN0cmluZywgYW55PiB7XHJcblx0XHRsZXQgb3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55PiA9IHtcclxuXHRcdFx0cG9zaXRpb246IHBvaW50LnBvc2l0aW9uLFxyXG5cdFx0XHRjb2xvcjogcG9pbnQuY29sb3IsXHJcblx0XHRcdHBvaW50U2l6ZTogcG9pbnQuc2l6ZSxcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gb3B0aW9ucztcclxuXHR9XHJcbn0iLCJpbXBvcnQgTWF0NHg0IGZyb20gXCIuLi8uLi8uLi9EYXRhVHlwZXMvTWF0NHg0XCI7XHJcbmltcG9ydCBTaGFkZXJUeXBlIGZyb20gXCIuLi9TaGFkZXJUeXBlXCI7XHJcblxyXG4vKiogUmVwcmVzZW50cyBhbnkgV2ViR0wgb2JqZWN0cyB0aGF0IGhhdmUgYSBxdWFkIG1lc2ggKGkuZS4gYSByZWN0YW5ndWxhciBnYW1lIG9iamVjdCBjb21wb3NlZCBvZiBvbmx5IHR3byB0cmlhbmdsZXMpICovXHJcbmV4cG9ydCBkZWZhdWx0IGFic3RyYWN0IGNsYXNzIFF1YWRTaGFkZXJUeXBlIGV4dGVuZHMgU2hhZGVyVHlwZSB7XHJcblx0LyoqIFRoZSBrZXkgdG8gdGhlIGJ1ZmZlciBvYmplY3QgZm9yIHRoaXMgc2hhZGVyICovXHJcblx0cHJvdGVjdGVkIGJ1ZmZlck9iamVjdEtleTogc3RyaW5nO1xyXG5cclxuXHQvKiogVGhlIHNjYWxlIG1hdHJpYyAqL1xyXG5cdHByb3RlY3RlZCBzY2FsZTogTWF0NHg0O1xyXG5cclxuXHQvKiogVGhlIHJvdGF0aW9uIG1hdHJpeCAqL1xyXG5cdHByb3RlY3RlZCByb3RhdGlvbjogTWF0NHg0O1xyXG5cclxuXHQvKiogVGhlIHRyYW5zbGF0aW9uIG1hdHJpeCAqL1xyXG5cdHByb3RlY3RlZCB0cmFuc2xhdGlvbjogTWF0NHg0O1xyXG5cclxuXHRjb25zdHJ1Y3Rvcihwcm9ncmFtS2V5OiBzdHJpbmcpe1xyXG5cdFx0c3VwZXIocHJvZ3JhbUtleSk7XHJcblxyXG5cdFx0dGhpcy5zY2FsZSA9IE1hdDR4NC5JREVOVElUWTtcclxuXHRcdHRoaXMucm90YXRpb24gPSBNYXQ0eDQuSURFTlRJVFk7XHJcblx0XHR0aGlzLnRyYW5zbGF0aW9uID0gTWF0NHg0LklERU5USVRZO1xyXG5cdH1cclxufSIsImltcG9ydCBNYXQ0eDQgZnJvbSBcIi4uLy4uLy4uL0RhdGFUeXBlcy9NYXQ0eDRcIjtcclxuaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uLy4uL0RhdGFUeXBlcy9WZWMyXCI7XHJcbmltcG9ydCBSZWN0IGZyb20gXCIuLi8uLi8uLi9Ob2Rlcy9HcmFwaGljcy9SZWN0XCI7XHJcbmltcG9ydCBSZXNvdXJjZU1hbmFnZXIgZnJvbSBcIi4uLy4uLy4uL1Jlc291cmNlTWFuYWdlci9SZXNvdXJjZU1hbmFnZXJcIjtcclxuaW1wb3J0IFF1YWRTaGFkZXJUeXBlIGZyb20gXCIuL1F1YWRTaGFkZXJUeXBlXCI7XHJcblxyXG4vKiogKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVjdFNoYWRlclR5cGUgZXh0ZW5kcyBRdWFkU2hhZGVyVHlwZSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKHByb2dyYW1LZXk6IHN0cmluZyl7XHJcblx0XHRzdXBlcihwcm9ncmFtS2V5KTtcclxuXHRcdHRoaXMucmVzb3VyY2VNYW5hZ2VyID0gUmVzb3VyY2VNYW5hZ2VyLmdldEluc3RhbmNlKCk7XHJcblx0fVxyXG5cclxuXHRpbml0QnVmZmVyT2JqZWN0KCk6IHZvaWQge1xyXG5cdFx0dGhpcy5idWZmZXJPYmplY3RLZXkgPSBcInJlY3RcIjtcclxuXHRcdHRoaXMucmVzb3VyY2VNYW5hZ2VyLmNyZWF0ZUJ1ZmZlcih0aGlzLmJ1ZmZlck9iamVjdEtleSk7XHJcblx0fVxyXG5cclxuXHRyZW5kZXIoZ2w6IFdlYkdMUmVuZGVyaW5nQ29udGV4dCwgb3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55Pik6IHZvaWQge1xyXG5cdFx0Y29uc3QgY29sb3IgPSBvcHRpb25zLmNvbG9yLnRvV2ViR0woKTtcclxuXHJcblx0XHRjb25zdCBwcm9ncmFtID0gdGhpcy5yZXNvdXJjZU1hbmFnZXIuZ2V0U2hhZGVyUHJvZ3JhbSh0aGlzLnByb2dyYW1LZXkpO1xyXG5cdFx0Y29uc3QgYnVmZmVyID0gdGhpcy5yZXNvdXJjZU1hbmFnZXIuZ2V0QnVmZmVyKHRoaXMuYnVmZmVyT2JqZWN0S2V5KTtcclxuXHJcblx0XHRnbC51c2VQcm9ncmFtKHByb2dyYW0pO1xyXG5cclxuXHRcdGNvbnN0IHZlcnRleERhdGEgPSB0aGlzLmdldFZlcnRpY2VzKG9wdGlvbnMuc2l6ZS54LCBvcHRpb25zLnNpemUueSk7XHJcblxyXG5cdFx0Y29uc3QgRlNJWkUgPSB2ZXJ0ZXhEYXRhLkJZVEVTX1BFUl9FTEVNRU5UO1xyXG5cclxuXHRcdC8vIEJpbmQgdGhlIGJ1ZmZlclxyXG5cdFx0Z2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcik7XHJcblx0XHRnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgdmVydGV4RGF0YSwgZ2wuU1RBVElDX0RSQVcpO1xyXG5cclxuXHRcdC8vIEF0dHJpYnV0ZXNcclxuXHRcdGNvbnN0IGFfUG9zaXRpb24gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCBcImFfUG9zaXRpb25cIik7XHJcblx0XHRnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGFfUG9zaXRpb24sIDIsIGdsLkZMT0FULCBmYWxzZSwgMiAqIEZTSVpFLCAwICogRlNJWkUpO1xyXG5cdFx0Z2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoYV9Qb3NpdGlvbik7XHJcblxyXG5cdFx0Ly8gVW5pZm9ybXNcclxuXHRcdGNvbnN0IHVfQ29sb3IgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgXCJ1X0NvbG9yXCIpO1xyXG5cdFx0Z2wudW5pZm9ybTRmdih1X0NvbG9yLCBjb2xvcik7XHJcblxyXG5cdFx0Ly8gR2V0IHRyYW5zZm9ybWF0aW9uIG1hdHJpeFxyXG5cdFx0Ly8gV2Ugd2FudCBhIHNxdWFyZSBmb3Igb3VyIHJlbmRlcmluZyBzcGFjZSwgc28gZ2V0IHRoZSBtYXhpbXVtIGRpbWVuc2lvbiBvZiBvdXIgcXVhZFxyXG5cdFx0bGV0IG1heERpbWVuc2lvbiA9IE1hdGgubWF4KG9wdGlvbnMuc2l6ZS54LCBvcHRpb25zLnNpemUueSk7XHJcblxyXG5cdFx0Ly8gVGhlIHNpemUgb2YgdGhlIHJlbmRlcmluZyBzcGFjZSB3aWxsIGJlIGEgc3F1YXJlIHdpdGggdGhpcyBtYXhpbXVtIGRpbWVuc2lvblxyXG5cdFx0bGV0IHNpemUgPSBuZXcgVmVjMihtYXhEaW1lbnNpb24sIG1heERpbWVuc2lvbikuc2NhbGUoMi9vcHRpb25zLndvcmxkU2l6ZS54LCAyL29wdGlvbnMud29ybGRTaXplLnkpO1xyXG5cclxuXHRcdC8vIENlbnRlciBvdXIgdHJhbnNsYXRpb25zIGFyb3VuZCAoMCwgMClcclxuXHRcdGNvbnN0IHRyYW5zbGF0ZVggPSAob3B0aW9ucy5wb3NpdGlvbi54IC0gb3B0aW9ucy5vcmlnaW4ueCAtIG9wdGlvbnMud29ybGRTaXplLngvMikvbWF4RGltZW5zaW9uO1xyXG5cdFx0Y29uc3QgdHJhbnNsYXRlWSA9IC0ob3B0aW9ucy5wb3NpdGlvbi55IC0gb3B0aW9ucy5vcmlnaW4ueSAtIG9wdGlvbnMud29ybGRTaXplLnkvMikvbWF4RGltZW5zaW9uO1xyXG5cclxuXHRcdC8vIENyZWF0ZSBvdXIgdHJhbnNmb3JtYXRpb24gbWF0cml4XHJcblx0XHR0aGlzLnRyYW5zbGF0aW9uLnRyYW5zbGF0ZShuZXcgRmxvYXQzMkFycmF5KFt0cmFuc2xhdGVYLCB0cmFuc2xhdGVZXSkpO1xyXG5cdFx0dGhpcy5zY2FsZS5zY2FsZShzaXplKTtcclxuXHRcdHRoaXMucm90YXRpb24ucm90YXRlKG9wdGlvbnMucm90YXRpb24pO1xyXG5cdFx0bGV0IHRyYW5zZm9ybWF0aW9uID0gTWF0NHg0Lk1VTFQodGhpcy50cmFuc2xhdGlvbiwgdGhpcy5zY2FsZSwgdGhpcy5yb3RhdGlvbik7XHJcblxyXG5cdFx0Ly8gUGFzcyB0aGUgdHJhbnNsYXRpb24gbWF0cml4IHRvIG91ciBzaGFkZXJcclxuXHRcdGNvbnN0IHVfVHJhbnNmb3JtID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIFwidV9UcmFuc2Zvcm1cIik7XHJcblx0XHRnbC51bmlmb3JtTWF0cml4NGZ2KHVfVHJhbnNmb3JtLCBmYWxzZSwgdHJhbnNmb3JtYXRpb24udG9BcnJheSgpKTtcclxuXHJcblx0XHQvLyBEcmF3IHRoZSBxdWFkXHJcblx0XHRnbC5kcmF3QXJyYXlzKGdsLlRSSUFOR0xFX1NUUklQLCAwLCA0KTtcclxuXHR9XHJcblxyXG5cclxuXHQvKlxyXG5cdFx0U28gYXMgaXQgdHVybnMgb3V0LCBXZWJHTCBoYXMgYW4gaXNzdWUgd2l0aCBub24tc3F1YXJlIHF1YWRzLlxyXG5cdFx0SXQgZG9lc24ndCBsaWtlIHdoZW4geW91IGRvbid0IGhhdmUgYSAxLTEgc2NhbGUsIGFuZCByb3RhdGlvbnMgYXJlIGVudGlyZWx5IG1lc3NlZCB1cCBpZiB0aGlzIGlzIG5vdCB0aGUgY2FzZS5cclxuXHRcdFRvIHNvbHZlIHRoaXMsIEkgdXNlZCB0aGUgc2NhbGUgb2YgdGhlIExBUkdFU1QgZGltZW5zaW9uIG9mIHRoZSBxdWFkIHRvIG1ha2UgYSBzcXVhcmUsIHRoZW4gYWRqdXN0ZWQgdGhlIHZlcnRleCBjb29yZGluYXRlcyBpbnNpZGUgb2YgdGhhdC5cclxuXHRcdEEgZGlhZ3JhbSBvZiB0aGUgc29sdXRpb24gZm9sbG93cy5cclxuXHJcblx0XHRUaGVyZSBpcyBhIGJvdW5kaW5nIHNxdWFyZSBmb3IgdGhlIHF1YWQgd2l0aCBkaW1lbnNpb25zIGh4aCAoaW4gdGhpcyBjYXNlLCBzaW5jZSBoZWlnaHQgaXMgdGhlIGxhcmdlc3QgZGltZW5zaW9uKS5cclxuXHRcdFRoZSBvZmZzZXQgaW4gdGhlIHZlcnRpY2FsIGRpcmVjdGlvbiBpcyB0aGVyZWZvcmUgMC41LCBhcyBpdCBpcyBub3JtYWxseS5cclxuXHRcdEhvd2V2ZXIsIHRoZSBvZmZzZXQgaW4gdGhlIGhvcml6b250YWwgZGlyZWN0aW9uIGlzIG5vdCBzbyBzdHJhaWdodGZvcndhcmQsIGJ1dCBpc24ndCBjb25jZXB0dWFsbHkgaGFyZC5cclxuXHRcdEFsbCB3ZSByZWFsbHkgaGF2ZSB0byBkbyBpcyBhIHJhbmdlIGNoYW5nZSBmcm9tIFswLCBoZWlnaHQvMl0gdG8gWzAsIDAuNV0sIHdoZXJlIG91ciB2YWx1ZSBpcyB0ID0gd2lkdGgvMiwgYW5kIDAgPD0gdCA8PSBoZWlnaHQvMi5cclxuXHJcblx0XHRTbyBub3cgd2UgaGF2ZSBvdXIgcmVjdCwgaW4gYSBzcGFjZSBzY2FsZWQgd2l0aCByZXNwZWN0IHRvIHRoZSBsYXJnZXN0IGRpbWVuc2lvbi5cclxuXHRcdFJvdGF0aW9ucyB3b3JrIGFzIHlvdSB3b3VsZCBleHBlY3QsIGV2ZW4gZm9yIGxvbmcgcmVjdGFuZ2xlcy5cclxuXHJcblx0XHRcdFx0XHQwLjVcclxuXHRcdFx0X18gX18gX18gX18gX18gX18gX19cclxuXHRcdFx0fFx0fDg4ODg4ODg4ODg4fFx0fFxyXG5cdFx0XHR8XHR8ODg4ODg4ODg4ODh8XHR8XHJcblx0XHRcdHxcdHw4ODg4ODg4ODg4OHxcdHxcclxuXHRcdC0wLjV8XyBffDg4ODg4ODg4ODg4fF8gX3wwLjVcclxuXHRcdFx0fFx0fDg4ODg4ODg4ODg4fFx0fFxyXG5cdFx0XHR8XHR8ODg4ODg4ODg4ODh8XHR8XHJcblx0XHRcdHxcdHw4ODg4ODg4ODg4OHxcdHxcclxuXHQgIFx0XHR8X19ffDg4ODg4ODg4ODg4fF9fX3xcclxuXHRcdFx0ICBcdFx0LTAuNVxyXG5cclxuXHRcdFRoZSBnZXRWZXJ0aWNlcyBmdW5jdGlvbiBiZWxvdyBkb2VzIGFzIGRlc2NyaWJlZCwgYW5kIGNvbnZlcnRzIHRoZSByYW5nZVxyXG5cdCovXHJcblx0LyoqXHJcblx0ICogVGhlIHJlbmRlcmluZyBzcGFjZSBhbHdheXMgaGFzIHRvIGJlIGEgc3F1YXJlLCBzbyBtYWtlIHN1cmUgaXRzIHNxdWFyZSB3LnIudCB0byB0aGUgbGFyZ2VzdCBkaW1lbnNpb25cclxuXHQgKiBAcGFyYW0gdyBUaGUgd2lkdGggb2YgdGhlIHF1YWQgaW4gcGl4ZWxzXHJcblx0ICogQHBhcmFtIGggVGhlIGhlaWdodCBvZiB0aGUgcXVhZCBpbiBwaXhlbHNcclxuXHQgKiBAcmV0dXJucyBBbiBhcnJheSBvZiB0aGUgdmVydGljZXMgb2YgdGhlIHF1YWRcclxuXHQgKi9cclxuXHRnZXRWZXJ0aWNlcyh3OiBudW1iZXIsIGg6IG51bWJlcik6IEZsb2F0MzJBcnJheSB7XHJcblx0XHRsZXQgeCwgeTtcclxuXHJcblx0XHRpZihoID4gdyl7XHJcblx0XHRcdHkgPSAwLjU7XHJcblx0XHRcdHggPSB3LygyKmgpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0eCA9IDAuNTtcclxuXHRcdFx0eSA9IGgvKDIqdyk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoW1xyXG5cdFx0XHQteCwgIHksXHJcblx0XHRcdC14LCAteSxcclxuXHRcdFx0IHgsICB5LFxyXG5cdFx0XHQgeCwgLXlcclxuXHRcdF0pO1xyXG5cdH1cclxuXHJcblx0Z2V0T3B0aW9ucyhyZWN0OiBSZWN0KTogUmVjb3JkPHN0cmluZywgYW55PiB7XHJcblx0XHRsZXQgb3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55PiA9IHtcclxuXHRcdFx0cG9zaXRpb246IHJlY3QucG9zaXRpb24sXHJcblx0XHRcdGNvbG9yOiByZWN0LmNvbG9yLFxyXG5cdFx0XHRzaXplOiByZWN0LnNpemUsXHJcblx0XHRcdHJvdGF0aW9uOiByZWN0LnJvdGF0aW9uXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG9wdGlvbnM7XHJcblx0fVxyXG59IiwiaW1wb3J0IE1hdDR4NCBmcm9tIFwiLi4vLi4vLi4vRGF0YVR5cGVzL01hdDR4NFwiO1xyXG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vLi4vRGF0YVR5cGVzL1ZlYzJcIjtcclxuaW1wb3J0IERlYnVnIGZyb20gXCIuLi8uLi8uLi9EZWJ1Zy9EZWJ1Z1wiO1xyXG5pbXBvcnQgQW5pbWF0ZWRTcHJpdGUgZnJvbSBcIi4uLy4uLy4uL05vZGVzL1Nwcml0ZXMvQW5pbWF0ZWRTcHJpdGVcIjtcclxuaW1wb3J0IFNwcml0ZSBmcm9tIFwiLi4vLi4vLi4vTm9kZXMvU3ByaXRlcy9TcHJpdGVcIjtcclxuaW1wb3J0IFJlc291cmNlTWFuYWdlciBmcm9tIFwiLi4vLi4vLi4vUmVzb3VyY2VNYW5hZ2VyL1Jlc291cmNlTWFuYWdlclwiO1xyXG5pbXBvcnQgUXVhZFNoYWRlclR5cGUgZnJvbSBcIi4vUXVhZFNoYWRlclR5cGVcIjtcclxuXHJcbi8qKiBBIHNoYWRlciBmb3Igc3ByaXRlcyBhbmQgYW5pbWF0ZWQgc3ByaXRlcyAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTcHJpdGVTaGFkZXJUeXBlIGV4dGVuZHMgUXVhZFNoYWRlclR5cGUge1xyXG5cdGNvbnN0cnVjdG9yKHByb2dyYW1LZXk6IHN0cmluZyl7XHJcblx0XHRzdXBlcihwcm9ncmFtS2V5KTtcclxuXHRcdHRoaXMucmVzb3VyY2VNYW5hZ2VyID0gUmVzb3VyY2VNYW5hZ2VyLmdldEluc3RhbmNlKCk7XHJcblx0fVxyXG5cclxuXHRpbml0QnVmZmVyT2JqZWN0KCk6IHZvaWQge1xyXG5cdFx0dGhpcy5idWZmZXJPYmplY3RLZXkgPSBcInNwcml0ZVwiO1xyXG5cdFx0dGhpcy5yZXNvdXJjZU1hbmFnZXIuY3JlYXRlQnVmZmVyKHRoaXMuYnVmZmVyT2JqZWN0S2V5KTtcclxuXHR9XHJcblxyXG5cdHJlbmRlcihnbDogV2ViR0xSZW5kZXJpbmdDb250ZXh0LCBvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogdm9pZCB7XHJcblx0XHRjb25zdCBwcm9ncmFtID0gdGhpcy5yZXNvdXJjZU1hbmFnZXIuZ2V0U2hhZGVyUHJvZ3JhbSh0aGlzLnByb2dyYW1LZXkpO1xyXG5cdFx0Y29uc3QgYnVmZmVyID0gdGhpcy5yZXNvdXJjZU1hbmFnZXIuZ2V0QnVmZmVyKHRoaXMuYnVmZmVyT2JqZWN0S2V5KTtcclxuXHRcdGNvbnN0IHRleHR1cmUgPSB0aGlzLnJlc291cmNlTWFuYWdlci5nZXRUZXh0dXJlKG9wdGlvbnMuaW1hZ2VLZXkpO1xyXG5cclxuXHRcdGdsLnVzZVByb2dyYW0ocHJvZ3JhbSk7XHJcblxyXG5cdFx0Y29uc3QgdmVydGV4RGF0YSA9IHRoaXMuZ2V0VmVydGljZXMob3B0aW9ucy5zaXplLngsIG9wdGlvbnMuc2l6ZS55LCBvcHRpb25zLnNjYWxlKTtcclxuXHJcblx0XHRjb25zdCBGU0laRSA9IHZlcnRleERhdGEuQllURVNfUEVSX0VMRU1FTlQ7XHJcblxyXG5cdFx0Ly8gQmluZCB0aGUgYnVmZmVyXHJcblx0XHRnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYnVmZmVyKTtcclxuXHRcdGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCB2ZXJ0ZXhEYXRhLCBnbC5TVEFUSUNfRFJBVyk7XHJcblxyXG5cdFx0Ly8gQXR0cmlidXRlc1xyXG5cdFx0Y29uc3QgYV9Qb3NpdGlvbiA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sIFwiYV9Qb3NpdGlvblwiKTtcclxuXHRcdGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoYV9Qb3NpdGlvbiwgMiwgZ2wuRkxPQVQsIGZhbHNlLCA0ICogRlNJWkUsIDAgKiBGU0laRSk7XHJcblx0XHRnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShhX1Bvc2l0aW9uKTtcclxuXHJcblx0XHRjb25zdCBhX1RleENvb3JkID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgXCJhX1RleENvb3JkXCIpO1xyXG5cdFx0Z2wudmVydGV4QXR0cmliUG9pbnRlcihhX1RleENvb3JkLCAyLCBnbC5GTE9BVCwgZmFsc2UsIDQgKiBGU0laRSwgMipGU0laRSk7XHJcblx0XHRnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShhX1RleENvb3JkKTtcclxuXHJcblx0XHQvLyBVbmlmb3Jtc1xyXG5cdFx0Ly8gR2V0IHRyYW5zZm9ybWF0aW9uIG1hdHJpeFxyXG5cdFx0Ly8gV2Ugd2FudCBhIHNxdWFyZSBmb3Igb3VyIHJlbmRlcmluZyBzcGFjZSwgc28gZ2V0IHRoZSBtYXhpbXVtIGRpbWVuc2lvbiBvZiBvdXIgcXVhZFxyXG5cdFx0bGV0IG1heERpbWVuc2lvbiA9IE1hdGgubWF4KG9wdGlvbnMuc2l6ZS54LCBvcHRpb25zLnNpemUueSk7XHJcblxyXG5cdFx0Ly8gVGhlIHNpemUgb2YgdGhlIHJlbmRlcmluZyBzcGFjZSB3aWxsIGJlIGEgc3F1YXJlIHdpdGggdGhpcyBtYXhpbXVtIGRpbWVuc2lvblxyXG5cdFx0bGV0IHNpemUgPSBuZXcgVmVjMihtYXhEaW1lbnNpb24sIG1heERpbWVuc2lvbikuc2NhbGUoMi9vcHRpb25zLndvcmxkU2l6ZS54LCAyL29wdGlvbnMud29ybGRTaXplLnkpO1xyXG5cclxuXHRcdC8vIENlbnRlciBvdXIgdHJhbnNsYXRpb25zIGFyb3VuZCAoMCwgMClcclxuXHRcdGNvbnN0IHRyYW5zbGF0ZVggPSAob3B0aW9ucy5wb3NpdGlvbi54IC0gb3B0aW9ucy5vcmlnaW4ueCAtIG9wdGlvbnMud29ybGRTaXplLngvMikvbWF4RGltZW5zaW9uO1xyXG5cdFx0Y29uc3QgdHJhbnNsYXRlWSA9IC0ob3B0aW9ucy5wb3NpdGlvbi55IC0gb3B0aW9ucy5vcmlnaW4ueSAtIG9wdGlvbnMud29ybGRTaXplLnkvMikvbWF4RGltZW5zaW9uO1xyXG5cclxuXHRcdC8vIENyZWF0ZSBvdXIgdHJhbnNmb3JtYXRpb24gbWF0cml4XHJcblx0XHR0aGlzLnRyYW5zbGF0aW9uLnRyYW5zbGF0ZShuZXcgRmxvYXQzMkFycmF5KFt0cmFuc2xhdGVYLCB0cmFuc2xhdGVZXSkpO1xyXG5cdFx0dGhpcy5zY2FsZS5zY2FsZShzaXplKTtcclxuXHRcdHRoaXMucm90YXRpb24ucm90YXRlKG9wdGlvbnMucm90YXRpb24pO1xyXG5cdFx0bGV0IHRyYW5zZm9ybWF0aW9uID0gTWF0NHg0Lk1VTFQodGhpcy50cmFuc2xhdGlvbiwgdGhpcy5zY2FsZSwgdGhpcy5yb3RhdGlvbik7XHJcblxyXG5cdFx0Ly8gUGFzcyB0aGUgdHJhbnNsYXRpb24gbWF0cml4IHRvIG91ciBzaGFkZXJcclxuXHRcdGNvbnN0IHVfVHJhbnNmb3JtID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIFwidV9UcmFuc2Zvcm1cIik7XHJcblx0XHRnbC51bmlmb3JtTWF0cml4NGZ2KHVfVHJhbnNmb3JtLCBmYWxzZSwgdHJhbnNmb3JtYXRpb24udG9BcnJheSgpKTtcclxuXHJcblx0XHQvLyBTZXQgdXAgb3VyIHNhbXBsZXIgd2l0aCBvdXIgYXNzaWduZWQgdGV4dHVyZSB1bml0XHJcblx0XHRjb25zdCB1X1NhbXBsZXIgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgXCJ1X1NhbXBsZXJcIik7XHJcblx0XHRnbC51bmlmb3JtMWkodV9TYW1wbGVyLCB0ZXh0dXJlKTtcclxuXHJcblx0XHQvLyBQYXNzIGluIHRleFNoaWZ0XHJcblx0XHRjb25zdCB1X3RleFNoaWZ0ID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIFwidV90ZXhTaGlmdFwiKTtcclxuXHRcdGdsLnVuaWZvcm0yZnYodV90ZXhTaGlmdCwgb3B0aW9ucy50ZXhTaGlmdCk7XHJcblxyXG5cdFx0Ly8gUGFzcyBpbiB0ZXhTY2FsZVxyXG5cdFx0Y29uc3QgdV90ZXhTY2FsZSA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCBcInVfdGV4U2NhbGVcIik7XHJcblx0XHRnbC51bmlmb3JtMmZ2KHVfdGV4U2NhbGUsIG9wdGlvbnMudGV4U2NhbGUpO1xyXG5cclxuXHRcdC8vIERyYXcgdGhlIHF1YWRcclxuXHRcdGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVfU1RSSVAsIDAsIDQpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogVGhlIHJlbmRlcmluZyBzcGFjZSBhbHdheXMgaGFzIHRvIGJlIGEgc3F1YXJlLCBzbyBtYWtlIHN1cmUgaXRzIHNxdWFyZSB3LnIudCB0byB0aGUgbGFyZ2VzdCBkaW1lbnNpb25cclxuXHQgKiBAcGFyYW0gdyBUaGUgd2lkdGggb2YgdGhlIHF1YWQgaW4gcGl4ZWxzXHJcblx0ICogQHBhcmFtIGggVGhlIGhlaWdodCBvZiB0aGUgcXVhZCBpbiBwaXhlbHNcclxuXHQgKiBAcmV0dXJucyBBbiBhcnJheSBvZiB0aGUgdmVydGljZXMgb2YgdGhlIHF1YWRcclxuXHQgKi9cclxuXHRnZXRWZXJ0aWNlcyh3OiBudW1iZXIsIGg6IG51bWJlciwgc2NhbGU6IEZsb2F0MzJBcnJheSk6IEZsb2F0MzJBcnJheSB7XHJcblx0XHRsZXQgeCwgeTtcclxuXHJcblx0XHRpZihoID4gdyl7XHJcblx0XHRcdHkgPSAwLjU7XHJcblx0XHRcdHggPSB3LygyKmgpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0eCA9IDAuNTtcclxuXHRcdFx0eSA9IGgvKDIqdyk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gU2NhbGUgdGhlIHJlbmRlcmluZyBzcGFjZSBpZiBuZWVkZWRcclxuXHRcdHggKj0gc2NhbGVbMF07XHJcblx0XHR5ICo9IHNjYWxlWzFdO1xyXG5cclxuXHRcdHJldHVybiBuZXcgRmxvYXQzMkFycmF5KFtcclxuXHRcdFx0LXgsICB5LCAwLjAsIDAuMCxcclxuXHRcdFx0LXgsIC15LCAwLjAsIDEuMCxcclxuXHRcdFx0IHgsICB5LCAxLjAsIDAuMCxcclxuXHRcdFx0IHgsIC15LCAxLjAsIDEuMFxyXG5cdFx0XSk7XHJcblx0fVxyXG5cclxuXHRnZXRPcHRpb25zKHNwcml0ZTogU3ByaXRlKTogUmVjb3JkPHN0cmluZywgYW55PiB7XHJcblx0XHRsZXQgdGV4U2hpZnQ7XHJcblx0XHRsZXQgdGV4U2NhbGU7XHJcblxyXG5cdFx0aWYoc3ByaXRlIGluc3RhbmNlb2YgQW5pbWF0ZWRTcHJpdGUpe1xyXG5cdFx0XHRsZXQgYW5pbWF0aW9uSW5kZXggPSBzcHJpdGUuYW5pbWF0aW9uLmdldEluZGV4QW5kQWR2YW5jZUFuaW1hdGlvbigpO1xyXG5cdFx0XHRsZXQgb2Zmc2V0ID0gc3ByaXRlLmdldEFuaW1hdGlvbk9mZnNldChhbmltYXRpb25JbmRleCk7XHJcblx0XHRcdHRleFNoaWZ0ID0gbmV3IEZsb2F0MzJBcnJheShbb2Zmc2V0LnggLyAoc3ByaXRlLmNvbHMgKiBzcHJpdGUuc2l6ZS54KSwgb2Zmc2V0LnkgLyAoc3ByaXRlLnJvd3MgKiBzcHJpdGUuc2l6ZS55KV0pO1xyXG5cdFx0XHR0ZXhTY2FsZSA9IG5ldyBGbG9hdDMyQXJyYXkoWzEvKHNwcml0ZS5jb2xzKSwgMS8oc3ByaXRlLnJvd3MpXSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0ZXhTaGlmdCA9IG5ldyBGbG9hdDMyQXJyYXkoWzAsIDBdKTtcclxuXHRcdFx0dGV4U2NhbGUgPSBuZXcgRmxvYXQzMkFycmF5KFsxLCAxXSk7XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT4gPSB7XHJcblx0XHRcdHBvc2l0aW9uOiBzcHJpdGUucG9zaXRpb24sXHJcblx0XHRcdHJvdGF0aW9uOiBzcHJpdGUucm90YXRpb24sXHJcblx0XHRcdHNpemU6IHNwcml0ZS5zaXplLFxyXG5cdFx0XHRzY2FsZTogc3ByaXRlLnNjYWxlLnRvQXJyYXkoKSxcclxuXHRcdFx0aW1hZ2VLZXk6IHNwcml0ZS5pbWFnZUlkLFxyXG5cdFx0XHR0ZXhTaGlmdCxcclxuXHRcdFx0dGV4U2NhbGVcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gb3B0aW9ucztcclxuXHR9XHJcbn0iLCJpbXBvcnQgTWFwIGZyb20gXCIuLi9EYXRhVHlwZXMvTWFwXCI7XHJcbmltcG9ydCBRdWV1ZSBmcm9tIFwiLi4vRGF0YVR5cGVzL1F1ZXVlXCI7XHJcbmltcG9ydCB7IFRpbGVkVGlsZW1hcERhdGEgfSBmcm9tIFwiLi4vRGF0YVR5cGVzL1RpbGVzZXRzL1RpbGVkRGF0YVwiO1xyXG5pbXBvcnQgU3RyaW5nVXRpbHMgZnJvbSBcIi4uL1V0aWxzL1N0cmluZ1V0aWxzXCI7XHJcbmltcG9ydCBBdWRpb01hbmFnZXIgZnJvbSBcIi4uL1NvdW5kL0F1ZGlvTWFuYWdlclwiO1xyXG5pbXBvcnQgU3ByaXRlc2hlZXQgZnJvbSBcIi4uL0RhdGFUeXBlcy9TcHJpdGVzaGVldFwiO1xyXG5pbXBvcnQgV2ViR0xQcm9ncmFtVHlwZSBmcm9tIFwiLi4vRGF0YVR5cGVzL1JlbmRlcmluZy9XZWJHTFByb2dyYW1UeXBlXCI7XHJcblxyXG4vKipcclxuICogVGhlIHJlc291cmNlIG1hbmFnZXIgZm9yIHRoZSBnYW1lIGVuZ2luZS5cclxuICogVGhlIHJlc291cmNlIG1hbmFnZXIgaW50ZXJmYWNlcyB3aXRoIHRoZSBsb2FkYWJsZSBhc3NldHMgb2YgYSBnYW1lIHN1Y2ggYXMgaW1hZ2VzLCBkYXRhIGZpbGVzLFxyXG4gKiBhbmQgc291bmRzLCB3aGljaCBhcmUgYWxsIGZvdW5kIGluIHRoZSBkaXN0IGZvbGRlci5cclxuICogVGhpcyBjbGFzcyBjb250cm9scyBsb2FkaW5nIGFuZCB1cGRhdGVzIHRoZSBAcmVmZXJlbmNlW1NjZW5lXSB3aXRoIHRoZSBsb2FkaW5nIHByb2dyZXNzLCBzbyB0aGF0IHRoZSBzY2VuZSBkb2VzIFxyXG4gKiBub3Qgc3RhcnQgYmVmb3JlIGFsbCBuZWNlc3NhcnkgYXNzZXRzIGFyZSBsb2FkZWQuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZXNvdXJjZU1hbmFnZXIge1xyXG4gICAgLy8gSW5zdGFuY2UgZm9yIHRoZSBzaW5nbGV0b24gY2xhc3NcclxuICAgIHByaXZhdGUgc3RhdGljIGluc3RhbmNlOiBSZXNvdXJjZU1hbmFnZXI7XHJcbiAgICBcclxuICAgIC8vIEJvb2xlYW5zIHRvIGtlZXAgdHJhY2sgb2Ygd2hldGhlciBvciBub3QgdGhlIFJlc291cmNlTWFuYWdlciBpcyBjdXJyZW50bHkgbG9hZGluZyBzb21ldGhpbmdcclxuICAgIC8qKiBXaGV0aGVyIG9yIG5vdCBhbnkgcmVzb3VyY2VzIGFyZSBsb2FkaW5nICovXHJcbiAgICBwcml2YXRlIGxvYWRpbmc6IGJvb2xlYW47XHJcbiAgICAvKiogQSBib29sZWFuIHRvIGluZGljYXRlIHRoYXQgdGhlIGFzc2V0cyBqdXN0IGZpbmlzaGVkIGxvYWRpbmcgKi9cclxuICAgIHByaXZhdGUganVzdExvYWRlZDogYm9vbGVhbjtcclxuXHJcbiAgICAvLyBGdW5jdGlvbnMgdG8gZG8gc29tZXRoaW5nIHdoZW4gbG9hZGluZyBwcm9ncmVzc2VzIG9yIGlzIGNvbXBsZXRlZCBzdWNoIGFzIHJlbmRlciBhIGxvYWRpbmcgc2NyZWVuXHJcbiAgICAvKiogQSBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aGVuIGxvYWRpbmcgcHJvZ3Jlc3NlcyAqL1xyXG4gICAgcHVibGljIG9uTG9hZFByb2dyZXNzOiBGdW5jdGlvbjtcclxuICAgIC8qKiBBIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdoZW4gbG9hZGluZyBjb21wbGV0ZXMgKi9cclxuICAgIHB1YmxpYyBvbkxvYWRDb21wbGV0ZTogRnVuY3Rpb247XHJcblxyXG5cclxuICAgIC8qKiBOdW1iZXIgdG8ga2VlcCB0cmFjayBvZiBob3cgbWFueSBpbWFnZXMgbmVlZCB0byBiZSBsb2FkZWQqL1xyXG4gICAgcHJpdmF0ZSBsb2Fkb25seV9pbWFnZXNMb2FkZWQ6IG51bWJlcjtcclxuICAgIC8qKiBOdW1iZXIgdG8ga2VlcCB0cmFjayBvZiBob3cgbWFueSBpbWFnZXMgYXJlIGxvYWRlZCAqL1xyXG4gICAgcHJpdmF0ZSBsb2Fkb25seV9pbWFnZXNUb0xvYWQ6IG51bWJlcjtcclxuICAgIC8qKiBUaGUgcXVldWUgb2YgaW1hZ2VzIHdlIG11c3QgbG9hZCAqL1xyXG4gICAgcHJpdmF0ZSBsb2Fkb25seV9pbWFnZUxvYWRpbmdRdWV1ZTogUXVldWU8S2V5UGF0aFBhaXI+O1xyXG4gICAgLyoqIEEgbWFwIG9mIHRoZSBpbWFnZXMgdGhhdCBhcmUgY3VycmVudGx5IGxvYWRlZCBhbmQgYmVpbmcgdXNlZCBieSB0aGUgc2NlbmUuIFRoZSByZWZlcmVuY2UgdG8gdGhlc2UgaW1hZ2VzIG9ubHkgZXhpc3QgaGVyZSBmb3IgZWFzeSBjbGVhbnVwLiAqL1xyXG4gICAgcHJpdmF0ZSBpbWFnZXM6IE1hcDxIVE1MSW1hZ2VFbGVtZW50PjtcclxuXHJcbiAgICAvKiogTnVtYmVyIHRvIGtlZXAgdHJhY2sgb2YgaG93IG1hbnkgdGlsZW1hcHMgbmVlZCB0byBiZSBsb2FkZWQgKi9cclxuICAgIHByaXZhdGUgbG9hZG9ubHlfc3ByaXRlc2hlZXRzTG9hZGVkOiBudW1iZXI7XHJcbiAgICAvKiogTnVtYmVyIHRvIGtlZXAgdHJhY2sgb2YgaG93IG1hbnkgdGlsZW1hcHMgYXJlIGxvYWRlZCAqL1xyXG4gICAgcHJpdmF0ZSBsb2Fkb25seV9zcHJpdGVzaGVldHNUb0xvYWQ6IG51bWJlcjtcclxuICAgIC8qKiBUaGUgcXVldWUgb2YgdGlsZW1hcHMgd2UgbXVzdCBsb2FkICovXHJcbiAgICBwcml2YXRlIGxvYWRvbmx5X3Nwcml0ZXNoZWV0TG9hZGluZ1F1ZXVlOiBRdWV1ZTxLZXlQYXRoUGFpcj47XHJcbiAgICAvKiogQSBtYXAgb2YgdGhlIHRpbGVtYXBzIHRoYXQgYXJlIGN1cnJlbnRseSBsb2FkZWQgYW5kIChwcmVzdW1hYmx5KSBiZWluZyB1c2VkIGJ5IHRoZSBzY2VuZSAqL1xyXG4gICAgcHJpdmF0ZSBzcHJpdGVzaGVldHM6IE1hcDxTcHJpdGVzaGVldD47XHJcblxyXG4gICAgLyoqIE51bWJlciB0byBrZWVwIHRyYWNrIG9mIGhvdyBtYW55IHRpbGVtYXBzIG5lZWQgdG8gYmUgbG9hZGVkICovXHJcbiAgICBwcml2YXRlIGxvYWRvbmx5X3RpbGVtYXBzTG9hZGVkOiBudW1iZXI7XHJcbiAgICAvKiogTnVtYmVyIHRvIGtlZXAgdHJhY2sgb2YgaG93IG1hbnkgdGlsZW1hcHMgYXJlIGxvYWRlZCAqL1xyXG4gICAgcHJpdmF0ZSBsb2Fkb25seV90aWxlbWFwc1RvTG9hZDogbnVtYmVyO1xyXG4gICAgLyoqIFRoZSBxdWV1ZSBvZiB0aWxlbWFwcyB3ZSBtdXN0IGxvYWQgKi9cclxuICAgIHByaXZhdGUgbG9hZG9ubHlfdGlsZW1hcExvYWRpbmdRdWV1ZTogUXVldWU8S2V5UGF0aFBhaXI+O1xyXG4gICAgLyoqIEEgbWFwIG9mIHRoZSB0aWxlbWFwcyB0aGF0IGFyZSBjdXJyZW50bHkgbG9hZGVkIGFuZCAocHJlc3VtYWJseSkgYmVpbmcgdXNlZCBieSB0aGUgc2NlbmUgKi9cclxuICAgIHByaXZhdGUgdGlsZW1hcHM6IE1hcDxUaWxlZFRpbGVtYXBEYXRhPjtcclxuXHJcbiAgICAvKiogTnVtYmVyIHRvIGtlZXAgdHJhY2sgb2YgaG93IG1hbnkgc291bmRzIG5lZWQgdG8gYmUgbG9hZGVkICovXHJcbiAgICBwcml2YXRlIGxvYWRvbmx5X2F1ZGlvTG9hZGVkOiBudW1iZXI7XHJcbiAgICAvKiogTnVtYmVyIHRvIGtlZXAgdHJhY2sgb2YgaG93IG1hbnkgc291bmRzIGFyZSBsb2FkZWQgKi9cclxuICAgIHByaXZhdGUgbG9hZG9ubHlfYXVkaW9Ub0xvYWQ6IG51bWJlcjtcclxuICAgIC8qKiBUaGUgcXVldWUgb2Ygc291bmRzIHdlIG11c3QgbG9hZCAqL1xyXG4gICAgcHJpdmF0ZSBsb2Fkb25seV9hdWRpb0xvYWRpbmdRdWV1ZTogUXVldWU8S2V5UGF0aFBhaXI+O1xyXG4gICAgLyoqIEEgbWFwIG9mIHRoZSBzb3VuZHMgdGhhdCBhcmUgY3VycmVudGx5IGxvYWRlZCBhbmQgKHByZXN1bWFibHkpIGJlaW5nIHVzZWQgYnkgdGhlIHNjZW5lICovXHJcbiAgICBwcml2YXRlIGF1ZGlvQnVmZmVyczogTWFwPEF1ZGlvQnVmZmVyPjtcclxuXHJcbiAgICAvKiogVGhlIHRvdGFsIG51bWJlciBvZiBcInR5cGVzXCIgb2YgdGhpbmdzIHRoYXQgbmVlZCB0byBiZSBsb2FkZWQgKGkuZS4gaW1hZ2VzIGFuZCB0aWxlbWFwcykgKi9cclxuICAgIHByaXZhdGUgbG9hZG9ubHlfdHlwZXNUb0xvYWQ6IG51bWJlcjtcclxuXHJcbiAgICBwcml2YXRlIGxvYWRvbmx5X2pzb25Mb2FkZWQ6IG51bWJlcjtcclxuICAgIHByaXZhdGUgbG9hZG9ubHlfanNvblRvTG9hZDogbnVtYmVyO1xyXG4gICAgcHJpdmF0ZSBsb2Fkb25seV9qc29uTG9hZGluZ1F1ZXVlOiBRdWV1ZTxLZXlQYXRoUGFpcj47XHJcbiAgICBwcml2YXRlIGpzb25PYmplY3RzOiBNYXA8UmVjb3JkPHN0cmluZywgYW55Pj47XHJcblxyXG4gICAgLyogIyMjIyMjIyMjIyBJTkZPUk1BVElPTiBTUEVDSUFMIFRPIFdFQkdMICMjIyMjIyMjIyMgKi9cclxuICAgIHByaXZhdGUgZ2xfV2ViR0xBY3RpdmU6IGJvb2xlYW47XHJcblxyXG4gICAgcHJpdmF0ZSBsb2Fkb25seV9nbF9TaGFkZXJQcm9ncmFtc0xvYWRlZDogbnVtYmVyO1xyXG4gICAgcHJpdmF0ZSBsb2Fkb25seV9nbF9TaGFkZXJQcm9ncmFtc1RvTG9hZDogbnVtYmVyO1xyXG4gICAgcHJpdmF0ZSBsb2Fkb25seV9nbF9TaGFkZXJMb2FkaW5nUXVldWU6IFF1ZXVlPEtleVBhdGhfU2hhZGVyPjtcclxuXHJcbiAgICBwcml2YXRlIGdsX1NoYWRlclByb2dyYW1zOiBNYXA8V2ViR0xQcm9ncmFtVHlwZT47XHJcblxyXG4gICAgcHJpdmF0ZSBnbF9UZXh0dXJlczogTWFwPG51bWJlcj47XHJcbiAgICBwcml2YXRlIGdsX05leHRUZXh0dXJlSUQ6IG51bWJlcjtcclxuICAgIHByaXZhdGUgZ2xfQnVmZmVyczogTWFwPFdlYkdMQnVmZmVyPjsgXHJcblxyXG4gICAgcHJpdmF0ZSBnbDogV2ViR0xSZW5kZXJpbmdDb250ZXh0O1xyXG5cclxuICAgIC8qICMjIyMjIyMjIyMgVU5MT0FESU5HIEFORCBFWENMVVNJT04gTElTVCAjIyMjIyMjIyMjICovXHJcbiAgICAvKiogQSBsaXN0IG9mIHJlc291cmNlcyB0aGF0IHdpbGwgYmUgdW5sb2FkZWQgYXQgdGhlIGVuZCBvZiB0aGUgY3VycmVudCBzY2VuZSAqL1xyXG4gICAgcHJpdmF0ZSByZXNvdXJjZXNUb1VubG9hZDogQXJyYXk8UmVzb3VyY2VSZWZlcmVuY2U+O1xyXG5cclxuICAgIC8qKiBBIGxpc3Qgb2YgcmVzb3VyY2VzIHRvIGtlZXAgdW50aWwgZnVydGhlciBub3RpY2UgKi9cclxuICAgIHByaXZhdGUgcmVzb3VyY2VzVG9LZWVwOiBBcnJheTxSZXNvdXJjZVJlZmVyZW5jZT47XHJcblxyXG4gICAgcHJpdmF0ZSBjb25zdHJ1Y3Rvcigpe1xyXG4gICAgICAgIHRoaXMubG9hZGluZyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuanVzdExvYWRlZCA9IGZhbHNlO1xyXG5cclxuICAgICAgICB0aGlzLmxvYWRvbmx5X2ltYWdlc0xvYWRlZCA9IDA7XHJcbiAgICAgICAgdGhpcy5sb2Fkb25seV9pbWFnZXNUb0xvYWQgPSAwO1xyXG4gICAgICAgIHRoaXMubG9hZG9ubHlfaW1hZ2VMb2FkaW5nUXVldWUgPSBuZXcgUXVldWUoKTtcclxuICAgICAgICB0aGlzLmltYWdlcyA9IG5ldyBNYXAoKTtcclxuXHJcbiAgICAgICAgdGhpcy5sb2Fkb25seV9zcHJpdGVzaGVldHNMb2FkZWQgPSAwO1xyXG4gICAgICAgIHRoaXMubG9hZG9ubHlfc3ByaXRlc2hlZXRzVG9Mb2FkID0gMDtcclxuICAgICAgICB0aGlzLmxvYWRvbmx5X3Nwcml0ZXNoZWV0TG9hZGluZ1F1ZXVlID0gbmV3IFF1ZXVlKCk7XHJcbiAgICAgICAgdGhpcy5zcHJpdGVzaGVldHMgPSBuZXcgTWFwKCk7XHJcblxyXG4gICAgICAgIHRoaXMubG9hZG9ubHlfdGlsZW1hcHNMb2FkZWQgPSAwO1xyXG4gICAgICAgIHRoaXMubG9hZG9ubHlfdGlsZW1hcHNUb0xvYWQgPSAwO1xyXG4gICAgICAgIHRoaXMubG9hZG9ubHlfdGlsZW1hcExvYWRpbmdRdWV1ZSA9IG5ldyBRdWV1ZSgpO1xyXG4gICAgICAgIHRoaXMudGlsZW1hcHMgPSBuZXcgTWFwKCk7XHJcblxyXG4gICAgICAgIHRoaXMubG9hZG9ubHlfYXVkaW9Mb2FkZWQgPSAwO1xyXG4gICAgICAgIHRoaXMubG9hZG9ubHlfYXVkaW9Ub0xvYWQgPSAwO1xyXG4gICAgICAgIHRoaXMubG9hZG9ubHlfYXVkaW9Mb2FkaW5nUXVldWUgPSBuZXcgUXVldWUoKTtcclxuICAgICAgICB0aGlzLmF1ZGlvQnVmZmVycyA9IG5ldyBNYXAoKTtcclxuXHJcbiAgICAgICAgdGhpcy5sb2Fkb25seV9qc29uTG9hZGVkID0gMDtcclxuICAgICAgICB0aGlzLmxvYWRvbmx5X2pzb25Ub0xvYWQgPSAwO1xyXG4gICAgICAgIHRoaXMubG9hZG9ubHlfanNvbkxvYWRpbmdRdWV1ZSA9IG5ldyBRdWV1ZSgpO1xyXG4gICAgICAgIHRoaXMuanNvbk9iamVjdHMgPSBuZXcgTWFwKCk7XHJcblxyXG4gICAgICAgIHRoaXMubG9hZG9ubHlfZ2xfU2hhZGVyUHJvZ3JhbXNMb2FkZWQgPSAwO1xyXG4gICAgICAgIHRoaXMubG9hZG9ubHlfZ2xfU2hhZGVyUHJvZ3JhbXNUb0xvYWQgPSAwO1xyXG4gICAgICAgIHRoaXMubG9hZG9ubHlfZ2xfU2hhZGVyTG9hZGluZ1F1ZXVlID0gbmV3IFF1ZXVlKCk7XHJcblxyXG4gICAgICAgIHRoaXMuZ2xfU2hhZGVyUHJvZ3JhbXMgPSBuZXcgTWFwKCk7XHJcblxyXG4gICAgICAgIHRoaXMuZ2xfVGV4dHVyZXMgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy5nbF9OZXh0VGV4dHVyZUlEID0gMDtcclxuICAgICAgICB0aGlzLmdsX0J1ZmZlcnMgPSBuZXcgTWFwKCk7XHJcblxyXG4gICAgICAgIHRoaXMucmVzb3VyY2VzVG9VbmxvYWQgPSBuZXcgQXJyYXkoKTtcclxuICAgICAgICB0aGlzLnJlc291cmNlc1RvS2VlcCA9IG5ldyBBcnJheSgpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKiAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIFNJTkdMRVRPTiAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjKi9cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgY3VycmVudCBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzIG9yIGEgbmV3IGluc3RhbmNlIGlmIG5vbmUgZXhpc3RcclxuICAgICAqIEByZXR1cm5zIFRoZSByZXNvdXJjZSBtYW5hZ2VyXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXRJbnN0YW5jZSgpOiBSZXNvdXJjZU1hbmFnZXIge1xyXG4gICAgICAgIGlmKCF0aGlzLmluc3RhbmNlKXtcclxuICAgICAgICAgICAgdGhpcy5pbnN0YW5jZSA9IG5ldyBSZXNvdXJjZU1hbmFnZXIoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLmluc3RhbmNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgUFVCTElDIEZVTkNUSU9OICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMqL1xyXG4gICAgLyoqXHJcbiAgICAgKiBBY3RpdmF0ZXMgb3IgZGVhY3RpdmF0ZXMgdGhlIHVzZSBvZiBXZWJHTFxyXG4gICAgICogQHBhcmFtIGZsYWcgVHJ1ZSBpZiBXZWJHTCBzaG91bGQgYmUgdXNlZCwgZmFsc2Ugb3RoZXJ3aXNlXHJcbiAgICAgKiBAcGFyYW0gZ2wgVGhlIGluc3RhbmNlIG9mIHRoZSBncmFwaGljcyBjb250ZXh0LCBpZiBhcHBsaWNhYmxlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB1c2VXZWJHTChmbGFnOiBib29sZWFuLCBnbDogV2ViR0xSZW5kZXJpbmdDb250ZXh0KTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5nbF9XZWJHTEFjdGl2ZSA9IGZsYWc7XHJcblxyXG4gICAgICAgIGlmKHRoaXMuZ2xfV2ViR0xBY3RpdmUpe1xyXG4gICAgICAgICAgICB0aGlzLmdsID0gZ2w7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTG9hZHMgYW4gaW1hZ2UgZnJvbSBmaWxlXHJcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgdG8gYXNzb2NpYXRlIHRoZSBsb2FkZWQgaW1hZ2Ugd2l0aFxyXG4gICAgICogQHBhcmFtIHBhdGggVGhlIHBhdGggdG8gdGhlIGltYWdlIHRvIGxvYWRcclxuICAgICAqL1xyXG4gICAgcHVibGljIGltYWdlKGtleTogc3RyaW5nLCBwYXRoOiBzdHJpbmcpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmxvYWRvbmx5X2ltYWdlTG9hZGluZ1F1ZXVlLmVucXVldWUoe2tleToga2V5LCBwYXRoOiBwYXRofSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUZWxscyB0aGUgcmVzb3VyY2UgbWFuYWdlciB0byBrZWVwIHRoaXMgcmVzb3VyY2VcclxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgcmVzb3VyY2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIGtlZXBJbWFnZShrZXk6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMua2VlcFJlc291cmNlKGtleSwgUmVzb3VyY2VUeXBlLklNQUdFKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHJpZXZlcyBhIGxvYWRlZCBpbWFnZVxyXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBsb2FkZWQgaW1hZ2VcclxuICAgICAqIEByZXR1cm5zIFRoZSBpbWFnZSBlbGVtZW50IGFzc29jaWF0ZWQgd2l0aCB0aGlzIGtleVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0SW1hZ2Uoa2V5OiBzdHJpbmcpOiBIVE1MSW1hZ2VFbGVtZW50IHtcclxuICAgICAgICBsZXQgaW1hZ2UgPSB0aGlzLmltYWdlcy5nZXQoa2V5KTtcclxuICAgICAgICBpZihpbWFnZSA9PT0gdW5kZWZpbmVkKXtcclxuICAgICAgICAgICAgdGhyb3cgYFRoZXJlIGlzIG5vIGltYWdlIGFzc29jaWF0ZWQgd2l0aCBrZXkgXCIke2tleX1cImBcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGltYWdlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTG9hZHMgYSBzcHJpdGVzaGVldCBmcm9tIGZpbGVcclxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSB0byBhc3NvY2lhdGUgdGhlIGxvYWRlZCBzcHJpdGVzaGVldCB3aXRoXHJcbiAgICAgKiBAcGFyYW0gcGF0aCBUaGUgcGF0aCB0byB0aGUgc3ByaXRlc2hlZXQgdG8gbG9hZFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3ByaXRlc2hlZXQoa2V5OiBzdHJpbmcsIHBhdGg6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMubG9hZG9ubHlfc3ByaXRlc2hlZXRMb2FkaW5nUXVldWUuZW5xdWV1ZSh7a2V5OiBrZXksIHBhdGg6IHBhdGh9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRlbGxzIHRoZSByZXNvdXJjZSBtYW5hZ2VyIHRvIGtlZXAgdGhpcyByZXNvdXJjZVxyXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSByZXNvdXJjZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMga2VlcFNwcml0ZXNoZWV0KGtleTogc3RyaW5nKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5rZWVwUmVzb3VyY2Uoa2V5LCBSZXNvdXJjZVR5cGUuU1BSSVRFU0hFRVQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0cmlldmVzIGEgbG9hZGVkIHNwcml0ZXNoZWV0XHJcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIHNwcml0ZXNoZWV0IHRvIGxvYWRcclxuICAgICAqIEByZXR1cm5zIFRoZSBsb2FkZWQgU3ByaXRlc2hlZXRcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldFNwcml0ZXNoZWV0KGtleTogc3RyaW5nKTogU3ByaXRlc2hlZXQge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNwcml0ZXNoZWV0cy5nZXQoa2V5KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIExvYWRzIGFuIGF1ZGlvIGZpbGVcclxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSB0byBhc3NvY2lhdGUgd2l0aCB0aGUgbG9hZGVkIGF1ZGlvIGZpbGVcclxuICAgICAqIEBwYXJhbSBwYXRoIFRoZSBwYXRoIHRvIHRoZSBhdWRpbyBmaWxlIHRvIGxvYWRcclxuICAgICAqL1xyXG4gICAgcHVibGljIGF1ZGlvKGtleTogc3RyaW5nLCBwYXRoOiBzdHJpbmcpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmxvYWRvbmx5X2F1ZGlvTG9hZGluZ1F1ZXVlLmVucXVldWUoe2tleToga2V5LCBwYXRoOiBwYXRofSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUZWxscyB0aGUgcmVzb3VyY2UgbWFuYWdlciB0byBrZWVwIHRoaXMgcmVzb3VyY2VcclxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgcmVzb3VyY2VcclxuICAgICAqL1xyXG4gICAgIHB1YmxpYyBrZWVwQXVkaW8oa2V5OiBzdHJpbmcpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmtlZXBSZXNvdXJjZShrZXksIFJlc291cmNlVHlwZS5BVURJTyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyaWV2ZXMgYSBsb2FkZWQgYXVkaW8gZmlsZVxyXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBhdWRpbyBmaWxlIHRvIGxvYWRcclxuICAgICAqIEByZXR1cm5zIFRoZSBBdWRpb0J1ZmZlciBjcmVhdGVkIGZyb20gdGhlIGxvYWRlZCBhdWRpbyBmbGVcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldEF1ZGlvKGtleTogc3RyaW5nKTogQXVkaW9CdWZmZXIge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmF1ZGlvQnVmZmVycy5nZXQoa2V5KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIExvYWQgYSB0aWxlbWFwIGZyb20gYSBqc29uIGZpbGUuIEF1dG9tYXRpY2FsbHkgbG9hZHMgcmVsYXRlZCBpbWFnZXNcclxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSB0byBhc3NvY2lhdGUgd2l0aCB0aGUgbG9hZGVkIHRpbGVtYXBcclxuICAgICAqIEBwYXJhbSBwYXRoIFRoZSBwYXRoIHRvIHRoZSB0aWxlbWFwIHRvIGxvYWRcclxuICAgICAqL1xyXG4gICAgcHVibGljIHRpbGVtYXAoa2V5OiBzdHJpbmcsIHBhdGg6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMubG9hZG9ubHlfdGlsZW1hcExvYWRpbmdRdWV1ZS5lbnF1ZXVlKHtrZXk6IGtleSwgcGF0aDogcGF0aH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGVsbHMgdGhlIHJlc291cmNlIG1hbmFnZXIgdG8ga2VlcCB0aGlzIHJlc291cmNlXHJcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIHJlc291cmNlXHJcbiAgICAgKi9cclxuICAgICBwdWJsaWMga2VlcFRpbGVtYXAoa2V5OiBzdHJpbmcpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmtlZXBSZXNvdXJjZShrZXksIFJlc291cmNlVHlwZS5USUxFTUFQKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHJlaXZlcyBhIGxvYWRlZCB0aWxlbWFwXHJcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIGxvYWRlZCB0aWxlbWFwXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgdGlsZW1hcCBkYXRhIGFzc29jaWF0ZWQgd2l0aCB0aGUga2V5XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRUaWxlbWFwKGtleTogc3RyaW5nKTogVGlsZWRUaWxlbWFwRGF0YSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudGlsZW1hcHMuZ2V0KGtleSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMb2FkcyBhbiBvYmplY3QgZnJvbSBhIGpzb24gZmlsZS5cclxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSB0byBhc3NvY2lhdGUgd2l0aCB0aGUgbG9hZGVkIG9iamVjdFxyXG4gICAgICogQHBhcmFtIHBhdGggVGhlIHBhdGggdG8gdGhlIGpzb24gZmlsZSB0byBsb2FkXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBvYmplY3Qoa2V5OiBzdHJpbmcsIHBhdGg6IHN0cmluZyl7XHJcbiAgICAgICAgdGhpcy5sb2Fkb25seV9qc29uTG9hZGluZ1F1ZXVlLmVucXVldWUoe2tleToga2V5LCBwYXRoOiBwYXRofSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUZWxscyB0aGUgcmVzb3VyY2UgbWFuYWdlciB0byBrZWVwIHRoaXMgcmVzb3VyY2VcclxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgcmVzb3VyY2VcclxuICAgICAqL1xyXG4gICAgIHB1YmxpYyBrZWVwT2JqZWN0KGtleTogc3RyaW5nKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5rZWVwUmVzb3VyY2Uoa2V5LCBSZXNvdXJjZVR5cGUuSlNPTik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyZWl2ZXMgYSBsb2FkZWQgb2JqZWN0XHJcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIGxvYWRlZCBvYmplY3RcclxuICAgICAqIEByZXR1cm5zIFRoZSBvYmplY3QgZGF0YSBhc3NvY2lhdGVkIHdpdGggdGhlIGtleVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0T2JqZWN0KGtleTogc3RyaW5nKXtcclxuICAgICAgICByZXR1cm4gdGhpcy5qc29uT2JqZWN0cy5nZXQoa2V5KTtcclxuICAgIH1cclxuXHJcbiAgICAvKiAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIExPQUQgRlVOQ1RJT04gIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyovXHJcbiAgICAvKipcclxuICAgICAqIExvYWRzIGFsbCByZXNvdXJjZXMgY3VycmVudGx5IGluIHRoZSBxdWV1ZVxyXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0byBjYWwgd2hlbiB0aGUgcmVzb3VyY2VzIGFyZSBmaW5pc2hlZCBsb2FkaW5nXHJcbiAgICAgKi9cclxuICAgIGxvYWRSZXNvdXJjZXNGcm9tUXVldWUoY2FsbGJhY2s6IEZ1bmN0aW9uKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5sb2Fkb25seV90eXBlc1RvTG9hZCA9IDU7XHJcblxyXG4gICAgICAgIHRoaXMubG9hZGluZyA9IHRydWU7XHJcblxyXG4gICAgICAgIC8vIExvYWQgZXZlcnl0aGluZyBpbiB0aGUgcXVldWVzLiBUaWxlbWFwcyBoYXZlIHRvIGNvbWUgYmVmb3JlIGltYWdlcyBiZWNhdXNlIHRoZXkgd2lsbCBhZGQgbmV3IGltYWdlcyB0byB0aGUgcXVldWVcclxuICAgICAgICB0aGlzLmxvYWRUaWxlbWFwc0Zyb21RdWV1ZSgoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiTG9hZGVkIFRpbGVtYXBzXCIpO1xyXG4gICAgICAgICAgICB0aGlzLmxvYWRTcHJpdGVzaGVldHNGcm9tUXVldWUoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJMb2FkZWQgU3ByaXRlc2hlZXRzXCIpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2FkSW1hZ2VzRnJvbVF1ZXVlKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkxvYWRlZCBJbWFnZXNcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2FkQXVkaW9Gcm9tUXVldWUoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkxvYWRlZCBBdWRpb1wiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2FkT2JqZWN0c0Zyb21RdWV1ZSgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkxvYWRlZCBPYmplY3RzXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZih0aGlzLmdsX1dlYkdMQWN0aXZlKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdsX0xvYWRTaGFkZXJzRnJvbVF1ZXVlKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJMb2FkZWQgU2hhZGVyc1wiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5maW5pc2hMb2FkaW5nKGNhbGxiYWNrKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5maW5pc2hMb2FkaW5nKGNhbGxiYWNrKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGZpbmlzaExvYWRpbmcoY2FsbGJhY2s6IEZ1bmN0aW9uKTogdm9pZCB7XHJcbiAgICAgICAgLy8gRG9uZSBsb2FkaW5nXHJcbiAgICAgICAgdGhpcy5sb2FkaW5nID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5qdXN0TG9hZGVkID0gdHJ1ZTtcclxuICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgVU5MT0FEIEZVTkNUSU9OICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMqL1xyXG4gICAgXHJcbiAgICBwcml2YXRlIGtlZXBSZXNvdXJjZShrZXk6IHN0cmluZywgdHlwZTogUmVzb3VyY2VUeXBlKTogdm9pZCB7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJLZWVwIHJlc291cmNlLi4uXCIpO1xyXG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCB0aGlzLnJlc291cmNlc1RvVW5sb2FkLmxlbmd0aDsgaSsrKXtcclxuICAgICAgICAgICAgbGV0IHJlc291cmNlID0gdGhpcy5yZXNvdXJjZXNUb1VubG9hZFtpXTtcclxuICAgICAgICAgICAgaWYocmVzb3VyY2Uua2V5ID09PSBrZXkgJiYgcmVzb3VyY2UucmVzb3VyY2VUeXBlID09PSB0eXBlKXtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRm91bmQgcmVzb3VyY2UgXCIgKyBrZXkgKyBcIiBvZiB0eXBlIFwiICsgdHlwZSArIFwiLiBLZWVwaW5nLlwiKTtcclxuICAgICAgICAgICAgICAgIGxldCByZXNvdXJjZVRvTW92ZSA9IHRoaXMucmVzb3VyY2VzVG9VbmxvYWQuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZXNvdXJjZXNUb0tlZXAucHVzaCguLi5yZXNvdXJjZVRvTW92ZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8qKlxyXG4gICAgICogRGVsZXRlcyByZWZlcmVuY2VzIHRvIGFsbCByZXNvdXJjZXMgaW4gdGhlIHJlc291cmNlIG1hbmFnZXJcclxuICAgICAqL1xyXG4gICAgdW5sb2FkQWxsUmVzb3VyY2VzKCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMubG9hZGluZyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuanVzdExvYWRlZCA9IGZhbHNlO1xyXG5cclxuICAgICAgICBmb3IobGV0IHJlc291cmNlIG9mIHRoaXMucmVzb3VyY2VzVG9VbmxvYWQpe1xyXG4gICAgICAgICAgICAvLyBVbmxvYWQgdGhlIHJlc291cmNlXHJcbiAgICAgICAgICAgIHRoaXMudW5sb2FkUmVzb3VyY2UocmVzb3VyY2UpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHVubG9hZFJlc291cmNlKHJlc291cmNlOiBSZXNvdXJjZVJlZmVyZW5jZSk6IHZvaWQge1xyXG4gICAgICAgIC8vIERlbGV0ZSB0aGUgcmVzb3VyY2UgaXRzZWxmXHJcbiAgICAgICAgc3dpdGNoKHJlc291cmNlLnJlc291cmNlVHlwZSl7XHJcbiAgICAgICAgICAgIGNhc2UgUmVzb3VyY2VUeXBlLklNQUdFOlxyXG4gICAgICAgICAgICAgICAgdGhpcy5pbWFnZXMuZGVsZXRlKHJlc291cmNlLmtleSk7XHJcbiAgICAgICAgICAgICAgICBpZih0aGlzLmdsX1dlYkdMQWN0aXZlKXtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdsX1RleHR1cmVzLmRlbGV0ZShyZXNvdXJjZS5rZXkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgUmVzb3VyY2VUeXBlLlRJTEVNQVA6XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRpbGVtYXBzLmRlbGV0ZShyZXNvdXJjZS5rZXkpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgUmVzb3VyY2VUeXBlLlNQUklURVNIRUVUOlxyXG4gICAgICAgICAgICAgICAgdGhpcy5zcHJpdGVzaGVldHMuZGVsZXRlKHJlc291cmNlLmtleSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBSZXNvdXJjZVR5cGUuQVVESU86XHJcbiAgICAgICAgICAgICAgICB0aGlzLmF1ZGlvQnVmZmVycy5kZWxldGUocmVzb3VyY2Uua2V5KTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFJlc291cmNlVHlwZS5KU09OOlxyXG4gICAgICAgICAgICAgICAgdGhpcy5qc29uT2JqZWN0cy5kZWxldGUocmVzb3VyY2Uua2V5KTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAvKmNhc2UgUmVzb3VyY2VUeXBlLlNIQURFUjpcclxuICAgICAgICAgICAgICAgIHRoaXMuZ2xfU2hhZGVyUHJvZ3JhbXMuZ2V0KHJlc291cmNlLmtleSkuZGVsZXRlKHRoaXMuZ2wpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5nbF9TaGFkZXJQcm9ncmFtcy5kZWxldGUocmVzb3VyY2Uua2V5KTtcclxuICAgICAgICAgICAgICAgIGJyZWFrOyovXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBEZWxldGUgYW55IGRlcGVuZGVuY2llc1xyXG4gICAgICAgIGZvcihsZXQgZGVwZW5kZW5jeSBvZiByZXNvdXJjZS5kZXBlbmRlbmNpZXMpe1xyXG4gICAgICAgICAgICB0aGlzLnVubG9hZFJlc291cmNlKGRlcGVuZGVuY3kpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKiAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIFdPUksgRlVOQ1RJT05TICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMqL1xyXG4gICAgLyoqXHJcbiAgICAgKiBMb2FkcyBhbGwgdGlsZW1hcHMgY3VycmVudGx5IGluIHRoZSB0aWxlbWFwIGxvYWRpbmcgcXVldWVcclxuICAgICAqIEBwYXJhbSBvbkZpbmlzaExvYWRpbmcgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiBsb2FkaW5nIGlzIGNvbXBsZXRlXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgbG9hZFRpbGVtYXBzRnJvbVF1ZXVlKG9uRmluaXNoTG9hZGluZzogRnVuY3Rpb24pOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmxvYWRvbmx5X3RpbGVtYXBzVG9Mb2FkID0gdGhpcy5sb2Fkb25seV90aWxlbWFwTG9hZGluZ1F1ZXVlLmdldFNpemUoKTtcclxuICAgICAgICB0aGlzLmxvYWRvbmx5X3RpbGVtYXBzTG9hZGVkID0gMDtcclxuXHJcbiAgICAgICAgLy8gSWYgbm8gaXRlbXMgdG8gbG9hZCwgd2UncmUgZmluaXNoZWRcclxuICAgICAgICBpZih0aGlzLmxvYWRvbmx5X3RpbGVtYXBzVG9Mb2FkID09PSAwKXtcclxuICAgICAgICAgICAgb25GaW5pc2hMb2FkaW5nKCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHdoaWxlKHRoaXMubG9hZG9ubHlfdGlsZW1hcExvYWRpbmdRdWV1ZS5oYXNJdGVtcygpKXtcclxuICAgICAgICAgICAgbGV0IHRpbGVtYXAgPSB0aGlzLmxvYWRvbmx5X3RpbGVtYXBMb2FkaW5nUXVldWUuZGVxdWV1ZSgpO1xyXG4gICAgICAgICAgICB0aGlzLmxvYWRUaWxlbWFwKHRpbGVtYXAua2V5LCB0aWxlbWFwLnBhdGgsIG9uRmluaXNoTG9hZGluZyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTG9hZHMgYSBzaW5ndWxhciB0aWxlbWFwIFxyXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSB0aWxlbWFwXHJcbiAgICAgKiBAcGFyYW0gcGF0aFRvVGlsZW1hcEpTT04gVGhlIHBhdGggdG8gdGhlIHRpbGVtYXAgSlNPTiBmaWxlXHJcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2tJZkxhc3QgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgaWYgdGhpcyBpcyB0aGUgbGFzdCB0aWxlbWFwIHRvIGxvYWRcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBsb2FkVGlsZW1hcChrZXk6IHN0cmluZywgcGF0aFRvVGlsZW1hcEpTT046IHN0cmluZywgY2FsbGJhY2tJZkxhc3Q6IEZ1bmN0aW9uKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5sb2FkVGV4dEZpbGUocGF0aFRvVGlsZW1hcEpTT04sIChmaWxlVGV4dDogc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgICAgIGxldCB0aWxlbWFwT2JqZWN0ID0gPFRpbGVkVGlsZW1hcERhdGE+SlNPTi5wYXJzZShmaWxlVGV4dCk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyBXZSBjYW4gcGFyc2UgdGhlIG9iamVjdCBsYXRlciAtIGl0J3MgbXVjaCBmYXN0ZXIgdGhhbiBsb2FkaW5nXHJcbiAgICAgICAgICAgIHRoaXMudGlsZW1hcHMuYWRkKGtleSwgdGlsZW1hcE9iamVjdCk7XHJcbiAgICAgICAgICAgIGxldCByZXNvdXJjZSA9IG5ldyBSZXNvdXJjZVJlZmVyZW5jZShrZXksIFJlc291cmNlVHlwZS5USUxFTUFQKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEdyYWIgdGhlIHRpbGVzZXQgaW1hZ2VzIHdlIG5lZWQgdG8gbG9hZCBhbmQgYWRkIHRoZW0gdG8gdGhlIGltYWdlbG9hZGluZyBxdWV1ZVxyXG4gICAgICAgICAgICBmb3IobGV0IHRpbGVzZXQgb2YgdGlsZW1hcE9iamVjdC50aWxlc2V0cyl7XHJcbiAgICAgICAgICAgICAgICBpZih0aWxlc2V0LmltYWdlKXtcclxuICAgICAgICAgICAgICAgICAgICBsZXQga2V5ID0gdGlsZXNldC5pbWFnZTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgcGF0aCA9IFN0cmluZ1V0aWxzLmdldFBhdGhGcm9tRmlsZVBhdGgocGF0aFRvVGlsZW1hcEpTT04pICsga2V5O1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9hZG9ubHlfaW1hZ2VMb2FkaW5nUXVldWUuZW5xdWV1ZSh7a2V5OiBrZXksIHBhdGg6IHBhdGgsIGlzRGVwZW5kZW5jeTogdHJ1ZX0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBBZGQgdGhpcyBpbWFnZSBhcyBhIGRlcGVuZGVuY3kgdG8gdGhlIHRpbGVtYXBcclxuICAgICAgICAgICAgICAgICAgICByZXNvdXJjZS5hZGREZXBlbmRlbmN5KG5ldyBSZXNvdXJjZVJlZmVyZW5jZShrZXksIFJlc291cmNlVHlwZS5JTUFHRSkpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmKHRpbGVzZXQudGlsZXMpe1xyXG4gICAgICAgICAgICAgICAgICAgIGZvcihsZXQgdGlsZSBvZiB0aWxlc2V0LnRpbGVzKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGtleSA9IHRpbGUuaW1hZ2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwYXRoID0gU3RyaW5nVXRpbHMuZ2V0UGF0aEZyb21GaWxlUGF0aChwYXRoVG9UaWxlbWFwSlNPTikgKyBrZXk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG9hZG9ubHlfaW1hZ2VMb2FkaW5nUXVldWUuZW5xdWV1ZSh7a2V5OiBrZXksIHBhdGg6IHBhdGgsIGlzRGVwZW5kZW5jeTogdHJ1ZX0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHRoaXMgaW1hZ2UgYXMgYSBkZXBlbmRlbmN5IHRvIHRoZSB0aWxlbWFwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc291cmNlLmFkZERlcGVuZGVuY3kobmV3IFJlc291cmNlUmVmZXJlbmNlKGtleSwgUmVzb3VyY2VUeXBlLklNQUdFKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBBZGQgdGhlIHJlc291cmNlIHJlZmVyZW5jZSB0byB0aGUgbGlzdCBvZiByZXNvdXJjZSB0byB1bmxvYWRcclxuICAgICAgICAgICAgdGhpcy5yZXNvdXJjZXNUb1VubG9hZC5wdXNoKHJlc291cmNlKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEZpbmlzaCBsb2FkaW5nXHJcbiAgICAgICAgICAgIHRoaXMuZmluaXNoTG9hZGluZ1RpbGVtYXAoY2FsbGJhY2tJZkxhc3QpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmluaXNoIGxvYWRpbmcgYSB0aWxlbWFwLiBDYWxscyB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gaWYgdGhpcyBpcyB0aGUgbGFzdCB0aWxlbWFwIGJlaW5nIGxvYWRlZFxyXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0byBjYWxsIGlmIHRoaXMgaXMgdGhlIGxhc3QgdGlsZW1hcCB0byBsb2FkXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgZmluaXNoTG9hZGluZ1RpbGVtYXAoY2FsbGJhY2s6IEZ1bmN0aW9uKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5sb2Fkb25seV90aWxlbWFwc0xvYWRlZCArPSAxO1xyXG5cclxuICAgICAgICBpZih0aGlzLmxvYWRvbmx5X3RpbGVtYXBzTG9hZGVkID09PSB0aGlzLmxvYWRvbmx5X3RpbGVtYXBzVG9Mb2FkKXtcclxuICAgICAgICAgICAgLy8gV2UncmUgZG9uZSBsb2FkaW5nIHRpbGVtYXBzXHJcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTG9hZHMgYWxsIHNwcml0ZXNoZWV0cyBjdXJyZW50bHkgaW4gdGhlIHNwcml0ZXNoZWV0IGxvYWRpbmcgcXVldWVcclxuICAgICAqIEBwYXJhbSBvbkZpbmlzaExvYWRpbmcgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGUgc3ByaXRlc2hlZXRzIGFyZSBkb25lIGxvYWRpbmdcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBsb2FkU3ByaXRlc2hlZXRzRnJvbVF1ZXVlKG9uRmluaXNoTG9hZGluZzogRnVuY3Rpb24pOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmxvYWRvbmx5X3Nwcml0ZXNoZWV0c1RvTG9hZCA9IHRoaXMubG9hZG9ubHlfc3ByaXRlc2hlZXRMb2FkaW5nUXVldWUuZ2V0U2l6ZSgpO1xyXG4gICAgICAgIHRoaXMubG9hZG9ubHlfc3ByaXRlc2hlZXRzTG9hZGVkID0gMDtcclxuXHJcbiAgICAgICAgLy8gSWYgbm8gaXRlbXMgdG8gbG9hZCwgd2UncmUgZmluaXNoZWRcclxuICAgICAgICBpZih0aGlzLmxvYWRvbmx5X3Nwcml0ZXNoZWV0c1RvTG9hZCA9PT0gMCl7XHJcbiAgICAgICAgICAgIG9uRmluaXNoTG9hZGluZygpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB3aGlsZSh0aGlzLmxvYWRvbmx5X3Nwcml0ZXNoZWV0TG9hZGluZ1F1ZXVlLmhhc0l0ZW1zKCkpe1xyXG4gICAgICAgICAgICBsZXQgc3ByaXRlc2hlZXQgPSB0aGlzLmxvYWRvbmx5X3Nwcml0ZXNoZWV0TG9hZGluZ1F1ZXVlLmRlcXVldWUoKTtcclxuICAgICAgICAgICAgdGhpcy5sb2FkU3ByaXRlc2hlZXQoc3ByaXRlc2hlZXQua2V5LCBzcHJpdGVzaGVldC5wYXRoLCBvbkZpbmlzaExvYWRpbmcpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIExvYWRzIGEgc2luZ3VsYXIgc3ByaXRlc2hlZXQgXHJcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIHNwcml0ZXNoZWV0IHRvIGxvYWRcclxuICAgICAqIEBwYXJhbSBwYXRoVG9TcHJpdGVzaGVldEpTT04gVGhlIHBhdGggdG8gdGhlIHNwcml0ZXNoZWV0IEpTT04gZmlsZVxyXG4gICAgICogQHBhcmFtIGNhbGxiYWNrSWZMYXN0IFRoZSBmdW5jdGlvbiB0byBjYWxsIGlmIHRoaXMgaXMgdGhlIGxhc3Qgc3ByaXRlc2hlZXRcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBsb2FkU3ByaXRlc2hlZXQoa2V5OiBzdHJpbmcsIHBhdGhUb1Nwcml0ZXNoZWV0SlNPTjogc3RyaW5nLCBjYWxsYmFja0lmTGFzdDogRnVuY3Rpb24pOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmxvYWRUZXh0RmlsZShwYXRoVG9TcHJpdGVzaGVldEpTT04sIChmaWxlVGV4dDogc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBzcHJpdGVzaGVldCA9IDxTcHJpdGVzaGVldD5KU09OLnBhcnNlKGZpbGVUZXh0KTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIFdlIGNhbiBwYXJzZSB0aGUgb2JqZWN0IGxhdGVyIC0gaXQncyBtdWNoIGZhc3RlciB0aGFuIGxvYWRpbmdcclxuICAgICAgICAgICAgdGhpcy5zcHJpdGVzaGVldHMuYWRkKGtleSwgc3ByaXRlc2hlZXQpO1xyXG5cclxuICAgICAgICAgICAgbGV0IHJlc291cmNlID0gbmV3IFJlc291cmNlUmVmZXJlbmNlKGtleSwgUmVzb3VyY2VUeXBlLlNQUklURVNIRUVUKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEdyYWIgdGhlIGltYWdlIHdlIG5lZWQgdG8gbG9hZCBhbmQgYWRkIGl0IHRvIHRoZSBpbWFnZWxvYWRpbmcgcXVldWVcclxuICAgICAgICAgICAgbGV0IHBhdGggPSBTdHJpbmdVdGlscy5nZXRQYXRoRnJvbUZpbGVQYXRoKHBhdGhUb1Nwcml0ZXNoZWV0SlNPTikgKyBzcHJpdGVzaGVldC5zcHJpdGVTaGVldEltYWdlO1xyXG4gICAgICAgICAgICB0aGlzLmxvYWRvbmx5X2ltYWdlTG9hZGluZ1F1ZXVlLmVucXVldWUoe2tleTogc3ByaXRlc2hlZXQubmFtZSwgcGF0aDogcGF0aCwgaXNEZXBlbmRlbmN5OiB0cnVlfSk7XHJcblxyXG4gICAgICAgICAgICByZXNvdXJjZS5hZGREZXBlbmRlbmN5KG5ldyBSZXNvdXJjZVJlZmVyZW5jZShzcHJpdGVzaGVldC5uYW1lLCBSZXNvdXJjZVR5cGUuSU1BR0UpKTtcclxuICAgICAgICAgICAgdGhpcy5yZXNvdXJjZXNUb1VubG9hZC5wdXNoKHJlc291cmNlKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEZpbmlzaCBsb2FkaW5nXHJcbiAgICAgICAgICAgIHRoaXMuZmluaXNoTG9hZGluZ1Nwcml0ZXNoZWV0KGNhbGxiYWNrSWZMYXN0KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEZpbmlzaCBsb2FkaW5nIGEgc3ByaXRlc2hlZXQuIENhbGxzIHRoZSBjYWxsYmFjayBmdW5jdGlvbiBpZiB0aGlzIGlzIHRoZSBsYXN0IHNwcml0ZXNoZWV0IGJlaW5nIGxvYWRlZFxyXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0byBjYWxsIGlmIHRoaXMgaXMgdGhlIGxhc3Qgc3ByaXRlc2hlZXQgdG8gbG9hZFxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGZpbmlzaExvYWRpbmdTcHJpdGVzaGVldChjYWxsYmFjazogRnVuY3Rpb24pOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmxvYWRvbmx5X3Nwcml0ZXNoZWV0c0xvYWRlZCArPSAxO1xyXG5cclxuICAgICAgICBpZih0aGlzLmxvYWRvbmx5X3Nwcml0ZXNoZWV0c0xvYWRlZCA9PT0gdGhpcy5sb2Fkb25seV9zcHJpdGVzaGVldHNUb0xvYWQpe1xyXG4gICAgICAgICAgICAvLyBXZSdyZSBkb25lIGxvYWRpbmcgc3ByaXRlc2hlZXRzXHJcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTG9hZHMgYWxsIGltYWdlcyBjdXJyZW50bHkgaW4gdGhlIGltYWdlIGxvYWRpbmcgcXVldWVcclxuICAgICAqIEBwYXJhbSBvbkZpbmlzaExvYWRpbmcgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGVyZSBhcmUgbm8gbW9yZSBpbWFnZXMgdG8gbG9hZFxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGxvYWRJbWFnZXNGcm9tUXVldWUob25GaW5pc2hMb2FkaW5nOiBGdW5jdGlvbik6IHZvaWQge1xyXG4gICAgICAgIHRoaXMubG9hZG9ubHlfaW1hZ2VzVG9Mb2FkID0gdGhpcy5sb2Fkb25seV9pbWFnZUxvYWRpbmdRdWV1ZS5nZXRTaXplKCk7XHJcbiAgICAgICAgdGhpcy5sb2Fkb25seV9pbWFnZXNMb2FkZWQgPSAwO1xyXG5cclxuICAgICAgICAvLyBJZiBubyBpdGVtcyB0byBsb2FkLCB3ZSdyZSBmaW5pc2hlZFxyXG4gICAgICAgIGlmKHRoaXMubG9hZG9ubHlfaW1hZ2VzVG9Mb2FkID09PSAwKXtcclxuICAgICAgICAgICAgb25GaW5pc2hMb2FkaW5nKCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHdoaWxlKHRoaXMubG9hZG9ubHlfaW1hZ2VMb2FkaW5nUXVldWUuaGFzSXRlbXMoKSl7XHJcbiAgICAgICAgICAgIGxldCBpbWFnZSA9IHRoaXMubG9hZG9ubHlfaW1hZ2VMb2FkaW5nUXVldWUuZGVxdWV1ZSgpO1xyXG4gICAgICAgICAgICB0aGlzLmxvYWRJbWFnZShpbWFnZS5rZXksIGltYWdlLnBhdGgsIGltYWdlLmlzRGVwZW5kZW5jeSwgb25GaW5pc2hMb2FkaW5nKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMb2FkcyBhIHNpbmd1bGFyIGltYWdlXHJcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIGltYWdlIHRvIGxvYWRcclxuICAgICAqIEBwYXJhbSBwYXRoIFRoZSBwYXRoIHRvIHRoZSBpbWFnZSB0byBsb2FkXHJcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2tJZkxhc3QgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgaWYgdGhpcyBpcyB0aGUgbGFzdCBpbWFnZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgbG9hZEltYWdlKGtleTogc3RyaW5nLCBwYXRoOiBzdHJpbmcsIGlzRGVwZW5kZW5jeTogYm9vbGVhbiwgY2FsbGJhY2tJZkxhc3Q6IEZ1bmN0aW9uKTogdm9pZCB7XHJcbiAgICAgICAgdmFyIGltYWdlID0gbmV3IEltYWdlKCk7XHJcblxyXG4gICAgICAgIGltYWdlLm9ubG9hZCA9ICgpID0+IHtcclxuICAgICAgICAgICAgLy8gQWRkIHRvIGxvYWRlZCBpbWFnZXNcclxuICAgICAgICAgICAgdGhpcy5pbWFnZXMuYWRkKGtleSwgaW1hZ2UpO1xyXG5cclxuICAgICAgICAgICAgLy8gSWYgbm90IGEgZGVwZW5kZW5jeSwgcHVzaCBpdCB0byB0aGUgdW5sb2FkIGxpc3QuIE90aGVyd2lzZSBpdCdzIG1hbmFnZWQgYnkgc29tZXRoaW5nIGVsc2VcclxuICAgICAgICAgICAgaWYoIWlzRGVwZW5kZW5jeSl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlc291cmNlc1RvVW5sb2FkLnB1c2gobmV3IFJlc291cmNlUmVmZXJlbmNlKGtleSwgUmVzb3VyY2VUeXBlLklNQUdFKSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIElmIFdlYkdMIGlzIGFjdGl2ZSwgY3JlYXRlIGEgdGV4dHVyZVxyXG4gICAgICAgICAgICBpZih0aGlzLmdsX1dlYkdMQWN0aXZlKXtcclxuICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlV2ViR0xUZXh0dXJlKGtleSwgaW1hZ2UpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBGaW5pc2ggaW1hZ2UgbG9hZFxyXG4gICAgICAgICAgICB0aGlzLmZpbmlzaExvYWRpbmdJbWFnZShjYWxsYmFja0lmTGFzdCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbWFnZS5zcmMgPSBwYXRoO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmluaXNoIGxvYWRpbmcgYW4gaW1hZ2UuIElmIHRoaXMgaXMgdGhlIGxhc3QgaW1hZ2UsIGl0IGNhbGxzIHRoZSBjYWxsYmFjayBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0byBjYWxsIGlmIHRoaXMgaXMgdGhlIGxhc3QgaW1hZ2VcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBmaW5pc2hMb2FkaW5nSW1hZ2UoY2FsbGJhY2s6IEZ1bmN0aW9uKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5sb2Fkb25seV9pbWFnZXNMb2FkZWQgKz0gMTtcclxuXHJcbiAgICAgICAgaWYodGhpcy5sb2Fkb25seV9pbWFnZXNMb2FkZWQgPT09IHRoaXMubG9hZG9ubHlfaW1hZ2VzVG9Mb2FkICl7XHJcbiAgICAgICAgICAgIC8vIFdlJ3JlIGRvbmUgbG9hZGluZyBpbWFnZXNcclxuICAgICAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMb2FkcyBhbGwgYXVkaW8gY3VycmVudGx5IGluIHRoZSB0aWxlbWFwIGxvYWRpbmcgcXVldWVcclxuICAgICAqIEBwYXJhbSBvbkZpbmlzaExvYWRpbmcgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aWxlbWFwcyBhcmUgZG9uZSBsb2FkaW5nXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgbG9hZEF1ZGlvRnJvbVF1ZXVlKG9uRmluaXNoTG9hZGluZzogRnVuY3Rpb24pe1xyXG4gICAgICAgIHRoaXMubG9hZG9ubHlfYXVkaW9Ub0xvYWQgPSB0aGlzLmxvYWRvbmx5X2F1ZGlvTG9hZGluZ1F1ZXVlLmdldFNpemUoKTtcclxuICAgICAgICB0aGlzLmxvYWRvbmx5X2F1ZGlvTG9hZGVkID0gMDtcclxuXHJcbiAgICAgICAgLy8gSWYgbm8gaXRlbXMgdG8gbG9hZCwgd2UncmUgZmluaXNoZWRcclxuICAgICAgICBpZih0aGlzLmxvYWRvbmx5X2F1ZGlvVG9Mb2FkID09PSAwKXtcclxuICAgICAgICAgICAgb25GaW5pc2hMb2FkaW5nKCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHdoaWxlKHRoaXMubG9hZG9ubHlfYXVkaW9Mb2FkaW5nUXVldWUuaGFzSXRlbXMoKSl7XHJcbiAgICAgICAgICAgIGxldCBhdWRpbyA9IHRoaXMubG9hZG9ubHlfYXVkaW9Mb2FkaW5nUXVldWUuZGVxdWV1ZSgpO1xyXG4gICAgICAgICAgICB0aGlzLmxvYWRBdWRpbyhhdWRpby5rZXksIGF1ZGlvLnBhdGgsIG9uRmluaXNoTG9hZGluZyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTG9hZCBhIHNpbmd1bGFyIGF1ZGlvIGZpbGVcclxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSB0byB0aGUgYXVkaW8gZmlsZSB0byBsb2FkXHJcbiAgICAgKiBAcGFyYW0gcGF0aCBUaGUgcGF0aCB0byB0aGUgYXVkaW8gZmlsZSB0byBsb2FkXHJcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2tJZkxhc3QgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgaWYgdGhpcyBpcyB0aGUgbGFzdCBhdWRpbyBmaWxlIHRvIGxvYWRcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBsb2FkQXVkaW8oa2V5OiBzdHJpbmcsIHBhdGg6IHN0cmluZywgY2FsbGJhY2tJZkxhc3Q6IEZ1bmN0aW9uKTogdm9pZCB7XHJcbiAgICAgICAgbGV0IGF1ZGlvQ3R4ID0gQXVkaW9NYW5hZ2VyLmdldEluc3RhbmNlKCkuZ2V0QXVkaW9Db250ZXh0KCk7XHJcblxyXG4gICAgICAgIGxldCByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XHJcbiAgICAgICAgcmVxdWVzdC5vcGVuKCdHRVQnLCBwYXRoLCB0cnVlKTtcclxuICAgICAgICByZXF1ZXN0LnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XHJcblxyXG4gICAgICAgIHJlcXVlc3Qub25sb2FkID0gKCkgPT4ge1xyXG4gICAgICAgICAgICBhdWRpb0N0eC5kZWNvZGVBdWRpb0RhdGEocmVxdWVzdC5yZXNwb25zZSwgKGJ1ZmZlcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgLy8gQWRkIHRvIGxpc3Qgb2YgYXVkaW8gYnVmZmVyc1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hdWRpb0J1ZmZlcnMuYWRkKGtleSwgYnVmZmVyKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVzb3VyY2VzVG9VbmxvYWQucHVzaChuZXcgUmVzb3VyY2VSZWZlcmVuY2Uoa2V5LCBSZXNvdXJjZVR5cGUuQVVESU8pKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBGaW5pc2ggbG9hZGluZyBzb3VuZFxyXG4gICAgICAgICAgICAgICAgdGhpcy5maW5pc2hMb2FkaW5nQXVkaW8oY2FsbGJhY2tJZkxhc3QpO1xyXG4gICAgICAgICAgICB9LCAoZXJyb3IpID0+e1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgXCJFcnJvciBsb2FkaW5nIHNvdW5kXCI7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXF1ZXN0LnNlbmQoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEZpbmlzaCBsb2FkaW5nIGFuIGF1ZGlvIGZpbGUuIENhbGxzIHRoZSBjYWxsYmFjayBmdW5jdG9uIGlmIHRoaXMgaXMgdGhlIGxhc3QgYXVkaW8gc2FtcGxlIGJlaW5nIGxvYWRlZC5cclxuICAgICAqIEBwYXJhbSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdG8gY2FsbCBpZiB0aGlzIGlzIHRoZSBsYXN0IGF1ZGlvIGZpbGUgdG8gbG9hZFxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGZpbmlzaExvYWRpbmdBdWRpbyhjYWxsYmFjazogRnVuY3Rpb24pOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmxvYWRvbmx5X2F1ZGlvTG9hZGVkICs9IDE7XHJcblxyXG4gICAgICAgIGlmKHRoaXMubG9hZG9ubHlfYXVkaW9Mb2FkZWQgPT09IHRoaXMubG9hZG9ubHlfYXVkaW9Ub0xvYWQpe1xyXG4gICAgICAgICAgICAvLyBXZSdyZSBkb25lIGxvYWRpbmcgYXVkaW9cclxuICAgICAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMb2FkcyBhbGwgb2JqZWN0cyBjdXJyZW50bHkgaW4gdGhlIG9iamVjdCBsb2FkaW5nIHF1ZXVlXHJcbiAgICAgKiBAcGFyYW0gb25GaW5pc2hMb2FkaW5nIFRoZSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhlcmUgYXJlIG5vIG1vcmUgb2JqZWN0cyB0byBsb2FkXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgbG9hZE9iamVjdHNGcm9tUXVldWUob25GaW5pc2hMb2FkaW5nOiBGdW5jdGlvbik6IHZvaWQge1xyXG4gICAgICAgIHRoaXMubG9hZG9ubHlfanNvblRvTG9hZCA9IHRoaXMubG9hZG9ubHlfanNvbkxvYWRpbmdRdWV1ZS5nZXRTaXplKCk7XHJcbiAgICAgICAgdGhpcy5sb2Fkb25seV9qc29uTG9hZGVkID0gMDtcclxuXHJcbiAgICAgICAgLy8gSWYgbm8gaXRlbXMgdG8gbG9hZCwgd2UncmUgZmluaXNoZWRcclxuICAgICAgICBpZih0aGlzLmxvYWRvbmx5X2pzb25Ub0xvYWQgPT09IDApe1xyXG4gICAgICAgICAgICBvbkZpbmlzaExvYWRpbmcoKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgd2hpbGUodGhpcy5sb2Fkb25seV9qc29uTG9hZGluZ1F1ZXVlLmhhc0l0ZW1zKCkpe1xyXG4gICAgICAgICAgICBsZXQgb2JqID0gdGhpcy5sb2Fkb25seV9qc29uTG9hZGluZ1F1ZXVlLmRlcXVldWUoKTtcclxuICAgICAgICAgICAgdGhpcy5sb2FkT2JqZWN0KG9iai5rZXksIG9iai5wYXRoLCBvbkZpbmlzaExvYWRpbmcpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIExvYWRzIGEgc2luZ3VsYXIgb2JqZWN0XHJcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIG9iamVjdCB0byBsb2FkXHJcbiAgICAgKiBAcGFyYW0gcGF0aCBUaGUgcGF0aCB0byB0aGUgb2JqZWN0IHRvIGxvYWRcclxuICAgICAqIEBwYXJhbSBjYWxsYmFja0lmTGFzdCBUaGUgZnVuY3Rpb24gdG8gY2FsbCBpZiB0aGlzIGlzIHRoZSBsYXN0IG9iamVjdFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgbG9hZE9iamVjdChrZXk6IHN0cmluZywgcGF0aDogc3RyaW5nLCBjYWxsYmFja0lmTGFzdDogRnVuY3Rpb24pOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmxvYWRUZXh0RmlsZShwYXRoLCAoZmlsZVRleHQ6IHN0cmluZykgPT4ge1xyXG4gICAgICAgICAgICBsZXQgb2JqID0gSlNPTi5wYXJzZShmaWxlVGV4dCk7XHJcbiAgICAgICAgICAgIHRoaXMuanNvbk9iamVjdHMuYWRkKGtleSwgb2JqKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMucmVzb3VyY2VzVG9VbmxvYWQucHVzaChuZXcgUmVzb3VyY2VSZWZlcmVuY2Uoa2V5LCBSZXNvdXJjZVR5cGUuSlNPTikpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5maW5pc2hMb2FkaW5nT2JqZWN0KGNhbGxiYWNrSWZMYXN0KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEZpbmlzaCBsb2FkaW5nIGFuIG9iamVjdC4gSWYgdGhpcyBpcyB0aGUgbGFzdCBvYmplY3QsIGl0IGNhbGxzIHRoZSBjYWxsYmFjayBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0byBjYWxsIGlmIHRoaXMgaXMgdGhlIGxhc3Qgb2JqZWN0XHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgZmluaXNoTG9hZGluZ09iamVjdChjYWxsYmFjazogRnVuY3Rpb24pOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmxvYWRvbmx5X2pzb25Mb2FkZWQgKz0gMTtcclxuXHJcbiAgICAgICAgaWYodGhpcy5sb2Fkb25seV9qc29uTG9hZGVkID09PSB0aGlzLmxvYWRvbmx5X2pzb25Ub0xvYWQpe1xyXG4gICAgICAgICAgICAvLyBXZSdyZSBkb25lIGxvYWRpbmcgb2JqZWN0c1xyXG4gICAgICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKiAjIyMjIyMjIyMjIFdFQkdMIFNQRUNJRklDIEZVTkNUSU9OUyAjIyMjIyMjIyMjICovXHJcblxyXG4gICAgcHVibGljIGdldFRleHR1cmUoa2V5OiBzdHJpbmcpOiBudW1iZXIge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdsX1RleHR1cmVzLmdldChrZXkpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRTaGFkZXJQcm9ncmFtKGtleTogc3RyaW5nKTogV2ViR0xQcm9ncmFtIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nbF9TaGFkZXJQcm9ncmFtcy5nZXQoa2V5KS5wcm9ncmFtO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRCdWZmZXIoa2V5OiBzdHJpbmcpOiBXZWJHTEJ1ZmZlciB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2xfQnVmZmVycy5nZXQoa2V5KTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGNyZWF0ZVdlYkdMVGV4dHVyZShpbWFnZUtleTogc3RyaW5nLCBpbWFnZTogSFRNTEltYWdlRWxlbWVudCk6IHZvaWQge1xyXG4gICAgICAgIC8vIEdldCB0aGUgdGV4dHVyZSBJRFxyXG4gICAgICAgIGNvbnN0IHRleHR1cmVJRCA9IHRoaXMuZ2V0VGV4dHVyZUlEKHRoaXMuZ2xfTmV4dFRleHR1cmVJRCk7XHJcblxyXG4gICAgICAgIC8vIENyZWF0ZSB0aGUgdGV4dHVyZVxyXG4gICAgICAgIGNvbnN0IHRleHR1cmUgPSB0aGlzLmdsLmNyZWF0ZVRleHR1cmUoKTtcclxuXHJcbiAgICAgICAgLy8gU2V0IHVwIHRoZSB0ZXh0dXJlXHJcbiAgICAgICAgLy8gRW5hYmxlIHRleHR1cmUwXHJcbiAgICAgICAgdGhpcy5nbC5hY3RpdmVUZXh0dXJlKHRleHR1cmVJRCk7XHJcblxyXG4gICAgICAgIC8vIEJpbmQgb3VyIHRleHR1cmUgdG8gdGV4dHVyZSAwXHJcbiAgICAgICAgdGhpcy5nbC5iaW5kVGV4dHVyZSh0aGlzLmdsLlRFWFRVUkVfMkQsIHRleHR1cmUpO1xyXG5cclxuICAgICAgICAvLyBTZXQgdGhlIHRleHR1cmUgcGFyYW1ldGVyc1xyXG4gICAgICAgIHRoaXMuZ2wudGV4UGFyYW1ldGVyaSh0aGlzLmdsLlRFWFRVUkVfMkQsIHRoaXMuZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCB0aGlzLmdsLkxJTkVBUik7XHJcbiAgICAgICAgdGhpcy5nbC50ZXhQYXJhbWV0ZXJpKHRoaXMuZ2wuVEVYVFVSRV8yRCwgdGhpcy5nbC5URVhUVVJFX1dSQVBfUywgdGhpcy5nbC5DTEFNUF9UT19FREdFKTtcclxuICAgICAgICB0aGlzLmdsLnRleFBhcmFtZXRlcmkodGhpcy5nbC5URVhUVVJFXzJELCB0aGlzLmdsLlRFWFRVUkVfV1JBUF9ULCB0aGlzLmdsLkNMQU1QX1RPX0VER0UpO1xyXG5cclxuICAgICAgICAvLyBTZXQgdGhlIHRleHR1cmUgaW1hZ2VcclxuICAgICAgICB0aGlzLmdsLnRleEltYWdlMkQodGhpcy5nbC5URVhUVVJFXzJELCAwLCB0aGlzLmdsLlJHQkEsIHRoaXMuZ2wuUkdCQSwgdGhpcy5nbC5VTlNJR05FRF9CWVRFLCBpbWFnZSk7XHJcblxyXG4gICAgICAgIC8vIEFkZCB0aGUgdGV4dHVyZSB0byBvdXIgbWFwIHdpdGggdGhlIHNhbWUga2V5IGFzIHRoZSBpbWFnZVxyXG4gICAgICAgIHRoaXMuZ2xfVGV4dHVyZXMuYWRkKGltYWdlS2V5LCB0aGlzLmdsX05leHRUZXh0dXJlSUQpO1xyXG5cclxuICAgICAgICAvLyBJbmNyZW1lbnQgdGhlIGtleVxyXG4gICAgICAgIHRoaXMuZ2xfTmV4dFRleHR1cmVJRCArPSAxO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgZ2V0VGV4dHVyZUlEKGlkOiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgICAgIC8vIFN0YXJ0IHdpdGggOSBjYXNlcyAtIHRoaXMgY2FuIGJlIGV4cGFuZGVkIGlmIG5lZWRlZCwgYnV0IGZvciB0aGUgYmVzdCBwZXJmb3JtYW5jZSxcclxuICAgICAgICAvLyBUZXh0dXJlcyBzaG91bGQgYmUgc3RpdGNoZWQgaW50byBhbiBhdGxhc1xyXG4gICAgICAgIHN3aXRjaChpZCl7XHJcbiAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIHRoaXMuZ2wuVEVYVFVSRTA7XHJcbiAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIHRoaXMuZ2wuVEVYVFVSRTE7XHJcbiAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIHRoaXMuZ2wuVEVYVFVSRTI7XHJcbiAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuIHRoaXMuZ2wuVEVYVFVSRTM7XHJcbiAgICAgICAgICAgIGNhc2UgNDogcmV0dXJuIHRoaXMuZ2wuVEVYVFVSRTQ7XHJcbiAgICAgICAgICAgIGNhc2UgNTogcmV0dXJuIHRoaXMuZ2wuVEVYVFVSRTU7XHJcbiAgICAgICAgICAgIGNhc2UgNjogcmV0dXJuIHRoaXMuZ2wuVEVYVFVSRTY7XHJcbiAgICAgICAgICAgIGNhc2UgNzogcmV0dXJuIHRoaXMuZ2wuVEVYVFVSRTc7XHJcbiAgICAgICAgICAgIGNhc2UgODogcmV0dXJuIHRoaXMuZ2wuVEVYVFVSRTg7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6IHJldHVybiB0aGlzLmdsLlRFWFRVUkU5O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgY3JlYXRlQnVmZmVyKGtleTogc3RyaW5nKTogdm9pZCB7XHJcbiAgICAgICAgaWYodGhpcy5nbF9XZWJHTEFjdGl2ZSl7XHJcbiAgICAgICAgICAgIGxldCBidWZmZXIgPSB0aGlzLmdsLmNyZWF0ZUJ1ZmZlcigpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5nbF9CdWZmZXJzLmFkZChrZXksIGJ1ZmZlcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRW5xdWV1ZXMgbG9hZGluZyBvZiBhIG5ldyBzaGFkZXIgcHJvZ3JhbVxyXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBzaGFkZXIgcHJvZ3JhbVxyXG4gICAgICogQHBhcmFtIHZTaGFkZXJGaWxlcGF0aCBcclxuICAgICAqIEBwYXJhbSBmU2hhZGVyRmlsZXBhdGggXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzaGFkZXIoa2V5OiBzdHJpbmcsIHZTaGFkZXJGaWxlcGF0aDogc3RyaW5nLCBmU2hhZGVyRmlsZXBhdGg6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgICAgIGxldCBzcGxpdFBhdGggPSB2U2hhZGVyRmlsZXBhdGguc3BsaXQoXCIuXCIpO1xyXG4gICAgICAgIGxldCBlbmQgPSBzcGxpdFBhdGhbc3BsaXRQYXRoLmxlbmd0aCAtIDFdO1xyXG5cclxuICAgICAgICBpZihlbmQgIT09IFwidnNoYWRlclwiKXtcclxuICAgICAgICAgICAgdGhyb3cgYCR7dlNoYWRlckZpbGVwYXRofSBpcyBub3QgYSB2YWxpZCB2ZXJ0ZXggc2hhZGVyIC0gbXVzdCBlbmQgaW4gXCIudnNoYWRlcmA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzcGxpdFBhdGggPSBmU2hhZGVyRmlsZXBhdGguc3BsaXQoXCIuXCIpO1xyXG4gICAgICAgIGVuZCA9IHNwbGl0UGF0aFtzcGxpdFBhdGgubGVuZ3RoIC0gMV07XHJcblxyXG4gICAgICAgIGlmKGVuZCAhPT0gXCJmc2hhZGVyXCIpe1xyXG4gICAgICAgICAgICB0aHJvdyBgJHtmU2hhZGVyRmlsZXBhdGh9IGlzIG5vdCBhIHZhbGlkIHZlcnRleCBzaGFkZXIgLSBtdXN0IGVuZCBpbiBcIi5mc2hhZGVyYDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBwYXRocyA9IG5ldyBLZXlQYXRoX1NoYWRlcigpO1xyXG4gICAgICAgIHBhdGhzLmtleSA9IGtleTtcclxuICAgICAgICBwYXRocy52cGF0aCA9IHZTaGFkZXJGaWxlcGF0aDtcclxuICAgICAgICBwYXRocy5mcGF0aCA9IGZTaGFkZXJGaWxlcGF0aDtcclxuXHJcbiAgICAgICAgdGhpcy5sb2Fkb25seV9nbF9TaGFkZXJMb2FkaW5nUXVldWUuZW5xdWV1ZShwYXRocyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUZWxscyB0aGUgcmVzb3VyY2UgbWFuYWdlciB0byBrZWVwIHRoaXMgcmVzb3VyY2VcclxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgcmVzb3VyY2VcclxuICAgICAqL1xyXG4gICAgIHB1YmxpYyBrZWVwU2hhZGVyKGtleTogc3RyaW5nKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5rZWVwUmVzb3VyY2Uoa2V5LCBSZXNvdXJjZVR5cGUuSU1BR0UpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgZ2xfTG9hZFNoYWRlcnNGcm9tUXVldWUob25GaW5pc2hMb2FkaW5nOiBGdW5jdGlvbik6IHZvaWQge1xyXG4gICAgICAgIHRoaXMubG9hZG9ubHlfZ2xfU2hhZGVyUHJvZ3JhbXNUb0xvYWQgPSB0aGlzLmxvYWRvbmx5X2dsX1NoYWRlckxvYWRpbmdRdWV1ZS5nZXRTaXplKCk7XHJcbiAgICAgICAgdGhpcy5sb2Fkb25seV9nbF9TaGFkZXJQcm9ncmFtc0xvYWRlZCA9IDA7XHJcblxyXG4gICAgICAgIC8vIElmIHdlYkdMIGlzbidhY3RpdmUgb3IgdGhlcmUgYXJlIG5vIGl0ZW1zIHRvIGxvYWQsIHdlJ3JlIGZpbmlzaGVkXHJcbiAgICAgICAgaWYoIXRoaXMuZ2xfV2ViR0xBY3RpdmUgfHwgdGhpcy5sb2Fkb25seV9nbF9TaGFkZXJQcm9ncmFtc1RvTG9hZCA9PT0gMCl7XHJcbiAgICAgICAgICAgIG9uRmluaXNoTG9hZGluZygpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB3aGlsZSh0aGlzLmxvYWRvbmx5X2dsX1NoYWRlckxvYWRpbmdRdWV1ZS5oYXNJdGVtcygpKXtcclxuICAgICAgICAgICAgbGV0IHNoYWRlciA9IHRoaXMubG9hZG9ubHlfZ2xfU2hhZGVyTG9hZGluZ1F1ZXVlLmRlcXVldWUoKTtcclxuICAgICAgICAgICAgdGhpcy5nbF9Mb2FkU2hhZGVyKHNoYWRlci5rZXksIHNoYWRlci52cGF0aCwgc2hhZGVyLmZwYXRoLCBvbkZpbmlzaExvYWRpbmcpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGdsX0xvYWRTaGFkZXIoa2V5OiBzdHJpbmcsIHZwYXRoOiBzdHJpbmcsIGZwYXRoOiBzdHJpbmcsIGNhbGxiYWNrSWZMYXN0OiBGdW5jdGlvbik6IHZvaWQge1xyXG4gICAgICAgIHRoaXMubG9hZFRleHRGaWxlKHZwYXRoLCAodkZpbGVUZXh0OiBzdHJpbmcpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgdlNoYWRlciA9IHZGaWxlVGV4dDtcclxuXHJcbiAgICAgICAgICAgIHRoaXMubG9hZFRleHRGaWxlKGZwYXRoLCAoZkZpbGVUZXh0OiBzdHJpbmcpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGZTaGFkZXIgPSBmRmlsZVRleHRcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IHRoZSBwcm9ncmFtIGFuZCBzaGFkZXJzXHJcbiAgICAgICAgICAgICAgICBjb25zdCBbc2hhZGVyUHJvZ3JhbSwgdmVydGV4U2hhZGVyLCBmcmFnbWVudFNoYWRlcl0gPSB0aGlzLmNyZWF0ZVNoYWRlclByb2dyYW0odlNoYWRlciwgZlNoYWRlcik7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGEgd3JhcHBlciB0eXBlXHJcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9ncmFtV3JhcHBlciA9IG5ldyBXZWJHTFByb2dyYW1UeXBlKCk7XHJcbiAgICAgICAgICAgICAgICBwcm9ncmFtV3JhcHBlci5wcm9ncmFtID0gc2hhZGVyUHJvZ3JhbTtcclxuICAgICAgICAgICAgICAgIHByb2dyYW1XcmFwcGVyLnZlcnRleFNoYWRlciA9IHZlcnRleFNoYWRlcjtcclxuICAgICAgICAgICAgICAgIHByb2dyYW1XcmFwcGVyLmZyYWdtZW50U2hhZGVyID0gZnJhZ21lbnRTaGFkZXI7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQWRkIHRvIG91ciBtYXBcclxuICAgICAgICAgICAgICAgIHRoaXMuZ2xfU2hhZGVyUHJvZ3JhbXMuYWRkKGtleSwgcHJvZ3JhbVdyYXBwZXIpO1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMucmVzb3VyY2VzVG9VbmxvYWQucHVzaChuZXcgUmVzb3VyY2VSZWZlcmVuY2Uoa2V5LCBSZXNvdXJjZVR5cGUuU0hBREVSKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRmluaXNoIGxvYWRpbmdcclxuICAgICAgICAgICAgICAgIHRoaXMuZ2xfRmluaXNoTG9hZGluZ1NoYWRlcihjYWxsYmFja0lmTGFzdCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgZ2xfRmluaXNoTG9hZGluZ1NoYWRlcihjYWxsYmFjazogRnVuY3Rpb24pOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmxvYWRvbmx5X2dsX1NoYWRlclByb2dyYW1zTG9hZGVkICs9IDE7XHJcblxyXG4gICAgICAgIGlmKHRoaXMubG9hZG9ubHlfZ2xfU2hhZGVyUHJvZ3JhbXNMb2FkZWQgPT09IHRoaXMubG9hZG9ubHlfZ2xfU2hhZGVyUHJvZ3JhbXNUb0xvYWQpe1xyXG4gICAgICAgICAgICAvLyBXZSdyZSBkb25lIGxvYWRpbmcgc2hhZGVyc1xyXG4gICAgICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGNyZWF0ZVNoYWRlclByb2dyYW0odlNoYWRlclNvdXJjZTogc3RyaW5nLCBmU2hhZGVyU291cmNlOiBzdHJpbmcpe1xyXG4gICAgICAgIGNvbnN0IHZlcnRleFNoYWRlciA9IHRoaXMubG9hZFZlcnRleFNoYWRlcih2U2hhZGVyU291cmNlKTtcclxuICAgICAgICBjb25zdCBmcmFnbWVudFNoYWRlciA9IHRoaXMubG9hZEZyYWdtZW50U2hhZGVyKGZTaGFkZXJTb3VyY2UpO1xyXG4gICAgXHJcbiAgICAgICAgaWYodmVydGV4U2hhZGVyID09PSBudWxsIHx8IGZyYWdtZW50U2hhZGVyID09PSBudWxsKXtcclxuICAgICAgICAgICAgLy8gV2UgaGFkIGEgcHJvYmxlbSBpbnRpYWxpemluZyAtIGVycm9yXHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIFxyXG4gICAgICAgIC8vIENyZWF0ZSBhIHNoYWRlciBwcm9ncmFtXHJcbiAgICAgICAgY29uc3QgcHJvZ3JhbSA9IHRoaXMuZ2wuY3JlYXRlUHJvZ3JhbSgpO1xyXG4gICAgICAgIGlmKCFwcm9ncmFtKSB7XHJcbiAgICAgICAgICAgIC8vIEVycm9yIGNyZWF0aW5nXHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkZhaWxlZCB0byBjcmVhdGUgcHJvZ3JhbVwiKTtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgXHJcbiAgICAgICAgLy8gQXR0YWNoIG91ciB2ZXJ0ZXggYW5kIGZyYWdtZW50IHNoYWRlclxyXG4gICAgICAgIHRoaXMuZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIHZlcnRleFNoYWRlcik7XHJcbiAgICAgICAgdGhpcy5nbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgZnJhZ21lbnRTaGFkZXIpO1xyXG4gICAgXHJcbiAgICAgICAgLy8gTGlua1xyXG4gICAgICAgIHRoaXMuZ2wubGlua1Byb2dyYW0ocHJvZ3JhbSk7XHJcbiAgICAgICAgaWYoIXRoaXMuZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCB0aGlzLmdsLkxJTktfU1RBVFVTKSl7XHJcbiAgICAgICAgICAgIC8vIEVycm9yIGxpbmtpbmdcclxuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmdsLmdldFByb2dyYW1JbmZvTG9nKHByb2dyYW0pO1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJGYWlsZWQgdG8gbGluayBwcm9ncmFtOiBcIiArIGVycm9yKTtcclxuICAgIFxyXG4gICAgICAgICAgICAvLyBDbGVhbiB1cFxyXG4gICAgICAgICAgICB0aGlzLmdsLmRlbGV0ZVByb2dyYW0ocHJvZ3JhbSk7XHJcbiAgICAgICAgICAgIHRoaXMuZ2wuZGVsZXRlU2hhZGVyKHZlcnRleFNoYWRlcik7XHJcbiAgICAgICAgICAgIHRoaXMuZ2wuZGVsZXRlU2hhZGVyKGZyYWdtZW50U2hhZGVyKTtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgXHJcbiAgICAgICAgLy8gV2Ugc3VjY2Vzc2Z1bGx5IGNyZWF0ZSBhIHByb2dyYW1cclxuICAgICAgICByZXR1cm4gW3Byb2dyYW0sIHZlcnRleFNoYWRlciwgZnJhZ21lbnRTaGFkZXJdO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBwcml2YXRlIGxvYWRWZXJ0ZXhTaGFkZXIoc2hhZGVyU291cmNlOiBzdHJpbmcpOiBXZWJHTFNoYWRlcntcclxuICAgICAgICAvLyBDcmVhdGUgYSBuZXcgdmVydGV4IHNoYWRlclxyXG4gICAgICAgIHJldHVybiB0aGlzLmxvYWRTaGFkZXIodGhpcy5nbC5WRVJURVhfU0hBREVSLCBzaGFkZXJTb3VyY2UpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBwcml2YXRlIGxvYWRGcmFnbWVudFNoYWRlcihzaGFkZXJTb3VyY2U6IHN0cmluZyk6IFdlYkdMU2hhZGVye1xyXG4gICAgICAgIC8vIENyZWF0ZSBhIG5ldyBmcmFnbWVudCBzaGFkZXJcclxuICAgICAgICByZXR1cm4gdGhpcy5sb2FkU2hhZGVyKHRoaXMuZ2wuRlJBR01FTlRfU0hBREVSLCBzaGFkZXJTb3VyY2UpO1x0XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHByaXZhdGUgbG9hZFNoYWRlcih0eXBlOiBudW1iZXIsIHNoYWRlclNvdXJjZTogc3RyaW5nKTogV2ViR0xTaGFkZXJ7XHJcbiAgICAgICAgY29uc3Qgc2hhZGVyID0gdGhpcy5nbC5jcmVhdGVTaGFkZXIodHlwZSk7XHJcbiAgICBcclxuICAgICAgICAvLyBJZiB3ZSBjb3VsZG4ndCBjcmVhdGUgdGhlIHNoYWRlciwgZXJyb3JcclxuICAgICAgICBpZihzaGFkZXIgPT09IG51bGwpe1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJVbmFibGUgdG8gY3JlYXRlIHNoYWRlclwiKTtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgXHJcbiAgICAgICAgLy8gQWRkIHRoZSBzb3VyY2UgdG8gdGhlIHNoYWRlciBhbmQgY29tcGlsZVxyXG4gICAgICAgIHRoaXMuZ2wuc2hhZGVyU291cmNlKHNoYWRlciwgc2hhZGVyU291cmNlKTtcclxuICAgICAgICB0aGlzLmdsLmNvbXBpbGVTaGFkZXIoc2hhZGVyKTtcclxuICAgIFxyXG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGVyZSB3ZXJlIG5vIGVycm9ycyBkdXJpbmcgdGhpcyBwcm9jZXNzXHJcbiAgICAgICAgaWYoIXRoaXMuZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKHNoYWRlciwgdGhpcy5nbC5DT01QSUxFX1NUQVRVUykpe1xyXG4gICAgICAgICAgICAvLyBOb3QgY29tcGlsZWQgLSBlcnJvclxyXG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMuZ2wuZ2V0U2hhZGVySW5mb0xvZyhzaGFkZXIpO1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJGYWlsZWQgdG8gY29tcGlsZSBzaGFkZXI6IFwiICsgZXJyb3IpO1xyXG4gICAgXHJcbiAgICAgICAgICAgIC8vIENsZWFuIHVwXHJcbiAgICAgICAgICAgIHRoaXMuZ2wuZGVsZXRlU2hhZGVyKHNoYWRlcik7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIFxyXG4gICAgICAgIC8vIFN1Y2Vzcywgc28gcmV0dXJuIHRoZSBzaGFkZXJcclxuICAgICAgICByZXR1cm4gc2hhZGVyO1xyXG4gICAgfVxyXG5cclxuICAgIC8qICMjIyMjIyMjIyMgR0VORVJBTCBMT0FESU5HIEZVTkNUSU9OUyAjIyMjIyMjIyMjICovXHJcblxyXG4gICAgcHJpdmF0ZSBsb2FkVGV4dEZpbGUodGV4dEZpbGVQYXRoOiBzdHJpbmcsIGNhbGxiYWNrOiBGdW5jdGlvbik6IHZvaWQge1xyXG4gICAgICAgIGxldCB4b2JqOiBYTUxIdHRwUmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xyXG4gICAgICAgIHhvYmoub3ZlcnJpZGVNaW1lVHlwZShcImFwcGxpY2F0aW9uL2pzb25cIik7XHJcbiAgICAgICAgeG9iai5vcGVuKCdHRVQnLCB0ZXh0RmlsZVBhdGgsIHRydWUpO1xyXG4gICAgICAgIHhvYmoub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoKHhvYmoucmVhZHlTdGF0ZSA9PSA0KSAmJiAoeG9iai5zdGF0dXMgPT0gMjAwKSkge1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2soeG9iai5yZXNwb25zZVRleHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICB4b2JqLnNlbmQobnVsbCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyogIyMjIyMjIyMjIyBMT0FESU5HIEJBUiBJTkZPICMjIyMjIyMjIyMgKi9cclxuXHJcbiAgICBwcml2YXRlIGdldExvYWRQZXJjZW50KCk6IG51bWJlciB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLmxvYWRvbmx5X3RpbGVtYXBzTG9hZGVkL3RoaXMubG9hZG9ubHlfdGlsZW1hcHNUb0xvYWRcclxuICAgICAgICAgICAgKyB0aGlzLmxvYWRvbmx5X3Nwcml0ZXNoZWV0c0xvYWRlZC90aGlzLmxvYWRvbmx5X3Nwcml0ZXNoZWV0c1RvTG9hZFxyXG4gICAgICAgICAgICArIHRoaXMubG9hZG9ubHlfaW1hZ2VzTG9hZGVkL3RoaXMubG9hZG9ubHlfaW1hZ2VzVG9Mb2FkXHJcbiAgICAgICAgICAgICsgdGhpcy5sb2Fkb25seV9hdWRpb0xvYWRlZC90aGlzLmxvYWRvbmx5X2F1ZGlvVG9Mb2FkKVxyXG4gICAgICAgICAgICAvIHRoaXMubG9hZG9ubHlfdHlwZXNUb0xvYWQ7XHJcbiAgICB9XHJcblxyXG4gICAgdXBkYXRlKGRlbHRhVDogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgICAgaWYodGhpcy5sb2FkaW5nKXtcclxuICAgICAgICAgICAgaWYodGhpcy5vbkxvYWRQcm9ncmVzcyl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9uTG9hZFByb2dyZXNzKHRoaXMuZ2V0TG9hZFBlcmNlbnQoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2UgaWYodGhpcy5qdXN0TG9hZGVkKXtcclxuICAgICAgICAgICAgdGhpcy5qdXN0TG9hZGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGlmKHRoaXMub25Mb2FkQ29tcGxldGUpe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vbkxvYWRDb21wbGV0ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogQSBjbGFzcyByZXByZXNlbnRpbmcgYSByZWZlcmVuY2UgdG8gYSByZXNvdXJjZS5cclxuICogVGhpcyBpcyB1c2VkIGZvciB0aGUgZXhlbXB0aW9uIGxpc3QgdG8gYXNzdXJlIGFzc2V0cyBhbmQgdGhlaXIgZGVwZW5kZW5jaWVzIGRvbid0IGdldFxyXG4gKiBkZXN0cm95ZWQgaWYgdGhleSBhcmUgc3RpbGwgbmVlZGVkLlxyXG4gKi9cclxuY2xhc3MgUmVzb3VyY2VSZWZlcmVuY2Uge1xyXG4gICAga2V5OiBzdHJpbmc7XHJcbiAgICByZXNvdXJjZVR5cGU6IFJlc291cmNlVHlwZTtcclxuICAgIGRlcGVuZGVuY2llczogQXJyYXk8UmVzb3VyY2VSZWZlcmVuY2U+O1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGtleTogc3RyaW5nLCByZXNvdXJjZVR5cGU6IFJlc291cmNlVHlwZSl7XHJcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XHJcbiAgICAgICAgdGhpcy5yZXNvdXJjZVR5cGUgPSByZXNvdXJjZVR5cGU7XHJcbiAgICAgICAgdGhpcy4gZGVwZW5kZW5jaWVzID0gbmV3IEFycmF5KCk7XHJcbiAgICB9XHJcblxyXG4gICAgYWRkRGVwZW5kZW5jeShyZXNvdXJjZTogUmVzb3VyY2VSZWZlcmVuY2UpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmRlcGVuZGVuY2llcy5wdXNoKHJlc291cmNlKTtcclxuICAgIH1cclxufVxyXG5cclxuXHJcbmVudW0gUmVzb3VyY2VUeXBlIHtcclxuICAgIElNQUdFID0gXCJJTUFHRVwiLFxyXG4gICAgVElMRU1BUCA9IFwiVElMRU1BUFwiLFxyXG4gICAgU1BSSVRFU0hFRVQgPSBcIlNQUklURVNIRUVUXCIsXHJcbiAgICBBVURJTyA9IFwiQVVESU9cIixcclxuICAgIEpTT04gPSBcIkpTT05cIixcclxuICAgIFNIQURFUiA9IFwiU0hBREVSXCJcclxufVxyXG5cclxuLyoqXHJcbiAqIEEgcGFpciByZXByZXNlbnRpbmcgYSBrZXkgYW5kIHRoZSBwYXRoIG9mIHRoZSByZXNvdXJjZSB0byBsb2FkXHJcbiAqL1xyXG5jbGFzcyBLZXlQYXRoUGFpciB7XHJcbiAgICBrZXk6IHN0cmluZztcclxuICAgIHBhdGg6IHN0cmluZztcclxuICAgIGlzRGVwZW5kZW5jeT86IGJvb2xlYW4gPSBmYWxzZTtcclxufVxyXG5cclxuY2xhc3MgS2V5UGF0aF9TaGFkZXIge1xyXG4gICAga2V5OiBzdHJpbmc7XHJcbiAgICB2cGF0aDogc3RyaW5nO1xyXG4gICAgZnBhdGg6IHN0cmluZztcclxufSIsImltcG9ydCBWaWV3cG9ydCBmcm9tIFwiLi9WaWV3cG9ydFwiO1xyXG5pbXBvcnQgQ2FudmFzTm9kZSBmcm9tIFwiLi4vTm9kZXMvQ2FudmFzTm9kZVwiO1xyXG5pbXBvcnQgTWFwIGZyb20gXCIuLi9EYXRhVHlwZXMvTWFwXCI7XHJcbmltcG9ydCBWZWMyIGZyb20gXCIuLi9EYXRhVHlwZXMvVmVjMlwiO1xyXG5pbXBvcnQgU2NlbmUgZnJvbSBcIi4uL1NjZW5lL1NjZW5lXCI7XHJcbmltcG9ydCBBQUJCIGZyb20gXCIuLi9EYXRhVHlwZXMvU2hhcGVzL0FBQkJcIjtcclxuXHJcbi8qKlxyXG4gKiBBbiBhYnN0cmFjdCBpbnRlcmZhY2Ugb2YgYSBTY2VuZUdyYXBoLlxyXG4gKiBFeHBvc2VzIG1ldGhvZHMgZm9yIHVzZSBieSBvdGhlciBjb2RlLCBidXQgbGVhdmVzIHRoZSBpbXBsZW1lbnRhdGlvbiB1cCB0byB0aGUgc3ViY2xhc3Nlcy5cclxuICogVGhlIFNjZW5lR3JhcGggbWFuYWdlcyB0aGUgcG9zaXRpb25zIG9mIGFsbCBHYW1lTm9kZXMsIGFuZCBjYW4gZWFzaWx5IHBydW5lIGEgdmlzaWJsZSBzZXQgZm9yIHJlbmRlcmluZy5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGFic3RyYWN0IGNsYXNzIFNjZW5lR3JhcGgge1xyXG5cdC8qKlx0QSByZWZlcmVuY2UgdG8gdGhlIHZpZXdwb3J0ICovXHJcblx0cHJvdGVjdGVkIHZpZXdwb3J0OiBWaWV3cG9ydDtcclxuXHQvKipcdEEgbWFwIG9mIENhbnZhc05vZGVzIGluIHRoaXMgU2NlbmVHcmFwaCAqL1xyXG5cdHByb3RlY3RlZCBub2RlTWFwOiBBcnJheTxDYW52YXNOb2RlPjtcclxuXHQvKiogQSBjb3VudGVyIG9mIElEcyBmb3Igbm9kZXMgaW4gdGhpcyBTY2VuZUdyYXBoICovXHJcblx0cHJvdGVjdGVkIGlkQ291bnRlcjogbnVtYmVyO1xyXG5cdC8qKiBBIHJlZmVyZW5jZSB0byB0aGUgU2NlbmUgdGhpcyBTY2VuZUdyYXBoIGJlbG9uZ3MgdG8gKi9cclxuXHRwcm90ZWN0ZWQgc2NlbmU6IFNjZW5lO1xyXG5cclxuXHQvKipcclxuXHQgKiBDcmVhdGVzIGEgbmV3IFNjZW5lR3JhcGhcclxuXHQgKiBAcGFyYW0gdmlld3BvcnQgVGhlIHZpZXdwb3J0XHJcblx0ICogQHBhcmFtIHNjZW5lIFRoZSBTY2VuZSB0aGlzIFNjZW5lR3JhcGggYmVsb25ncyB0b1xyXG5cdCAqL1xyXG4gICAgY29uc3RydWN0b3Iodmlld3BvcnQ6IFZpZXdwb3J0LCBzY2VuZTogU2NlbmUpe1xyXG5cdFx0dGhpcy52aWV3cG9ydCA9IHZpZXdwb3J0O1xyXG5cdFx0dGhpcy5zY2VuZSA9IHNjZW5lO1xyXG5cdFx0dGhpcy5ub2RlTWFwID0gbmV3IEFycmF5KCk7XHJcblx0XHR0aGlzLmlkQ291bnRlciA9IDA7XHJcbiAgICB9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEFkZCBhIG5vZGUgdG8gdGhlIFNjZW5lR3JhcGhcclxuXHQgKiBAcGFyYW0gbm9kZSBUaGUgQ2FudmFzTm9kZSB0byBhZGQgdG8gdGhlIFNjZW5lR3JhcGhcclxuXHQgKiBAcmV0dXJucyBUaGUgU2NlbmVHcmFwaCBJRCBvZiB0aGlzIG5ld2x5IGFkZGVkIENhbnZhc05vZGVcclxuXHQgKi9cclxuICAgIGFkZE5vZGUobm9kZTogQ2FudmFzTm9kZSk6IG51bWJlciB7XHJcblx0XHR0aGlzLm5vZGVNYXBbbm9kZS5pZF0gPSBub2RlO1xyXG5cdFx0dGhpcy5hZGROb2RlU3BlY2lmaWMobm9kZSwgdGhpcy5pZENvdW50ZXIpO1xyXG5cdFx0dGhpcy5pZENvdW50ZXIgKz0gMTtcclxuXHRcdHJldHVybiB0aGlzLmlkQ291bnRlciAtIDE7XHJcblx0fTtcclxuXHJcblx0LyoqXHJcblx0ICogQW4gb3ZlcnJpZGFibGUgbWV0aG9kIHRvIGFkZCBhIENhbnZhc05vZGUgdG8gdGhlIHNwZWNpZmljIGRhdGEgc3RydWN0dXJlIG9mIHRoZSBTY2VuZUdyYXBoXHJcblx0ICogQHBhcmFtIG5vZGUgVGhlIG5vZGUgdG8gYWRkIHRvIHRoZSBkYXRhIHN0cnVjdHVyZVxyXG5cdCAqIEBwYXJhbSBpZCBUaGUgaWQgb2YgdGhlIENhbnZhc05vZGVcclxuXHQgKi9cclxuXHRwcm90ZWN0ZWQgYWJzdHJhY3QgYWRkTm9kZVNwZWNpZmljKG5vZGU6IENhbnZhc05vZGUsIGlkOiBudW1iZXIpOiB2b2lkO1xyXG5cclxuXHQvKipcclxuXHQgKiBSZW1vdmVzIGEgbm9kZSBmcm9tIHRoZSBTY2VuZUdyYXBoXHJcblx0ICogQHBhcmFtIG5vZGUgVGhlIG5vZGUgdG8gcmVtb3ZlXHJcblx0ICovXHJcbiAgICByZW1vdmVOb2RlKG5vZGU6IENhbnZhc05vZGUpOiB2b2lkIHtcclxuXHRcdC8vIEZpbmQgYW5kIHJlbW92ZSBub2RlIGluIE8obilcclxuXHRcdHRoaXMubm9kZU1hcFtub2RlLmlkXSA9IHVuZGVmaW5lZDtcclxuXHRcdHRoaXMucmVtb3ZlTm9kZVNwZWNpZmljKG5vZGUsIG5vZGUuaWQpO1xyXG5cdH07XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoZSBzcGVjaWZpYyBpbXBsZW1lbnRhdGlvbiBvZiByZW1vdmluZyBhIG5vZGVcclxuXHQgKiBAcGFyYW0gbm9kZSBUaGUgbm9kZSB0byByZW1vdmVcclxuXHQgKiBAcGFyYW0gaWQgVGhlIGlkIG9mIHRoZSBub2RlIHRvIHJlbW92ZVxyXG5cdCAqL1xyXG5cdHByb3RlY3RlZCBhYnN0cmFjdCByZW1vdmVOb2RlU3BlY2lmaWMobm9kZTogQ2FudmFzTm9kZSwgaWQ6IG51bWJlcik6IHZvaWQ7XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCBhIHNwZWNpZmljIG5vZGUgdXNpbmcgaXRzIGlkXHJcblx0ICogQHBhcmFtIGlkIFRoZSBpZCBvZiB0aGUgQ2FudmFzTm9kZSB0byByZXRyaWV2ZVxyXG5cdCAqIEByZXR1cm5zIFRoZSBub2RlIHdpdGggdGhpcyBJRFxyXG5cdCAqL1xyXG5cdGdldE5vZGUoaWQ6IG51bWJlcik6IENhbnZhc05vZGUge1xyXG5cdFx0cmV0dXJuIHRoaXMubm9kZU1hcFtpZF07XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRoZSBub2RlcyBhdCBzcGVjaWZpYyBjb29yZGluYXRlc1xyXG5cdCAqIEBwYXJhbSB2ZWNPclggVGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgcG9zaXRpb24sIG9yIHRoZSBjb29yZGluYXRlcyBpbiBhIFZlYzJcclxuXHQgKiBAcGFyYW0geSBUaGUgeS1jb29yZGluYXRlIG9mIHRoZSBwb3NpdGlvblxyXG5cdCAqIEByZXR1cm5zIEFuIGFycmF5IG9mIG5vZGVzIGZvdW5kIGF0IHRoZSBwb3NpdGlvbiBwcm92aWRlZFxyXG5cdCAqL1xyXG4gICAgZ2V0Tm9kZXNBdCh2ZWNPclg6IFZlYzIgfCBudW1iZXIsIHk6IG51bWJlciA9IG51bGwpOiBBcnJheTxDYW52YXNOb2RlPiB7XHJcblx0XHRpZih2ZWNPclggaW5zdGFuY2VvZiBWZWMyKXtcclxuXHRcdFx0cmV0dXJuIHRoaXMuZ2V0Tm9kZXNBdENvb3Jkcyh2ZWNPclgueCwgdmVjT3JYLnkpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMuZ2V0Tm9kZXNBdENvb3Jkcyh2ZWNPclgsIHkpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0aGUgbm9kZXMgdGhhdCBvdmVybGFwIGEgc3BlY2lmaWMgYm91bmRhcnlcclxuXHQgKiBAcGFyYW0gYm91bmRhcnkgVGhlIHJlZ2lvbiB0byBjaGVja1xyXG5cdCAqIEByZXR1cm5zIEFuIGFycmF5IG9mIG5vZGVzIGZvdW5kIG92ZXJsYXBwaW5nIHRoZSBwcm92aWRlZCBib3VuZGFyeVxyXG5cdCAqL1xyXG5cdGFic3RyYWN0IGdldE5vZGVzSW5SZWdpb24oYm91bmRhcnk6IEFBQkIpOiBBcnJheTxDYW52YXNOb2RlPjtcclxuXHRcclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIGFsbCBub2RlcyBpbiB0aGUgU2NlbmVHcmFwaFxyXG5cdCAqIEByZXR1cm5zIEFuIEFycmF5IGNvbnRhaW5pbmcgYWxsIG5vZGVzIGluIHRoZSBTY2VuZUdyYXBoXHJcblx0ICovXHJcblx0Z2V0QWxsTm9kZXMoKTogQXJyYXk8Q2FudmFzTm9kZT4ge1xyXG5cdFx0bGV0IGFyciA9IG5ldyBBcnJheTxDYW52YXNOb2RlPigpO1xyXG5cdFx0Zm9yKGxldCBpID0gMDsgaSA8IHRoaXMubm9kZU1hcC5sZW5ndGg7IGkrKyl7XHJcblx0XHRcdGlmKHRoaXMubm9kZU1hcFtpXSAhPT0gdW5kZWZpbmVkKXtcclxuXHRcdFx0XHRhcnIucHVzaCh0aGlzLm5vZGVNYXBbaV0pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gYXJyO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogVGhlIHNwZWNpZmljIGltcGxlbWVudGF0aW9uIG9mIGdldHRpbmcgYSBub2RlIGF0IGNlcnRhaW4gY29vcmRpbmF0ZXNcclxuXHQgKiBAcGFyYW0geCBUaGUgeC1jb29yZGluYXRlcyBvZiB0aGUgbm9kZVxyXG5cdCAqIEBwYXJhbSB5IFRoZSB5LWNvb3JkaW5hdGVzIG9mIHRoZSBub2RlXHJcblx0ICovXHJcbiAgICBwcm90ZWN0ZWQgYWJzdHJhY3QgZ2V0Tm9kZXNBdENvb3Jkcyh4OiBudW1iZXIsIHk6IG51bWJlcik6IEFycmF5PENhbnZhc05vZGU+O1xyXG5cclxuXHRhYnN0cmFjdCB1cGRhdGUoZGVsdGFUOiBudW1iZXIpOiB2b2lkO1xyXG5cdFxyXG5cdGFic3RyYWN0IHJlbmRlcihjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCk6IHZvaWQ7XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldHMgdGhlIHZpc2libGUgc2V0IG9mIENhbnZhc05vZGVzIGJhc2VkIG9uIHRoZSBAcmVmZXJlbmNlW1ZpZXdwb3J0XVxyXG5cdCAqIEByZXR1cm5zIEFuIGFycmF5IGNvbnRhaW5pbmcgYWxsIHZpc2libGUgbm9kZXMgaW4gdGhlIFNjZW5lR3JhcGhcclxuXHQgKi9cclxuICAgIGFic3RyYWN0IGdldFZpc2libGVTZXQoKTogQXJyYXk8Q2FudmFzTm9kZT47XHJcbn0iLCJpbXBvcnQgU2NlbmVHcmFwaCBmcm9tIFwiLi9TY2VuZUdyYXBoXCI7XHJcbmltcG9ydCBDYW52YXNOb2RlIGZyb20gXCIuLi9Ob2Rlcy9DYW52YXNOb2RlXCI7XHJcbmltcG9ydCBWaWV3cG9ydCBmcm9tIFwiLi9WaWV3cG9ydFwiO1xyXG5pbXBvcnQgU2NlbmUgZnJvbSBcIi4uL1NjZW5lL1NjZW5lXCI7XHJcbmltcG9ydCBBQUJCIGZyb20gXCIuLi9EYXRhVHlwZXMvU2hhcGVzL0FBQkJcIjtcclxuaW1wb3J0IFN0YXRzIGZyb20gXCIuLi9EZWJ1Zy9TdGF0c1wiO1xyXG5cclxuLyoqXHJcbiAqIEFuIGltcGxlbWVudGF0aW9uIG9mIGEgU2NlbmVHcmFwaCB0aGF0IHNpbXBseSBzdG9yZWQgQ2FudmFzTm9kZXMgaW4gYW4gYXJyYXkuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTY2VuZUdyYXBoQXJyYXkgZXh0ZW5kcyBTY2VuZUdyYXBoIHtcclxuICAgIC8qKiBUaGUgbGlzdCBvZiBDYW52YXNOb2RlcyBpbiB0aGlzIFNjZW5lR3JhcGggKi9cclxuICAgIHByaXZhdGUgbm9kZUxpc3Q6IEFycmF5PENhbnZhc05vZGU+O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBTY2VuZUdyYXBoQXJyYXlcclxuICAgICAqIEBwYXJhbSB2aWV3cG9ydCBUaGUgVmlld3BvcnRcclxuICAgICAqIEBwYXJhbSBzY2VuZSBUaGUgU2NlbmUgdGhpcyBTY2VuZUdyYXBoIGJlbG9uZ3MgdG9cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3Iodmlld3BvcnQ6IFZpZXdwb3J0LCBzY2VuZTogU2NlbmUpe1xyXG4gICAgICAgIHN1cGVyKHZpZXdwb3J0LCBzY2VuZSk7XHJcblxyXG4gICAgICAgIHRoaXMubm9kZUxpc3QgPSBuZXcgQXJyYXk8Q2FudmFzTm9kZT4oKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBAb3ZlcnJpZGVcclxuICAgIHByb3RlY3RlZCBhZGROb2RlU3BlY2lmaWMobm9kZTogQ2FudmFzTm9kZSwgaWQ6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICAgIHRoaXMubm9kZUxpc3QucHVzaChub2RlKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBAb3ZlcnJpZGVcclxuICAgIHByb3RlY3RlZCByZW1vdmVOb2RlU3BlY2lmaWMobm9kZTogQ2FudmFzTm9kZSwgaWQ6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICAgIGxldCBpbmRleCA9IHRoaXMubm9kZUxpc3QuaW5kZXhPZihub2RlKTtcclxuICAgICAgICBpZihpbmRleCA+IC0xKXtcclxuICAgICAgICAgICAgdGhpcy5ub2RlTGlzdC5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBAb3ZlcnJpZGVcclxuICAgIGdldE5vZGVzQXRDb29yZHMoeDogbnVtYmVyLCB5OiBudW1iZXIpOiBBcnJheTxDYW52YXNOb2RlPiB7XHJcbiAgICAgICAgbGV0IHJlc3VsdHMgPSBbXTtcclxuXHJcbiAgICAgICAgZm9yKGxldCBub2RlIG9mIHRoaXMubm9kZUxpc3Qpe1xyXG4gICAgICAgICAgICBpZihub2RlLmNvbnRhaW5zKHgsIHkpKXtcclxuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChub2RlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQG92ZXJyaWRlXHJcbiAgICBnZXROb2Rlc0luUmVnaW9uKGJvdW5kYXJ5OiBBQUJCKTogQXJyYXk8Q2FudmFzTm9kZT4ge1xyXG4gICAgICAgIGxldCB0MCA9IHBlcmZvcm1hbmNlLm5vdygpO1xyXG4gICAgICAgIGxldCByZXN1bHRzID0gW107XHJcblxyXG4gICAgICAgIGZvcihsZXQgbm9kZSBvZiB0aGlzLm5vZGVMaXN0KXtcclxuICAgICAgICAgICAgaWYoYm91bmRhcnkub3ZlcmxhcHMobm9kZS5ib3VuZGFyeSkpe1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKG5vZGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCB0MSA9IHBlcmZvcm1hbmNlLm5vdygpO1xyXG4gICAgICAgIFN0YXRzLmxvZyhcInNncXVlcnlcIiwgKHQxLXQwKSk7XHJcblxyXG4gICAgICAgIHJldHVybiByZXN1bHRzO1xyXG4gICAgfVxyXG5cclxuICAgIHVwZGF0ZShkZWx0YVQ6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICAgIGxldCB0MCA9IHBlcmZvcm1hbmNlLm5vdygpO1xyXG4gICAgICAgIGZvcihsZXQgbm9kZSBvZiB0aGlzLm5vZGVMaXN0KXtcclxuICAgICAgICAgICAgaWYoIW5vZGUuZ2V0TGF5ZXIoKS5pc1BhdXNlZCgpKXtcclxuICAgICAgICAgICAgICAgIG5vZGUudXBkYXRlKGRlbHRhVCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHQxID0gcGVyZm9ybWFuY2Uubm93KCk7XHJcbiAgICAgICAgU3RhdHMubG9nKFwic2d1cGRhdGVcIiwgKHQxLXQwKSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmVuZGVyKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKTogdm9pZCB7fVxyXG5cclxuICAgIC8vIEBvdmVycmlkZVxyXG4gICAgZ2V0VmlzaWJsZVNldCgpOiBBcnJheTxDYW52YXNOb2RlPiB7XHJcbiAgICAgICAgbGV0IHZpc2libGVTZXQgPSBuZXcgQXJyYXk8Q2FudmFzTm9kZT4oKTtcclxuXHJcbiAgICAgICAgZm9yKGxldCBub2RlIG9mIHRoaXMubm9kZUxpc3Qpe1xyXG4gICAgICAgICAgICBpZighbm9kZS5nZXRMYXllcigpLmlzSGlkZGVuKCkgJiYgbm9kZS52aXNpYmxlICYmIHRoaXMudmlld3BvcnQuaW5jbHVkZXMobm9kZSkpe1xyXG4gICAgICAgICAgICAgICAgdmlzaWJsZVNldC5wdXNoKG5vZGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdmlzaWJsZVNldDtcclxuICAgIH1cclxufSIsImltcG9ydCBWZWMyIGZyb20gXCIuLi9EYXRhVHlwZXMvVmVjMlwiO1xyXG5pbXBvcnQgR2FtZU5vZGUgZnJvbSBcIi4uL05vZGVzL0dhbWVOb2RlXCI7XHJcbmltcG9ydCBDYW52YXNOb2RlIGZyb20gXCIuLi9Ob2Rlcy9DYW52YXNOb2RlXCI7XHJcbmltcG9ydCBNYXRoVXRpbHMgZnJvbSBcIi4uL1V0aWxzL01hdGhVdGlsc1wiO1xyXG5pbXBvcnQgUXVldWUgZnJvbSBcIi4uL0RhdGFUeXBlcy9RdWV1ZVwiO1xyXG5pbXBvcnQgQUFCQiBmcm9tIFwiLi4vRGF0YVR5cGVzL1NoYXBlcy9BQUJCXCI7XHJcbmltcG9ydCBJbnB1dCBmcm9tIFwiLi4vSW5wdXQvSW5wdXRcIjtcclxuaW1wb3J0IFBhcmFsbGF4TGF5ZXIgZnJvbSBcIi4uL1NjZW5lL0xheWVycy9QYXJhbGxheExheWVyXCI7XHJcbmltcG9ydCBVSUxheWVyIGZyb20gXCIuLi9TY2VuZS9MYXllcnMvVUlMYXllclwiO1xyXG5cclxuLyoqXHJcbiAqIFRoZSB2aWV3cG9ydCBvZiB0aGUgZ2FtZS4gQ29ycmVzcG9uZHMgdG8gdGhlIHZpc2libGUgd2luZG93IGRpc3BsYXllZCBpbiB0aGUgYnJvd3Nlci5cclxuICogVGhlIHZpZXdwb3J0IGtlZXBzIHRyYWNrIG9mIGl0cyBwb3NpdGlvbiBpbiB0aGUgZ2FtZSB3b3JsZCwgYW5kIGNhbiBhY3QgYXMgYSBjYW1lcmEgdG8gZm9sbG93IG9iamVjdHMuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBWaWV3cG9ydCB7XHJcbiAgICAvKiogVGhlIEFBQkIgdGhhdCBjb250YWlucyB0aGUgcG9zaXRpb24gYW5kIHNpemUgb2YgdGhlIHZpZXdwb3J0IHZpZXcgKi9cclxuICAgIHByaXZhdGUgdmlldzogQUFCQjtcclxuICAgIC8qKiBUaGUgYm91bmRhcnkgZm9yIHRoZSB2aWV3cG9ydC4gVGhpcyByZXByZXNlbnRzIHRoZSBsaW1pdHMgdG8gd2hlcmUgdGhlIHZpZXdwb3J0IGNhbiBnbyAqL1xyXG4gICAgcHJpdmF0ZSBib3VuZGFyeTogQUFCQjtcclxuICAgIC8qKiBUaGUgR2FtZU5vZGUgdGhlIFZpZXdwb3J0IGlzIGZvbGxvd2luZyAqL1xyXG4gICAgcHJpdmF0ZSBmb2xsb3dpbmc6IEdhbWVOb2RlO1xyXG4gICAgLyoqIFRoZSBwb3NpdGlvbiB0aGUgR2FtZU5vZGUgaXMgZm9jdXNpbmcgb24uIFRoaXMgaXMgb3ZlcnJpZGRlbiBpZiBcImZvbGxvd2luZ1wiIGlzIHNldC4gKi9cclxuICAgIHByaXZhdGUgZm9jdXM6IFZlYzI7XHJcblxyXG4gICAgLyoqIEEgcXVldWUgb2YgcHJldmlvdXMgcG9zaXRpb25zIG9mIHdoYXQgdGhpcyB2aWV3cG9ydCBpcyBmb2xsb3dpbmcuIFVzZWQgZm9yIHNtb290aGluZyB2aWV3cG9ydCBtb3ZlbWVudCAqL1xyXG4gICAgcHJpdmF0ZSBsYXN0UG9zaXRpb25zOiBRdWV1ZTxWZWMyPjtcclxuXHJcbiAgICAvKiogVGhlIG51bWJlciBvZiBwcmV2aW91cyBwb3NpdGlvbnMgdGhpcyB2aWV3cG9ydCB0cmFja3MgKi9cclxuICAgIHByaXZhdGUgc21vb3RoaW5nRmFjdG9yOiBudW1iZXI7XHJcblxyXG4gICAgLyoqIEEgYm9vbGVhbiB0aGEgcmVwcmVzZW50cyB3aGV0aGVyIHRoZSBwbGF5ZXIgY2FuIHpvb20gYnkgc2Nyb2xsaW5nIHdpdGggdGhlIG1vdXNlIHdoZWVsICovXHJcbiAgICBwcml2YXRlIHNjcm9sbFpvb21FbmFibGVkOiBib29sZWFuO1xyXG5cclxuICAgIC8qKiBUaGUgYW1vdW50IHRoYXQgaXMgem9vbWVkIGluIG9yIG91dC4gKi9cclxuICAgIHByaXZhdGUgWk9PTV9GQUNUT1I6IG51bWJlciA9IDEuMjtcclxuXHJcbiAgICAvKiogVGhlIHNpemUgb2YgdGhlIGNhbnZhcyAqL1xyXG4gICAgcHJpdmF0ZSBjYW52YXNTaXplOiBWZWMyO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGNhbnZhc1NpemU6IFZlYzIsIHpvb21MZXZlbDogbnVtYmVyKXtcclxuICAgICAgICB0aGlzLnZpZXcgPSBuZXcgQUFCQihWZWMyLlpFUk8sIFZlYzIuWkVSTyk7XHJcbiAgICAgICAgdGhpcy5ib3VuZGFyeSA9IG5ldyBBQUJCKFZlYzIuWkVSTywgVmVjMi5aRVJPKTtcclxuICAgICAgICB0aGlzLmxhc3RQb3NpdGlvbnMgPSBuZXcgUXVldWUoKTtcclxuICAgICAgICB0aGlzLnNtb290aGluZ0ZhY3RvciA9IDEwO1xyXG4gICAgICAgIHRoaXMuc2Nyb2xsWm9vbUVuYWJsZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmNhbnZhc1NpemUgPSBWZWMyLlpFUk87XHJcbiAgICAgICAgdGhpcy5mb2N1cyA9IFZlYzIuWkVSTztcclxuXHJcbiAgICAgICAgLy8gU2V0IHRoZSBzaXplIG9mIHRoZSBjYW52YXNcclxuICAgICAgICB0aGlzLnNldENhbnZhc1NpemUoY2FudmFzU2l6ZSk7XHJcblxyXG4gICAgICAgIC8vIFNldCB0aGUgc2l6ZSBvZiB0aGUgdmlld3BvcnRcclxuICAgICAgICB0aGlzLnNldFNpemUoY2FudmFzU2l6ZSk7XHJcbiAgICAgICAgdGhpcy5zZXRab29tTGV2ZWwoem9vbUxldmVsKTtcclxuXHJcbiAgICAgICAgLy8gU2V0IHRoZSBjZW50ZXIgKGFuZCBtYWtlIHRoZSB2aWV3cG9ydCBzdGF5IHRoZXJlKVxyXG4gICAgICAgIHRoaXMuc2V0Q2VudGVyKHRoaXMudmlldy5oYWxmU2l6ZS5jbG9uZSgpKTtcclxuICAgICAgICB0aGlzLnNldEZvY3VzKHRoaXMudmlldy5oYWxmU2l6ZS5jbG9uZSgpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogRW5hYmxlcyB0aGUgdmlld3BvcnQgdG8gem9vbSBpbiBhbmQgb3V0ICovXHJcbiAgICBlbmFibGVab29tKCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuc2Nyb2xsWm9vbUVuYWJsZWQgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgcG9zaXRpb24gb2YgdGhlIHZpZXdwb3J0XHJcbiAgICAgKiBAcmV0dXJucyBUaGUgY2VudGVyIG9mIHRoZSB2aWV3cG9ydCBhcyBhIFZlYzJcclxuICAgICAqL1xyXG4gICAgZ2V0Q2VudGVyKCk6IFZlYzIge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnZpZXcuY2VudGVyO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIG5ldyBWZWMyIHdpdGggdGhlIG9yaWdpbiBvZiB0aGUgdmlld3BvcnRcclxuICAgICAqIEByZXR1cm5zIFRoZSB0b3AgbGVmdCBjb3JuZGVyIG9mIHRoZSBWaWVwb3J0IGFzIGEgVmVjMlxyXG4gICAgICovXHJcbiAgICBnZXRPcmlnaW4oKTogVmVjMiB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBWZWMyKHRoaXMudmlldy5sZWZ0LCB0aGlzLnZpZXcudG9wKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHJlZ2lvbiB2aXNpYmxlIHRvIHRoaXMgdmlld3BvcnRcclxuICAgICAqIEByZXR1cm5zIFRoZSBBQUJCIGNvbnRhaW5pbmcgdGhlIHJlZ2lvbiB2aXNpYmxlIHRvIHRoZSB2aWV3cG9ydFxyXG4gICAgICovXHJcbiAgICBnZXRWaWV3KCk6IEFBQkIge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnZpZXc7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIHBvc2l0aW9uIG9mIHRoZSB2aWV3cG9ydFxyXG4gICAgICogQHBhcmFtIHZlY09yWCBUaGUgbmV3IHBvc2l0aW9uIG9yIHRoZSB4LWNvb3JkaW5hdGUgb2YgdGhlIG5ldyBwb3NpdGlvblxyXG4gICAgICogQHBhcmFtIHkgVGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgbmV3IHBvc2l0aW9uXHJcbiAgICAgKi9cclxuICAgIHNldENlbnRlcih2ZWNPclg6IFZlYzIgfCBudW1iZXIsIHk6IG51bWJlciA9IG51bGwpOiB2b2lkIHtcclxuICAgICAgICBsZXQgcG9zOiBWZWMyO1xyXG5cdFx0aWYodmVjT3JYIGluc3RhbmNlb2YgVmVjMil7XHJcbiAgICAgICAgICAgIHBvcyA9IHZlY09yWDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBwb3MgPSBuZXcgVmVjMih2ZWNPclgsIHkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy52aWV3LmNlbnRlciA9IHBvcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHNpemUgb2YgdGhlIHZpZXdwb3J0IGFzIGEgVmVjMlxyXG4gICAgICogQHJldHVybnMgVGhlIGhhbGYtc2l6ZSBvZiB0aGUgdmlld3BvcnQgYXMgYSBWZWMyXHJcbiAgICAgKi9cclxuICAgIGdldEhhbGZTaXplKCk6IFZlYzIge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnZpZXcuZ2V0SGFsZlNpemUoKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBzaXplIG9mIHRoZSB2aWV3cG9ydFxyXG4gICAgICogQHBhcmFtIHZlY09yWCBUaGUgbmV3IHdpZHRoIG9mIHRoZSB2aWV3cG9ydCBvciB0aGUgbmV3IHNpemUgYXMgYSBWZWMyXHJcbiAgICAgKiBAcGFyYW0geSBUaGUgbmV3IGhlaWdodCBvZiB0aGUgdmlld3BvcnRcclxuICAgICAqL1xyXG4gICAgc2V0U2l6ZSh2ZWNPclg6IFZlYzIgfCBudW1iZXIsIHk6IG51bWJlciA9IG51bGwpOiB2b2lkIHtcclxuXHRcdGlmKHZlY09yWCBpbnN0YW5jZW9mIFZlYzIpe1xyXG5cdFx0XHR0aGlzLnZpZXcuc2V0SGFsZlNpemUodmVjT3JYLnNjYWxlZCgxLzIpKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRoaXMudmlldy5zZXRIYWxmU2l6ZShuZXcgVmVjMih2ZWNPclgvMiwgeS8yKSk7XHJcblx0XHR9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBoYWxmLXNpemUgb2YgdGhlIHZpZXdwb3J0XHJcbiAgICAgKiBAcGFyYW0gdmVjT3JYIFRoZSBuZXcgaGFsZi13aWR0aCBvZiB0aGUgdmlld3BvcnQgb3IgdGhlIG5ldyBoYWxmLXNpemUgYXMgYSBWZWMyXHJcbiAgICAgKiBAcGFyYW0geSBUaGUgbmV3IGhlaWdodCBvZiB0aGUgdmlld3BvcnRcclxuICAgICAqL1xyXG4gICAgc2V0SGFsZlNpemUodmVjT3JYOiBWZWMyIHwgbnVtYmVyLCB5OiBudW1iZXIgPSBudWxsKTogdm9pZCB7XHJcblx0XHRpZih2ZWNPclggaW5zdGFuY2VvZiBWZWMyKXtcclxuXHRcdFx0dGhpcy52aWV3LnNldEhhbGZTaXplKHZlY09yWC5jbG9uZSgpKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRoaXMudmlldy5zZXRIYWxmU2l6ZShuZXcgVmVjMih2ZWNPclgsIHkpKTtcclxuXHRcdH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgdGhlIHZpZXdwb3J0IHdpdGggdGhlIHNpemUgb2YgdGhlIGN1cnJlbnQgQ2FudmFzXHJcbiAgICAgKiBAcGFyYW0gdmVjT3JYIFRoZSB3aWR0aCBvZiB0aGUgY2FudmFzLCBvciB0aGUgY2FudmFzIHNpemUgYXMgYSBWZWMyXHJcbiAgICAgKiBAcGFyYW0geSBUaGUgaGVpZ2h0IG9mIHRoZSBjYW52YXNcclxuICAgICAqL1xyXG4gICAgc2V0Q2FudmFzU2l6ZSh2ZWNPclg6IFZlYzIgfCBudW1iZXIsIHk6IG51bWJlciA9IG51bGwpOiB2b2lkIHtcclxuXHRcdGlmKHZlY09yWCBpbnN0YW5jZW9mIFZlYzIpe1xyXG5cdFx0XHR0aGlzLmNhbnZhc1NpemUgPSB2ZWNPclguY2xvbmUoKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRoaXMuY2FudmFzU2l6ZSA9IG5ldyBWZWMyKHZlY09yWCwgeSk7XHJcblx0XHR9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSB6b29tIGxldmVsIG9mIHRoZSB2aWV3cG9ydFxyXG4gICAgICogQHBhcmFtIHpvb20gVGhlIHpvb20gbGV2ZWxcclxuICAgICAqL1xyXG4gICAgc2V0Wm9vbUxldmVsKHpvb206IG51bWJlcik6IHZvaWQge1xyXG4gICAgICAgIHRoaXMudmlldy5oYWxmU2l6ZS5jb3B5KHRoaXMuY2FudmFzU2l6ZS5zY2FsZWQoMS96b29tLzIpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIHpvb20gbGV2ZWwgb2YgdGhlIHZpZXdwb3J0XHJcbiAgICAgKiBAcmV0dXJucyBUaGUgem9vbSBsZXZlbFxyXG4gICAgICovXHJcbiAgICBnZXRab29tTGV2ZWwoKTogbnVtYmVyIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jYW52YXNTaXplLngvdGhpcy52aWV3Lmh3LzJcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIHNtb290aGluZyBmYWN0b3IgZm9yIHRoZSB2aWV3cG9ydCBtb3ZlbWVudC5cclxuICAgICAqIEBwYXJhbSBzbW9vdGhpbmdGYWN0b3IgVGhlIHNtb290aGluZyBmYWN0b3IgZm9yIHRoZSB2aWV3cG9ydFxyXG4gICAgICovXHJcbiAgICBzZXRTbW9vdGhpbmdGYWN0b3Ioc21vb3RoaW5nRmFjdG9yOiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgICBpZihzbW9vdGhpbmdGYWN0b3IgPCAxKSBzbW9vdGhpbmdGYWN0b3IgPSAxO1xyXG4gICAgICAgIHRoaXMuc21vb3RoaW5nRmFjdG9yID0gc21vb3RoaW5nRmFjdG9yO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGVsbHMgdGhlIHZpZXdwb3J0IHRvIGZvY3VzIG9uIGEgcG9pbnQuIE92ZXJpZGRlbiBieSBcImZvbGxvd2luZ1wiLlxyXG4gICAgICogQHBhcmFtIGZvY3VzIFRoZSBwb2ludCB0aGUgIHZpZXdwb3J0IHNob3VsZCBmb2N1cyBvblxyXG4gICAgICovXHJcbiAgICBzZXRGb2N1cyhmb2N1czogVmVjMik6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuZm9jdXMuY29weShmb2N1cyk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBDYW52YXNOb2RlIGlzIGluc2lkZSBvZiB0aGUgdmlld3BvcnRcclxuICAgICAqIEBwYXJhbSBub2RlIFRoZSBub2RlIHRvIGNoZWNrXHJcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBub2RlIGlzIGN1cnJlbnRseSB2aXNpYmxlIGluIHRoZSB2aWV3cG9ydCwgZmFsc2UgaWYgbm90XHJcbiAgICAgKi9cclxuICAgIGluY2x1ZGVzKG5vZGU6IENhbnZhc05vZGUpOiBib29sZWFuIHtcclxuICAgICAgICBsZXQgcGFyYWxsYXggPSBub2RlLmdldExheWVyKCkgaW5zdGFuY2VvZiBQYXJhbGxheExheWVyIHx8IG5vZGUuZ2V0TGF5ZXIoKSBpbnN0YW5jZW9mIFVJTGF5ZXIgPyAoPFBhcmFsbGF4TGF5ZXI+bm9kZS5nZXRMYXllcigpKS5wYXJhbGxheCA6IG5ldyBWZWMyKDEsIDEpO1xyXG4gICAgICAgIGxldCBjZW50ZXIgPSB0aGlzLnZpZXcuY2VudGVyLmNsb25lKCk7XHJcbiAgICAgICAgdGhpcy52aWV3LmNlbnRlci5tdWx0KHBhcmFsbGF4KTtcclxuICAgICAgICBsZXQgb3ZlcmxhcHMgPSB0aGlzLnZpZXcub3ZlcmxhcHMobm9kZS5ib3VuZGFyeSk7XHJcbiAgICAgICAgdGhpcy52aWV3LmNlbnRlciA9IGNlbnRlclxyXG4gICAgICAgIHJldHVybiBvdmVybGFwcztcclxuICAgIH1cclxuXHJcblx0Ly8gVE9ETzogUHV0IHNvbWUgZXJyb3IgaGFuZGxpbmcgb24gdGhpcyBmb3IgdHJ5aW5nIHRvIG1ha2UgdGhlIGJvdW5kcyB0b28gc21hbGwgZm9yIHRoZSB2aWV3cG9ydFxyXG4gICAgLy8gVE9ETzogVGhpcyBzaG91bGQgcHJvYmFibHkgYmUgZG9uZSBhdXRvbWF0aWNhbGx5LCBvciBzaG91bGQgY29uc2lkZXIgdGhlIGFzcGVjdCByYXRpbyBvciBzb21ldGhpbmdcclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgYm91bmRzIG9mIHRoZSB2aWV3cG9ydFxyXG4gICAgICogQHBhcmFtIGxvd2VyWCBUaGUgbGVmdCBlZGdlIG9mIHRoZSB2aWV3cG9ydFxyXG4gICAgICogQHBhcmFtIGxvd2VyWSBUaGUgdG9wIGVkZ2Ugb2YgdGhlIHZpZXdwb3J0XHJcbiAgICAgKiBAcGFyYW0gdXBwZXJYIFRoZSByaWdodCBlZGdlIG9mIHRoZSB2aWV3cG9ydFxyXG4gICAgICogQHBhcmFtIHVwcGVyWSBUaGUgYm90dG9tIGVkZ2Ugb2YgdGhlIHZpZXdwb3J0XHJcbiAgICAgKi9cclxuICAgIHNldEJvdW5kcyhsb3dlclg6IG51bWJlciwgbG93ZXJZOiBudW1iZXIsIHVwcGVyWDogbnVtYmVyLCB1cHBlclk6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICAgIGxldCBod2lkdGggPSAodXBwZXJYIC0gbG93ZXJYKS8yO1xyXG4gICAgICAgIGxldCBoaGVpZ2h0ID0gKHVwcGVyWSAtIGxvd2VyWSkvMjtcclxuICAgICAgICBsZXQgeCA9IGxvd2VyWCArIGh3aWR0aDtcclxuICAgICAgICBsZXQgeSA9IGxvd2VyWSArIGhoZWlnaHQ7XHJcbiAgICAgICAgdGhpcy5ib3VuZGFyeS5jZW50ZXIuc2V0KHgsIHkpO1xyXG4gICAgICAgIHRoaXMuYm91bmRhcnkuaGFsZlNpemUuc2V0KGh3aWR0aCwgaGhlaWdodCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNYWtlIHRoZSB2aWV3cG9ydCBmb2xsb3cgdGhlIHNwZWNpZmllZCBHYW1lTm9kZVxyXG4gICAgICogQHBhcmFtIG5vZGUgVGhlIEdhbWVOb2RlIHRvIGZvbGxvd1xyXG4gICAgICovXHJcbiAgICBmb2xsb3cobm9kZTogR2FtZU5vZGUpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmZvbGxvd2luZyA9IG5vZGU7XHJcbiAgICB9XHJcblxyXG4gICAgdXBkYXRlVmlldygpOiB2b2lkIHtcclxuICAgICAgICBpZih0aGlzLmxhc3RQb3NpdGlvbnMuZ2V0U2l6ZSgpID4gdGhpcy5zbW9vdGhpbmdGYWN0b3Ipe1xyXG4gICAgICAgICAgICB0aGlzLmxhc3RQb3NpdGlvbnMuZGVxdWV1ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAvLyBHZXQgdGhlIGF2ZXJhZ2Ugb2YgdGhlIGxhc3QgMTAgcG9zaXRpb25zXHJcbiAgICAgICAgbGV0IHBvcyA9IFZlYzIuWkVSTztcclxuICAgICAgICB0aGlzLmxhc3RQb3NpdGlvbnMuZm9yRWFjaChwb3NpdGlvbiA9PiBwb3MuYWRkKHBvc2l0aW9uKSk7XHJcbiAgICAgICAgcG9zLnNjYWxlKDEvdGhpcy5sYXN0UG9zaXRpb25zLmdldFNpemUoKSk7XHJcblxyXG4gICAgICAgIC8vIFNldCB0aGlzIHBvc2l0aW9uIGVpdGhlciB0byB0aGUgb2JqZWN0IG9yIHRvIGl0cyBib3VuZHNcclxuICAgICAgICBwb3MueCA9IE1hdGhVdGlscy5jbGFtcChwb3MueCwgdGhpcy5ib3VuZGFyeS5sZWZ0ICsgdGhpcy52aWV3Lmh3LCB0aGlzLmJvdW5kYXJ5LnJpZ2h0IC0gdGhpcy52aWV3Lmh3KTtcclxuICAgICAgICBwb3MueSA9IE1hdGhVdGlscy5jbGFtcChwb3MueSwgdGhpcy5ib3VuZGFyeS50b3AgKyB0aGlzLnZpZXcuaGgsIHRoaXMuYm91bmRhcnkuYm90dG9tIC0gdGhpcy52aWV3LmhoKTtcclxuXHJcbiAgICAgICAgLy8gQXNzdXJlIHRoZXJlIGFyZSBubyBsaW5lcyBpbiB0aGUgdGlsZW1hcFxyXG4gICAgICAgIHBvcy54ID0gTWF0aC5mbG9vcihwb3MueCk7XHJcbiAgICAgICAgcG9zLnkgPSBNYXRoLmZsb29yKHBvcy55KTtcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLnZpZXcuY2VudGVyLmNvcHkocG9zKTtcclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGUoZGVsdGFUOiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgICAvLyBJZiB6b29tIGlzIGVuYWJsZWRcclxuICAgICAgICBpZih0aGlzLnNjcm9sbFpvb21FbmFibGVkKXtcclxuICAgICAgICAgICAgaWYoSW5wdXQuZGlkSnVzdFNjcm9sbCgpKXtcclxuICAgICAgICAgICAgICAgIGxldCBjdXJyZW50U2l6ZSA9IHRoaXMudmlldy5nZXRIYWxmU2l6ZSgpLmNsb25lKCk7XHJcbiAgICAgICAgICAgICAgICBpZihJbnB1dC5nZXRTY3JvbGxEaXJlY3Rpb24oKSA8IDApe1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFpvb20gaW5cclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50U2l6ZS5zY2FsZSgxL3RoaXMuWk9PTV9GQUNUT1IpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBab29tIG91dFxyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTaXplLnNjYWxlKHRoaXMuWk9PTV9GQUNUT1IpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmKGN1cnJlbnRTaXplLnggPiB0aGlzLmJvdW5kYXJ5Lmh3KXtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgZmFjdG9yID0gdGhpcy5ib3VuZGFyeS5ody9jdXJyZW50U2l6ZS54O1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTaXplLnggPSB0aGlzLmJvdW5kYXJ5Lmh3O1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTaXplLnkgKj0gZmFjdG9yO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmKGN1cnJlbnRTaXplLnkgPiB0aGlzLmJvdW5kYXJ5LmhoKXtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgZmFjdG9yID0gdGhpcy5ib3VuZGFyeS5oaC9jdXJyZW50U2l6ZS55O1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTaXplLnkgPSB0aGlzLmJvdW5kYXJ5LmhoO1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTaXplLnggKj0gZmFjdG9yO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMudmlldy5zZXRIYWxmU2l6ZShjdXJyZW50U2l6ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIElmIHZpZXdwb3J0IGlzIGZvbGxvd2luZyBhbiBvYmplY3RcclxuICAgICAgICBpZih0aGlzLmZvbGxvd2luZyl7XHJcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBvdXIgbGlzdCBvZiBwcmV2aW91cyBwb3NpdGlvbnNcclxuICAgICAgICAgICAgdGhpcy5sYXN0UG9zaXRpb25zLmVucXVldWUodGhpcy5mb2xsb3dpbmcucG9zaXRpb24uY2xvbmUoKSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5sYXN0UG9zaXRpb25zLmVucXVldWUodGhpcy5mb2N1cyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnVwZGF0ZVZpZXcoKTtcclxuICAgIH1cclxufSIsImltcG9ydCBTY2VuZSBmcm9tIFwiLi4vU2NlbmVcIjtcclxuaW1wb3J0IFVJRWxlbWVudCBmcm9tIFwiLi4vLi4vTm9kZXMvVUlFbGVtZW50XCI7XHJcbmltcG9ydCBHcmFwaGljIGZyb20gXCIuLi8uLi9Ob2Rlcy9HcmFwaGljXCI7XHJcbmltcG9ydCBTcHJpdGUgZnJvbSBcIi4uLy4uL05vZGVzL1Nwcml0ZXMvU3ByaXRlXCI7XHJcbmltcG9ydCBBbmltYXRlZFNwcml0ZSBmcm9tIFwiLi4vLi4vTm9kZXMvU3ByaXRlcy9BbmltYXRlZFNwcml0ZVwiO1xyXG5pbXBvcnQgeyBHcmFwaGljVHlwZSB9IGZyb20gXCIuLi8uLi9Ob2Rlcy9HcmFwaGljcy9HcmFwaGljVHlwZXNcIjtcclxuaW1wb3J0IHsgVUlFbGVtZW50VHlwZSB9IGZyb20gXCIuLi8uLi9Ob2Rlcy9VSUVsZW1lbnRzL1VJRWxlbWVudFR5cGVzXCI7XHJcbmltcG9ydCBQb2ludCBmcm9tIFwiLi4vLi4vTm9kZXMvR3JhcGhpY3MvUG9pbnRcIjtcclxuaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9WZWMyXCI7XHJcbmltcG9ydCBCdXR0b24gZnJvbSBcIi4uLy4uL05vZGVzL1VJRWxlbWVudHMvQnV0dG9uXCI7XHJcbmltcG9ydCBMYWJlbCBmcm9tIFwiLi4vLi4vTm9kZXMvVUlFbGVtZW50cy9MYWJlbFwiO1xyXG5pbXBvcnQgU2xpZGVyIGZyb20gXCIuLi8uLi9Ob2Rlcy9VSUVsZW1lbnRzL1NsaWRlclwiO1xyXG5pbXBvcnQgVGV4dElucHV0IGZyb20gXCIuLi8uLi9Ob2Rlcy9VSUVsZW1lbnRzL1RleHRJbnB1dFwiO1xyXG5pbXBvcnQgUmVjdCBmcm9tIFwiLi4vLi4vTm9kZXMvR3JhcGhpY3MvUmVjdFwiO1xyXG5pbXBvcnQgUmVzb3VyY2VNYW5hZ2VyIGZyb20gXCIuLi8uLi9SZXNvdXJjZU1hbmFnZXIvUmVzb3VyY2VNYW5hZ2VyXCI7XHJcbmltcG9ydCBMaW5lIGZyb20gXCIuLi8uLi9Ob2Rlcy9HcmFwaGljcy9MaW5lXCI7XHJcbmltcG9ydCBQYXJ0aWNsZSBmcm9tIFwiLi4vLi4vTm9kZXMvR3JhcGhpY3MvUGFydGljbGVcIjtcclxuXHJcbi8vIEBpZ25vcmVQYWdlXHJcblxyXG4vKipcclxuICogQSBmYWN0b3J5IHRoYXQgYWJzdHJhY3RzIGFkZGluZyBAcmVmZXJlbmNlW0NhbnZhc05vZGVdcyB0byB0aGUgQHJlZmVyZW5jZVtTY2VuZV0uXHJcbiAqIEFjY2VzcyBtZXRob2RzIGluIHRoaXMgZmFjdG9yeSB0aHJvdWdoIFNjZW5lLmFkZC5bbWV0aG9kTmFtZV0oKS5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENhbnZhc05vZGVGYWN0b3J5IHtcclxuXHRwcm90ZWN0ZWQgc2NlbmU6IFNjZW5lO1xyXG5cdHByb3RlY3RlZCByZXNvdXJjZU1hbmFnZXI6IFJlc291cmNlTWFuYWdlcjtcclxuXHJcblx0aW5pdChzY2VuZTogU2NlbmUpOiB2b2lkIHtcclxuXHRcdHRoaXMuc2NlbmUgPSBzY2VuZTtcclxuXHRcdHRoaXMucmVzb3VyY2VNYW5hZ2VyID0gUmVzb3VyY2VNYW5hZ2VyLmdldEluc3RhbmNlKCk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBBZGRzIGFuIGluc3RhbmNlIG9mIGEgVUlFbGVtZW50IHRvIHRoZSBjdXJyZW50IHNjZW5lIC0gaS5lLiBhbnkgY2xhc3MgdGhhdCBleHRlbmRzIFVJRWxlbWVudFxyXG5cdCAqIEBwYXJhbSB0eXBlIFRoZSB0eXBlIG9mIFVJRWxlbWVudCB0byBhZGRcclxuXHQgKiBAcGFyYW0gbGF5ZXJOYW1lIFRoZSBsYXllciB0byBhZGQgdGhlIFVJRWxlbWVudCB0b1xyXG5cdCAqIEBwYXJhbSBvcHRpb25zIEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyB0byBmZWVkIHRvIHRoZSBjb25zdHJ1Y3RvclxyXG5cdCAqIEByZXR1cm5zIEEgbmV3IFVJRWxlbWVudFxyXG5cdCAqL1xyXG5cdGFkZFVJRWxlbWVudCA9ICh0eXBlOiBzdHJpbmcgfCBVSUVsZW1lbnRUeXBlLCBsYXllck5hbWU6IHN0cmluZywgb3B0aW9ucz86IFJlY29yZDxzdHJpbmcsIGFueT4pOiBVSUVsZW1lbnQgPT4ge1xyXG5cdFx0Ly8gR2V0IHRoZSBsYXllclxyXG5cdFx0bGV0IGxheWVyID0gdGhpcy5zY2VuZS5nZXRMYXllcihsYXllck5hbWUpO1xyXG5cclxuXHRcdGxldCBpbnN0YW5jZTogVUlFbGVtZW50O1xyXG5cclxuXHRcdHN3aXRjaCh0eXBlKXtcclxuXHRcdFx0Y2FzZSBVSUVsZW1lbnRUeXBlLkJVVFRPTjpcclxuXHRcdFx0XHRpbnN0YW5jZSA9IHRoaXMuYnVpbGRCdXR0b24ob3B0aW9ucyk7XHJcblx0XHRcdGJyZWFrO1xyXG5cdFx0XHRjYXNlIFVJRWxlbWVudFR5cGUuTEFCRUw6XHJcblx0XHRcdFx0aW5zdGFuY2UgPSB0aGlzLmJ1aWxkTGFiZWwob3B0aW9ucyk7XHJcblx0XHRcdGJyZWFrO1xyXG5cdFx0XHRjYXNlIFVJRWxlbWVudFR5cGUuU0xJREVSOlxyXG5cdFx0XHRcdGluc3RhbmNlID0gdGhpcy5idWlsZFNsaWRlcihvcHRpb25zKTtcclxuXHRcdFx0YnJlYWs7XHJcblx0XHRcdGNhc2UgVUlFbGVtZW50VHlwZS5URVhUX0lOUFVUOlxyXG5cdFx0XHRcdGluc3RhbmNlID0gdGhpcy5idWlsZFRleHRJbnB1dChvcHRpb25zKTtcclxuXHRcdFx0YnJlYWs7XHJcblx0XHRcdGRlZmF1bHQ6XHJcblx0XHRcdFx0dGhyb3cgYFVJRWxlbWVudFR5cGUgJyR7dHlwZX0nIGRvZXMgbm90IGV4aXN0LCBvciBpcyByZWdpc3RlcmVkIGluY29ycmVjdGx5LmBcclxuXHRcdH1cclxuXHJcblx0XHRpbnN0YW5jZS5zZXRTY2VuZSh0aGlzLnNjZW5lKTtcclxuXHRcdGluc3RhbmNlLmlkID0gdGhpcy5zY2VuZS5nZW5lcmF0ZUlkKCk7XHJcblx0XHR0aGlzLnNjZW5lLmdldFNjZW5lR3JhcGgoKS5hZGROb2RlKGluc3RhbmNlKTtcclxuXHJcblx0XHQvLyBBZGQgaW5zdGFuY2UgdG8gbGF5ZXJcclxuXHRcdGxheWVyLmFkZE5vZGUoaW5zdGFuY2UpXHJcblxyXG5cdFx0cmV0dXJuIGluc3RhbmNlO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQWRkcyBhIHNwcml0ZSB0byB0aGUgY3VycmVudCBzY2VuZVxyXG5cdCAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgaW1hZ2UgdGhlIHNwcml0ZSB3aWxsIHJlcHJlc2VudFxyXG5cdCAqIEBwYXJhbSBsYXllck5hbWUgVGhlIGxheWVyIG9uIHdoaWNoIHRvIGFkZCB0aGUgc3ByaXRlXHJcblx0ICogQHJldHVybnMgQSBuZXcgU3ByaXRlXHJcblx0ICovXHJcblx0YWRkU3ByaXRlID0gKGtleTogc3RyaW5nLCBsYXllck5hbWU6IHN0cmluZyk6IFNwcml0ZSA9PiB7XHJcblx0XHRsZXQgbGF5ZXIgPSB0aGlzLnNjZW5lLmdldExheWVyKGxheWVyTmFtZSk7XHJcblxyXG5cdFx0bGV0IGluc3RhbmNlID0gbmV3IFNwcml0ZShrZXkpO1xyXG5cclxuXHRcdC8vIEFkZCBpbnN0YW5jZSB0byBzY2VuZVxyXG5cdFx0aW5zdGFuY2Uuc2V0U2NlbmUodGhpcy5zY2VuZSk7XHJcblx0XHRpbnN0YW5jZS5pZCA9IHRoaXMuc2NlbmUuZ2VuZXJhdGVJZCgpO1xyXG5cclxuXHRcdGlmKCEodGhpcy5zY2VuZS5pc1BhcmFsbGF4TGF5ZXIobGF5ZXJOYW1lKSB8fCB0aGlzLnNjZW5lLmlzVUlMYXllcihsYXllck5hbWUpKSl7XHJcblx0XHRcdHRoaXMuc2NlbmUuZ2V0U2NlbmVHcmFwaCgpLmFkZE5vZGUoaW5zdGFuY2UpO1xyXG5cdFx0fVxyXG5cdFx0XHJcblx0XHQvLyBBZGQgaW5zdGFuY2UgdG8gbGF5ZXJcclxuXHRcdGxheWVyLmFkZE5vZGUoaW5zdGFuY2UpO1xyXG5cclxuXHRcdHJldHVybiBpbnN0YW5jZTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEFkZHMgYW4gQW5pbWF0ZWRTcHJpdGUgdG8gdGhlIGN1cnJlbnQgc2NlbmVcclxuXHQgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIGltYWdlIHRoZSBzcHJpdGUgd2lsbCByZXByZXNlbnRcclxuXHQgKiBAcGFyYW0gbGF5ZXJOYW1lIFRoZSBsYXllciBvbiB3aGljaCB0byBhZGQgdGhlIHNwcml0ZVxyXG5cdCAqIEByZXR1cm5zIEEgbmV3IEFuaW1hdGVkU3ByaXRlXHJcblx0ICovXHJcblx0YWRkQW5pbWF0ZWRTcHJpdGUgPSAoa2V5OiBzdHJpbmcsIGxheWVyTmFtZTogc3RyaW5nKTogQW5pbWF0ZWRTcHJpdGUgPT4ge1xyXG5cdFx0bGV0IGxheWVyID0gdGhpcy5zY2VuZS5nZXRMYXllcihsYXllck5hbWUpO1xyXG5cdFx0bGV0IHNwcml0ZXNoZWV0ID0gdGhpcy5yZXNvdXJjZU1hbmFnZXIuZ2V0U3ByaXRlc2hlZXQoa2V5KTtcclxuXHRcdGxldCBpbnN0YW5jZSA9IG5ldyBBbmltYXRlZFNwcml0ZShzcHJpdGVzaGVldCk7XHJcblxyXG5cdFx0Ly8gQWRkIGluc3RhbmNlIGZvIHNjZW5lXHJcblx0XHRpbnN0YW5jZS5zZXRTY2VuZSh0aGlzLnNjZW5lKTtcclxuXHRcdGluc3RhbmNlLmlkID0gdGhpcy5zY2VuZS5nZW5lcmF0ZUlkKCk7XHJcblx0XHRcclxuXHRcdGlmKCEodGhpcy5zY2VuZS5pc1BhcmFsbGF4TGF5ZXIobGF5ZXJOYW1lKSB8fCB0aGlzLnNjZW5lLmlzVUlMYXllcihsYXllck5hbWUpKSl7XHJcblx0XHRcdHRoaXMuc2NlbmUuZ2V0U2NlbmVHcmFwaCgpLmFkZE5vZGUoaW5zdGFuY2UpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEFkZCBpbnN0YW5jZSB0byBsYXllclxyXG5cdFx0bGF5ZXIuYWRkTm9kZShpbnN0YW5jZSk7XHJcblxyXG5cdFx0cmV0dXJuIGluc3RhbmNlO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQWRkcyBhIG5ldyBncmFwaGljIGVsZW1lbnQgdG8gdGhlIGN1cnJlbnQgU2NlbmVcclxuXHQgKiBAcGFyYW0gdHlwZSBUaGUgdHlwZSBvZiBncmFwaGljIHRvIGFkZFxyXG5cdCAqIEBwYXJhbSBsYXllck5hbWUgVGhlIGxheWVyIG9uIHdoaWNoIHRvIGFkZCB0aGUgZ3JhcGhpY1xyXG5cdCAqIEBwYXJhbSBvcHRpb25zIEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyB0byBzZW5kIHRvIHRoZSBncmFwaGljIGNvbnN0cnVjdG9yXHJcblx0ICogQHJldHVybnMgQSBuZXcgR3JhcGhpY1xyXG5cdCAqL1xyXG5cdGFkZEdyYXBoaWMgPSAodHlwZTogR3JhcGhpY1R5cGUgfCBzdHJpbmcsIGxheWVyTmFtZTogc3RyaW5nLCBvcHRpb25zPzogUmVjb3JkPHN0cmluZywgYW55Pik6IEdyYXBoaWMgPT4ge1xyXG5cdFx0Ly8gR2V0IHRoZSBsYXllclxyXG5cdFx0bGV0IGxheWVyID0gdGhpcy5zY2VuZS5nZXRMYXllcihsYXllck5hbWUpO1xyXG5cclxuXHRcdGxldCBpbnN0YW5jZTogR3JhcGhpYztcclxuXHJcblx0XHRzd2l0Y2godHlwZSl7XHJcblx0XHRcdGNhc2UgR3JhcGhpY1R5cGUuUE9JTlQ6XHJcblx0XHRcdFx0aW5zdGFuY2UgPSB0aGlzLmJ1aWxkUG9pbnQob3B0aW9ucyk7XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdGNhc2UgR3JhcGhpY1R5cGUuTElORTpcclxuXHRcdFx0XHRpbnN0YW5jZSA9IHRoaXMuYnVpbGRMaW5lKG9wdGlvbnMpO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRjYXNlIEdyYXBoaWNUeXBlLlJFQ1Q6XHJcblx0XHRcdFx0aW5zdGFuY2UgPSB0aGlzLmJ1aWxkUmVjdChvcHRpb25zKTtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0Y2FzZSBHcmFwaGljVHlwZS5QQVJUSUNMRTpcclxuXHRcdFx0XHRpbnN0YW5jZSA9IHRoaXMuYnVpbGRQYXJ0aWNsZShvcHRpb25zKTtcclxuXHRcdFx0XHRicmVhaztcdFx0XHRcdFxyXG5cdFx0XHRkZWZhdWx0OlxyXG5cdFx0XHRcdHRocm93IGBHcmFwaGljVHlwZSAnJHt0eXBlfScgZG9lcyBub3QgZXhpc3QsIG9yIGlzIHJlZ2lzdGVyZWQgaW5jb3JyZWN0bHkuYFxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEFkZCBpbnN0YW5jZSB0byBzY2VuZVxyXG5cdFx0aW5zdGFuY2Uuc2V0U2NlbmUodGhpcy5zY2VuZSk7XHJcblx0XHRpbnN0YW5jZS5pZCA9IHRoaXMuc2NlbmUuZ2VuZXJhdGVJZCgpO1xyXG5cclxuXHRcdGlmKCEodGhpcy5zY2VuZS5pc1BhcmFsbGF4TGF5ZXIobGF5ZXJOYW1lKSB8fCB0aGlzLnNjZW5lLmlzVUlMYXllcihsYXllck5hbWUpKSl7XHJcblx0XHRcdHRoaXMuc2NlbmUuZ2V0U2NlbmVHcmFwaCgpLmFkZE5vZGUoaW5zdGFuY2UpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEFkZCBpbnN0YW5jZSB0byBsYXllclxyXG5cdFx0bGF5ZXIuYWRkTm9kZShpbnN0YW5jZSk7XHJcblxyXG5cdFx0cmV0dXJuIGluc3RhbmNlO1xyXG5cdH1cclxuXHJcblx0LyogLS0tLS0tLS0tLSBCVUlMREVSUyAtLS0tLS0tLS0tICovXHJcblxyXG5cdGJ1aWxkQnV0dG9uKG9wdGlvbnM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogQnV0dG9uIHtcclxuXHRcdHRoaXMuY2hlY2tJZlByb3BFeGlzdHMoXCJCdXR0b25cIiwgb3B0aW9ucywgXCJwb3NpdGlvblwiLCBWZWMyLCBcIlZlYzJcIik7XHJcblx0XHR0aGlzLmNoZWNrSWZQcm9wRXhpc3RzKFwiQnV0dG9uXCIsIG9wdGlvbnMsIFwidGV4dFwiLCBcInN0cmluZ1wiKTtcclxuXHJcblx0XHRyZXR1cm4gbmV3IEJ1dHRvbihvcHRpb25zLnBvc2l0aW9uLCBvcHRpb25zLnRleHQpO1xyXG5cdH1cclxuXHJcblx0YnVpbGRMYWJlbChvcHRpb25zPzogUmVjb3JkPHN0cmluZywgYW55Pik6IExhYmVsIHtcclxuXHRcdHRoaXMuY2hlY2tJZlByb3BFeGlzdHMoXCJMYWJlbFwiLCBvcHRpb25zLCBcInBvc2l0aW9uXCIsIFZlYzIsIFwiVmVjMlwiKTtcclxuXHRcdHRoaXMuY2hlY2tJZlByb3BFeGlzdHMoXCJMYWJlbFwiLCBvcHRpb25zLCBcInRleHRcIiwgXCJzdHJpbmdcIik7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBMYWJlbChvcHRpb25zLnBvc2l0aW9uLCBvcHRpb25zLnRleHQpXHJcblx0fVxyXG5cclxuXHRidWlsZFNsaWRlcihvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogU2xpZGVyIHtcclxuXHRcdHRoaXMuY2hlY2tJZlByb3BFeGlzdHMoXCJTbGlkZXJcIiwgb3B0aW9ucywgXCJwb3NpdGlvblwiLCBWZWMyLCBcIlZlYzJcIik7XHJcblxyXG5cdFx0bGV0IGluaXRWYWx1ZSA9IDA7XHJcblx0XHRpZihvcHRpb25zLnZhbHVlICE9PSB1bmRlZmluZWQpe1xyXG5cdFx0XHRpbml0VmFsdWUgPSBvcHRpb25zLnZhbHVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBuZXcgU2xpZGVyKG9wdGlvbnMucG9zaXRpb24sIGluaXRWYWx1ZSk7XHJcblx0fVxyXG5cclxuXHRidWlsZFRleHRJbnB1dChvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogVGV4dElucHV0IHtcclxuXHRcdHRoaXMuY2hlY2tJZlByb3BFeGlzdHMoXCJUZXh0SW5wdXRcIiwgb3B0aW9ucywgXCJwb3NpdGlvblwiLCBWZWMyLCBcIlZlYzJcIik7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBUZXh0SW5wdXQob3B0aW9ucy5wb3NpdGlvbik7XHJcblx0fVxyXG5cclxuXHRidWlsZFBvaW50KG9wdGlvbnM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogUG9pbnQge1xyXG5cdFx0dGhpcy5jaGVja0lmUHJvcEV4aXN0cyhcIlBvaW50XCIsIG9wdGlvbnMsIFwicG9zaXRpb25cIiwgVmVjMiwgXCJWZWMyXCIpO1xyXG5cclxuXHRcdHJldHVybiBuZXcgUG9pbnQob3B0aW9ucy5wb3NpdGlvbik7XHJcblx0fVxyXG5cclxuXHRidWlsZFBhcnRpY2xlKG9wdGlvbnM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogUG9pbnQge1xyXG5cdFx0dGhpcy5jaGVja0lmUHJvcEV4aXN0cyhcIlBhcnRpY2xlXCIsIG9wdGlvbnMsIFwicG9zaXRpb25cIiwgVmVjMiwgXCJWZWMyXCIpO1xyXG5cdFx0dGhpcy5jaGVja0lmUHJvcEV4aXN0cyhcIlBhcnRpY2xlXCIsIG9wdGlvbnMsIFwic2l6ZVwiLCBWZWMyLCBcIlZlYzJcIik7XHJcblx0XHR0aGlzLmNoZWNrSWZQcm9wRXhpc3RzKFwiUGFydGljbGVcIiwgb3B0aW9ucywgXCJtYXNzXCIsIFwibnVtYmVyXCIsIFwibnVtYmVyXCIpO1xyXG5cclxuXHRcdC8vQ2hhbmdlZCBmb3IgdGVzdGluZ1xyXG5cdFx0cmV0dXJuIG5ldyBQYXJ0aWNsZShvcHRpb25zLnBvc2l0aW9uLCBvcHRpb25zLnNpemUsIG9wdGlvbnMubWFzcyk7XHJcblx0fVxyXG5cclxuXHRidWlsZExpbmUob3B0aW9ucz86IFJlY29yZDxzdHJpbmcsIGFueT4pOiBQb2ludCB7XHJcblx0XHR0aGlzLmNoZWNrSWZQcm9wRXhpc3RzKFwiTGluZVwiLCBvcHRpb25zLCBcInN0YXJ0XCIsIFZlYzIsIFwiVmVjMlwiKTtcclxuXHRcdHRoaXMuY2hlY2tJZlByb3BFeGlzdHMoXCJMaW5lXCIsIG9wdGlvbnMsIFwiZW5kXCIsIFZlYzIsIFwiVmVjMlwiKTtcclxuXHJcblx0XHRyZXR1cm4gbmV3IExpbmUob3B0aW9ucy5zdGFydCwgb3B0aW9ucy5lbmQpO1xyXG5cdH1cclxuXHJcblx0YnVpbGRSZWN0KG9wdGlvbnM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogUmVjdCB7XHJcblx0XHR0aGlzLmNoZWNrSWZQcm9wRXhpc3RzKFwiUmVjdFwiLCBvcHRpb25zLCBcInBvc2l0aW9uXCIsIFZlYzIsIFwiVmVjMlwiKTtcclxuXHRcdHRoaXMuY2hlY2tJZlByb3BFeGlzdHMoXCJSZWN0XCIsIG9wdGlvbnMsIFwic2l6ZVwiLCBWZWMyLCBcIlZlYzJcIik7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBSZWN0KG9wdGlvbnMucG9zaXRpb24sIG9wdGlvbnMuc2l6ZSk7XHJcblx0fVxyXG5cclxuXHQvKiAtLS0tLS0tLS0tIEVSUk9SIEhBTkRMSU5HIC0tLS0tLS0tLS0gKi9cclxuXHJcblx0Y2hlY2tJZlByb3BFeGlzdHM8VD4ob2JqZWN0TmFtZTogc3RyaW5nLCBvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+LCBwcm9wOiBzdHJpbmcsIHR5cGU6IChuZXcgKC4uLmFyZ3M6IGFueSkgPT4gVCkgfCBzdHJpbmcsIHR5cGVOYW1lPzogc3RyaW5nKXtcclxuXHRcdGlmKCFvcHRpb25zIHx8IG9wdGlvbnNbcHJvcF0gPT09IHVuZGVmaW5lZCl7XHJcblx0XHRcdC8vIENoZWNrIHRoYXQgdGhlIG9wdGlvbnMgb2JqZWN0IGhhcyB0aGUgcHJvcGVydHlcclxuXHRcdFx0dGhyb3cgYCR7b2JqZWN0TmFtZX0gb2JqZWN0IHJlcXVpcmVzIGFyZ3VtZW50ICR7cHJvcH0gb2YgdHlwZSAke3R5cGVOYW1lfSwgYnV0IG5vbmUgd2FzIHByb3ZpZGVkLmA7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHQvLyBDaGVjayB0aGF0IHRoZSBwcm9wZXJ0eSBoYXMgdGhlIGNvcnJlY3QgdHlwZVxyXG5cdFx0XHRpZigodHlwZW9mIHR5cGUpID09PSBcInN0cmluZ1wiKXtcclxuXHRcdFx0XHRpZighKHR5cGVvZiBvcHRpb25zW3Byb3BdID09PSB0eXBlKSl7XHJcblx0XHRcdFx0XHR0aHJvdyBgJHtvYmplY3ROYW1lfSBvYmplY3QgcmVxdWlyZXMgYXJndW1lbnQgJHtwcm9wfSBvZiB0eXBlICR7dHlwZX0sIGJ1dCBwcm92aWRlZCAke3Byb3B9IHdhcyBub3Qgb2YgdHlwZSAke3R5cGV9LmA7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9IGVsc2UgaWYodHlwZSBpbnN0YW5jZW9mIEZ1bmN0aW9uKXtcclxuXHRcdFx0XHQvLyBJZiB0eXBlIGlzIGEgY29uc3RydWN0b3IsIGNoZWNrIGFnYWluc3QgdGhhdFxyXG5cdFx0XHRcdGlmKCEob3B0aW9uc1twcm9wXSBpbnN0YW5jZW9mIHR5cGUpKXtcclxuXHRcdFx0XHRcdHRocm93IGAke29iamVjdE5hbWV9IG9iamVjdCByZXF1aXJlcyBhcmd1bWVudCAke3Byb3B9IG9mIHR5cGUgJHt0eXBlTmFtZX0sIGJ1dCBwcm92aWRlZCAke3Byb3B9IHdhcyBub3Qgb2YgdHlwZSAke3R5cGVOYW1lfS5gO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR0aHJvdyBgJHtvYmplY3ROYW1lfSBvYmplY3QgcmVxdWlyZXMgYXJndW1lbnQgJHtwcm9wfSBvZiB0eXBlICR7dHlwZU5hbWV9LCBidXQgcHJvdmlkZWQgJHtwcm9wfSB3YXMgbm90IG9mIHR5cGUgJHt0eXBlTmFtZX0uYDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxufSIsImltcG9ydCBTY2VuZSBmcm9tIFwiLi4vU2NlbmVcIjtcclxuaW1wb3J0IENhbnZhc05vZGVGYWN0b3J5IGZyb20gXCIuL0NhbnZhc05vZGVGYWN0b3J5XCI7XHJcbmltcG9ydCBUaWxlbWFwRmFjdG9yeSBmcm9tIFwiLi9UaWxlbWFwRmFjdG9yeVwiO1xyXG5pbXBvcnQgVGlsZW1hcCBmcm9tIFwiLi4vLi4vTm9kZXMvVGlsZW1hcFwiO1xyXG5pbXBvcnQgeyBVSUVsZW1lbnRUeXBlIH0gZnJvbSBcIi4uLy4uL05vZGVzL1VJRWxlbWVudHMvVUlFbGVtZW50VHlwZXNcIjtcclxuaW1wb3J0IFVJRWxlbWVudCBmcm9tIFwiLi4vLi4vTm9kZXMvVUlFbGVtZW50XCI7XHJcbmltcG9ydCBTcHJpdGUgZnJvbSBcIi4uLy4uL05vZGVzL1Nwcml0ZXMvU3ByaXRlXCI7XHJcbmltcG9ydCB7IEdyYXBoaWNUeXBlIH0gZnJvbSBcIi4uLy4uL05vZGVzL0dyYXBoaWNzL0dyYXBoaWNUeXBlc1wiO1xyXG5pbXBvcnQgR3JhcGhpYyBmcm9tIFwiLi4vLi4vTm9kZXMvR3JhcGhpY1wiO1xyXG5pbXBvcnQgQW5pbWF0ZWRTcHJpdGUgZnJvbSBcIi4uLy4uL05vZGVzL1Nwcml0ZXMvQW5pbWF0ZWRTcHJpdGVcIjtcclxuaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9WZWMyXCI7XHJcbmltcG9ydCBMYXllciBmcm9tIFwiLi4vTGF5ZXJcIjtcclxuXHJcbi8qKlxyXG4gKiBUaGUgbWFuYWdlciBvZiBhbGwgZmFjdG9yaWVzIHVzZWQgZm9yIGFkZGluZyBAcmVmZXJlbmNlW0dhbWVOb2RlXXMgdG8gdGhlIEByZWZlcmVuY2VbU2NlbmVdLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRmFjdG9yeU1hbmFnZXIge1xyXG5cclxuICAgIC8vIENvbnN0cnVjdG9ycyBhcmUgY2FsbGVkIGhlcmUgdG8gYWxsb3cgYXNzaWdubWVudCBvZiB0aGVpciBmdW5jdGlvbnMgdG8gZnVuY3Rpb25zIGluIHRoaXMgY2xhc3NcclxuICAgIHByaXZhdGUgY2FudmFzTm9kZUZhY3Rvcnk6IENhbnZhc05vZGVGYWN0b3J5ID0gbmV3IENhbnZhc05vZGVGYWN0b3J5KCk7XHJcbiAgICBwcml2YXRlIHRpbGVtYXBGYWN0b3J5OiBUaWxlbWFwRmFjdG9yeSA9IG5ldyBUaWxlbWFwRmFjdG9yeSgpO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKHNjZW5lOiBTY2VuZSwgdGlsZW1hcHM6IEFycmF5PFRpbGVtYXA+KXtcclxuICAgICAgICB0aGlzLmNhbnZhc05vZGVGYWN0b3J5LmluaXQoc2NlbmUpO1xyXG4gICAgICAgIHRoaXMudGlsZW1hcEZhY3RvcnkuaW5pdChzY2VuZSwgdGlsZW1hcHMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEV4cG9zZSBhbGwgb2YgdGhlIGZhY3RvcmllcyB0aHJvdWdoIHRoZSBmYWN0b3J5IG1hbmFnZXJcclxuICAgIC8qKlxyXG5cdCAqIEFkZHMgYW4gaW5zdGFuY2Ugb2YgYSBVSUVsZW1lbnQgdG8gdGhlIGN1cnJlbnQgc2NlbmUgLSBpLmUuIGFueSBjbGFzcyB0aGF0IGV4dGVuZHMgVUlFbGVtZW50XHJcblx0ICogQHBhcmFtIHR5cGUgVGhlIHR5cGUgb2YgVUlFbGVtZW50IHRvIGFkZFxyXG5cdCAqIEBwYXJhbSBsYXllck5hbWUgVGhlIGxheWVyIHRvIGFkZCB0aGUgVUlFbGVtZW50IHRvXHJcblx0ICogQHBhcmFtIG9wdGlvbnMgQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIHRvIGZlZWQgdG8gdGhlIGNvbnN0cnVjdG9yXHJcblx0ICogQHJldHVybnMgQSBuZXcgVUlFbGVtZW50XHJcblx0ICovXHJcbiAgICB1aUVsZW1lbnQodHlwZTogc3RyaW5nIHwgVUlFbGVtZW50VHlwZSwgbGF5ZXJOYW1lOiBzdHJpbmcsIG9wdGlvbnM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogVUlFbGVtZW50IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jYW52YXNOb2RlRmFjdG9yeS5hZGRVSUVsZW1lbnQodHlwZSwgbGF5ZXJOYW1lLCBvcHRpb25zKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuXHQgKiBBZGRzIGEgc3ByaXRlIHRvIHRoZSBjdXJyZW50IHNjZW5lXHJcblx0ICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBpbWFnZSB0aGUgc3ByaXRlIHdpbGwgcmVwcmVzZW50XHJcblx0ICogQHBhcmFtIGxheWVyTmFtZSBUaGUgbGF5ZXIgb24gd2hpY2ggdG8gYWRkIHRoZSBzcHJpdGVcclxuXHQgKiBAcmV0dXJucyBBIG5ldyBTcHJpdGVcclxuXHQgKi9cclxuXHRzcHJpdGUoa2V5OiBzdHJpbmcsIGxheWVyTmFtZTogc3RyaW5nKTogU3ByaXRlIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jYW52YXNOb2RlRmFjdG9yeS5hZGRTcHJpdGUoa2V5LCBsYXllck5hbWUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG5cdCAqIEFkZHMgYW4gQW5pbWF0ZWRTcHJpdGUgdG8gdGhlIGN1cnJlbnQgc2NlbmVcclxuXHQgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIGltYWdlIHRoZSBzcHJpdGUgd2lsbCByZXByZXNlbnRcclxuXHQgKiBAcGFyYW0gbGF5ZXJOYW1lIFRoZSBsYXllciBvbiB3aGljaCB0byBhZGQgdGhlIHNwcml0ZVxyXG5cdCAqIEByZXR1cm5zIEEgbmV3IEFuaW1hdGVkU3ByaXRlXHJcblx0ICovXHJcblx0YW5pbWF0ZWRTcHJpdGUoa2V5OiBzdHJpbmcsIGxheWVyTmFtZTogc3RyaW5nKTogQW5pbWF0ZWRTcHJpdGUge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNhbnZhc05vZGVGYWN0b3J5LmFkZEFuaW1hdGVkU3ByaXRlKGtleSwgbGF5ZXJOYW1lKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuXHQgKiBBZGRzIGEgbmV3IGdyYXBoaWMgZWxlbWVudCB0byB0aGUgY3VycmVudCBTY2VuZVxyXG5cdCAqIEBwYXJhbSB0eXBlIFRoZSB0eXBlIG9mIGdyYXBoaWMgdG8gYWRkXHJcblx0ICogQHBhcmFtIGxheWVyTmFtZSBUaGUgbGF5ZXIgb24gd2hpY2ggdG8gYWRkIHRoZSBncmFwaGljXHJcblx0ICogQHBhcmFtIG9wdGlvbnMgQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIHRvIHNlbmQgdG8gdGhlIGdyYXBoaWMgY29uc3RydWN0b3JcclxuXHQgKiBAcmV0dXJucyBBIG5ldyBHcmFwaGljXHJcblx0ICovXHJcblx0Z3JhcGhpYyh0eXBlOiBHcmFwaGljVHlwZSB8IHN0cmluZywgbGF5ZXJOYW1lOiBzdHJpbmcsIG9wdGlvbnM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogR3JhcGhpYyB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FudmFzTm9kZUZhY3RvcnkuYWRkR3JhcGhpYyh0eXBlLCBsYXllck5hbWUsIG9wdGlvbnMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIHRpbGVtYXAgdG8gdGhlIHNjZW5lXHJcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIGxvYWRlZCB0aWxlbWFwIHRvIGxvYWRcclxuICAgICAqIEBwYXJhbSBjb25zdHIgVGhlIGNvbnN0cnVjdG9yIG9mIHRoZSBkZXNpcmVkIHRpbGVtYXBcclxuICAgICAqIEBwYXJhbSBhcmdzIEFkZGl0aW9uYWwgYXJndW1lbnRzIHRvIHNlbmQgdG8gdGhlIHRpbGVtYXAgY29uc3RydWN0b3JcclxuICAgICAqIEByZXR1cm5zIEFuIGFycmF5IG9mIExheWVycywgZWFjaCBvZiB3aGljaCBjb250YWlucyBhIGxheWVyIG9mIHRoZSB0aWxlbWFwIGFzIGl0cyBvd24gVGlsZW1hcCBpbnN0YW5jZS5cclxuICAgICAqL1xyXG5cdHRpbGVtYXAoa2V5OiBzdHJpbmcsIHNjYWxlPzogVmVjMik6IEFycmF5PExheWVyPiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudGlsZW1hcEZhY3RvcnkuYWRkKGtleSwgc2NhbGUpO1xyXG4gICAgfVxyXG59IiwiaW1wb3J0IFNjZW5lIGZyb20gXCIuLi9TY2VuZVwiO1xyXG5pbXBvcnQgVGlsZW1hcCBmcm9tIFwiLi4vLi4vTm9kZXMvVGlsZW1hcFwiO1xyXG5pbXBvcnQgUmVzb3VyY2VNYW5hZ2VyIGZyb20gXCIuLi8uLi9SZXNvdXJjZU1hbmFnZXIvUmVzb3VyY2VNYW5hZ2VyXCI7XHJcbmltcG9ydCBPcnRob2dvbmFsVGlsZW1hcCBmcm9tIFwiLi4vLi4vTm9kZXMvVGlsZW1hcHMvT3J0aG9nb25hbFRpbGVtYXBcIjtcclxuaW1wb3J0IExheWVyIGZyb20gXCIuLi9MYXllclwiO1xyXG5pbXBvcnQgVGlsZXNldCBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL1RpbGVzZXRzL1RpbGVzZXRcIjtcclxuaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uL0RhdGFUeXBlcy9WZWMyXCI7XHJcbmltcG9ydCB7IFRpbGVkQ29sbGVjdGlvblRpbGUgfSBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL1RpbGVzZXRzL1RpbGVkRGF0YVwiO1xyXG5pbXBvcnQgU3ByaXRlIGZyb20gXCIuLi8uLi9Ob2Rlcy9TcHJpdGVzL1Nwcml0ZVwiO1xyXG5pbXBvcnQgUG9zaXRpb25HcmFwaCBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL0dyYXBocy9Qb3NpdGlvbkdyYXBoXCI7XHJcbmltcG9ydCBOYXZtZXNoIGZyb20gXCIuLi8uLi9QYXRoZmluZGluZy9OYXZtZXNoXCI7XHJcblxyXG4vLyBAaWdub3JlUGFnZVxyXG5cclxuLyoqXHJcbiAqIEEgZmFjdG9yeSB0aGF0IGFic3RyYWN0cyBhZGRpbmcgQHJlZmVyZW5jZVtUaWxlbWFwXXMgdG8gdGhlIEByZWZlcmVuY2VbU2NlbmVdLlxyXG4gKiBBY2Nlc3MgbWV0aG9kcyBpbiB0aGlzIGZhY3RvcnkgdGhyb3VnaCBTY2VuZS5hZGQuW21ldGhvZE5hbWVdKCkuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUaWxlbWFwRmFjdG9yeSB7XHJcbiAgICBwcml2YXRlIHNjZW5lOiBTY2VuZTtcclxuICAgIHByaXZhdGUgdGlsZW1hcHM6IEFycmF5PFRpbGVtYXA+O1xyXG4gICAgcHJpdmF0ZSByZXNvdXJjZU1hbmFnZXI6IFJlc291cmNlTWFuYWdlcjtcclxuICAgIFxyXG4gICAgaW5pdChzY2VuZTogU2NlbmUsIHRpbGVtYXBzOiBBcnJheTxUaWxlbWFwPik6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuc2NlbmUgPSBzY2VuZTtcclxuICAgICAgICB0aGlzLnRpbGVtYXBzID0gdGlsZW1hcHM7XHJcbiAgICAgICAgdGhpcy5yZXNvdXJjZU1hbmFnZXIgPSBSZXNvdXJjZU1hbmFnZXIuZ2V0SW5zdGFuY2UoKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBUT0RPIC0gVGhpcyBpcyBzcGVjaWZpY2FsbHkgY2F0ZXJlZCB0byBUaWxlZCB0aWxlbWFwcyByaWdodCBub3cuIEluIHRoZSBmdXR1cmUsXHJcbiAgICAvLyBpdCB3b3VsZCBiZSBnb29kIHRvIGhhdmUgYSBcInBhcnNlVGlsZW1hcFwiIGZ1bmN0aW9uIHRoYXQgd291bGQgY29udmVydCB0aGUgdGlsZW1hcFxyXG4gICAgLy8gZGF0YSBpbnRvIGEgc3RhbmRhcmQgZm9ybWF0LiBUaGlzIGNvdWxkIGFsbG93IGZvciBzdXBwb3J0IGZyb20gb3RoZXIgcHJvZ3JhbXNcclxuICAgIC8vIG9yIHRoZSBkZXZlbG9wbWVudCBvZiBhbiBpbnRlcm5hbCBsZXZlbCBidWlsZGVyIHRvb2xcclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIHRpbGVtYXAgdG8gdGhlIHNjZW5lXHJcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIGxvYWRlZCB0aWxlbWFwIHRvIGxvYWRcclxuICAgICAqIEBwYXJhbSBjb25zdHIgVGhlIGNvbnN0cnVjdG9yIG9mIHRoZSBkZXNpcmVkIHRpbGVtYXBcclxuICAgICAqIEBwYXJhbSBhcmdzIEFkZGl0aW9uYWwgYXJndW1lbnRzIHRvIHNlbmQgdG8gdGhlIHRpbGVtYXAgY29uc3RydWN0b3JcclxuICAgICAqIEByZXR1cm5zIEFuIGFycmF5IG9mIExheWVycywgZWFjaCBvZiB3aGljaCBjb250YWlucyBhIGxheWVyIG9mIHRoZSB0aWxlbWFwIGFzIGl0cyBvd24gVGlsZW1hcCBpbnN0YW5jZS5cclxuICAgICAqL1xyXG5cdGFkZCA9IChrZXk6IHN0cmluZywgc2NhbGU6IFZlYzIgPSBuZXcgVmVjMigxLCAxKSk6IEFycmF5PExheWVyPiA9PiB7XHJcbiAgICAgICAgLy8gR2V0IFRpbGVtYXAgRGF0YVxyXG4gICAgICAgIGxldCB0aWxlbWFwRGF0YSA9IHRoaXMucmVzb3VyY2VNYW5hZ2VyLmdldFRpbGVtYXAoa2V5KTtcclxuXHJcbiAgICAgICAgLy8gU2V0IHRoZSBjb25zdHJ1Y3RvciBmb3IgdGhpcyB0aWxlbWFwIHRvIGVpdGhlciBiZSBvcnRob2dyYXBoaWMgb3IgaXNvbWV0cmljXHJcbiAgICAgICAgbGV0IGNvbnN0cjogbmV3KC4uLmFyZ3M6IGFueSkgPT4gVGlsZW1hcDtcclxuICAgICAgICBpZih0aWxlbWFwRGF0YS5vcmllbnRhdGlvbiA9PT0gXCJvcnRob2dyYXBoaWNcIil7XHJcbiAgICAgICAgICAgIGNvbnN0ciA9IE9ydGhvZ29uYWxUaWxlbWFwO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIE5vIGlzb21ldHJpYyB0aWxlbWFwIHN1cHBvcnQgcmlnaHQgbm93LCBzbyBPcnRob2dyYXBoaWMgdGlsZW1hcFxyXG4gICAgICAgICAgICBjb25zdHIgPSBPcnRob2dvbmFsVGlsZW1hcDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEluaXRpYWxpemUgdGhlIHJldHVybiB2YWx1ZSBhcnJheVxyXG4gICAgICAgIGxldCBzY2VuZUxheWVycyA9IG5ldyBBcnJheTxMYXllcj4oKTtcclxuXHJcbiAgICAgICAgLy8gQ3JlYXRlIGFsbCBvZiB0aGUgdGlsZXNldHMgZm9yIHRoaXMgdGlsZW1hcFxyXG4gICAgICAgIGxldCB0aWxlc2V0cyA9IG5ldyBBcnJheTxUaWxlc2V0PigpO1xyXG5cclxuICAgICAgICBsZXQgY29sbGVjdGlvblRpbGVzID0gbmV3IEFycmF5PFRpbGVkQ29sbGVjdGlvblRpbGU+KCk7XHJcblxyXG4gICAgICAgIGZvcihsZXQgdGlsZXNldCBvZiB0aWxlbWFwRGF0YS50aWxlc2V0cyl7XHJcbiAgICAgICAgICAgIGlmKHRpbGVzZXQuaW1hZ2Upe1xyXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhpcyBpcyBhIHN0YW5kYXJkIHRpbGVzZXQgYW5kIG5vdCBhIGNvbGxlY3Rpb24sIGNyZWF0ZSBhIHRpbGVzZXQgZm9yIGl0LlxyXG4gICAgICAgICAgICAgICAgLy8gVE9ETyAtIFdlIGFyZSBpZ25vcmluZyBjb2xsZWN0aW9uIHRpbGVzZXRzIGZvciBub3cuIFRoaXMgaXMgbGlrZWx5IG5vdCBhIGdyZWF0IGlkZWEgaW4gcHJhY3RpY2UsXHJcbiAgICAgICAgICAgICAgICAvLyBhcyB0aGVvcmV0aWNhbGx5IHNvbWVvbmUgY291bGQgd2FudCB0byB1c2Ugb25lIGZvciBhIHN0YW5kYXJkIHRpbGVtYXAuIFdlIGFyZSBhc3N1bWluZyBmb3Igbm93XHJcbiAgICAgICAgICAgICAgICAvLyB0aGF0IHdlIG9ubHkgd2FudCB0byB1c2UgdGhlbSBmb3Igb2JqZWN0IGxheWVyc1xyXG4gICAgICAgICAgICAgICAgdGlsZXNldHMucHVzaChuZXcgVGlsZXNldCh0aWxlc2V0KSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aWxlc2V0LnRpbGVzLmZvckVhY2godGlsZSA9PiB0aWxlLmlkICs9IHRpbGVzZXQuZmlyc3RnaWQpO1xyXG4gICAgICAgICAgICAgICAgY29sbGVjdGlvblRpbGVzLnB1c2goLi4udGlsZXNldC50aWxlcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIExvb3Agb3ZlciB0aGUgbGF5ZXJzIG9mIHRoZSB0aWxlbWFwIGFuZCBjcmVhdGUgdGlsZWRsYXllcnMgb3Igb2JqZWN0IGxheWVyc1xyXG4gICAgICAgIGZvcihsZXQgbGF5ZXIgb2YgdGlsZW1hcERhdGEubGF5ZXJzKXtcclxuXHJcbiAgICAgICAgICAgIGxldCBzY2VuZUxheWVyO1xyXG4gICAgICAgICAgICBsZXQgaXNQYXJhbGxheExheWVyID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGxldCBkZXB0aCA9IDA7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZihsYXllci5wcm9wZXJ0aWVzKXtcclxuICAgICAgICAgICAgICAgIGZvcihsZXQgcHJvcCBvZiBsYXllci5wcm9wZXJ0aWVzKXtcclxuICAgICAgICAgICAgICAgICAgICBpZihwcm9wLm5hbWUgPT09IFwiUGFyYWxsYXhcIil7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzUGFyYWxsYXhMYXllciA9IHByb3AudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmKHByb3AubmFtZSA9PT0gXCJEZXB0aFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlcHRoID0gcHJvcC52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKGlzUGFyYWxsYXhMYXllcil7XHJcbiAgICAgICAgICAgICAgICBzY2VuZUxheWVyID0gdGhpcy5zY2VuZS5hZGRQYXJhbGxheExheWVyKGxheWVyLm5hbWUsIG5ldyBWZWMyKDEsIDEpLCBkZXB0aCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzY2VuZUxheWVyID0gdGhpcy5zY2VuZS5hZGRMYXllcihsYXllci5uYW1lLCBkZXB0aCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmKGxheWVyLnR5cGUgPT09IFwidGlsZWxheWVyXCIpe1xyXG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IHRpbGVtYXAgb2JqZWN0IGZvciB0aGUgbGF5ZXJcclxuICAgICAgICAgICAgICAgIGxldCB0aWxlbWFwID0gbmV3IGNvbnN0cih0aWxlbWFwRGF0YSwgbGF5ZXIsIHRpbGVzZXRzLCBzY2FsZSk7XHJcbiAgICAgICAgICAgICAgICB0aWxlbWFwLmlkID0gdGhpcy5zY2VuZS5nZW5lcmF0ZUlkKCk7XHJcbiAgICAgICAgICAgICAgICB0aWxlbWFwLnNldFNjZW5lKHRoaXMuc2NlbmUpO1xyXG4gICAgXHJcbiAgICAgICAgICAgICAgICAvLyBBZGQgdGlsZW1hcCB0byBzY2VuZVxyXG4gICAgICAgICAgICAgICAgdGhpcy50aWxlbWFwcy5wdXNoKHRpbGVtYXApO1xyXG4gICAgXHJcbiAgICAgICAgICAgICAgICBzY2VuZUxheWVyLmFkZE5vZGUodGlsZW1hcCk7XHJcbiAgICBcclxuICAgICAgICAgICAgICAgIC8vIFJlZ2lzdGVyIHRpbGVtYXAgd2l0aCBwaHlzaWNzIGlmIGl0J3MgY29sbGlkYWJsZVxyXG4gICAgICAgICAgICAgICAgaWYodGlsZW1hcC5pc0NvbGxpZGFibGUpe1xyXG4gICAgICAgICAgICAgICAgICAgIHRpbGVtYXAuYWRkUGh5c2ljcygpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZihsYXllci5wcm9wZXJ0aWVzKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yKGxldCBpdGVtIG9mIGxheWVyLnByb3BlcnRpZXMpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoaXRlbS5uYW1lID09PSBcIkdyb3VwXCIpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbGVtYXAuc2V0R3JvdXAoaXRlbS52YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgbGV0IGlzTmF2bWVzaFBvaW50cyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgbGV0IG5hdm1lc2hOYW1lO1xyXG4gICAgICAgICAgICAgICAgbGV0IGVkZ2VzO1xyXG4gICAgICAgICAgICAgICAgaWYobGF5ZXIucHJvcGVydGllcyl7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yKGxldCBwcm9wIG9mIGxheWVyLnByb3BlcnRpZXMpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihwcm9wLm5hbWUgPT09IFwiTmF2bWVzaFBvaW50c1wiKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzTmF2bWVzaFBvaW50cyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZihwcm9wLm5hbWUgPT09IFwibmFtZVwiKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdm1lc2hOYW1lID0gcHJvcC52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmKHByb3AubmFtZSA9PT0gXCJlZGdlc1wiKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVkZ2VzID0gcHJvcC52YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBpZihpc05hdm1lc2hQb2ludHMpe1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBnID0gbmV3IFBvc2l0aW9uR3JhcGgoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yKGxldCBvYmogb2YgbGF5ZXIub2JqZWN0cyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGcuYWRkUG9zaXRpb25lZE5vZGUobmV3IFZlYzIob2JqLngsIG9iai55KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBmb3IobGV0IGVkZ2Ugb2YgZWRnZXMpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBnLmFkZEVkZ2UoZWRnZS5mcm9tLCBlZGdlLnRvKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2NlbmUuZ2V0TmF2aWdhdGlvbk1hbmFnZXIoKS5hZGROYXZpZ2FibGVFbnRpdHkobmF2bWVzaE5hbWUsIG5ldyBOYXZtZXNoKGcpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gTGF5ZXIgaXMgYW4gb2JqZWN0IGxheWVyLCBzbyBhZGQgZWFjaCBvYmplY3QgYXMgYSBzcHJpdGUgdG8gYSBuZXcgbGF5ZXJcclxuICAgICAgICAgICAgICAgIGZvcihsZXQgb2JqIG9mIGxheWVyLm9iamVjdHMpe1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIG9iaiBpcyBjb2xsaWRhYmxlXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGhhc1BoeXNpY3MgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgaXNDb2xsaWRhYmxlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGlzVHJpZ2dlciA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBvbkVudGVyID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgb25FeGl0ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgdHJpZ2dlckdyb3VwID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgZ3JvdXAgPSBcIlwiO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZihvYmoucHJvcGVydGllcyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcihsZXQgcHJvcCBvZiBvYmoucHJvcGVydGllcyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihwcm9wLm5hbWUgPT09IFwiSGFzUGh5c2ljc1wiKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNQaHlzaWNzID0gcHJvcC52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZihwcm9wLm5hbWUgPT09IFwiQ29sbGlkYWJsZVwiKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0NvbGxpZGFibGUgPSBwcm9wLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmKHByb3AubmFtZSA9PT0gXCJHcm91cFwiKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBncm91cCA9IHByb3AudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYocHJvcC5uYW1lID09PSBcIklzVHJpZ2dlclwiKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1RyaWdnZXIgPSBwcm9wLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmKHByb3AubmFtZSA9PT0gXCJUcmlnZ2VyR3JvdXBcIil7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJpZ2dlckdyb3VwID0gcHJvcC52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZihwcm9wLm5hbWUgPT09IFwiVHJpZ2dlck9uRW50ZXJcIil7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25FbnRlciA9IHByb3AudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYocHJvcC5uYW1lID09PSBcIlRyaWdnZXJPbkV4aXRcIil7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25FeGl0ID0gcHJvcC52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNwcml0ZTogU3ByaXRlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBvYmogaXMgYSB0aWxlIGZyb20gYSB0aWxlc2V0XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yKGxldCB0aWxlc2V0IG9mIHRpbGVzZXRzKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYodGlsZXNldC5oYXNUaWxlKG9iai5naWQpKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBvYmplY3QgaXMgYSB0aWxlIGZyb20gdGhpcyBzZXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpbWFnZUtleSA9IHRpbGVzZXQuZ2V0SW1hZ2VLZXkoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBvZmZzZXQgPSB0aWxlc2V0LmdldEltYWdlT2Zmc2V0Rm9yVGlsZShvYmouZ2lkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwcml0ZSA9IHRoaXMuc2NlbmUuYWRkLnNwcml0ZShpbWFnZUtleSwgbGF5ZXIubmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgc2l6ZSA9IHRpbGVzZXQuZ2V0VGlsZVNpemUoKS5jbG9uZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ByaXRlLnBvc2l0aW9uLnNldCgob2JqLnggKyBzaXplLngvMikqc2NhbGUueCwgKG9iai55IC0gc2l6ZS55LzIpKnNjYWxlLnkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ByaXRlLnNldEltYWdlT2Zmc2V0KG9mZnNldCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcHJpdGUuc2l6ZS5jb3B5KHNpemUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ByaXRlLnNjYWxlLnNldChzY2FsZS54LCBzY2FsZS55KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTm90IGluIGEgdGlsZXNldCwgbXVzdCBjb3JyZXNwb25kIHRvIGEgY29sbGVjdGlvblxyXG4gICAgICAgICAgICAgICAgICAgIGlmKCFzcHJpdGUpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IobGV0IHRpbGUgb2YgY29sbGVjdGlvblRpbGVzKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKG9iai5naWQgPT09IHRpbGUuaWQpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpbWFnZUtleSA9IHRpbGUuaW1hZ2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ByaXRlID0gdGhpcy5zY2VuZS5hZGQuc3ByaXRlKGltYWdlS2V5LCBsYXllci5uYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcHJpdGUucG9zaXRpb24uc2V0KChvYmoueCArIHRpbGUuaW1hZ2V3aWR0aC8yKSpzY2FsZS54LCAob2JqLnkgLSB0aWxlLmltYWdlaGVpZ2h0LzIpKnNjYWxlLnkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwcml0ZS5zY2FsZS5zZXQoc2NhbGUueCwgc2NhbGUueSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdyB3ZSBoYXZlIHNwcml0ZS4gQXNzb2NpYXRlIGl0IHdpdGggb3VyIHBoeXNpY3Mgb2JqZWN0IGlmIHRoZXJlIGlzIG9uZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmKGhhc1BoeXNpY3Mpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBNYWtlIHRoZSBzcHJpdGUgYSBzdGF0aWMgcGh5c2ljcyBvYmplY3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3ByaXRlLmFkZFBoeXNpY3Moc3ByaXRlLmJvdW5kYXJ5LmNsb25lKCksIFZlYzIuWkVSTywgaXNDb2xsaWRhYmxlLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3ByaXRlLnNldEdyb3VwKGdyb3VwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoaXNUcmlnZ2VyICYmIHRyaWdnZXJHcm91cCAhPT0gbnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcHJpdGUuc2V0VHJpZ2dlcih0cmlnZ2VyR3JvdXAsIG9uRW50ZXIsIG9uRXhpdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgcmV0dXJuIHZhbHVlXHJcbiAgICAgICAgICAgIHNjZW5lTGF5ZXJzLnB1c2goc2NlbmVMYXllcik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gc2NlbmVMYXllcnM7XHJcblx0fVxyXG59IiwiaW1wb3J0IFNjZW5lIGZyb20gXCIuL1NjZW5lXCI7XHJcbmltcG9ydCBNYXRoVXRpbHMgZnJvbSBcIi4uL1V0aWxzL01hdGhVdGlsc1wiO1xyXG5pbXBvcnQgR2FtZU5vZGUgZnJvbSBcIi4uL05vZGVzL0dhbWVOb2RlXCI7XHJcblxyXG5cclxuLyoqXHJcbiAqIEEgbGF5ZXIgaW4gdGhlIHNjZW5lLiBMYXllcnMgYXJlIHVzZWQgZm9yIHNvcnRpbmcgQHJlZmVyZW5jZVtHYW1lTm9kZV1zIGJ5IGRlcHRoLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGF5ZXIge1xyXG4gICAgLyoqIFRoZSBzY2VuZSB0aGlzIGxheWVyIGJlbG9uZ3MgdG8gKi9cclxuICAgIHByb3RlY3RlZCBzY2VuZTogU2NlbmU7XHJcblxyXG4gICAgLyoqIFRoZSBuYW1lIG9mIHRoaXMgbGF5ZXIgKi9cclxuICAgIHByb3RlY3RlZCBuYW1lOiBzdHJpbmc7XHJcblxyXG4gICAgLyoqIFdoZXRoZXIgdGhpcyBsYXllciBpcyBwYXVzZWQgb3Igbm90ICovXHJcbiAgICBwcm90ZWN0ZWQgcGF1c2VkOiBib29sZWFuO1xyXG5cclxuICAgIC8qKiBXaGV0aGVyIHRoaXMgbGF5ZXIgaXMgaGlkZGVuIGZyb20gYmVpbmcgcmVuZGVyZWQgb3Igbm90ICovXHJcbiAgICBwcm90ZWN0ZWQgaGlkZGVuOiBib29sZWFuO1xyXG5cclxuICAgIC8qKiBUaGUgZ2xvYmFsIGFscGhhIGxldmVsIG9mIHRoaXMgbGF5ZXIgKi9cclxuICAgIHByb3RlY3RlZCBhbHBoYTogbnVtYmVyO1xyXG5cclxuICAgIC8qKiBBbiBhcnJheSBvZiB0aGUgR2FtZU5vZGVzIHRoYXQgYmVsb25nIHRvIHRoaXMgbGF5ZXIgKi9cclxuICAgIHByb3RlY3RlZCBpdGVtczogQXJyYXk8R2FtZU5vZGU+O1xyXG5cclxuICAgIC8qKiBXaGV0aGVyIG9yIG5vdCB0aGlzIGxheWVyIHNob3VsZCBiZSB5c29ydGVkICovXHJcbiAgICBwcm90ZWN0ZWQgeVNvcnQ6IGJvb2xlYW47XHJcblxyXG4gICAgLyoqIFRoZSBkZXB0aCBvZiB0aGlzIGxheWVyIGNvbXBhcmVkIHRvIG90aGVyIGxheWVycyAqL1xyXG4gICAgcHJvdGVjdGVkIGRlcHRoOiBudW1iZXI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGxheWVyLiBUbyBkbyB0aGlzIGluIGEgZ2FtZSwgdXNlIHRoZSBhZGRMYXllcigpIG1ldGhvZCBpbiBAcmVmcmVuY2VbU2NlbmVdXHJcbiAgICAgKiBAcGFyYW0gc2NlbmUgVGhlIHNjZW5lIHRvIGFkZCB0aGUgbGF5ZXIgdG9cclxuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBsYXllclxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihzY2VuZTogU2NlbmUsIG5hbWU6IHN0cmluZyl7XHJcbiAgICAgICAgdGhpcy5zY2VuZSA9IHNjZW5lO1xyXG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcbiAgICAgICAgdGhpcy5wYXVzZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmhpZGRlbiA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuYWxwaGEgPSAxO1xyXG4gICAgICAgIHRoaXMuaXRlbXMgPSBuZXcgQXJyYXkoKTtcclxuICAgICAgICB0aGlzLnlTb3J0ID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5kZXB0aCA9IDA7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyZWl2ZXMgdGhlIG5hbWUgb2YgdGhlIGxheWVyXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgbmFtZSBvZiB0aGUgbGF5ZXJcclxuICAgICAqL1xyXG4gICAgZ2V0TmFtZSgpOiBzdHJpbmcge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm5hbWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQYXVzZXMvVW5wYXVzZXMgdGhlIGxheWVyLiBBZmZlY3RzIGFsbCBlbGVtZW50cyBpbiB0aGlzIGxheWVyXHJcbiAgICAgKiBAcGFyYW0gcGF1c2VWYWx1ZSBUcnVlIGlmIHRoZSBsYXllciBzaG91bGQgYmUgcGF1c2VkLCBmYWxzZSBpZiBub3RcclxuICAgICAqL1xyXG4gICAgc2V0UGF1c2VkKHBhdXNlVmFsdWU6IGJvb2xlYW4pOiB2b2lkIHtcclxuICAgICAgICB0aGlzLnBhdXNlZCA9IHBhdXNlVmFsdWU7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgbGF5ZXIgaXMgcGF1c2VkXHJcbiAgICAgKi9cclxuICAgIGlzUGF1c2VkKCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBhdXNlZDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIG9wYWNpdHkgb2YgdGhlIGxheWVyXHJcbiAgICAgKiBAcGFyYW0gYWxwaGEgVGhlIG5ldyBvcGFjaXR5IHZhbHVlIGluIHRoZSByYW5nZSBbMCwgMV1cclxuICAgICAqL1xyXG4gICAgc2V0QWxwaGEoYWxwaGE6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuYWxwaGEgPSBNYXRoVXRpbHMuY2xhbXAoYWxwaGEsIDAsIDEpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgb3BhY2l0eSBvZiB0aGUgbGF5ZXJcclxuICAgICAqIEByZXR1cm5zIFRoZSBvcGFjaXR5XHJcbiAgICAgKi9cclxuICAgIGdldEFscGhhKCk6IG51bWJlciB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYWxwaGE7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBsYXllcidzIGhpZGRlbiB2YWx1ZS4gSWYgaGlkZGVuLCBhIGxheWVyIHdpbGwgbm90IGJlIHJlbmRlcmVkLCBidXQgd2lsbCBzdGlsbCB1cGRhdGVcclxuICAgICAqIEBwYXJhbSBoaWRkZW4gVGhlIGhpZGRlbiB2YWx1ZSBvZiB0aGUgbGF5ZXJcclxuICAgICAqL1xyXG4gICAgc2V0SGlkZGVuKGhpZGRlbjogYm9vbGVhbik6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuaGlkZGVuID0gaGlkZGVuO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgaGlkZWVuIHZhbHVlIG9mIHRoZSBseWFlclxyXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgc2NlbmUgaXMgaGlkZGVuLCBmYWxzZSBvdGhlcndpc2VcclxuICAgICAqL1xyXG4gICAgaXNIaWRkZW4oKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaGlkZGVuO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBQYXVzZXMgdGhpcyBzY2VuZSBhbmQgaGlkZXMgaXQgKi9cclxuICAgIGRpc2FibGUoKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5wYXVzZWQgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuaGlkZGVuID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogVW5wYXVzZXMgdGhpcyBsYXllciBhbmQgbWFrZXMgaXQgdmlzaWJsZSAqL1xyXG4gICAgZW5hYmxlKCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMucGF1c2VkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5oaWRkZW4gPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgd2hldGhlciBvciBub3QgdGhlIHNjZW5lIHdpbGwgeVNvcnQgYXV0b21hdGljYWxseS5cclxuICAgICAqIHlTb3J0aW5nIG1lYW5zIHRoYXQgQ2FudmFzTm9kZXMgb24gdGhpcyBsYXllciB3aWxsIGhhdmUgdGhlaXIgZGVwdGggc29ydGVkIGRlcGVuZGluZyBvbiB0aGVpciB5LXZhbHVlLlxyXG4gICAgICogVGhpcyBtZWFucyB0aGF0IGlmIGFuIG9iamVjdCBpcyBcImhpZ2hlclwiIGluIHRoZSBzY2VuZSwgaXQgd2lsbCBzb3J0IGJlaGluZCBvYmplY3RzIHRoYXQgYXJlIFwibG93ZXJcIi5cclxuICAgICAqIFRoaXMgaXMgdXNlZnVsIGZvciAzLzQgdmlldyBnYW1lcywgb3Igc2ltaWxhciBzaXR1YXRpb25zLCB3aGVyZSB5b3Ugc29tZXRpbWVzIHdhbnQgdG8gYmUgaW4gZnJvbnQgb2Ygb2JqZWN0cyxcclxuICAgICAqIGFuZCBvdGhlciB0aW1lcyB3YW50IHRvIGJlIGJlaGluZCB0aGUgc2FtZSBvYmplY3RzLlxyXG4gICAgICogQHBhcmFtIHlTb3J0IFRydWUgaWYgeVNvcnRpbmcgc2hvdWxkIGJlIGFjdGl2ZSwgZmFsc2UgaWYgbm90XHJcbiAgICAgKi9cclxuICAgIHNldFlTb3J0KHlTb3J0OiBib29sZWFuKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy55U29ydCA9IHlTb3J0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgeVNvcnQgc3RhdHVzIG9mIHRoZSBzY2VuZVxyXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB5U29ydGluZyBpcyBvY2N1cnJpbmcsIGZhbHNlIG90aGVyd2lzZVxyXG4gICAgICovXHJcbiAgICBnZXRZU29ydCgpOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gdGhpcy55U29ydDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGRlcHRoIG9mIHRoZSBsYXllciBjb21wYXJlZCB0byBvdGhlciBsYXllcnMuIEEgbGFyZ2VyIG51bWJlciBtZWFucyB0aGUgbGF5ZXIgd2lsbCBiZSBjbG9zZXIgdG8gdGhlIHNjcmVlbi5cclxuICAgICAqIEBwYXJhbSBkZXB0aCBUaGUgZGVwdGggb2YgdGhlIGxheWVyLlxyXG4gICAgICovXHJcbiAgICBzZXREZXB0aChkZXB0aDogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5kZXB0aCA9IGRlcHRoO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0cmlldmVzIHRoZSBkZXB0aCBvZiB0aGUgbGF5ZXIuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgZGVwdGhcclxuICAgICAqL1xyXG4gICAgZ2V0RGVwdGgoKTogbnVtYmVyIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kZXB0aDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSBub2RlIHRvIHRoaXMgbGF5ZXJcclxuICAgICAqIEBwYXJhbSBub2RlIFRoZSBub2RlIHRvIGFkZCB0byB0aGlzIGxheWVyLlxyXG4gICAgICovXHJcbiAgICBhZGROb2RlKG5vZGU6IEdhbWVOb2RlKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5pdGVtcy5wdXNoKG5vZGUpO1xyXG4gICAgICAgIG5vZGUuc2V0TGF5ZXIodGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIGEgbm9kZSBmcm9tIHRoaXMgbGF5ZXJcclxuICAgICAqIEBwYXJhbSBub2RlIFRoZSBub2RlIHRvIHJlbW92ZVxyXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgbm9kZSB3YXMgcmVtb3ZlZCwgZmFsc2Ugb3RoZXJ3aXNlXHJcbiAgICAgKi9cclxuICAgIHJlbW92ZU5vZGUobm9kZTogR2FtZU5vZGUpOiB2b2lkIHtcclxuICAgICAgICAvLyBGaW5kIGFuZCByZW1vdmUgdGhlIG5vZGVcclxuICAgICAgICBsZXQgaW5kZXggPSB0aGlzLml0ZW1zLmluZGV4T2Yobm9kZSk7XHJcblxyXG4gICAgICAgIGlmKGluZGV4ICE9PSAtMSl7XHJcbiAgICAgICAgICAgIHRoaXMuaXRlbXMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgICAgbm9kZS5zZXRMYXllcih1bmRlZmluZWQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHJlaXZlcyBhbGwgR2FtZU5vZGVzIGZyb20gdGhpcyBsYXllclxyXG4gICAgICogQHJldHVybnMgYW4gQXJyYXkgdGhhdCBjb250YWlucyBhbGwgb2YgdGhlIEdhbWVOb2RlcyBpbiB0aGlzIGxheWVyLlxyXG4gICAgICovXHJcbiAgICBnZXRJdGVtcygpOiBBcnJheTxHYW1lTm9kZT4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLml0ZW1zO1xyXG4gICAgfVxyXG59IiwiaW1wb3J0IExheWVyIGZyb20gXCIuLi9MYXllclwiO1xyXG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL1ZlYzJcIjtcclxuaW1wb3J0IFNjZW5lIGZyb20gXCIuLi9TY2VuZVwiO1xyXG5cclxuLyoqXHJcbiAqIEFuIGV4dGVuc2lvbiBvZiBhIExheWVyIHRoYXQgaGFzIGEgcGFyYWxsYXggdmFsdWUuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQYXJhbGxheExheWVyIGV4dGVuZHMgTGF5ZXIge1xyXG5cdC8qKiBUaGUgdmFsdWUgb2YgdGhlIHBhcmFsbGF4IG9mIHRoZSBMYXllciAqL1xyXG5cdHBhcmFsbGF4OiBWZWMyO1xyXG5cdFxyXG5cdC8qKlxyXG5cdCAqIENyZWF0ZXMgYSBuZXcgUGFyYWxsYXhMYXllci5cclxuXHQgKiBVc2UgYWRkUGFyYWxsYXhMYXllcigpIGluIEByZWZlcmVuY2VbU2NlbmVdIHRvIGFkZCBhIGxheWVyIG9mIHRoaXMgdHlwZSB0byB5b3VyIGdhbWUuXHJcblx0ICogQHBhcmFtIHNjZW5lIFRoZSBTY2VuZSB0byBhZGQgdGhpcyBQYXJhbGxheExheWVyIHRvXHJcblx0ICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIFBhcmFsbGF4TGF5ZXJcclxuXHQgKiBAcGFyYW0gcGFyYWxsYXggVGhlIHBhcmFsbGF4IGxldmVsXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3Ioc2NlbmU6IFNjZW5lLCBuYW1lOiBzdHJpbmcsIHBhcmFsbGF4OiBWZWMyKXtcclxuXHRcdHN1cGVyKHNjZW5lLCBuYW1lKTtcclxuXHRcdHRoaXMucGFyYWxsYXggPSBwYXJhbGxheDtcclxuXHR9XHJcbn0iLCJpbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vRGF0YVR5cGVzL1ZlYzJcIjtcclxuaW1wb3J0IFNjZW5lIGZyb20gXCIuLi9TY2VuZVwiO1xyXG5pbXBvcnQgUGFyYWxsYXhMYXllciBmcm9tIFwiLi9QYXJhbGxheExheWVyXCI7XHJcblxyXG4vKipcclxuICogQSBMYXllciBzdHJpY3RseSB0byBiZSB1c2VkIGZvciBtYW5hZ2luZyBVSUVsZW1lbnRzLlxyXG4gKiBUaGlzIGlzIGludGVuZGVkIHRvIGJlIGEgTGF5ZXIgdGhhdCBhbHdheXMgc3RheXMgaW4gdGhlIHNhbWUgcGxhY2UsXHJcbiAqIGFuZCB0aHVzIHJlbmRlcnMgdGhpbmdzIGxpa2UgYSBIVUQgb3IgYW4gaW52ZW50b3J5IHdpdGhvdXQgdGFraW5nIGludG8gY29uc2lkZXJhdGlvbiB0aGUgXFxyZWZlcmVuY2VbVmlld3BvcnRdIHNjcm9sbC5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFVJTGF5ZXIgZXh0ZW5kcyBQYXJhbGxheExheWVyIHtcclxuXHQvKipcclxuXHQgKiBDcmVhdGVzIGEgbmV3IFVJTGF5ZXIuXHJcblx0ICogVXNlIGFkZFVJTGF5ZXIoKSBpbiBAcmVmZXJlbmNlW1NjZW5lXSB0byBhZGQgYSBsYXllciBvZiB0aGlzIHR5cGUgdG8geW91ciBnYW1lLlxyXG5cdCAqIEBwYXJhbSBzY2VuZSBUaGUgU2NlbmUgdG8gYWRkIHRoaXMgVUlMYXllciB0b1xyXG5cdCAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBVSUxheWVyXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3Ioc2NlbmU6IFNjZW5lLCBuYW1lOiBzdHJpbmcpe1xyXG5cdFx0c3VwZXIoc2NlbmUsIG5hbWUsIFZlYzIuWkVSTyk7XHJcblx0fVxyXG59IiwiaW1wb3J0IExheWVyIGZyb20gXCIuL0xheWVyXCI7XHJcbmltcG9ydCBWaWV3cG9ydCBmcm9tIFwiLi4vU2NlbmVHcmFwaC9WaWV3cG9ydFwiO1xyXG5pbXBvcnQgVmVjMiBmcm9tIFwiLi4vRGF0YVR5cGVzL1ZlYzJcIjtcclxuaW1wb3J0IFNjZW5lR3JhcGggZnJvbSBcIi4uL1NjZW5lR3JhcGgvU2NlbmVHcmFwaFwiO1xyXG5pbXBvcnQgUGh5c2ljc01hbmFnZXIgZnJvbSBcIi4uL1BoeXNpY3MvUGh5c2ljc01hbmFnZXJcIjtcclxuaW1wb3J0IEJhc2ljUGh5c2ljc01hbmFnZXIgZnJvbSBcIi4uL1BoeXNpY3MvQmFzaWNQaHlzaWNzTWFuYWdlclwiO1xyXG5pbXBvcnQgU2NlbmVHcmFwaEFycmF5IGZyb20gXCIuLi9TY2VuZUdyYXBoL1NjZW5lR3JhcGhBcnJheVwiO1xyXG5pbXBvcnQgRmFjdG9yeU1hbmFnZXIgZnJvbSBcIi4vRmFjdG9yaWVzL0ZhY3RvcnlNYW5hZ2VyXCI7XHJcbmltcG9ydCBUaWxlbWFwIGZyb20gXCIuLi9Ob2Rlcy9UaWxlbWFwXCI7XHJcbmltcG9ydCBSZXNvdXJjZU1hbmFnZXIgZnJvbSBcIi4uL1Jlc291cmNlTWFuYWdlci9SZXNvdXJjZU1hbmFnZXJcIjtcclxuaW1wb3J0IEdhbWUgZnJvbSBcIi4uL0xvb3AvR2FtZVwiO1xyXG5pbXBvcnQgU2NlbmVNYW5hZ2VyIGZyb20gXCIuL1NjZW5lTWFuYWdlclwiO1xyXG5pbXBvcnQgUmVjZWl2ZXIgZnJvbSBcIi4uL0V2ZW50cy9SZWNlaXZlclwiO1xyXG5pbXBvcnQgRW1pdHRlciBmcm9tIFwiLi4vRXZlbnRzL0VtaXR0ZXJcIjtcclxuaW1wb3J0IFVwZGF0ZWFibGUgZnJvbSBcIi4uL0RhdGFUeXBlcy9JbnRlcmZhY2VzL1VwZGF0ZWFibGVcIjtcclxuaW1wb3J0IE5hdmlnYXRpb25NYW5hZ2VyIGZyb20gXCIuLi9QYXRoZmluZGluZy9OYXZpZ2F0aW9uTWFuYWdlclwiO1xyXG5pbXBvcnQgQUlNYW5hZ2VyIGZyb20gXCIuLi9BSS9BSU1hbmFnZXJcIjtcclxuaW1wb3J0IE1hcCBmcm9tIFwiLi4vRGF0YVR5cGVzL01hcFwiO1xyXG5pbXBvcnQgUGFyYWxsYXhMYXllciBmcm9tIFwiLi9MYXllcnMvUGFyYWxsYXhMYXllclwiO1xyXG5pbXBvcnQgVUlMYXllciBmcm9tIFwiLi9MYXllcnMvVUlMYXllclwiO1xyXG5pbXBvcnQgQ2FudmFzTm9kZSBmcm9tIFwiLi4vTm9kZXMvQ2FudmFzTm9kZVwiO1xyXG5pbXBvcnQgR2FtZU5vZGUgZnJvbSBcIi4uL05vZGVzL0dhbWVOb2RlXCI7XHJcbmltcG9ydCBTY2VuZU9wdGlvbnMgZnJvbSBcIi4vU2NlbmVPcHRpb25zXCI7XHJcbmltcG9ydCBSZW5kZXJpbmdNYW5hZ2VyIGZyb20gXCIuLi9SZW5kZXJpbmcvUmVuZGVyaW5nTWFuYWdlclwiO1xyXG5pbXBvcnQgRGVidWcgZnJvbSBcIi4uL0RlYnVnL0RlYnVnXCI7XHJcbmltcG9ydCBUaW1lck1hbmFnZXIgZnJvbSBcIi4uL1RpbWluZy9UaW1lck1hbmFnZXJcIjtcclxuaW1wb3J0IFR3ZWVuTWFuYWdlciBmcm9tIFwiLi4vUmVuZGVyaW5nL0FuaW1hdGlvbnMvVHdlZW5NYW5hZ2VyXCI7XHJcbmltcG9ydCBQYXJ0aWNsZVN5c3RlbU1hbmFnZXIgZnJvbSBcIi4uL1JlbmRlcmluZy9BbmltYXRpb25zL1BhcnRpY2xlU3lzdGVtTWFuYWdlclwiO1xyXG5cclxuLyoqXHJcbiAqIFNjZW5lcyBhcmUgdGhlIG1haW4gY29udGFpbmVyIGluIHRoZSBnYW1lIGVuZ2luZS5cclxuICogWW91ciBtYWluIHNjZW5lIGlzIHRoZSBjdXJyZW50IGxldmVsIG9yIG1lbnUgb2YgdGhlIGdhbWUsIGFuZCB3aWxsIGNvbnRhaW4gYWxsIG9mIHRoZSBHYW1lTm9kZXMgbmVlZGVkLlxyXG4gKiBTY2VuZXMgcHJvdmlkZSBhbiBlYXN5IHdheSB0byBsb2FkIGFzc2V0cywgYWRkIGFzc2V0cyB0byB0aGUgZ2FtZSB3b3JsZCwgYW5kIHVubG9hZCBhc3NldHMsXHJcbiAqIGFuZCBoYXZlIGxpZmVjeWNsZSBtZXRob2RzIGV4cG9zZWQgZm9yIHRoZXNlIGZ1bmN0aW9ucy5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNjZW5lIGltcGxlbWVudHMgVXBkYXRlYWJsZSB7XHJcbiAgICAvKiogVGhlIHNpemUgb2YgdGhlIGdhbWUgd29ybGQuICovXHJcbiAgICBwcm90ZWN0ZWQgd29ybGRTaXplOiBWZWMyO1xyXG5cclxuICAgIC8qKiBUaGUgdmlld3BvcnQuICovXHJcbiAgICBwcm90ZWN0ZWQgdmlld3BvcnQ6IFZpZXdwb3J0O1xyXG5cclxuICAgIC8qKiBBIGZsYWcgdGhhdCByZXByZXNlbnRzIHdoZXRoZXIgdGhpcyBzY2VuZSBpcyBydW5uaW5nIG9yIG5vdC4gKi9cclxuICAgIHByb3RlY3RlZCBydW5uaW5nOiBib29sZWFuO1xyXG5cclxuICAgIC8qKiBUaGUgbWFuYWdlciBvZiB0aGlzIHNjZW5lLiAqL1xyXG4gICAgcHJvdGVjdGVkIHNjZW5lTWFuYWdlcjogU2NlbmVNYW5hZ2VyO1xyXG5cclxuICAgIC8qKiBUaGUgcmVjZWl2ZXIgZm9yIHRoaXMgc2NlbmUuICovXHJcbiAgICBwcm90ZWN0ZWQgcmVjZWl2ZXI6IFJlY2VpdmVyO1xyXG5cclxuICAgIC8qKiBUaGUgZW1pdHRlciBmb3IgdGhpcyBzY2VuZS4gKi9cclxuICAgIHByb3RlY3RlZCBlbWl0dGVyOiBFbWl0dGVyO1xyXG5cclxuICAgIC8qKiBUaGlzIGxpc3Qgb2YgdGlsZW1hcHMgaW4gdGhpcyBzY2VuZS4gKi9cclxuICAgIHByb3RlY3RlZCB0aWxlbWFwczogQXJyYXk8VGlsZW1hcD47XHJcblxyXG4gICAgLyoqIEEgbWFwIGZyb20gbGF5ZXIgbmFtZXMgdG8gdGhlIGxheWVycyB0aGVtc2VsdmVzICovXHJcbiAgICBwcm90ZWN0ZWQgbGF5ZXJzOiBNYXA8TGF5ZXI+O1xyXG5cclxuICAgIC8qKiBBIG1hcCBmcm9tIHBhcmFsbGF4IGxheWVyIG5hbWVzIHRvIHRoZSBwYXJhbGxheCBsYXllcnMgdGhlbXNlbHZlcyAqL1xyXG4gICAgcHJvdGVjdGVkIHBhcmFsbGF4TGF5ZXJzOiBNYXA8UGFyYWxsYXhMYXllcj47XHJcblxyXG4gICAgLyoqIEEgbWFwIGZyb20gdWlMYXllciBuYW1lcyB0byB0aGUgdWlMYXllcnMgdGhlbXNlbHZlcyAqL1xyXG4gICAgcHJvdGVjdGVkIHVpTGF5ZXJzOiBNYXA8VUlMYXllcj47XHJcblxyXG4gICAgLyoqIFRoZSBzY2VuZSBncmFwaCBvZiB0aGUgU2NlbmUqL1xyXG4gICAgcHJvdGVjdGVkIHNjZW5lR3JhcGg6IFNjZW5lR3JhcGg7XHJcblxyXG4gICAgLyoqIFRoZSBwaHlzaWNzIG1hbmFnZXIgb2YgdGhlIFNjZW5lICovXHJcbiAgICBwcm90ZWN0ZWQgcGh5c2ljc01hbmFnZXI6IFBoeXNpY3NNYW5hZ2VyO1xyXG4gICAgXHJcbiAgICAvKiogVGhlIG5hdmlnYXRpb24gbWFuYWdlciBvZiB0aGUgU2NlbmUgKi9cclxuICAgIHByb3RlY3RlZCBuYXZNYW5hZ2VyOiBOYXZpZ2F0aW9uTWFuYWdlcjtcclxuXHJcbiAgICAvKiogVGhlIEFJIG1hbmFnZXIgb2YgdGhlIFNjZW5lICovXHJcbiAgICBwcm90ZWN0ZWQgYWlNYW5hZ2VyOiBBSU1hbmFnZXI7XHJcblxyXG4gICAgLyoqIFRoZSByZW5kZXJpbmdNYW5hZ2VyIG9mIHRoZSBzY2VuZSAqL1xyXG4gICAgcHJvdGVjdGVkIHJlbmRlcmluZ01hbmFnZXI6IFJlbmRlcmluZ01hbmFnZXI7XHJcblxyXG4gICAgLyoqIEFuIGludGVyZmFjZSB0aGF0IGFsbG93cyB0aGUgYWRkaW5nIG9mIGRpZmZlcmVudCBub2RlcyB0byB0aGUgc2NlbmUgKi9cclxuICAgIHB1YmxpYyBhZGQ6IEZhY3RvcnlNYW5hZ2VyO1xyXG5cclxuICAgIC8qKiBBbiBpbnRlcmZhY2UgdGhhdCBhbGxvd3MgdGhlIGxvYWRpbmcgb2YgZGlmZmVyZW50IGZpbGVzIGZvciB1c2UgaW4gdGhlIHNjZW5lLiBBbiBhbGlhcyBmb3IgcmVzb3VyY2VNYW5hZ2VyICovXHJcbiAgICBwdWJsaWMgbG9hZDogUmVzb3VyY2VNYW5hZ2VyO1xyXG5cclxuICAgIC8qKiBBbiBpbnRlcmZhY2UgdGhhdCBhbGxvd3MgdGhlIGxvYWRpbmcgYW5kIHVubG9hZGluZyBvZiBkaWZmZXJlbnQgZmlsZXMgZm9yIHVzZSBpbiB0aGUgc2NlbmUgKi9cclxuICAgIHB1YmxpYyByZXNvdXJjZU1hbmFnZXI6IFJlc291cmNlTWFuYWdlcjtcclxuXHJcbiAgICAvKiogVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhpcyBzY2VuZSAqL1xyXG4gICAgcHVibGljIHNjZW5lT3B0aW9uczogU2NlbmVPcHRpb25zO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBTY2VuZS4gVG8gYWRkIGEgbmV3IFNjZW5lIGluIHlvdXIgZ2FtZSwgdXNlIGNoYW5nZVRvU2NlbmUoKSBpbiBAcmVmZXJlbmNlW1NjZW5lTWFuYWdlcl1cclxuICAgICAqIEBwYXJhbSB2aWV3cG9ydCBUaGUgdmlld3BvcnQgb2YgdGhlIGdhbWVcclxuICAgICAqIEBwYXJhbSBzY2VuZU1hbmFnZXIgVGhlIFNjZW5lTWFuYWdlciB0aGF0IG93bnMgdGhpcyBTY2VuZVxyXG4gICAgICogQHBhcmFtIHJlbmRlcmluZ01hbmFnZXIgVGhlIFJlbmRlcmluZ01hbmFnZXIgdGhhdCB3aWxsIGhhbmRsZSB0aGlzIFNjZW5lJ3MgcmVuZGVyaW5nXHJcbiAgICAgKiBAcGFyYW0gZ2FtZSBUaGUgaW5zdGFuY2Ugb2YgdGhlIEdhbWVcclxuICAgICAqIEBwYXJhbSBvcHRpb25zIFRoZSBvcHRpb25zIGZvciBTY2VuZSBpbml0aWFsaXphdGlvblxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcih2aWV3cG9ydDogVmlld3BvcnQsIHNjZW5lTWFuYWdlcjogU2NlbmVNYW5hZ2VyLCByZW5kZXJpbmdNYW5hZ2VyOiBSZW5kZXJpbmdNYW5hZ2VyLCBvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KXtcclxuICAgICAgICB0aGlzLnNjZW5lT3B0aW9ucyA9IFNjZW5lT3B0aW9ucy5wYXJzZShvcHRpb25zID09PSB1bmRlZmluZWQgPyB7fSA6IG9wdGlvbnMpO1xyXG5cclxuICAgICAgICB0aGlzLndvcmxkU2l6ZSA9IG5ldyBWZWMyKDUwMCwgNTAwKTtcclxuICAgICAgICB0aGlzLnZpZXdwb3J0ID0gdmlld3BvcnQ7XHJcbiAgICAgICAgdGhpcy52aWV3cG9ydC5zZXRCb3VuZHMoMCwgMCwgMjU2MCwgMTI4MCk7XHJcbiAgICAgICAgdGhpcy5ydW5uaW5nID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5zY2VuZU1hbmFnZXIgPSBzY2VuZU1hbmFnZXI7XHJcbiAgICAgICAgdGhpcy5yZWNlaXZlciA9IG5ldyBSZWNlaXZlcigpO1xyXG4gICAgICAgIHRoaXMuZW1pdHRlciA9IG5ldyBFbWl0dGVyKCk7XHJcblxyXG4gICAgICAgIHRoaXMudGlsZW1hcHMgPSBuZXcgQXJyYXkoKTtcclxuICAgICAgICB0aGlzLnNjZW5lR3JhcGggPSBuZXcgU2NlbmVHcmFwaEFycmF5KHRoaXMudmlld3BvcnQsIHRoaXMpO1xyXG5cclxuICAgICAgICB0aGlzLmxheWVycyA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLnVpTGF5ZXJzID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRoaXMucGFyYWxsYXhMYXllcnMgPSBuZXcgTWFwKCk7XHJcblxyXG4gICAgICAgIHRoaXMucGh5c2ljc01hbmFnZXIgPSBuZXcgQmFzaWNQaHlzaWNzTWFuYWdlcih0aGlzLnNjZW5lT3B0aW9ucy5waHlzaWNzKTtcclxuICAgICAgICB0aGlzLm5hdk1hbmFnZXIgPSBuZXcgTmF2aWdhdGlvbk1hbmFnZXIoKTtcclxuICAgICAgICB0aGlzLmFpTWFuYWdlciA9IG5ldyBBSU1hbmFnZXIoKTtcclxuICAgICAgICB0aGlzLnJlbmRlcmluZ01hbmFnZXIgPSByZW5kZXJpbmdNYW5hZ2VyO1xyXG5cclxuICAgICAgICB0aGlzLmFkZCA9IG5ldyBGYWN0b3J5TWFuYWdlcih0aGlzLCB0aGlzLnRpbGVtYXBzKTtcclxuXHJcbiAgICAgICAgdGhpcy5sb2FkID0gUmVzb3VyY2VNYW5hZ2VyLmdldEluc3RhbmNlKClcclxuICAgICAgICB0aGlzLnJlc291cmNlTWFuYWdlciA9IHRoaXMubG9hZDtcclxuXHJcbiAgICAgICAgLy8gR2V0IHRoZSB0aW1lciBtYW5hZ2VyIGFuZCBjbGVhciBhbnkgZXhpc3RpbmcgdGltZXJzXHJcbiAgICAgICAgVGltZXJNYW5hZ2VyLmdldEluc3RhbmNlKCkuY2xlYXJUaW1lcnMoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogQSBsaWZlY3ljbGUgbWV0aG9kIHRoYXQgZ2V0cyBjYWxsZWQgaW1tZWRpYXRlbHkgYWZ0ZXIgYSBuZXcgc2NlbmUgaXMgY3JlYXRlZCwgYmVmb3JlIGFueXRoaW5nIGVsc2UuICovXHJcbiAgICBpbml0U2NlbmUoaW5pdDogUmVjb3JkPHN0cmluZywgYW55Pik6IHZvaWQge31cclxuXHJcbiAgICAvKiogQSBsaWZlY3ljbGUgbWV0aG9kIHRoYXQgZ2V0cyBjYWxsZWQgd2hlbiBhIG5ldyBzY2VuZSBpcyBjcmVhdGVkLiBMb2FkIGFsbCBmaWxlcyB5b3Ugd2lzaCB0byBhY2Nlc3MgaW4gdGhlIHNjZW5lIGhlcmUuICovXHJcbiAgICBsb2FkU2NlbmUoKTogdm9pZCB7fVxyXG5cclxuICAgIC8qKiBBIGxpZmVjeWNsZSBtZXRob2QgY2FsbGVkIHN0cmljdGx5IGFmdGVyIGxvYWRTY2VuZSgpLiBDcmVhdGUgYW55IGdhbWUgb2JqZWN0cyB5b3Ugd2lzaCB0byB1c2UgaW4gdGhlIHNjZW5lIGhlcmUuICovXHJcbiAgICBzdGFydFNjZW5lKCk6IHZvaWQge31cclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgbGlmZWN5Y2xlIG1ldGhvZCBjYWxsZWQgZXZlcnkgZnJhbWUgb2YgdGhlIGdhbWUuIFRoaXMgaXMgd2hlcmUgeW91IGNhbiBkeW5hbWljYWxseSBkbyB0aGluZ3MgbGlrZSBhZGQgaW4gbmV3IGVuZW1pZXNcclxuICAgICAqIEBwYXJhbSBkZWx0YSBUaGUgdGltZSB0aGlzIGZyYW1lIHJlcHJlc2VudHNcclxuICAgICAqL1xyXG4gICAgdXBkYXRlU2NlbmUoZGVsdGFUOiBudW1iZXIpOiB2b2lkIHt9XHJcblxyXG4gICAgLyoqIEEgbGlmZWN5Y2xlIG1ldGhvZCB0aGF0IGdldHMgY2FsbGVkIG9uIHNjZW5lIGRlc3RydWN0aW9uLiBTcGVjaWZ5IHdoaWNoIGZpbGVzIHlvdSBubyBsb25nZXIgbmVlZCBmb3IgZ2FyYmFnZSBjb2xsZWN0aW9uLiAqL1xyXG4gICAgdW5sb2FkU2NlbmUoKTogdm9pZCB7fVxyXG5cclxuICAgIHVwZGF0ZShkZWx0YVQ6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICAgIHRoaXMudXBkYXRlU2NlbmUoZGVsdGFUKTtcclxuXHJcbiAgICAgICAgLy8gRG8gdGltZSB1cGRhdGVzXHJcbiAgICAgICAgVGltZXJNYW5hZ2VyLmdldEluc3RhbmNlKCkudXBkYXRlKGRlbHRhVCk7XHJcblxyXG4gICAgICAgIC8vIERvIGFsbCBBSSB1cGRhdGVzXHJcbiAgICAgICAgdGhpcy5haU1hbmFnZXIudXBkYXRlKGRlbHRhVCk7XHJcblxyXG4gICAgICAgIC8vIFVwZGF0ZSBhbGwgcGh5c2ljcyBvYmplY3RzXHJcbiAgICAgICAgdGhpcy5waHlzaWNzTWFuYWdlci51cGRhdGUoZGVsdGFUKTtcclxuXHJcbiAgICAgICAgLy8gVXBkYXRlIGFsbCBjYW52YXMgb2JqZWN0c1xyXG4gICAgICAgIHRoaXMuc2NlbmVHcmFwaC51cGRhdGUoZGVsdGFUKTtcclxuXHJcbiAgICAgICAgLy8gVXBkYXRlIGFsbCB0aWxlbWFwc1xyXG4gICAgICAgIHRoaXMudGlsZW1hcHMuZm9yRWFjaCh0aWxlbWFwID0+IHtcclxuICAgICAgICAgICAgaWYoIXRpbGVtYXAuZ2V0TGF5ZXIoKS5pc1BhdXNlZCgpKXtcclxuICAgICAgICAgICAgICAgIHRpbGVtYXAudXBkYXRlKGRlbHRhVCk7XHJcbiAgICAgICAgICAgIH0gXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gVXBkYXRlIGFsbCB0d2VlbnNcclxuICAgICAgICBUd2Vlbk1hbmFnZXIuZ2V0SW5zdGFuY2UoKS51cGRhdGUoZGVsdGFUKTtcclxuXHJcbiAgICAgICAgLy8gVXBkYXRlIGFsbCBwYXJ0aWNsZSBzeXN0ZW1zXHJcbiAgICAgICAgUGFydGljbGVTeXN0ZW1NYW5hZ2VyLmdldEluc3RhbmNlKCkudXBkYXRlKGRlbHRhVCk7XHJcblxyXG4gICAgICAgIC8vIFVwZGF0ZSB2aWV3cG9ydFxyXG4gICAgICAgIHRoaXMudmlld3BvcnQudXBkYXRlKGRlbHRhVCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb2xsZWN0cyByZW5kZXJhYmxlIHNldHMgYW5kIGNvb3JkaW5hdGVzIHdpdGggdGhlIFJlbmRlcmluZ01hbmFnZXIgdG8gZHJhdyB0aGUgU2NlbmVcclxuICAgICAqL1xyXG4gICAgcmVuZGVyKCk6IHZvaWQge1xyXG4gICAgICAgIC8vIEdldCB0aGUgdmlzaWJsZSBzZXQgb2Ygbm9kZXNcclxuICAgICAgICBsZXQgdmlzaWJsZVNldCA9IHRoaXMuc2NlbmVHcmFwaC5nZXRWaXNpYmxlU2V0KCk7XHJcblxyXG4gICAgICAgIC8vIEFkZCBwYXJhbGxheCBsYXllciBpdGVtcyB0byB0aGUgdmlzaWJsZSBzZXQgKHdlJ3JlIHJlbmRlcmluZyB0aGVtIGFsbCBmb3Igbm93KVxyXG4gICAgICAgIHRoaXMucGFyYWxsYXhMYXllcnMuZm9yRWFjaChrZXkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgcExheWVyID0gdGhpcy5wYXJhbGxheExheWVycy5nZXQoa2V5KTtcclxuICAgICAgICAgICAgZm9yKGxldCBub2RlIG9mIHBMYXllci5nZXRJdGVtcygpKXtcclxuICAgICAgICAgICAgICAgIGlmKG5vZGUgaW5zdGFuY2VvZiBDYW52YXNOb2RlKXtcclxuICAgICAgICAgICAgICAgICAgICB2aXNpYmxlU2V0LnB1c2gobm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy8gU2VuZCB0aGUgdmlzaWJsZSBzZXQsIHRpbGVtYXBzLCBhbmQgdWlMYXllcnMgdG8gdGhlIHJlbmRlcmVyXHJcbiAgICAgICAgdGhpcy5yZW5kZXJpbmdNYW5hZ2VyLnJlbmRlcih2aXNpYmxlU2V0LCB0aGlzLnRpbGVtYXBzLCB0aGlzLnVpTGF5ZXJzKTtcclxuXHJcbiAgICAgICAgbGV0IG5vZGVzID0gdGhpcy5zY2VuZUdyYXBoLmdldEFsbE5vZGVzKCk7XHJcbiAgICAgICAgdGhpcy50aWxlbWFwcy5mb3JFYWNoKHRpbGVtYXAgPT4gdGlsZW1hcC52aXNpYmxlID8gbm9kZXMucHVzaCh0aWxlbWFwKSA6IDApO1xyXG4gICAgICAgIERlYnVnLnNldE5vZGVzKG5vZGVzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIHNjZW5lIGFzIHJ1bm5pbmcgb3Igbm90XHJcbiAgICAgKiBAcGFyYW0gcnVubmluZyBUcnVlIGlmIHRoZSBTY2VuZSBzaG91bGQgYmUgcnVubmluZywgZmFsc2UgaWYgbm90XHJcbiAgICAgKi9cclxuICAgIHNldFJ1bm5pbmcocnVubmluZzogYm9vbGVhbik6IHZvaWQge1xyXG4gICAgICAgIHRoaXMucnVubmluZyA9IHJ1bm5pbmc7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBTY2VuZSBpcyBydW5uaW5nXHJcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBzY2VuZSBpcyBydW5uaW5nLCBmYWxzZSBvdGhlcndpc2VcclxuICAgICAqL1xyXG4gICAgaXNSdW5uaW5nKCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJ1bm5pbmc7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIGEgbm9kZSBmcm9tIHRoaXMgU2NlbmVcclxuICAgICAqIEBwYXJhbSBub2RlIFRoZSBub2RlIHRvIHJlbW92ZVxyXG4gICAgICovXHJcbiAgICByZW1vdmUobm9kZTogR2FtZU5vZGUpOiB2b2lkIHtcclxuICAgICAgICAvLyBSZW1vdmUgZnJvbSB0aGUgc2NlbmUgZ3JhcGhcclxuICAgICAgICBpZihub2RlIGluc3RhbmNlb2YgQ2FudmFzTm9kZSl7XHJcbiAgICAgICAgICAgIHRoaXMuc2NlbmVHcmFwaC5yZW1vdmVOb2RlKG5vZGUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG4gICAgLyoqIERlc3Ryb3lzIHRoaXMgc2NlbmUgYW5kIGFsbCBub2RlcyBpbiBpdCAqL1xyXG4gICAgZGVzdHJveSgpOiB2b2lkIHtcclxuICAgICAgICBmb3IobGV0IG5vZGUgb2YgdGhpcy5zY2VuZUdyYXBoLmdldEFsbE5vZGVzKCkpe1xyXG4gICAgICAgICAgICBub2RlLmRlc3Ryb3koKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvcihsZXQgdGlsZW1hcCBvZiB0aGlzLnRpbGVtYXBzKXtcclxuICAgICAgICAgICAgdGlsZW1hcC5kZXN0cm95KCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnJlY2VpdmVyLmRlc3Ryb3koKTtcclxuXHJcbiAgICAgICAgZGVsZXRlIHRoaXMuc2NlbmVHcmFwaDtcclxuICAgICAgICBkZWxldGUgdGhpcy5waHlzaWNzTWFuYWdlcjtcclxuICAgICAgICBkZWxldGUgdGhpcy5uYXZNYW5hZ2VyO1xyXG4gICAgICAgIGRlbGV0ZSB0aGlzLmFpTWFuYWdlcjtcclxuICAgICAgICBkZWxldGUgdGhpcy5yZWNlaXZlcjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSBuZXcgbGF5ZXIgdG8gdGhlIHNjZW5lIGFuZCByZXR1cm5zIGl0XHJcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgbmV3IGxheWVyXHJcbiAgICAgKiBAcGFyYW0gZGVwdGggVGhlIGRlcHRoIG9mIHRoZSBsYXllclxyXG4gICAgICogQHJldHVybnMgVGhlIG5ld2x5IGNyZWF0ZWQgTGF5ZXJcclxuICAgICAqL1xyXG4gICAgYWRkTGF5ZXIobmFtZTogc3RyaW5nLCBkZXB0aD86IG51bWJlcik6IExheWVyIHtcclxuICAgICAgICBpZih0aGlzLmxheWVycy5oYXMobmFtZSkgfHwgdGhpcy5wYXJhbGxheExheWVycy5oYXMobmFtZSkgfHwgdGhpcy51aUxheWVycy5oYXMobmFtZSkpe1xyXG4gICAgICAgICAgICB0aHJvdyBgTGF5ZXIgd2l0aCBuYW1lICR7bmFtZX0gYWxyZWFkeSBleGlzdHNgO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IGxheWVyID0gbmV3IExheWVyKHRoaXMsIG5hbWUpO1xyXG5cclxuICAgICAgICB0aGlzLmxheWVycy5hZGQobmFtZSwgbGF5ZXIpO1xyXG5cclxuICAgICAgICBpZihkZXB0aCl7XHJcbiAgICAgICAgICAgIGxheWVyLnNldERlcHRoKGRlcHRoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBsYXllcjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSBuZXcgcGFyYWxsYXggbGF5ZXIgdG8gdGhpcyBzY2VuZSBhbmQgcmV0dXJucyBpdFxyXG4gICAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIHBhcmFsbGF4IGxheWVyXHJcbiAgICAgKiBAcGFyYW0gcGFyYWxsYXggVGhlIHBhcmFsbGF4IGxldmVsXHJcbiAgICAgKiBAcGFyYW0gZGVwdGggVGhlIGRlcHRoIG9mIHRoZSBsYXllclxyXG4gICAgICogQHJldHVybnMgVGhlIG5ld2x5IGNyZWF0ZWQgUGFyYWxsYXhMYXllclxyXG4gICAgICovXHJcbiAgICBhZGRQYXJhbGxheExheWVyKG5hbWU6IHN0cmluZywgcGFyYWxsYXg6IFZlYzIsIGRlcHRoPzogbnVtYmVyKTogUGFyYWxsYXhMYXllciB7XHJcbiAgICAgICAgaWYodGhpcy5sYXllcnMuaGFzKG5hbWUpIHx8IHRoaXMucGFyYWxsYXhMYXllcnMuaGFzKG5hbWUpIHx8IHRoaXMudWlMYXllcnMuaGFzKG5hbWUpKXtcclxuICAgICAgICAgICAgdGhyb3cgYExheWVyIHdpdGggbmFtZSAke25hbWV9IGFscmVhZHkgZXhpc3RzYDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBsYXllciA9IG5ldyBQYXJhbGxheExheWVyKHRoaXMsIG5hbWUsIHBhcmFsbGF4KTtcclxuXHJcbiAgICAgICAgdGhpcy5wYXJhbGxheExheWVycy5hZGQobmFtZSwgbGF5ZXIpO1xyXG5cclxuICAgICAgICBpZihkZXB0aCl7XHJcbiAgICAgICAgICAgIGxheWVyLnNldERlcHRoKGRlcHRoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBsYXllcjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSBuZXcgVUlMYXllciB0byB0aGUgc2NlbmVcclxuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBuZXcgVUlsYXllclxyXG4gICAgICogQHJldHVybnMgVGhlIG5ld2x5IGNyZWF0ZWQgVUlMYXllclxyXG4gICAgICovXHJcbiAgICBhZGRVSUxheWVyKG5hbWU6IHN0cmluZyk6IFVJTGF5ZXIge1xyXG4gICAgICAgIGlmKHRoaXMubGF5ZXJzLmhhcyhuYW1lKSB8fCB0aGlzLnBhcmFsbGF4TGF5ZXJzLmhhcyhuYW1lKSB8fCB0aGlzLnVpTGF5ZXJzLmhhcyhuYW1lKSl7XHJcbiAgICAgICAgICAgIHRocm93IGBMYXllciB3aXRoIG5hbWUgJHtuYW1lfSBhbHJlYWR5IGV4aXN0c2A7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgbGF5ZXIgPSBuZXcgVUlMYXllcih0aGlzLCBuYW1lKTtcclxuXHJcbiAgICAgICAgdGhpcy51aUxheWVycy5hZGQobmFtZSwgbGF5ZXIpO1xyXG5cclxuICAgICAgICByZXR1cm4gbGF5ZXI7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIGEgbGF5ZXIgZnJvbSB0aGUgc2NlbmUgYnkgbmFtZSBpZiBpdCBleGlzdHMuXHJcbiAgICAgKiBUaGlzIGNhbiBiZSBhIExheWVyIG9yIGFueSBvZiBpdHMgc3ViY2xhc3Nlc1xyXG4gICAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIGxheWVyXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgTGF5ZXIgZm91bmQgd2l0aCB0aGF0IG5hbWVcclxuICAgICAqL1xyXG4gICAgZ2V0TGF5ZXIobmFtZTogc3RyaW5nKTogTGF5ZXIge1xyXG4gICAgICAgIGlmKHRoaXMubGF5ZXJzLmhhcyhuYW1lKSl7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxheWVycy5nZXQobmFtZSk7XHJcbiAgICAgICAgfSBlbHNlIGlmKHRoaXMucGFyYWxsYXhMYXllcnMuaGFzKG5hbWUpKXtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyYWxsYXhMYXllcnMuZ2V0KG5hbWUpO1xyXG4gICAgICAgIH0gZWxzZSBpZih0aGlzLnVpTGF5ZXJzLmhhcyhuYW1lKSl7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVpTGF5ZXJzLmdldChuYW1lKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvdyBgUmVxdWVzdGVkIGxheWVyICR7bmFtZX0gZG9lcyBub3QgZXhpc3QuYDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBsYXllciBpcyBhIFBhcmFsbGF4TGF5ZXJcclxuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBsYXllclxyXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGlzIGxheWVyIGlzIGEgUGFyYWxsYXhMYXllclxyXG4gICAgICovXHJcbiAgICBpc1BhcmFsbGF4TGF5ZXIobmFtZTogc3RyaW5nKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyYWxsYXhMYXllcnMuaGFzKG5hbWUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgbGF5ZXIgaXMgYSBVSUxheWVyXHJcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgbGF5ZXJcclxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhpcyBsYXllciBpcyBQYXJhbGxheExheWVyXHJcbiAgICAgKi9cclxuICAgIGlzVUlMYXllcihuYW1lOiBzdHJpbmcpOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gdGhpcy51aUxheWVycy5oYXMobmFtZSk7XHJcbiAgICB9ICAgIFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgdHJhbnNsYXRpb24gb2YgdGhpcyBub2RlIHdpdGggcmVzcGVjdCB0byBjYW1lcmEgc3BhY2UgKGR1ZSB0byB0aGUgdmlld3BvcnQgbW92aW5nKS5cclxuICAgICAqIFRoaXMgdmFsdWUgaXMgYWZmZWN0ZWQgYnkgdGhlIHBhcmFsbGF4IGxldmVsIG9mIHRoZSBAcmVmZXJlbmNlW0xheWVyXSB0aGUgbm9kZSBpcyBvbi5cclxuICAgICAqIEBwYXJhbSBub2RlIFRoZSBub2RlIHRvIGNoZWNrIHRoZSB2aWV3cG9ydCB3aXRoIHJlc3BlY3QgdG9cclxuICAgICAqIEByZXR1cm5zIEEgVmVjMiBjb250YWluaW5nIHRoZSB0cmFuc2xhdGlvbiBvZiB2aWV3cG9ydCB3aXRoIHJlc3BlY3QgdG8gdGhpcyBub2RlLlxyXG4gICAgICovXHJcbiAgICBnZXRWaWV3VHJhbnNsYXRpb24obm9kZTogR2FtZU5vZGUpOiBWZWMyIHtcclxuICAgICAgICBsZXQgbGF5ZXIgPSBub2RlLmdldExheWVyKCk7XHJcblxyXG4gICAgICAgIGlmKGxheWVyIGluc3RhbmNlb2YgUGFyYWxsYXhMYXllciB8fCBsYXllciBpbnN0YW5jZW9mIFVJTGF5ZXIpe1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy52aWV3cG9ydC5nZXRPcmlnaW4oKS5tdWx0KGxheWVyLnBhcmFsbGF4KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy52aWV3cG9ydC5nZXRPcmlnaW4oKTtcclxuICAgICAgICB9XHJcblx0fVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgc2NhbGUgbGV2ZWwgb2YgdGhlIHZpZXdcclxuICAgICAqIEByZXR1cm5zIFRoZSB6b29tIGxldmVsIG9mIHRoZSB2aWV3cG9ydFxyXG4gICAgKi9cclxuXHRnZXRWaWV3U2NhbGUoKTogbnVtYmVyIHtcclxuXHRcdHJldHVybiB0aGlzLnZpZXdwb3J0LmdldFpvb21MZXZlbCgpO1xyXG5cdH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIFZpZXdwb3J0IGFzc29jaWF0ZWQgd2l0aCB0aGlzIHNjZW5lXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgY3VycmVudCBWaWV3cG9ydFxyXG4gICAgICovXHJcbiAgICBnZXRWaWV3cG9ydCgpOiBWaWV3cG9ydCB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3BvcnQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSB3b3JsZCBzaXplIG9mIHRoaXMgU2NlbmVcclxuICAgICAqIEByZXR1cm5zIFRoZSB3b3JsZCBzaXplIGluIGEgVmVjMlxyXG4gICAgICovXHJcbiAgICBnZXRXb3JsZFNpemUoKTogVmVjMiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMud29ybGRTaXplO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgU2NlbmVHcmFwaCBhc3NvY2lhdGVkIHdpdGggdGhpcyBTY2VuZVxyXG4gICAgICogQHJldHVybnMgVGhlIFNjZW5lR3JhcGhcclxuICAgICAqL1xyXG4gICAgZ2V0U2NlbmVHcmFwaCgpOiBTY2VuZUdyYXBoIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zY2VuZUdyYXBoO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgUGh5c2ljc01hbmFnZXIgYXNzb2NpYXRlZCB3aXRoIHRoaXMgU2NlbmVcclxuICAgICAqIEByZXR1cm5zIFRoZSBQaHlzaWNzTWFuYWdlclxyXG4gICAgICovXHJcbiAgICBnZXRQaHlzaWNzTWFuYWdlcigpOiBQaHlzaWNzTWFuYWdlciB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucGh5c2ljc01hbmFnZXI7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBOYXZpZ2F0aW9uTWFuYWdlciBhc3NvY2lhdGVkIHdpdGggdGhpcyBTY2VuZVxyXG4gICAgICogQHJldHVybnMgVGhlIE5hdmlnYXRpb25NYW5hZ2VyXHJcbiAgICAgKi9cclxuICAgIGdldE5hdmlnYXRpb25NYW5hZ2VyKCk6IE5hdmlnYXRpb25NYW5hZ2VyIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5uYXZNYW5hZ2VyO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgQUlNYW5hZ2VyIGFzc29jaWF0ZWQgd2l0aCB0aGlzIFNjZW5lXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgQUlNYW5hZ2VyXHJcbiAgICAgKi9cclxuICAgIGdldEFJTWFuYWdlcigpOiBBSU1hbmFnZXIge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmFpTWFuYWdlcjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdlbmVyYXRlcyBhbiBJRCBmb3IgYSBHYW1lTm9kZVxyXG4gICAgICogQHJldHVybnMgVGhlIG5ldyBJRFxyXG4gICAgICovXHJcbiAgICBnZW5lcmF0ZUlkKCk6IG51bWJlciB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NlbmVNYW5hZ2VyLmdlbmVyYXRlSWQoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHJpZXZlcyBhIFRpbGVtYXAgaW4gdGhpcyBTY2VuZVxyXG4gICAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIFRpbGVtYXBcclxuICAgICAqIEByZXR1cm5zIFRoZSBUaWxlbWFwLCBpZiBvbmUgdGhpcyBuYW1lIGV4aXN0cywgb3RoZXJ3aXNlIG51bGxcclxuICAgICAqL1xyXG4gICAgZ2V0VGlsZW1hcChuYW1lOiBzdHJpbmcpOiBUaWxlbWFwIHtcclxuICAgICAgICBmb3IobGV0IHRpbGVtYXAgb2YgdGhpcyAudGlsZW1hcHMpe1xyXG4gICAgICAgICAgICBpZih0aWxlbWFwLm5hbWUgPT09IG5hbWUpe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRpbGVtYXA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG59IiwiaW1wb3J0IFNjZW5lIGZyb20gXCIuL1NjZW5lXCI7XHJcbmltcG9ydCBSZXNvdXJjZU1hbmFnZXIgZnJvbSBcIi4uL1Jlc291cmNlTWFuYWdlci9SZXNvdXJjZU1hbmFnZXJcIjtcclxuaW1wb3J0IFZpZXdwb3J0IGZyb20gXCIuLi9TY2VuZUdyYXBoL1ZpZXdwb3J0XCI7XHJcbmltcG9ydCBSZW5kZXJpbmdNYW5hZ2VyIGZyb20gXCIuLi9SZW5kZXJpbmcvUmVuZGVyaW5nTWFuYWdlclwiO1xyXG5pbXBvcnQgTWVtb3J5VXRpbHMgZnJvbSBcIi4uL1V0aWxzL01lbW9yeVV0aWxzXCI7XHJcblxyXG4vKipcclxuICogVGhlIFNjZW5lTWFuYWdlciBhY3RzIGFzIGFuIGludGVyZmFjZSB0byBjcmVhdGUgU2NlbmVzLCBhbmQgaGFuZGxlcyB0aGUgbGlmZWN5Y2xlIG1ldGhvZHMgb2YgU2NlbmVzLlxyXG4gKiBJdCBnaXZlcyBTY2VuZXMgYWNjZXNzIHRvIGluZm9ybWF0aW9uIHRoZXkgbmVlZCBmcm9tIHRoZSBAcmVmZXJlbmNlW0dhbWVdIGNsYXNzIHdoaWxlIGtlZXBpbmcgYSBsYXllciBvZiBzZXBhcmF0aW9uLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2NlbmVNYW5hZ2VyIHtcclxuXHQvKiogVGhlIGN1cnJlbnQgU2NlbmUgb2YgdGhlIGdhbWUgKi9cclxuXHRwcm90ZWN0ZWQgY3VycmVudFNjZW5lOiBTY2VuZTtcclxuXHJcblx0LyoqIFRoZSBWaWV3cG9ydCBvZiB0aGUgZ2FtZSAqL1xyXG5cdHByb3RlY3RlZCB2aWV3cG9ydDogVmlld3BvcnQ7XHJcblxyXG5cdC8qKiBBIHJlZmVyZW5jZSB0byB0aGUgUmVzb3VyY2VNYW5hZ2VyICovXHJcblx0cHJvdGVjdGVkIHJlc291cmNlTWFuYWdlcjogUmVzb3VyY2VNYW5hZ2VyO1xyXG5cclxuXHQvKiogQSBjb3VudGVyIHRvIGtlZXAgdHJhY2sgb2YgZ2FtZSBpZHMgKi9cclxuXHRwcm90ZWN0ZWQgaWRDb3VudGVyOiBudW1iZXI7XHJcblxyXG5cdC8qKiBUaGUgUmVuZGVyaW5nTWFuYWdlciBvZiB0aGUgZ2FtZSAqL1xyXG5cdHByb3RlY3RlZCByZW5kZXJpbmdNYW5hZ2VyOiBSZW5kZXJpbmdNYW5hZ2VyO1xyXG5cclxuXHQvKiogRm9yIGNvbnNpc3RlbmN5LCBvbmx5IGNoYW5nZSBzY2VuZXMgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgdXBkYXRlIGN5Y2xlICovXHJcblx0cHJvdGVjdGVkIHBlbmRpbmdTY2VuZTogU2NlbmU7XHJcblx0cHJvdGVjdGVkIHBlbmRpbmdTY2VuZUluaXQ6IFJlY29yZDxzdHJpbmcsIGFueT47XHJcblxyXG5cdC8qKlxyXG5cdCAqIENyZWF0ZXMgYSBuZXcgU2NlbmVNYW5hZ2VyXHJcblx0ICogQHBhcmFtIHZpZXdwb3J0IFRoZSBWaWV3cG9ydCBvZiB0aGUgZ2FtZVxyXG5cdCAqIEBwYXJhbSBnYW1lIFRoZSBHYW1lIGluc3RhbmNlXHJcblx0ICogQHBhcmFtIHJlbmRlcmluZ01hbmFnZXIgVGhlIFJlbmRlcmluZ01hbmFnZXIgb2YgdGhlIGdhbWVcclxuXHQgKi9cclxuXHRjb25zdHJ1Y3Rvcih2aWV3cG9ydDogVmlld3BvcnQsIHJlbmRlcmluZ01hbmFnZXI6IFJlbmRlcmluZ01hbmFnZXIpe1xyXG5cdFx0dGhpcy5yZXNvdXJjZU1hbmFnZXIgPSBSZXNvdXJjZU1hbmFnZXIuZ2V0SW5zdGFuY2UoKTtcclxuXHRcdHRoaXMudmlld3BvcnQgPSB2aWV3cG9ydDtcclxuXHRcdHRoaXMucmVuZGVyaW5nTWFuYWdlciA9IHJlbmRlcmluZ01hbmFnZXI7XHJcblx0XHR0aGlzLmlkQ291bnRlciA9IDA7XHJcblx0XHR0aGlzLnBlbmRpbmdTY2VuZSA9IG51bGw7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBBZGQgYSBzY2VuZSBhcyB0aGUgbWFpbiBzY2VuZS5cclxuXHQgKiBVc2UgdGhpcyBtZXRob2QgaWYgeW91J3ZlIGNyZWF0ZWQgYSBzdWJjbGFzcyBvZiBTY2VuZSwgYW5kIHlvdSB3YW50IHRvIGFkZCBpdCBhcyB0aGUgbWFpbiBTY2VuZS5cclxuXHQgKiBAcGFyYW0gY29uc3RyIFRoZSBjb25zdHJ1Y3RvciBvZiB0aGUgc2NlbmUgdG8gYWRkXHJcblx0ICogQHBhcmFtIGluaXQgQW4gb2JqZWN0IHRvIHBhc3MgdG8gdGhlIGluaXQgZnVuY3Rpb24gb2YgdGhlIG5ldyBzY2VuZVxyXG5cdCAqL1xyXG5cdHB1YmxpYyBjaGFuZ2VUb1NjZW5lPFQgZXh0ZW5kcyBTY2VuZT4oY29uc3RyOiBuZXcgKC4uLmFyZ3M6IGFueSkgPT4gVCwgaW5pdD86IFJlY29yZDxzdHJpbmcsIGFueT4sIG9wdGlvbnM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogdm9pZCB7XHJcblx0XHRjb25zb2xlLmxvZyhcIkNyZWF0aW5nIHRoZSBuZXcgc2NlbmUgLSBjaGFuZ2UgaXMgcGVuZGluZyB1bnRpbCBuZXh0IHVwZGF0ZVwiKTtcclxuXHRcdHRoaXMucGVuZGluZ1NjZW5lID0gbmV3IGNvbnN0cih0aGlzLnZpZXdwb3J0LCB0aGlzLCB0aGlzLnJlbmRlcmluZ01hbmFnZXIsIG9wdGlvbnMpO1xyXG5cdFx0dGhpcy5wZW5kaW5nU2NlbmVJbml0ID0gaW5pdDtcclxuXHR9XHJcblxyXG5cdHByb3RlY3RlZCBkb1NjZW5lQ2hhbmdlKCl7XHJcblx0XHRjb25zb2xlLmxvZyhcIlBlcmZvcm1pbmcgc2NlbmUgY2hhbmdlXCIpO1xyXG5cdFx0dGhpcy52aWV3cG9ydC5zZXRDZW50ZXIodGhpcy52aWV3cG9ydC5nZXRIYWxmU2l6ZSgpLngsIHRoaXMudmlld3BvcnQuZ2V0SGFsZlNpemUoKS55KTtcclxuXHRcdFxyXG5cdFx0aWYodGhpcy5jdXJyZW50U2NlbmUpe1xyXG5cdFx0XHRjb25zb2xlLmxvZyhcIlVubG9hZGluZyBvbGQgc2NlbmVcIilcclxuXHRcdFx0dGhpcy5jdXJyZW50U2NlbmUudW5sb2FkU2NlbmUoKTtcclxuXHJcblx0XHRcdGNvbnNvbGUubG9nKFwiRGVzdHJveWluZyBvbGQgc2NlbmVcIik7XHJcblx0XHRcdHRoaXMuY3VycmVudFNjZW5lLmRlc3Ryb3koKTtcclxuXHRcdH1cclxuXHJcblx0XHRjb25zb2xlLmxvZyhcIlVubG9hZGluZyBvbGQgcmVzb3VyY2VzLi4uXCIpO1xyXG5cdFx0dGhpcy5yZXNvdXJjZU1hbmFnZXIudW5sb2FkQWxsUmVzb3VyY2VzKCk7XHJcblxyXG5cdFx0Ly8gTWFrZSB0aGUgcGVuZGluZyBzY2VuZSB0aGUgY3VycmVudCBvbmVcclxuXHRcdHRoaXMuY3VycmVudFNjZW5lID0gdGhpcy5wZW5kaW5nU2NlbmU7XHJcblxyXG5cdFx0Ly8gTWFrZSB0aGUgcGVuZGluZyBzY2VuZSBudWxsXHJcblx0XHR0aGlzLnBlbmRpbmdTY2VuZSA9IG51bGw7XHJcblxyXG5cdFx0Ly8gSW5pdCB0aGUgc2NlbmVcclxuXHRcdHRoaXMuY3VycmVudFNjZW5lLmluaXRTY2VuZSh0aGlzLnBlbmRpbmdTY2VuZUluaXQpO1xyXG5cclxuXHRcdC8vIEVucXVldWUgYWxsIHNjZW5lIGFzc2V0IGxvYWRzXHJcblx0XHR0aGlzLmN1cnJlbnRTY2VuZS5sb2FkU2NlbmUoKTtcclxuXHJcblx0XHQvLyBMb2FkIGFsbCBhc3NldHNcclxuXHRcdGNvbnNvbGUubG9nKFwiU3RhcnRpbmcgU2NlbmUgTG9hZFwiKTtcclxuXHRcdHRoaXMucmVzb3VyY2VNYW5hZ2VyLmxvYWRSZXNvdXJjZXNGcm9tUXVldWUoKCkgPT4ge1xyXG5cdFx0XHRjb25zb2xlLmxvZyhcIlN0YXJ0aW5nIFNjZW5lXCIpO1xyXG5cdFx0XHR0aGlzLmN1cnJlbnRTY2VuZS5zdGFydFNjZW5lKCk7XHJcblx0XHRcdHRoaXMuY3VycmVudFNjZW5lLnNldFJ1bm5pbmcodHJ1ZSk7XHJcblx0XHR9KTtcclxuXHJcblx0XHR0aGlzLnJlbmRlcmluZ01hbmFnZXIuc2V0U2NlbmUodGhpcy5jdXJyZW50U2NlbmUpO1xyXG5cdH1cclxuXHRcclxuXHQvKipcclxuXHQgKiBHZW5lcmF0ZXMgYSB1bmlxdWUgSURcclxuXHQgKiBAcmV0dXJucyBBIG5ldyBJRFxyXG5cdCAqL1xyXG5cdHB1YmxpYyBnZW5lcmF0ZUlkKCk6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gdGhpcy5pZENvdW50ZXIrKztcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJlbmRlcnMgdGhlIGN1cnJlbnQgU2NlbmVcclxuXHQgKi9cclxuXHRwdWJsaWMgcmVuZGVyKCk6IHZvaWQge1xyXG5cdFx0aWYodGhpcy5jdXJyZW50U2NlbmUpe1xyXG5cdFx0XHR0aGlzLmN1cnJlbnRTY2VuZS5yZW5kZXIoKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFVwZGF0ZXMgdGhlIGN1cnJlbnQgU2NlbmVcclxuXHQgKiBAcGFyYW0gZGVsdGFUIFRoZSB0aW1lc3RlcCBvZiB0aGUgU2NlbmVcclxuXHQgKi9cclxuXHRwdWJsaWMgdXBkYXRlKGRlbHRhVDogbnVtYmVyKXtcclxuXHRcdGlmKHRoaXMucGVuZGluZ1NjZW5lICE9PSBudWxsKXtcclxuXHRcdFx0dGhpcy5kb1NjZW5lQ2hhbmdlKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYodGhpcy5jdXJyZW50U2NlbmUgJiYgdGhpcy5jdXJyZW50U2NlbmUuaXNSdW5uaW5nKCkpe1xyXG5cdFx0XHR0aGlzLmN1cnJlbnRTY2VuZS51cGRhdGUoZGVsdGFUKTtcclxuXHRcdH1cclxuXHR9XHJcbn0iLCJpbXBvcnQgQXJyYXlVdGlscyBmcm9tIFwiLi4vVXRpbHMvQXJyYXlVdGlsc1wiO1xyXG5cclxuLy8gQGlnbm9yZVBhZ2VcclxuXHJcbi8qKlxyXG4gKiBUaGUgb3B0aW9ucyB0byBnaXZlIGEgQHJlZmVyZW5jZVtTY2VuZV0gZm9yIGluaXRpYWxpemF0aW9uXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTY2VuZU9wdGlvbnMge1xyXG4gICAgcGh5c2ljczoge1xyXG4gICAgICAgIGdyb3VwczogQXJyYXk8c3RyaW5nPixcclxuICAgICAgICBjb2xsaXNpb25zOiBBcnJheTxBcnJheTxudW1iZXI+PjtcclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgcGFyc2Uob3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55Pik6IFNjZW5lT3B0aW9uc3tcclxuICAgICAgICBsZXQgc09wdCA9IG5ldyBTY2VuZU9wdGlvbnMoKTtcclxuXHJcbiAgICAgICAgaWYob3B0aW9ucy5waHlzaWNzID09PSB1bmRlZmluZWQpe1xyXG4gICAgICAgICAgICBzT3B0LnBoeXNpY3MgPSB7Z3JvdXBzOiB1bmRlZmluZWQsIGNvbGxpc2lvbnM6IHVuZGVmaW5lZH07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgc09wdC5waHlzaWNzID0gb3B0aW9ucy5waHlzaWNzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHNPcHQ7XHJcbiAgICB9XHJcbn0iLCJpbXBvcnQgTWFwIGZyb20gXCIuLi9EYXRhVHlwZXMvTWFwXCI7XHJcbmltcG9ydCBSZWNlaXZlciBmcm9tIFwiLi4vRXZlbnRzL1JlY2VpdmVyXCI7XHJcbmltcG9ydCBSZXNvdXJjZU1hbmFnZXIgZnJvbSBcIi4uL1Jlc291cmNlTWFuYWdlci9SZXNvdXJjZU1hbmFnZXJcIjtcclxuaW1wb3J0IHsgR2FtZUV2ZW50VHlwZSB9IGZyb20gXCIuLi9FdmVudHMvR2FtZUV2ZW50VHlwZVwiO1xyXG5cclxuLyoqXHJcbiAqIE1hbmFnZXMgYW55IHNvdW5kcyBvciBtdXNpYyBuZWVkZWQgZm9yIHRoZSBnYW1lLlxyXG4gKiBUaHJvdWdoIHRoZSBFdmVudFF1ZXVlLCBleHBvc2VzIGludGVyZmFjZSB0byBwbGF5IHNvdW5kcyBzbyBHYW1lTm9kZXMgY2FuIGFjdGl2YXRlIHNvdW5kcyB3aXRob3V0XHJcbiAqIG5lZWRpbmcgZGlyZWN0IHJlZmVyZW5jZXMgdG8gdGhlIGF1ZGlvIHN5c3RlbVxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQXVkaW9NYW5hZ2VyIHtcclxuICAgIHByaXZhdGUgc3RhdGljIGluc3RhbmNlOiBBdWRpb01hbmFnZXI7XHJcblxyXG4gICAgLyoqIFRoZSBldmVudCByZWNlaXZlciBvZiB0aGlzIEF1ZGlvTWFuYWdlciAqL1xyXG4gICAgcHJpdmF0ZSByZWNlaXZlcjogUmVjZWl2ZXI7XHJcblxyXG4gICAgLyoqIEEgTWFwIG9mIHRoZSBuYW1lcyBvZiBjdXJyZW50bHkgcGxheWluZyAob3IgcGF1c2VkKSBzb3VuZHMgdG8gdGhlaXIgQXVkaW9CdWZmZXJzICovXHJcbiAgICBwcml2YXRlIGN1cnJlbnRTb3VuZHM6IE1hcDxBdWRpb0J1ZmZlclNvdXJjZU5vZGU+O1xyXG5cclxuICAgIHByaXZhdGUgYXVkaW9DdHg6IEF1ZGlvQ29udGV4dDtcclxuXHJcbiAgICBwcml2YXRlIGdhaW5Ob2RlczogQXJyYXk8R2Fpbk5vZGU+O1xyXG5cclxuICAgIHByaXZhdGUgY29uc3RydWN0b3IoKXtcclxuICAgICAgICB0aGlzLmluaXRBdWRpbygpO1xyXG4gICAgICAgIHRoaXMucmVjZWl2ZXIgPSBuZXcgUmVjZWl2ZXIoKTtcclxuICAgICAgICB0aGlzLnJlY2VpdmVyLnN1YnNjcmliZShbXHJcbiAgICAgICAgICAgIEdhbWVFdmVudFR5cGUuUExBWV9TT1VORCxcclxuICAgICAgICAgICAgR2FtZUV2ZW50VHlwZS5TVE9QX1NPVU5ELFxyXG4gICAgICAgICAgICBHYW1lRXZlbnRUeXBlLlBMQVlfTVVTSUMsXHJcbiAgICAgICAgICAgIEdhbWVFdmVudFR5cGUuUExBWV9TRlgsXHJcbiAgICAgICAgICAgIEdhbWVFdmVudFR5cGUuTVVURV9DSEFOTkVMLFxyXG4gICAgICAgICAgICBHYW1lRXZlbnRUeXBlLlVOTVVURV9DSEFOTkVMXHJcbiAgICAgICAgXSk7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50U291bmRzID0gbmV3IE1hcCgpO1xyXG5cclxuICAgICAgICB0aGlzLmdhaW5Ob2RlcyA9IG5ldyBBcnJheTxHYWluTm9kZT4oTUFYX0FVRElPX0NIQU5ORUxTKTtcclxuICAgICAgICB0aGlzLmluaXRHYWluTm9kZXMoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgaW5zdGFuY2Ugb2YgdGhlIEF1ZGlvTWFuYWdlciBjbGFzcyBvciBjcmVhdGUgYSBuZXcgb25lIGlmIG5vbmUgZXhpc3RzXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgQXVkaW9NYW5hZ2VyXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0SW5zdGFuY2UoKTogQXVkaW9NYW5hZ2VyIHtcclxuICAgICAgICBpZighdGhpcy5pbnN0YW5jZSl7XHJcbiAgICAgICAgICAgIHRoaXMuaW5zdGFuY2UgPSBuZXcgQXVkaW9NYW5hZ2VyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmluc3RhbmNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIHdlYkF1ZGlvIGNvbnRleHRcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBpbml0QXVkaW8oKTogdm9pZCB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgd2luZG93LkF1ZGlvQ29udGV4dCA9IHdpbmRvdy5BdWRpb0NvbnRleHQ7Ly8gfHwgd2luZG93LndlYmtpdEF1ZGlvQ29udGV4dDsgXHJcbiAgICAgICAgICAgIHRoaXMuYXVkaW9DdHggPSBuZXcgQXVkaW9Db250ZXh0KCk7IFxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnV2ViIEF1ZGlvIEFQSSBzdWNjZXNzZnVsbHkgbG9hZGVkJyk7XHJcbiAgICAgICAgfSBjYXRjaChlKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignV2ViIEF1ZGlvIEFQSSBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3NlcicpOyBcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBpbml0R2Fpbk5vZGVzKCk6IHZvaWQge1xyXG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBNQVhfQVVESU9fQ0hBTk5FTFM7IGkrKyl7XHJcbiAgICAgICAgICAgIHRoaXMuZ2Fpbk5vZGVzW2ldID0gdGhpcy5hdWRpb0N0eC5jcmVhdGVHYWluKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgY3VycmVudCBhdWRpbyBjb250ZXh0XHJcbiAgICAgKiBAcmV0dXJucyBUaGUgQXVkaW9Db250ZXh0XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRBdWRpb0NvbnRleHQoKTogQXVkaW9Db250ZXh0IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5hdWRpb0N0eDtcclxuICAgIH1cclxuXHJcbiAgICAvKlxyXG4gICAgICAgIEFjY29yZGluZyB0byB0aGUgTUROLCBjcmVhdGUgYSBuZXcgc291bmQgZm9yIGV2ZXJ5IGNhbGw6XHJcblxyXG4gICAgICAgIEFuIEF1ZGlvQnVmZmVyU291cmNlTm9kZSBjYW4gb25seSBiZSBwbGF5ZWQgb25jZTsgYWZ0ZXIgZWFjaCBjYWxsIHRvIHN0YXJ0KCksIHlvdSBoYXZlIHRvIGNyZWF0ZSBhIG5ldyBub2RlXHJcbiAgICAgICAgaWYgeW91IHdhbnQgdG8gcGxheSB0aGUgc2FtZSBzb3VuZCBhZ2Fpbi4gRm9ydHVuYXRlbHksIHRoZXNlIG5vZGVzIGFyZSB2ZXJ5IGluZXhwZW5zaXZlIHRvIGNyZWF0ZSwgYW5kIHRoZVxyXG4gICAgICAgIGFjdHVhbCBBdWRpb0J1ZmZlcnMgY2FuIGJlIHJldXNlZCBmb3IgbXVsdGlwbGUgcGxheXMgb2YgdGhlIHNvdW5kLiBJbmRlZWQsIHlvdSBjYW4gdXNlIHRoZXNlIG5vZGVzIGluIGFcclxuICAgICAgICBcImZpcmUgYW5kIGZvcmdldFwiIG1hbm5lcjogY3JlYXRlIHRoZSBub2RlLCBjYWxsIHN0YXJ0KCkgdG8gYmVnaW4gcGxheWluZyB0aGUgc291bmQsIGFuZCBkb24ndCBldmVuIGJvdGhlciB0b1xyXG4gICAgICAgIGhvbGQgYSByZWZlcmVuY2UgdG8gaXQuIEl0IHdpbGwgYXV0b21hdGljYWxseSBiZSBnYXJiYWdlLWNvbGxlY3RlZCBhdCBhbiBhcHByb3ByaWF0ZSB0aW1lLCB3aGljaCB3b24ndCBiZVxyXG4gICAgICAgIHVudGlsIHNvbWV0aW1lIGFmdGVyIHRoZSBzb3VuZCBoYXMgZmluaXNoZWQgcGxheWluZy5cclxuICAgICovXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgc291bmQgZnJvbSB0aGUga2V5IG9mIGEgbG9hZGVkIGF1ZGlvIGZpbGVcclxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgbG9hZGVkIGF1ZGlvIGZpbGUgdG8gY3JlYXRlIGEgbmV3IHNvdW5kIGZvclxyXG4gICAgICogQHJldHVybnMgVGhlIG5ld2x5IGNyZWF0ZWQgQXVkaW9CdWZmZXJcclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGNyZWF0ZVNvdW5kKGtleTogc3RyaW5nLCBob2xkUmVmZXJlbmNlOiBib29sZWFuLCBjaGFubmVsOiBBdWRpb0NoYW5uZWxUeXBlLCBvcHRpb25zOiBNYXA8YW55Pik6IEF1ZGlvQnVmZmVyU291cmNlTm9kZSB7XHJcbiAgICAgICAgLy8gR2V0IGF1ZGlvIGJ1ZmZlclxyXG4gICAgICAgIGxldCBidWZmZXIgPSBSZXNvdXJjZU1hbmFnZXIuZ2V0SW5zdGFuY2UoKS5nZXRBdWRpbyhrZXkpO1xyXG5cclxuICAgICAgICAvLyBDcmVhdGUgYSBzb3VuZCBzb3VyY2VcclxuICAgICAgICB2YXIgc291cmNlID0gdGhpcy5hdWRpb0N0eC5jcmVhdGVCdWZmZXJTb3VyY2UoKTsgXHJcbiAgICAgIFxyXG4gICAgICAgIC8vIFRlbGwgdGhlIHNvdXJjZSB3aGljaCBzb3VuZCB0byBwbGF5XHJcbiAgICAgICAgc291cmNlLmJ1ZmZlciA9IGJ1ZmZlcjsgICAgICAgICAgICAgICBcclxuICAgICAgXHJcbiAgICAgICAgLy8gQWRkIGFueSBhZGRpdGlvbmFsIG5vZGVzXHJcbiAgICAgICAgY29uc3Qgbm9kZXM6IEFycmF5PEF1ZGlvTm9kZT4gPSBbc291cmNlXTtcclxuXHJcbiAgICAgICAgLy8gRG8gYW55IGFkZGl0aW9uYWwgbm9kZXMgaGVyZT9cclxuICAgICAgICAvLyBPZiBjb3Vyc2UsIHRoZXJlIGFyZW4ndCBhbnkgc3VwcG9ydGVkIHlldC4uLlxyXG5cclxuICAgICAgICAvLyBBZGQgdGhlIGdhaW4gbm9kZSBmb3IgdGhpcyBjaGFubmVsXHJcbiAgICAgICAgbm9kZXMucHVzaCh0aGlzLmdhaW5Ob2Rlc1tjaGFubmVsXSk7XHJcblxyXG4gICAgICAgIC8vIENvbm5lY3QgYW55IG5vZGVzIGFsb25nIHRoZSBwYXRoXHJcbiAgICAgICAgZm9yKGxldCBpID0gMTsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKXtcclxuICAgICAgICAgICAgbm9kZXNbaS0xXS5jb25uZWN0KG5vZGVzW2ldKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENvbm5lY3QgdGhlIHNvdXJjZSB0byB0aGUgY29udGV4dCdzIGRlc3RpbmF0aW9uXHJcbiAgICAgICAgbm9kZXNbbm9kZXMubGVuZ3RoIC0gMV0uY29ubmVjdCh0aGlzLmF1ZGlvQ3R4LmRlc3RpbmF0aW9uKTtcclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gc291cmNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUGxheSB0aGUgc291bmQgc3BlY2lmaWVkIGJ5IHRoZSBrZXlcclxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgc291bmQgdG8gcGxheVxyXG4gICAgICogQHBhcmFtIGxvb3AgQSBib29sZWFuIGZvciB3aGV0aGVyIG9yIG5vdCB0byBsb29wIHRoZSBzb3VuZFxyXG4gICAgICogQHBhcmFtIGhvbGRSZWZlcmVuY2UgQSBib29sZWFuIGZvciB3aGV0aGVyIG9yIG5vdCB3ZSB3YW50IHRvIGhvbGQgb24gdG8gYSByZWZlcmVuY2Ugb2YgdGhlIGF1ZGlvIG5vZGUuIFRoaXMgaXMgZ29vZCBmb3IgcGxheWluZyBtdXNpYyBvbiBhIGxvb3AgdGhhdCB3aWxsIGV2ZW50dWFsbHkgbmVlZCB0byBiZSBzdG9wcGVkLlxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgcGxheVNvdW5kKGtleTogc3RyaW5nLCBsb29wOiBib29sZWFuLCBob2xkUmVmZXJlbmNlOiBib29sZWFuLCBjaGFubmVsOiBBdWRpb0NoYW5uZWxUeXBlLCBvcHRpb25zOiBNYXA8YW55Pik6IHZvaWQge1xyXG4gICAgICAgIGxldCBzb3VuZCA9IHRoaXMuY3JlYXRlU291bmQoa2V5LCBob2xkUmVmZXJlbmNlLCBjaGFubmVsLCBvcHRpb25zKTtcclxuXHJcbiAgICAgICAgaWYobG9vcCl7XHJcbiAgICAgICAgICAgIHNvdW5kLmxvb3AgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQWRkIGEgcmVmZXJlbmNlIG9mIHRoZSBuZXcgc291bmQgdG8gYSBtYXAuIFRoaXMgd2lsbCBhbGxvdyB1cyB0byBzdG9wIGEgbG9vcGluZyBvciBsb25nIHNvdW5kIGF0IGEgbGF0ZXIgdGltZVxyXG4gICAgICAgIGlmKGhvbGRSZWZlcmVuY2Upe1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRTb3VuZHMuYWRkKGtleSwgc291bmQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBzb3VuZC5zdGFydCgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3RvcCB0aGUgc291bmQgc3BlY2lmaWVkIGJ5IHRoZSBrZXlcclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIHN0b3BTb3VuZChrZXk6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgICAgIGxldCBzb3VuZCA9IHRoaXMuY3VycmVudFNvdW5kcy5nZXQoa2V5KTtcclxuICAgICAgICBpZihzb3VuZCl7XHJcbiAgICAgICAgICAgIHNvdW5kLnN0b3AoKTtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50U291bmRzLmRlbGV0ZShrZXkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgbXV0ZUNoYW5uZWwoY2hhbm5lbDogQXVkaW9DaGFubmVsVHlwZSl7XHJcbiAgICAgICAgdGhpcy5nYWluTm9kZXNbY2hhbm5lbF0uZ2Fpbi5zZXRWYWx1ZUF0VGltZSgwLCB0aGlzLmF1ZGlvQ3R4LmN1cnJlbnRUaW1lKTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgdW5tdXRlQ2hhbm5lbChjaGFubmVsOiBBdWRpb0NoYW5uZWxUeXBlKXtcclxuICAgICAgICB0aGlzLmdhaW5Ob2Rlc1tjaGFubmVsXS5nYWluLnNldFZhbHVlQXRUaW1lKDEsIHRoaXMuYXVkaW9DdHguY3VycmVudFRpbWUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgdm9sdW1lIG9mIGEgY2hhbm5lbCB1c2luZyB0aGUgR2Fpbk5vZGUgZm9yIHRoYXQgY2hhbm5lbC4gRm9yIG1vcmVcclxuICAgICAqIGluZm9ybWF0aW9uIG9uIEdhaW5Ob2Rlcywgc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9HYWluTm9kZVxyXG4gICAgICogQHBhcmFtIGNoYW5uZWwgVGhlIGF1ZGlvIGNoYW5uZWwgdG8gc2V0IHRoZSB2b2x1bWUgZm9yXHJcbiAgICAgKiBAcGFyYW0gdm9sdW1lIFRoZSB2b2x1bWUgb2YgdGhlIGNoYW5uZWwuIDAgaXMgbXV0ZWQuIFZhbHVlcyBiZWxvdyB6ZXJvIHdpbGwgYmUgc2V0IHRvIHplcm8uXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBzZXRWb2x1bWUoY2hhbm5lbDogQXVkaW9DaGFubmVsVHlwZSwgdm9sdW1lOiBudW1iZXIpe1xyXG4gICAgICAgIGlmKHZvbHVtZSA8IDApe1xyXG4gICAgICAgICAgICB2b2x1bWUgPSAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgYW0gPSBBdWRpb01hbmFnZXIuZ2V0SW5zdGFuY2UoKTtcclxuICAgICAgICBhbS5nYWluTm9kZXNbY2hhbm5lbF0uZ2Fpbi5zZXRWYWx1ZUF0VGltZSh2b2x1bWUsIGFtLmF1ZGlvQ3R4LmN1cnJlbnRUaW1lKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIEdhaW5Ob2RlIGZvciB0aGlzIGNoYW5uZWwuXHJcbiAgICAgKiBMZWFybiBtb3JlIGFib3V0IEdhaW5Ob2RlcyBoZXJlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9HYWluTm9kZVxyXG4gICAgICogRE9OJ1QgVVNFIFRISVMgVU5MRVNTIFlPVSBLTk9XIFdIQVQgWU9VJ1JFIERPSU5HXHJcbiAgICAgKiBAcGFyYW0gY2hhbm5lbCBUaGUgY2hhbm5lbFxyXG4gICAgICogQHJldHVybnMgVGhlIEdhaW5Ob2RlIGZvciB0aGUgc3BlY2lmaWVkIGNoYW5uZWxcclxuICAgICAqL1xyXG4gICAgZ2V0Q2hhbm5lbEdhaW5Ob2RlKGNoYW5uZWw6IEF1ZGlvQ2hhbm5lbFR5cGUpe1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdhaW5Ob2Rlc1tjaGFubmVsXTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgdXBkYXRlKGRlbHRhVDogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgICAgLy8gUGxheSBlYWNoIGF1ZGlvIGNsaXAgcmVxdWVzdGVkXHJcbiAgICAgICAgLy8gVE9ETyAtIEFkZCBsb2dpYyB0byBtZXJnZSBzb3VuZHMgaWYgdGhlcmUgYXJlIG11bHRpcGxlIG9mIHRoZSBzYW1lIGtleVxyXG4gICAgICAgIHdoaWxlKHRoaXMucmVjZWl2ZXIuaGFzTmV4dEV2ZW50KCkpe1xyXG4gICAgICAgICAgICBsZXQgZXZlbnQgPSB0aGlzLnJlY2VpdmVyLmdldE5leHRFdmVudCgpO1xyXG4gICAgICAgICAgICBpZihldmVudC50eXBlID09PSBHYW1lRXZlbnRUeXBlLlBMQVlfU09VTkQgfHwgZXZlbnQudHlwZSA9PT0gR2FtZUV2ZW50VHlwZS5QTEFZX01VU0lDIHx8IGV2ZW50LnR5cGUgPT09IEdhbWVFdmVudFR5cGUuUExBWV9TRlgpe1xyXG4gICAgICAgICAgICAgICAgbGV0IHNvdW5kS2V5ID0gZXZlbnQuZGF0YS5nZXQoXCJrZXlcIik7XHJcbiAgICAgICAgICAgICAgICBsZXQgbG9vcCA9IGV2ZW50LmRhdGEuZ2V0KFwibG9vcFwiKTtcclxuICAgICAgICAgICAgICAgIGxldCBob2xkUmVmZXJlbmNlID0gZXZlbnQuZGF0YS5nZXQoXCJob2xkUmVmZXJlbmNlXCIpO1xyXG5cclxuICAgICAgICAgICAgICAgIGxldCBjaGFubmVsID0gQXVkaW9DaGFubmVsVHlwZS5ERUZBVUxUO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmKGV2ZW50LnR5cGUgPT09IEdhbWVFdmVudFR5cGUuUExBWV9NVVNJQyl7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbCA9IEF1ZGlvQ2hhbm5lbFR5cGUuTVVTSUM7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYoR2FtZUV2ZW50VHlwZS5QTEFZX1NGWCl7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbCA9IEF1ZGlvQ2hhbm5lbFR5cGUuU0ZYO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmKGV2ZW50LmRhdGEuaGFzKFwiY2hhbm5lbFwiKSl7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbCA9IGV2ZW50LmRhdGEuZ2V0KFwiY2hhbm5lbFwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLnBsYXlTb3VuZChzb3VuZEtleSwgbG9vcCwgaG9sZFJlZmVyZW5jZSwgY2hhbm5lbCwgZXZlbnQuZGF0YSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKGV2ZW50LnR5cGUgPT09IEdhbWVFdmVudFR5cGUuU1RPUF9TT1VORCl7XHJcbiAgICAgICAgICAgICAgICBsZXQgc291bmRLZXkgPSBldmVudC5kYXRhLmdldChcImtleVwiKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RvcFNvdW5kKHNvdW5kS2V5KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYoZXZlbnQudHlwZSA9PT0gR2FtZUV2ZW50VHlwZS5NVVRFX0NIQU5ORUwpe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tdXRlQ2hhbm5lbChldmVudC5kYXRhLmdldChcImNoYW5uZWxcIikpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZihldmVudC50eXBlID09PSBHYW1lRXZlbnRUeXBlLlVOTVVURV9DSEFOTkVMKXtcclxuICAgICAgICAgICAgICAgIHRoaXMudW5tdXRlQ2hhbm5lbChldmVudC5kYXRhLmdldChcImNoYW5uZWxcIikpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZW51bSBBdWRpb0NoYW5uZWxUeXBlIHtcclxuICAgIERFRkFVTFQgPSAwLFxyXG4gICAgU0ZYID0gMSxcclxuICAgIE1VU0lDID0gMixcclxuICAgIENVU1RPTV8xID0gMyxcclxuICAgIENVU1RPTV8yID0gNCxcclxuICAgIENVU1RPTV8zID0gNSxcclxuICAgIENVU1RPTV80ID0gNixcclxuICAgIENVU1RPTV81ID0gNyxcclxuICAgIENVU1RPTV82ID0gOCxcclxuICAgIENVU1RPTV83ID0gOSxcclxuICAgIENVU1RPTV84ID0gMTAsXHJcbiAgICBDVVNUT01fOSA9IDExLFxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgTUFYX0FVRElPX0NIQU5ORUxTID0gMTI7IiwiaW1wb3J0IFVwZGF0ZWFibGUgZnJvbSBcIi4uL0RhdGFUeXBlcy9JbnRlcmZhY2VzL1VwZGF0ZWFibGVcIjtcclxuaW1wb3J0IFRpbWVyIGZyb20gXCIuL1RpbWVyXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUaW1lck1hbmFnZXIgaW1wbGVtZW50cyBVcGRhdGVhYmxlIHtcclxuXHJcbiAgICBwcm90ZWN0ZWQgdGltZXJzOiBBcnJheTxUaW1lcj47XHJcblxyXG4gICAgY29uc3RydWN0b3IoKXtcclxuICAgICAgICB0aGlzLnRpbWVycyA9IG5ldyBBcnJheSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBzdGF0aWMgaW5zdGFuY2U6IFRpbWVyTWFuYWdlcjtcclxuXHJcbiAgICBzdGF0aWMgZ2V0SW5zdGFuY2UoKTogVGltZXJNYW5hZ2VyIHtcclxuICAgICAgICBpZighdGhpcy5pbnN0YW5jZSl7XHJcbiAgICAgICAgICAgIHRoaXMuaW5zdGFuY2UgPSBuZXcgVGltZXJNYW5hZ2VyKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5pbnN0YW5jZTtcclxuICAgIH1cclxuXHJcbiAgICBhZGRUaW1lcih0aW1lcjogVGltZXIpe1xyXG4gICAgICAgIHRoaXMudGltZXJzLnB1c2godGltZXIpO1xyXG4gICAgfVxyXG5cclxuICAgIGNsZWFyVGltZXJzKCl7XHJcbiAgICAgICAgdGhpcy50aW1lcnMgPSBuZXcgQXJyYXkoKTtcclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGUoZGVsdGFUOiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLnRpbWVycy5mb3JFYWNoKHRpbWVyID0+IHRpbWVyLnVwZGF0ZShkZWx0YVQpKTtcclxuICAgIH1cclxufSIsImltcG9ydCBNYXRoVXRpbHMgZnJvbSBcIi4vTWF0aFV0aWxzXCI7XHJcblxyXG4vLyBUT0RPOiBUaGlzIHNob3VsZCBiZSBtb3ZlZCB0byB0aGUgZGF0YXR5cGVzIGZvbGRlclxyXG4vKipcclxuICogQSBDb2xvciB1dGlsIGNsYXNzIHRoYXQga2VlcHMgdHJhY2sgb2YgY29sb3JzIGxpa2UgYSB2ZWN0b3IsIGJ1dCBjYW4gYmUgY29udmVydGVkIGludG8gYSBzdHJpbmcgZm9ybWF0XHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb2xvciB7XHJcblx0LyoqIFRoZSByZWQgdmFsdWUgKi9cclxuXHRwdWJsaWMgcjogbnVtYmVyO1xyXG5cdC8qKiBUaGUgZ3JlZW4gdmFsdWUgKi9cclxuXHRwdWJsaWMgZzogbnVtYmVyO1xyXG5cdC8qKiBUaGUgYmx1ZSB2YWx1ZSAqL1xyXG5cdHB1YmxpYyBiOiBudW1iZXI7XHJcblx0LyoqIFRoZSBhbHBoYSB2YWx1ZSAqL1xyXG5cdHB1YmxpYyBhOiBudW1iZXI7XHJcblxyXG5cdC8qKlxyXG5cdCAqIENyZWF0ZXMgYSBuZXcgY29sb3JcclxuXHQgKiBAcGFyYW0gciBSZWRcclxuXHQgKiBAcGFyYW0gZyBHcmVlblxyXG5cdCAqIEBwYXJhbSBiIEJsdWVcclxuXHQgKiBAcGFyYW0gYSBBbHBoYVxyXG5cdCAqL1xyXG5cdGNvbnN0cnVjdG9yKHI6IG51bWJlciA9IDAsIGc6IG51bWJlciA9IDAsIGI6IG51bWJlciA9IDAsIGE6IG51bWJlciA9IDEpe1xyXG4gICAgICAgIHRoaXMuciA9IHI7XHJcbiAgICAgICAgdGhpcy5nID0gZztcclxuICAgICAgICB0aGlzLmIgPSBiO1xyXG4gICAgICAgIHRoaXMuYSA9IGE7XHJcblx0fVxyXG5cclxuXHQvKipcdFxyXG5cdCAqIFRyYW5zcGFyZW50IGNvbG9yXHJcblx0ICogQHJldHVybnMgcmdiYSgwLCAwLCAwLCAwKVxyXG5cdCAqL1xyXG5cdHN0YXRpYyBnZXQgVFJBTlNQQVJFTlQoKTogQ29sb3Ige1xyXG5cdFx0cmV0dXJuIG5ldyBDb2xvcigwLCAwLCAwLCAwKTtcclxuXHR9XHJcblx0XHJcblx0LyoqXHRcclxuXHQgKiBSZWQgY29sb3JcclxuXHQgKiBAcmV0dXJucyByZ2IoMjU1LCAwLCAwKVxyXG5cdCAqL1xyXG5cdHN0YXRpYyBnZXQgUkVEKCk6IENvbG9yIHtcclxuXHRcdHJldHVybiBuZXcgQ29sb3IoMjU1LCAwLCAwLCAxKTtcclxuXHR9XHJcblxyXG5cdC8qKlx0XHJcblx0ICogR3JlZW4gY29sb3JcclxuXHQgKiBAcmV0dXJucyByZ2IoMCwgMjU1LCAwKVxyXG5cdCAqL1xyXG5cdHN0YXRpYyBnZXQgR1JFRU4oKTogQ29sb3Ige1xyXG5cdFx0cmV0dXJuIG5ldyBDb2xvcigwLCAyNTUsIDAsIDEpO1xyXG5cdH1cclxuXHJcblx0LyoqXHRcclxuXHQgKiBCbHVlIGNvbG9yXHJcblx0ICogQHJldHVybnMgcmdiKDAsIDAsIDI1NSlcclxuXHQgKi9cclxuXHRzdGF0aWMgZ2V0IEJMVUUoKTogQ29sb3Ige1xyXG5cdFx0cmV0dXJuIG5ldyBDb2xvcigwLCAwLCAyNTUsIDEpO1xyXG5cdH1cclxuXHJcblx0LyoqXHRcclxuXHQgKiBZZWxsb3cgY29sb3JcclxuXHQgKiBAcmV0dXJucyByZ2IoMjU1LCAyNTUsIDApXHJcblx0ICovXHJcblx0c3RhdGljIGdldCBZRUxMT1coKTogQ29sb3Ige1xyXG5cdFx0cmV0dXJuIG5ldyBDb2xvcigyNTUsIDI1NSwgMCwgMSk7XHJcblx0fVxyXG5cclxuXHQvKipcdFxyXG5cdCAqIE1hZ2VudGEgY29sb3JcclxuXHQgKiBAcmV0dXJucyByZ2IoMjU1LCAwLCAyNTUpXHJcblx0ICovXHJcblx0c3RhdGljIGdldCBNQUdFTlRBKCk6IENvbG9yIHtcclxuXHRcdHJldHVybiBuZXcgQ29sb3IoMjU1LCAwLCAyNTUsIDEpO1xyXG5cdH1cclxuXHJcblx0LyoqXHRcclxuXHQgKiBDeWFuIGNvbG9yXHJcblx0ICogQHJldHVybnMgcmdiKDAsIDI1NSwgMjU1KVxyXG5cdCAqL1xyXG5cdHN0YXRpYyBnZXQgQ1lBTigpOiBDb2xvciB7XHJcblx0XHRyZXR1cm4gbmV3IENvbG9yKDAsIDI1NSwgMjU1LCAxKTtcclxuXHR9XHJcblxyXG5cdC8qKlx0XHJcblx0ICogV2hpdGUgY29sb3JcclxuXHQgKiBAcmV0dXJucyByZ2IoMjU1LCAyNTUsIDI1NSlcclxuXHQgKi9cclxuXHRzdGF0aWMgZ2V0IFdISVRFKCk6IENvbG9yIHtcclxuXHRcdHJldHVybiBuZXcgQ29sb3IoMjU1LCAyNTUsIDI1NSwgMSk7XHJcblx0fSBcclxuXHJcblx0LyoqXHRcclxuXHQgKiBCbGFjayBjb2xvclxyXG5cdCAqIEByZXR1cm5zIHJnYigwLCAwLCAwKVxyXG5cdCAqL1xyXG5cdHN0YXRpYyBnZXQgQkxBQ0soKTogQ29sb3Ige1xyXG5cdFx0cmV0dXJuIG5ldyBDb2xvcigwLCAwLCAwLCAxKTtcclxuXHR9XHJcblxyXG5cdC8qKlx0XHJcblx0ICogT3JhbmdlIGNvbG9yXHJcblx0ICogQHJldHVybnMgcmdiKDI1NSwgMTAwLCAwKVxyXG5cdCAqL1xyXG5cdHN0YXRpYyBnZXQgT1JBTkdFKCk6IENvbG9yIHtcclxuXHRcdHJldHVybiBuZXcgQ29sb3IoMjU1LCAxMDAsIDAsIDEpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogU2V0cyB0aGUgY29sb3IgdG8gdGhlIHZhbHVlcyBwcm92aWRlZFxyXG5cdCAqIEBwYXJhbSByIFJlZFxyXG5cdCAqIEBwYXJhbSBnIEdyZWVuXHJcblx0ICogQHBhcmFtIGIgQmx1ZVxyXG5cdCAqIEBwYXJhbSBhIEFscGhhXHJcblx0ICovXHJcblx0c2V0KHI6IG51bWJlciwgZzogbnVtYmVyLCBiOiBudW1iZXIsIGE6IG51bWJlciA9IDEpOiB2b2lkIHtcclxuXHRcdHRoaXMuciA9IHI7XHJcblx0XHR0aGlzLmcgPSBnO1xyXG5cdFx0dGhpcy5iID0gYjtcclxuXHRcdHRoaXMuYSA9IGE7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIGEgbmV3IGNvbG9yIHNsaWdodGx5IGxpZ2h0ZXIgdGhhbiB0aGUgY3VycmVudCBjb2xvclxyXG5cdCAqIEByZXR1cm5zIEEgbmV3IGxpZ2h0ZXIgQ29sb3JcclxuXHQgKi9cclxuXHRsaWdodGVuKCk6IENvbG9yIHtcclxuXHRcdHJldHVybiBuZXcgQ29sb3IoTWF0aFV0aWxzLmNsYW1wKHRoaXMuciArIDQwLCAwLCAyNTUpLCBNYXRoVXRpbHMuY2xhbXAodGhpcy5nICsgNDAsIDAsIDI1NSksIE1hdGhVdGlscy5jbGFtcCh0aGlzLmIgKyA0MCwgMCwgMjU1KSwgTWF0aFV0aWxzLmNsYW1wKHRoaXMuYSArIDEwLCAwLCAyNTUpKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgYSBuZXcgY29sb3Igc2xpZ2h0bHkgZGFya2VyIHRoYW4gdGhlIGN1cnJlbnQgY29sb3JcclxuXHQgKiBAcmV0dXJucyBBIG5ldyBkYXJrZXIgQ29sb3JcclxuXHQgKi9cclxuXHRkYXJrZW4oKTogQ29sb3Ige1xyXG5cdFx0cmV0dXJuIG5ldyBDb2xvcihNYXRoVXRpbHMuY2xhbXAodGhpcy5yIC0gNDAsIDAsIDI1NSksIE1hdGhVdGlscy5jbGFtcCh0aGlzLmcgLSA0MCwgMCwgMjU1KSwgTWF0aFV0aWxzLmNsYW1wKHRoaXMuYiAtIDQwLCAwLCAyNTUpLCBNYXRoVXRpbHMuY2xhbXAodGhpcy5hICsgMTAsIDAsIDI1NSkpO1xyXG5cdH1cclxuXHRcclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRoaXMgY29sb3IgYXMgYW4gYXJyYXlcclxuXHQgKiBAcmV0dXJucyBbciwgZywgYiwgYV1cclxuXHQgKi9cclxuXHR0b0FycmF5KCk6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdIHtcclxuXHRcdHJldHVybiBbdGhpcy5yLCB0aGlzLmcsIHRoaXMuYiwgdGhpcy5hXTtcclxuXHR9XHJcblx0XHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0aGUgY29sb3IgYXMgYSBzdHJpbmcgb2YgdGhlIGZvcm0gI1JSR0dCQlxyXG5cdCAqIEByZXR1cm5zICNSUkdHQkJcclxuXHQgKi9cclxuXHR0b1N0cmluZygpOiBzdHJpbmcge1xyXG5cdFx0cmV0dXJuIFwiI1wiICsgTWF0aFV0aWxzLnRvSGV4KHRoaXMuciwgMikgKyBNYXRoVXRpbHMudG9IZXgodGhpcy5nLCAyKSArIE1hdGhVdGlscy50b0hleCh0aGlzLmIsIDIpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0aGUgY29sb3IgYXMgYSBzdHJpbmcgb2YgdGhlIGZvcm0gcmdiKHIsIGcsIGIpXHJcblx0ICogQHJldHVybnMgcmdiKHIsIGcsIGIpXHJcblx0ICovXHJcblx0dG9TdHJpbmdSR0IoKTogc3RyaW5nIHtcclxuXHRcdHJldHVybiBcInJnYihcIiArIHRoaXMuci50b1N0cmluZygpICsgXCIsIFwiICsgdGhpcy5nLnRvU3RyaW5nKCkgKyBcIiwgXCIgKyB0aGlzLmIudG9TdHJpbmcoKSArIFwiKVwiO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0aGUgY29sb3IgYXMgYSBzdHJpbmcgb2YgdGhlIGZvcm0gcmdiYShyLCBnLCBiLCBhKVxyXG5cdCAqIEByZXR1cm5zIHJnYmEociwgZywgYiwgYSlcclxuXHQgKi9cclxuXHR0b1N0cmluZ1JHQkEoKTogc3RyaW5nIHtcclxuXHRcdGlmKHRoaXMuYSA9PT0gMCl7XHJcblx0XHRcdHJldHVybiB0aGlzLnRvU3RyaW5nUkdCKCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gXCJyZ2JhKFwiICsgdGhpcy5yLnRvU3RyaW5nKCkgKyBcIiwgXCIgKyB0aGlzLmcudG9TdHJpbmcoKSArIFwiLCBcIiArIHRoaXMuYi50b1N0cmluZygpICsgXCIsIFwiICsgdGhpcy5hLnRvU3RyaW5nKCkgK1wiKVwiXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBUdXJucyB0aGlzIGNvbG9yIGludG8gYSBmbG9hdDMyQXJyYXkgYW5kIGNoYW5nZXMgY29sb3IgcmFuZ2UgdG8gWzAuMCwgMS4wXVxyXG5cdCAqIEByZXR1cm5zIGEgRmxvYXQzMkFycmF5IGNvbnRhaW5pbmcgdGhlIGNvbG9yXHJcblx0ICovXHJcblx0dG9XZWJHTCgpOiBGbG9hdDMyQXJyYXkge1xyXG5cdFx0cmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoW1xyXG5cdFx0XHR0aGlzLnIvMjU1LFxyXG5cdFx0XHR0aGlzLmcvMjU1LFxyXG5cdFx0XHR0aGlzLmIvMjU1LFxyXG5cdFx0XHR0aGlzLmFcclxuXHRcdF0pO1xyXG5cdH1cclxuXHJcblx0c3RhdGljIGZyb21TdHJpbmdIZXgoc3RyOiBzdHJpbmcpOiBDb2xvciB7XHJcblx0XHRsZXQgaSA9IDA7XHJcblx0XHRpZihzdHIuY2hhckF0KDApID09IFwiI1wiKSBpKz0gMTtcclxuXHRcdGxldCByID0gTWF0aFV0aWxzLmZyb21IZXgoc3RyLnN1YnN0cmluZyhpLCBpKzIpKTtcclxuXHRcdGxldCBnID0gTWF0aFV0aWxzLmZyb21IZXgoc3RyLnN1YnN0cmluZyhpKzIsIGkrNCkpO1xyXG5cdFx0bGV0IGIgPSBNYXRoVXRpbHMuZnJvbUhleChzdHIuc3Vic3RyaW5nKGkrNCwgaSs2KSk7XHJcblx0XHRyZXR1cm4gbmV3IENvbG9yKHIsIGcsIGIpO1xyXG5cdH1cclxufSIsIi8vIEBpZ25vcmVQYWdlXHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFYXNlRnVuY3Rpb25zIHtcclxuXHJcbiAgICBzdGF0aWMgZWFzZUluT3V0U2luZSh4OiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgICAgIHJldHVybiAtKE1hdGguY29zKE1hdGguUEkgKiB4KSAtIDEpIC8gMjtcclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgZWFzZU91dEluU2luZSh4OiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgICAgIHJldHVybiB4IDwgMC41ID8gLU1hdGguY29zKE1hdGguUEkqKHggKyAwLjUpKS8yIDogLU1hdGguY29zKE1hdGguUEkqKHggLSAwLjUpKS8yICsgMTtcclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgZWFzZU91dFNpbmUoeDogbnVtYmVyKTogbnVtYmVyIHtcclxuICAgICAgICByZXR1cm4gTWF0aC5zaW4oKHggKiBNYXRoLlBJKSAvIDIpO1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBlYXNlSW5TaW5lKHg6IG51bWJlcik6IG51bWJlciB7XHJcbiAgICAgICAgcmV0dXJuIDEgLSBNYXRoLmNvcygoeCAqIE1hdGguUEkpIC8gMik7IFxyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBlYXNlSW5PdXRRdWludCh4OiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgICAgIHJldHVybiB4IDwgMC41ID8gMTYgKiB4ICogeCAqIHggKiB4ICogeCA6IDEgLSBNYXRoLnBvdygtMiAqIHggKyAyLCA1KSAvIDI7ICAgIFxyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBlYXNlSW5PdXRRdWFkKHg6IG51bWJlcik6IG51bWJlciB7XHJcbiAgICAgICAgcmV0dXJuIHggPCAwLjUgPyAyICogeCAqIHggOiAxIC0gTWF0aC5wb3coLTIgKiB4ICsgMiwgMikgLyAyO1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBlYXNlT3V0SW5RdWFkKHg6IG51bWJlcik6IG51bWJlciB7XHJcbiAgICAgICAgcmV0dXJuIHggPCAwLjUgPyB0aGlzLmVhc2VPdXRJbl9PdXRQb3coeCwgMikgOiB0aGlzLmVhc2VPdXRJbl9JblBvdyh4LCAyKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHN0YXRpYyBlYXNlT3V0SW5fT3V0UG93KHg6IG51bWJlciwgcG93OiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgICAgIHJldHVybiAwLjUgLSBNYXRoLnBvdygtMiAqIHggKyAxLCBwb3cpIC8gMjtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHN0YXRpYyBlYXNlT3V0SW5fSW5Qb3coeDogbnVtYmVyLCBwb3c6IG51bWJlcik6IG51bWJlciB7XHJcbiAgICAgICAgcmV0dXJuIDAuNSArIE1hdGgucG93KDIgKiB4IC0gMSwgcG93KSAvIDI7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBlbnVtIEVhc2VGdW5jdGlvblR5cGUge1xyXG4gICAgLy8gU0lORVxyXG4gICAgSU5fT1VUX1NJTkUgPSBcImVhc2VJbk91dFNpbmVcIixcclxuICAgIE9VVF9JTl9TSU5FID0gXCJlYXNlT3V0SW5TaW5lXCIsXHJcbiAgICBJTl9TSU5FID0gXCJlYXNlSW5TaW5lXCIsXHJcbiAgICBPVVRfU0lORSA9IFwiZWFzZU91dFNpbmVcIixcclxuXHJcbiAgICAvLyBRVUFEXHJcbiAgICBJTl9PVVRfUVVBRCA9IFwiZWFzZUluT3V0UXVhZFwiLFxyXG4gICAgT1VUX0lOX1FVQUQgPSBcImVhc2VPdXRJblF1YWRcIixcclxuXHJcbiAgICAvLyBRVUlOVFxyXG4gICAgSU5fT1VUX1FVSU5UID0gXCJlYXNlSW5PdXRRdWludFwiXHJcbn0iLCJpbXBvcnQgR3JhcGggZnJvbSBcIi4uL0RhdGFUeXBlcy9HcmFwaHMvR3JhcGhcIjtcclxuaW1wb3J0IEVkZ2VOb2RlIGZyb20gXCIuLi9EYXRhVHlwZXMvR3JhcGhzL0VkZ2VOb2RlXCI7XHJcblxyXG4vKiogQSBjbGFzcyB0byBwcm92aWRlcyBzb21lIHV0aWxpdHkgZnVuY3Rpb25zIGZvciBncmFwaHMgKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgR3JhcGhVdGlscyB7XHJcblxyXG5cdC8qKlxyXG5cdCAqIEFuIGltcGxlbWVudGF0aW9uIG9mIERqaWtzdHJhJ3Mgc2hvcnRlc3QgcGF0aCBhbGdvcml0aG0gYmFzZWQgb24gdGhlIG9uZSBkZXNjcmliZWQgaW4gVGhlIEFsZ29yaXRobSBEZXNpZ24gTWFudWFsLlxyXG5cdCAqIEBwYXJhbSBnIFRoZSBncmFwaFxyXG5cdCAqIEBwYXJhbSBzdGFydCBUaGUgbnVtYmVyIHRvIHN0YXJ0IHRoZSBzaG9ydGVzdCBwYXRoIGZyb21cclxuXHQgKiBAcmV0dXJucyBBbiBhcnJheSBjb250YWluaW5nIHRoZSBwYXJlbnQgb2YgZWFjaCBub2RlIG9mIHRoZSBHcmFwaCBpbiB0aGUgc2hvcnRlc3QgcGF0aC5cclxuXHQgKi9cclxuXHRzdGF0aWMgZGppa3N0cmEoZzogR3JhcGgsIHN0YXJ0OiBudW1iZXIpOiBBcnJheTxudW1iZXI+IHtcclxuXHRcdGxldCBpOiBudW1iZXI7XHRcdC8vIENvdW50ZXJcclxuXHRcdGxldCBwOiBFZGdlTm9kZTtcdC8vIFBvaW50ZXIgdG8gZWRnZW5vZGVcclxuXHRcdGxldCBpblRyZWU6IEFycmF5PGJvb2xlYW4+ID0gbmV3IEFycmF5KGcubnVtVmVydGljZXMpO1xyXG5cdFx0bGV0IGRpc3RhbmNlOiBBcnJheTxudW1iZXI+ID0gbmV3IEFycmF5KGcubnVtVmVydGljZXMpO1xyXG5cdFx0bGV0IHBhcmVudDogQXJyYXk8bnVtYmVyPiA9IG5ldyBBcnJheShnLm51bVZlcnRpY2VzKTtcclxuXHRcdGxldCB2OiBudW1iZXI7XHRcdC8vIEN1cnJlbnQgdmVydGV4IHRvIHByb2Nlc3NcclxuXHRcdGxldCB3OiBudW1iZXI7IFx0XHQvLyBDYW5kaWRhdGUgZm9yIG5leHQgdmVydGV4XHJcblx0XHRsZXQgd2VpZ2h0OiBudW1iZXI7XHQvLyBFZGdlIHdlaWdodFxyXG5cdFx0bGV0IGRpc3Q7XHRcdFx0Ly8gQmVzdCBjdXJyZW50IGRpc3RhbmNlIGZyb20gc3RhcnRcclxuXHJcblx0XHRmb3IoaSA9IDA7IGkgPCBnLm51bVZlcnRpY2VzOyBpKyspe1xyXG5cdFx0XHRpblRyZWVbaV0gPSBmYWxzZTtcclxuXHRcdFx0ZGlzdGFuY2VbaV0gPSBJbmZpbml0eTtcclxuXHRcdFx0cGFyZW50W2ldID0gLTE7XHJcblx0XHR9XHJcblxyXG5cdFx0ZGlzdGFuY2Vbc3RhcnRdID0gMDtcclxuXHRcdHYgPSBzdGFydDtcclxuXHJcblx0XHR3aGlsZSghaW5UcmVlW3ZdKXtcclxuXHRcdFx0aW5UcmVlW3ZdID0gdHJ1ZTtcclxuXHRcdFx0cCA9IGcuZWRnZXNbdl07XHJcblxyXG5cdFx0XHR3aGlsZShwICE9PSBudWxsKXtcclxuXHRcdFx0XHR3ID0gcC55O1xyXG5cdFx0XHRcdHdlaWdodCA9IHAud2VpZ2h0O1xyXG5cclxuXHRcdFx0XHRpZihkaXN0YW5jZVt3XSA+IGRpc3RhbmNlW3ZdICsgd2VpZ2h0KXtcclxuXHRcdFx0XHRcdGRpc3RhbmNlW3ddID0gZGlzdGFuY2Vbdl0gKyB3ZWlnaHQ7XHJcblx0XHRcdFx0XHRwYXJlbnRbd10gPSB2O1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0cCA9IHAubmV4dDtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0diA9IDA7XHJcblxyXG5cdFx0XHRkaXN0ID0gSW5maW5pdHk7XHJcblxyXG5cdFx0XHRmb3IoaSA9IDA7IGkgPD0gZy5udW1WZXJ0aWNlczsgaSsrKXtcclxuXHRcdFx0XHRpZighaW5UcmVlW2ldICYmIGRpc3QgPiBkaXN0YW5jZVtpXSl7XHJcblx0XHRcdFx0XHRkaXN0ID0gZGlzdGFuY2U7XHJcblx0XHRcdFx0XHR2ID0gaTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcGFyZW50O1xyXG5cclxuXHR9XHJcbn0iLCJpbXBvcnQgVmVjMiBmcm9tIFwiLi4vRGF0YVR5cGVzL1ZlYzJcIjtcclxuXHJcbi8qKiBBIGNsYXNzIGNvbnRhaW5pbmcgc29tZSB1dGlsaXR5IGZ1bmN0aW9ucyBmb3IgbWF0aCBvcGVyYXRpb25zICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1hdGhVdGlscyB7XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHNpZ24gb2YgdGhlIHZhbHVlIHByb3ZpZGVkXHJcbiAgICAgKiBAcGFyYW0geCBUaGUgdmFsdWUgdG8gZXh0cmFjdCB0aGUgc2lnbiBmcm9tXHJcbiAgICAgKiBAcmV0dXJucyAtMSBpZiB0aGUgbnVtYmVyIGlzIGxlc3MgdGhhbiAwLCAxIG90aGVyd2lzZVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgc2lnbih4OiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgICAgIHJldHVybiB4IDwgMCA/IC0xIDogMTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgd2hldGhlciBvciBub3QgeCBpcyBiZXR3ZWVuIGEgYW5kIGJcclxuICAgICAqIEBwYXJhbSBhIFRoZSBtaW4gYm91bmRcclxuICAgICAqIEBwYXJhbSBiIFRoZSBtYXggYm91bmRcclxuICAgICAqIEBwYXJhbSB4IFRoZSB2YWx1ZSB0byBjaGVja1xyXG4gICAgICogQHBhcmFtIGV4Y2x1c2l2ZSBXaGV0aGVyIG9yIG5vdCBhIGFuZCBiIGFyZSBleGNsdXNpdmUgYm91bmRzXHJcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHggaXMgYmV0d2VlbiBhIGFuZCBiLCBmYWxzZSBvdGhlcndpc2VcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGJldHdlZW4oYTogbnVtYmVyLCBiOiBudW1iZXIsIHg6IG51bWJlciwgZXhjbHVzaXZlPzogYm9vbGVhbik6IGJvb2xlYW4ge1xyXG4gICAgICAgIGlmKGV4Y2x1c2l2ZSl7XHJcbiAgICAgICAgICAgIHJldHVybiAoYSA8IHgpICYmICh4IDwgYik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIChhIDw9IHgpICYmICh4IDw9IGIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENsYW1wcyB0aGUgdmFsdWUgeCB0byB0aGUgcmFuZ2UgW21pbiwgbWF4XSwgcm91bmRpbmcgdXAgb3IgZG93biBpZiBuZWVkZWRcclxuICAgICAqIEBwYXJhbSB4IFRoZSB2YWx1ZSB0byBiZSBjbGFtcGVkXHJcbiAgICAgKiBAcGFyYW0gbWluIFRoZSBtaW4gb2YgdGhlIHJhbmdlXHJcbiAgICAgKiBAcGFyYW0gbWF4IFRoZSBtYXggb2YgdGhlIHJhbmdlXHJcbiAgICAgKiBAcmV0dXJucyB4LCBpZiBpdCBpcyBiZXR3ZWVuIG1pbiBhbmQgbWF4LCBvciBtaW4vbWF4IGlmIGl0IGV4Y2VlZHMgdGhlaXIgYm91bmRzXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBjbGFtcCh4OiBudW1iZXIsIG1pbjogbnVtYmVyLCBtYXg6IG51bWJlcik6IG51bWJlciB7XHJcbiAgICAgICAgaWYoeCA8IG1pbikgcmV0dXJuIG1pbjtcclxuICAgICAgICBpZih4ID4gbWF4KSByZXR1cm4gbWF4O1xyXG4gICAgICAgIHJldHVybiB4O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2xhbXBzIHRoZSB2YWx1ZSB4IHRvIHRoZSByYW5nZSBiZXR3ZWVuIDAgYW5kIDFcclxuICAgICAqIEBwYXJhbSB4IFRoZSB2YWx1ZSB0byBiZSBjbGFtcGVkXHJcbiAgICAgKiBAcmV0dXJucyB4LCBpZiBpdCBpcyBiZXR3ZWVuIDAgYW5kIDEsIG9yIDAvMSBpZiBpdCBleGNlZWRzIHRoZWlyIGJvdW5kc1xyXG4gICAgICovXHJcbiAgICBzdGF0aWMgY2xhbXAwMSh4OiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgICAgIHJldHVybiBNYXRoVXRpbHMuY2xhbXAoeCwgMCwgMSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDbGFtcHMgdGhlIGxvd2VyIGVuZCBvZiB0aGUgdmFsdWUgb2YgeCB0byB0aGUgcmFuZ2UgdG8gbWluXHJcbiAgICAgKiBAcGFyYW0geCBUaGUgdmFsdWUgdG8gYmUgY2xhbXBlZFxyXG4gICAgICogQHBhcmFtIG1pbiBUaGUgbWluaW11bSBhbGxvd2VkIHZhbHVlIG9mIHhcclxuICAgICAqIEByZXR1cm5zIHgsIGlmIGl0IGlzIGdyZWF0ZXIgdGhhbiBtaW4sIG90aGVyd2lzZSBtaW5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGNsYW1wTG93KHg6IG51bWJlciwgbWluOiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgICAgIHJldHVybiB4IDwgbWluID8gbWluIDogeDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENsYW1wcyB0aGUgbG93ZXIgZW5kIG9mIHRoZSB2YWx1ZSBvZiB4IHRvIHplcm9cclxuICAgICAqIEBwYXJhbSB4IFRoZSB2YWx1ZSB0byBiZSBjbGFtcGVkXHJcbiAgICAgKiBAcmV0dXJucyB4LCBpZiBpdCBpcyBncmVhdGVyIHRoYW4gMCwgb3RoZXJ3aXNlIDBcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGNsYW1wTG93MCh4OiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgICAgIHJldHVybiBNYXRoVXRpbHMuY2xhbXBMb3coeCwgMCk7XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIGNsYW1wTWFnbml0dWRlKHY6IFZlYzIsIG06IG51bWJlcik6IFZlYzIge1xyXG4gICAgICAgIGlmKHYubWFnU3EoKSA+IG0qbSl7XHJcbiAgICAgICAgICAgIHJldHVybiB2LnNjYWxlVG8obSk7XHJcbiAgICAgICAgfSBlbHNle1xyXG4gICAgICAgICAgICByZXR1cm4gdjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIGNoYW5nZVJhbmdlKHg6IG51bWJlciwgbWluOiBudW1iZXIsIG1heDogbnVtYmVyLCBuZXdNaW46IG51bWJlciwgbmV3TWF4OiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxlcnAobmV3TWluLCBuZXdNYXgsIHRoaXMuaW52TGVycChtaW4sIG1heCwgeCkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG5cdCAqIExpbmVhciBJbnRlcnBvbGF0aW9uXHJcblx0ICogQHBhcmFtIGEgVGhlIGZpcnN0IHZhbHVlIGZvciB0aGUgaW50ZXJwb2xhdGlvbiBib3VuZFxyXG5cdCAqIEBwYXJhbSBiIFRoZSBzZWNvbmQgdmFsdWUgZm9yIHRoZSBpbnRlcnBvbGF0aW9uIGJvdW5kXHJcblx0ICogQHBhcmFtIHQgVGhlIHRpbWUgd2UgYXJlIGludGVycG9sYXRpbmcgdG9cclxuICAgICAqIEByZXR1cm5zIFRoZSB2YWx1ZSBiZXR3ZWVuIGEgYW5kIGIgYXQgdGltZSB0XHJcblx0ICovXHJcblx0c3RhdGljIGxlcnAoYTogbnVtYmVyLCBiOiBudW1iZXIsIHQ6IG51bWJlcik6IG51bWJlciB7XHJcbiAgICAgICAgcmV0dXJuIGEgKyB0ICogKGIgLSBhKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEludmVyc2UgTGluZWFyIEludGVycG9sYXRpb24uIEZpbmRzIHRoZSB0aW1lIGF0IHdoaWNoIGEgdmFsdWUgYmV0d2VlbiBhIGFuZCBiIHdvdWxkIG9jY3VyXHJcbiAgICAgKiBAcGFyYW0gYSBUaGUgZmlyc3QgdmFsdWUgZm9yIHRoZSBpbnRlcnBvbGF0aW9uIGJvdW5kXHJcbiAgICAgKiBAcGFyYW0gYiBUaGUgc2Vjb25kIHZhbHVlIGZvciB0aGUgaW50ZXJwb2xhdGlvbiBib3VuZFxyXG4gICAgICogQHBhcmFtIHZhbHVlIFRoZSBjdXJyZW50IHZhbHVlXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgdGltZSBhdCB3aGljaCB0aGUgY3VycmVudCB2YWx1ZSBvY2N1cnMgYmV0d2VlbiBhIGFuZCBiXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBpbnZMZXJwKGE6IG51bWJlciwgYjogbnVtYmVyLCB2YWx1ZTogbnVtYmVyKXtcclxuICAgICAgICByZXR1cm4gKHZhbHVlIC0gYSkvKGIgLSBhKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgKiBDdXRzIG9mZiBkZWNpbWFsIHBvaW50cyBvZiBhIG51bWJlciBhZnRlciBhIHNwZWNpZmllZCBwbGFjZVxyXG4gICAgICogQHBhcmFtIG51bSBUaGUgbnVtYmVyIHRvIGZsb29yXHJcbiAgICAgKiBAcGFyYW0gcGxhY2UgVGhlIGxhc3QgZGVjaW1hbCBwbGFjZSBvZiB0aGUgbmV3IG51bWJlclxyXG4gICAgICogQHJldHVybnMgVGhlIGZsb29yZWQgbnVtYmVyXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBmbG9vclRvUGxhY2UobnVtOiBudW1iZXIsIHBsYWNlOiBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgICAgIGlmKHBsYWNlID09PSAwKXtcclxuICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IobnVtKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBmYWN0b3IgPSAxMDtcclxuICAgICAgICB3aGlsZShwbGFjZSA+IDEpe1xyXG4gICAgICAgICAgICBmYWN0b3IgIT0gMTA7XHJcbiAgICAgICAgICAgIHBsYWNlLS07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihudW0qZmFjdG9yKS9mYWN0b3I7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIG51bWJlciBmcm9tIGEgaGV4IHN0cmluZ1xyXG4gICAgICogQHBhcmFtIHN0ciB0aGUgc3RyaW5nIGNvbnRhaW5pbmcgdGhlIGhleCBudW1iZXJcclxuICAgICAqIEByZXR1cm5zIHRoZSBudW1iZXIgaW4gZGVjaW1hbCByZXByZXNlbnRlZCBieSB0aGUgaGV4IHN0cmluZ1xyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZnJvbUhleChzdHI6IHN0cmluZyk6IG51bWJlciB7XHJcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KHN0ciwgMTYpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgbnVtYmVyIGFzIGEgaGV4YWRlY2ltYWxcclxuICAgICAqIEBwYXJhbSBudW0gVGhlIG51bWJlciB0byBjb252ZXJ0IHRvIGhleFxyXG4gICAgICogQHBhcmFtIG1pbkxlbmd0aCBUaGUgbGVuZ3RoIG9mIHRoZSByZXR1cm5lZCBoZXggc3RyaW5nIChhZGRzIHplcm8gcGFkZGluZyBpZiBuZWVkZWQpXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgaGV4IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBudW1iZXIgYXMgYSBzdHJpbmdcclxuICAgICAqL1xyXG4gICAgc3RhdGljIHRvSGV4KG51bTogbnVtYmVyLCBtaW5MZW5ndGg6IG51bWJlciA9IG51bGwpOiBzdHJpbmcge1xyXG4gICAgICAgIGxldCBmYWN0b3IgPSAxO1xyXG4gICAgICAgIHdoaWxlKGZhY3RvcioxNiA8IG51bSl7XHJcbiAgICAgICAgICAgIGZhY3RvciAqPSAxNjtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGhleFN0ciA9IFwiXCI7XHJcbiAgICAgICAgd2hpbGUoZmFjdG9yID49IDEpe1xyXG4gICAgICAgICAgICBsZXQgZGlnaXQgPSBNYXRoLmZsb29yKG51bS9mYWN0b3IpO1xyXG4gICAgICAgICAgICBoZXhTdHIgKz0gTWF0aFV0aWxzLnRvSGV4RGlnaXQoZGlnaXQpO1xyXG4gICAgICAgICAgICBudW0gLT0gZGlnaXQgKiBmYWN0b3I7XHJcbiAgICAgICAgICAgIGZhY3RvciAvPSAxNjtcclxuXHRcdH1cclxuXHRcdFxyXG5cdFx0aWYobWluTGVuZ3RoICE9PSBudWxsKXtcclxuXHRcdFx0d2hpbGUoaGV4U3RyLmxlbmd0aCA8IG1pbkxlbmd0aCl7XHJcblx0XHRcdFx0aGV4U3RyID0gXCIwXCIgKyBoZXhTdHI7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGhleFN0cjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIGEgZGlnaXQgdG8gaGV4YWRlY2ltYWwuIEluIHRoaXMgY2FzZSwgYSBkaWdpdCBpcyBiZXR3ZWVuIDAgYW5kIDE1IGluY2x1c2l2ZVxyXG4gICAgICogQHBhcmFtIG51bSBUaGUgZGlnaXQgdG8gY29udmVydCB0byBoZXhhZGVjaW1hbFxyXG4gICAgICogQHJldHVybnMgVGhlIGhleCByZXByZXNlbnRhdGlvbiBvZiB0aGUgZGlnaXQgYXMgYSBzdHJpbmdcclxuICAgICAqL1xyXG4gICAgc3RhdGljIHRvSGV4RGlnaXQobnVtOiBudW1iZXIpOiBzdHJpbmcge1xyXG4gICAgICAgIGlmKG51bSA8IDEwKXtcclxuICAgICAgICAgICAgcmV0dXJuIFwiXCIgKyBudW07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoNjUgKyBudW0gLSAxMCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59IiwiaW1wb3J0IFZlYzIgZnJvbSBcIi4uL0RhdGFUeXBlcy9WZWMyXCI7XHJcbmltcG9ydCBDb2xvciBmcm9tIFwiLi9Db2xvclwiO1xyXG5pbXBvcnQgTWF0aFV0aWxzIGZyb20gXCIuL01hdGhVdGlsc1wiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVuZGVyaW5nVXRpbHMge1xyXG5cdHN0YXRpYyB0b1dlYkdMQ29vcmRzKHBvaW50OiBWZWMyLCBvcmlnaW46IFZlYzIsIHdvcmxkU2l6ZTogVmVjMik6IEZsb2F0MzJBcnJheSB7XHJcblx0XHRyZXR1cm4gbmV3IEZsb2F0MzJBcnJheShbXHJcblx0XHRcdE1hdGhVdGlscy5jaGFuZ2VSYW5nZShwb2ludC54LCBvcmlnaW4ueCwgb3JpZ2luLnggKyB3b3JsZFNpemUueCwgLTEsIDEpLFxyXG5cdFx0XHRNYXRoVXRpbHMuY2hhbmdlUmFuZ2UocG9pbnQueSwgb3JpZ2luLnksIG9yaWdpbi55ICsgd29ybGRTaXplLnksIDEsIC0xKVxyXG5cdFx0XSk7XHJcblx0fVxyXG5cclxuXHRzdGF0aWMgdG9XZWJHTFNjYWxlKHNpemU6IFZlYzIsIHdvcmxkU2l6ZTogVmVjMik6IEZsb2F0MzJBcnJheSB7XHJcblx0XHRyZXR1cm4gbmV3IEZsb2F0MzJBcnJheShbXHJcblx0XHRcdDIqc2l6ZS54L3dvcmxkU2l6ZS54LFxyXG5cdFx0XHQyKnNpemUueS93b3JsZFNpemUueSxcclxuXHRcdF0pO1xyXG5cdH1cclxuXHJcblx0c3RhdGljIHRvV2ViR0xDb2xvcihjb2xvcjogQ29sb3IpOiBGbG9hdDMyQXJyYXkge1xyXG5cdFx0cmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoW1xyXG5cdFx0XHRNYXRoVXRpbHMuY2hhbmdlUmFuZ2UoY29sb3IuciwgMCwgMjU1LCAwLCAxKSxcclxuXHRcdFx0TWF0aFV0aWxzLmNoYW5nZVJhbmdlKGNvbG9yLmcsIDAsIDI1NSwgMCwgMSksXHJcblx0XHRcdE1hdGhVdGlscy5jaGFuZ2VSYW5nZShjb2xvci5iLCAwLCAyNTUsIDAsIDEpLFxyXG5cdFx0XHRjb2xvci5hXHJcblx0XHRdKTtcclxuXHR9XHJcbn0iLCIvKiogU29tZSB1dGlsaXR5IGZ1bmN0aW9ucyBmb3IgZGVhbGluZyB3aXRoIHN0cmluZ3MgKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3RyaW5nVXRpbHMge1xyXG4gICAgLyoqXHJcbiAgICAgKiBFeHRyYWN0cyB0aGUgcGF0aCBmcm9tIGEgZmlsZXBhdGggdGhhdCBpbmNsdWRlcyB0aGUgZmlsZVxyXG4gICAgICogQHBhcmFtIGZpbGVQYXRoIHRoZSBmaWxlcGF0aCB0byBleHRyYWN0IHRoZSBwYXRoIGZyb21cclxuICAgICAqIEByZXR1cm5zIFRoZSBwYXRoIHBvcnRpb24gb2YgdGhlIGZpbGVwYXRoIHByb3ZpZGVkXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXRQYXRoRnJvbUZpbGVQYXRoKGZpbGVQYXRoOiBzdHJpbmcpOiBzdHJpbmcge1xyXG4gICAgICAgIGxldCBzcGxpdFBhdGggPSBmaWxlUGF0aC5zcGxpdChcIi9cIik7XHJcbiAgICAgICAgc3BsaXRQYXRoLnBvcCgpO1xyXG4gICAgICAgIHNwbGl0UGF0aC5wdXNoKFwiXCIpO1xyXG4gICAgICAgIHJldHVybiBzcGxpdFBhdGguam9pbihcIi9cIik7XHJcbiAgICB9XHJcbn0iLCJpbXBvcnQgU3RhdGVNYWNoaW5lQUkgZnJvbSBcIi4uLy4uL1dvbGZpZTJEL0FJL1N0YXRlTWFjaGluZUFJXCI7XHJcbmltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9EYXRhVHlwZXMvVmVjMlwiO1xyXG5pbXBvcnQgSW5wdXQgZnJvbSBcIi4uLy4uL1dvbGZpZTJEL0lucHV0L0lucHV0XCI7XHJcbmltcG9ydCBTcHJpdGUgZnJvbSBcIi4uLy4uL1dvbGZpZTJEL05vZGVzL1Nwcml0ZXMvU3ByaXRlXCI7XHJcbmltcG9ydCBPcnRob2dvbmFsVGlsZW1hcCBmcm9tIFwiLi4vLi4vV29sZmllMkQvTm9kZXMvVGlsZW1hcHMvT3J0aG9nb25hbFRpbGVtYXBcIjtcclxuaW1wb3J0IHsgQ1RDZXZlbnQgfSBmcm9tIFwiLi4vU2NlbmVzL0NUQ0V2ZW50XCI7XHJcbmltcG9ydCB7IEVsZW1lbnQgfSBmcm9tIFwiLi9FbGVtZW50X0VudW1cIjtcclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRWxlbWVudENvbnRyb2xsZXIgZXh0ZW5kcyBTdGF0ZU1hY2hpbmVBSSB7XHJcbiAgICBwcm90ZWN0ZWQgb3duZXI6IFNwcml0ZTtcclxuICAgIHByb3RlY3RlZCBUeXBlIDogRWxlbWVudDtcclxuICAgIHByb3RlY3RlZCBWZWwgOiBWZWMyO1xyXG4gICAgcHJvdGVjdGVkIHRhcmdldFBvcyA6IFZlYzI7XHJcbiAgICBpbml0aWFsaXplQUkob3duZXI6IFNwcml0ZSwgb3B0aW9uczogUmVjb3JkPHN0cmluZywgYW55Pil7XHJcbiAgICAgICAgdGhpcy5vd25lciA9IG93bmVyO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGUoZGVsdGFUOiBudW1iZXIpOiB2b2lkIHtcclxuICAgIH1cclxufSIsImltcG9ydCBTdGF0ZU1hY2hpbmVBSSBmcm9tIFwiLi4vLi4vV29sZmllMkQvQUkvU3RhdGVNYWNoaW5lQUlcIjtcclxuaW1wb3J0IFZlYzIgZnJvbSBcIi4uLy4uL1dvbGZpZTJEL0RhdGFUeXBlcy9WZWMyXCI7XHJcbmltcG9ydCBJbnB1dCBmcm9tIFwiLi4vLi4vV29sZmllMkQvSW5wdXQvSW5wdXRcIjtcclxuaW1wb3J0IEFuaW1hdGVkU3ByaXRlIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9Ob2Rlcy9TcHJpdGVzL0FuaW1hdGVkU3ByaXRlXCI7XHJcbmltcG9ydCBPcnRob2dvbmFsVGlsZW1hcCBmcm9tIFwiLi4vLi4vV29sZmllMkQvTm9kZXMvVGlsZW1hcHMvT3J0aG9nb25hbFRpbGVtYXBcIjtcclxuaW1wb3J0IHsgUGxheWVyX2VudW1zIH0gZnJvbSBcIi4vUGxheWVyX2VudW1zXCI7XHJcbmltcG9ydCB7IENUQ2V2ZW50IH0gZnJvbSBcIi4uL1NjZW5lcy9DVENFdmVudFwiO1xyXG5pbXBvcnQgRWFydGggZnJvbSBcIi4uL1NjZW5lcy9FYXJ0aFwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGxheWVyQ29udHJvbGxlciBleHRlbmRzIFN0YXRlTWFjaGluZUFJIHtcclxuICAgIHByb3RlY3RlZCBvd25lcjogQW5pbWF0ZWRTcHJpdGU7XHJcbiAgICB0aWxlbWFwOiBPcnRob2dvbmFsVGlsZW1hcDtcclxuICAgIHNlbGVjdGVkRWxlbWVudDogbnVtYmVyO1xyXG4gICAgLy9pbmRpY2F0ZSB3aGljaCBkaXJlY3Rpb24gcGxheWVyIGZhY2luZ1xyXG4gICAgZmFjaW5nX2RpcmVjdGlvbjogUGxheWVyX2VudW1zO1xyXG5cclxuICAgIGhhc1Bvd2VyOiBBcnJheTxCb29sZWFuPjtcclxuXHJcbiAgICBpbml0aWFsaXplQUkob3duZXI6IEFuaW1hdGVkU3ByaXRlLCBvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KXtcclxuICAgICAgICB0aGlzLm93bmVyID0gb3duZXI7XHJcblxyXG4gICAgICAgIHRoaXMudGlsZW1hcCA9IHRoaXMub3duZXIuZ2V0U2NlbmUoKS5nZXRUaWxlbWFwKG9wdGlvbnMudGlsZW1hcCkgYXMgT3J0aG9nb25hbFRpbGVtYXA7XHJcblxyXG4gICAgICAgIHRoaXMuc2VsZWN0ZWRFbGVtZW50ID0gMTtcclxuXHJcbiAgICAgICAgdGhpcy5mYWNpbmdfZGlyZWN0aW9uID0gUGxheWVyX2VudW1zLkZBQ0lOR19ET1dOO1xyXG5cclxuICAgICAgICB0aGlzLmhhc1Bvd2VyID0gbmV3IEFycmF5KDUpLmZpbGwodHJ1ZSk7XHJcbiAgICAgICAgdGhpcy5yZWNlaXZlci5zdWJzY3JpYmUoW0NUQ2V2ZW50LlBMQVlFUl9NT1ZFXSlcclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGUoZGVsdGFUOiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgICB2YXIgbmV4dF9wb3NpdGlvbiA9IHRoaXMubmV4dHBvc2l0aW9uKCk7XHJcblx0XHRpZiAoSW5wdXQuaXNKdXN0UHJlc3NlZChcInVwXCIpKSB7XHJcbiAgICAgICAgICAgIGlmKHRoaXMuZmFjaW5nX2RpcmVjdGlvbiA9PSBQbGF5ZXJfZW51bXMuRkFDSU5HX1VQKXtcclxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdHRlci5maXJlRXZlbnQoQ1RDZXZlbnQuUExBWUVSX01PVkVfUkVRVUVTVCwge1wibmV4dFwiIDogbmV4dF9wb3NpdGlvbn0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuZmFjaW5nX2RpcmVjdGlvbiA9IFBsYXllcl9lbnVtcy5GQUNJTkdfVVA7XHJcbiAgICAgICAgICAgIHRoaXMub3duZXIuYW5pbWF0aW9uLnBsYXkoXCJ3YWxraW5nX3VwXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChJbnB1dC5pc0p1c3RQcmVzc2VkKFwibGVmdFwiKSkge1xyXG4gICAgICAgICAgICBpZih0aGlzLmZhY2luZ19kaXJlY3Rpb24gPT0gUGxheWVyX2VudW1zLkZBQ0lOR19MRUZUKXtcclxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdHRlci5maXJlRXZlbnQoQ1RDZXZlbnQuUExBWUVSX01PVkVfUkVRVUVTVCwge1wibmV4dFwiIDogbmV4dF9wb3NpdGlvbn0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuZmFjaW5nX2RpcmVjdGlvbiA9IFBsYXllcl9lbnVtcy5GQUNJTkdfTEVGVDtcclxuICAgICAgICAgICAgdGhpcy5vd25lci5hbmltYXRpb24ucGxheShcIndhbGtpbmdfbGVmdFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoSW5wdXQuaXNKdXN0UHJlc3NlZChcImRvd25cIikpIHtcclxuICAgICAgICAgICAgaWYodGhpcy5mYWNpbmdfZGlyZWN0aW9uID09IFBsYXllcl9lbnVtcy5GQUNJTkdfRE9XTil7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXR0ZXIuZmlyZUV2ZW50KENUQ2V2ZW50LlBMQVlFUl9NT1ZFX1JFUVVFU1QsIHtcIm5leHRcIiA6IG5leHRfcG9zaXRpb259KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmZhY2luZ19kaXJlY3Rpb24gPSBQbGF5ZXJfZW51bXMuRkFDSU5HX0RPV047XHJcbiAgICAgICAgICAgIHRoaXMub3duZXIuYW5pbWF0aW9uLnBsYXkoXCJ3YWxraW5nX2Rvd25cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKElucHV0LmlzSnVzdFByZXNzZWQoXCJyaWdodFwiKSkge1xyXG4gICAgICAgICAgICBpZih0aGlzLmZhY2luZ19kaXJlY3Rpb24gPT0gUGxheWVyX2VudW1zLkZBQ0lOR19SSUdIVCl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXR0ZXIuZmlyZUV2ZW50KENUQ2V2ZW50LlBMQVlFUl9NT1ZFX1JFUVVFU1QsIHtcIm5leHRcIiA6IG5leHRfcG9zaXRpb259KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmZhY2luZ19kaXJlY3Rpb24gPSBQbGF5ZXJfZW51bXMuRkFDSU5HX1JJR0hUO1xyXG4gICAgICAgICAgICB0aGlzLm93bmVyLmFuaW1hdGlvbi5wbGF5KFwid2Fsa2luZ19yaWdodFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoSW5wdXQuaXNKdXN0UHJlc3NlZChcImludGVyYWN0XCIpKSB7XHJcbiAgICAgICAgICAgIHRoaXMub3duZXIuYW5pbWF0aW9uLnBsYXkoXCJjYXN0aW5nX1wiICsgdGhpcy5mYWNpbmdfZGlyZWN0aW9uKTtcclxuICAgICAgICAgICAgdGhpcy5pbnRlcmFjdCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChJbnB1dC5pc0p1c3RQcmVzc2VkKFwicGxhY2VcIikpIHtcclxuICAgICAgICAgICAgdGhpcy5vd25lci5hbmltYXRpb24ucGxheShcImNhc3RpbmdfXCIgKyB0aGlzLmZhY2luZ19kaXJlY3Rpb24pO1xyXG4gICAgICAgICAgICB0aGlzLnBsYWNpbmdfZWxlbWVudCgpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoSW5wdXQuaXNKdXN0UHJlc3NlZChcImVsMVwiKSAmJiB0aGlzLmhhc1Bvd2VyWzBdKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRFbGVtZW50ID0gMTtcclxuICAgICAgICAgICAgdGhpcy5lbWl0dGVyLmZpcmVFdmVudChDVENldmVudC5DSEFOR0VfRUxFTUVOVCwge1wiZWxcIiA6IHRoaXMuc2VsZWN0ZWRFbGVtZW50fSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKElucHV0LmlzSnVzdFByZXNzZWQoXCJlbDJcIikgJiYgdGhpcy5oYXNQb3dlclsxXSkge1xyXG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkRWxlbWVudCA9IDI7XHJcbiAgICAgICAgICAgIHRoaXMuZW1pdHRlci5maXJlRXZlbnQoQ1RDZXZlbnQuQ0hBTkdFX0VMRU1FTlQsIHtcImVsXCIgOiB0aGlzLnNlbGVjdGVkRWxlbWVudH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChJbnB1dC5pc0p1c3RQcmVzc2VkKFwiZWwzXCIpICYmIHRoaXMuaGFzUG93ZXJbMl0pIHtcclxuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZEVsZW1lbnQgPSAzO1xyXG4gICAgICAgICAgICB0aGlzLmVtaXR0ZXIuZmlyZUV2ZW50KENUQ2V2ZW50LkNIQU5HRV9FTEVNRU5ULCB7XCJlbFwiIDogdGhpcy5zZWxlY3RlZEVsZW1lbnR9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoSW5wdXQuaXNKdXN0UHJlc3NlZChcImVsNFwiKSAmJiB0aGlzLmhhc1Bvd2VyWzNdKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRFbGVtZW50ID0gNDtcclxuICAgICAgICAgICAgdGhpcy5lbWl0dGVyLmZpcmVFdmVudChDVENldmVudC5DSEFOR0VfRUxFTUVOVCwge1wiZWxcIiA6IHRoaXMuc2VsZWN0ZWRFbGVtZW50fSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKElucHV0LmlzSnVzdFByZXNzZWQoXCJlbDVcIikgJiYgdGhpcy5oYXNQb3dlcls0XSkge1xyXG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkRWxlbWVudCA9IDU7XHJcbiAgICAgICAgICAgIHRoaXMuZW1pdHRlci5maXJlRXZlbnQoQ1RDZXZlbnQuQ0hBTkdFX0VMRU1FTlQsIHtcImVsXCIgOiB0aGlzLnNlbGVjdGVkRWxlbWVudH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChJbnB1dC5pc0p1c3RQcmVzc2VkKFwiZXNjXCIpKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwicGF1c2VkXCIpO1xyXG4gICAgICAgICAgICBFYXJ0aC5wYXVzZWQgPSAhRWFydGgucGF1c2VkO1xyXG4gICAgICAgICAgICAvL0NUQyB0b2RvOiBwYXVzZSB0aGUgZ2FtZVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBDVEMgVE9ETzogaWYgdGhlIGxldmVsLWVuZCBwb3J0YWwgaXMgYSB0aWxlLCB1c2UgdGhpcy50aWxlbWFwIGZpZWxkIGhlcmUgdG8gZmlyZSB0aGUgTEVWRUxfRU5EIGV2ZW50IChzaG91bGQgYmUgc2ltaWxhciB0byBIVzUgdGVzdGluZyBpZiBzd2l0Y2ggaXMgYmVsb3cgcGxheWVyKVxyXG4gICAgICAgIHdoaWxlKHRoaXMucmVjZWl2ZXIuaGFzTmV4dEV2ZW50KCkpe1xyXG4gICAgICAgICAgICBsZXQgZXZlbnQgPSB0aGlzLnJlY2VpdmVyLmdldE5leHRFdmVudCgpO1xyXG5cclxuICAgICAgICAgICAgc3dpdGNoKGV2ZW50LnR5cGUpe1xyXG4gICAgICAgICAgICAgICAgY2FzZSBDVENldmVudC5QTEFZRVJfTU9WRTpcclxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2godGhpcy5mYWNpbmdfZGlyZWN0aW9uKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBQbGF5ZXJfZW51bXMuRkFDSU5HX1VQOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vd25lci5tb3ZlKG5ldyBWZWMyKDAsIC0xNikpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgUGxheWVyX2VudW1zLkZBQ0lOR19ET1dOOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vd25lci5tb3ZlKG5ldyBWZWMyKDAsIDE2KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBQbGF5ZXJfZW51bXMuRkFDSU5HX1JJR0hUOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vd25lci5tb3ZlKG5ldyBWZWMyKDE2LCAwKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBQbGF5ZXJfZW51bXMuRkFDSU5HX0xFRlQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm93bmVyLm1vdmUobmV3IFZlYzIoLTE2LCAwKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblx0fVxyXG5cclxuICAgIG5leHRwb3NpdGlvbigpe1xyXG4gICAgICAgIHZhciBwb3NYID0gdGhpcy5vd25lci5wb3NpdGlvbi54O1xyXG4gICAgICAgIHZhciBwb3NZID0gdGhpcy5vd25lci5wb3NpdGlvbi55O1xyXG4gICAgICAgIHN3aXRjaCh0aGlzLmZhY2luZ19kaXJlY3Rpb24pe1xyXG4gICAgICAgICAgICBjYXNlIFBsYXllcl9lbnVtcy5GQUNJTkdfRE9XTjpcclxuICAgICAgICAgICAgICAgIHBvc1kgKz0gMTY7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBQbGF5ZXJfZW51bXMuRkFDSU5HX1VQOlxyXG4gICAgICAgICAgICAgICAgcG9zWSAtPSAxNjtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFBsYXllcl9lbnVtcy5GQUNJTkdfTEVGVDpcclxuICAgICAgICAgICAgICAgIHBvc1ggLT0gMTY7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBQbGF5ZXJfZW51bXMuRkFDSU5HX1JJR0hUOlxyXG4gICAgICAgICAgICAgICAgcG9zWCArPSAxNjtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHBvc1ggPSAocG9zWCAtIDgpIC8gMTY7XHJcbiAgICAgICAgICAgIHBvc1kgPSAocG9zWSAtIDgpIC8gMTY7XHJcbiAgICAgICAgICAgIC8vIG5vdCBhYnNvbHV0ZSBjb29yZGluYW50ID0+IEluZGV4IG9mIGdhbWVib2FyZFxyXG4gICAgICAgICAgICB2YXIgbmV4dF9wb3NpdGlvbiA9IG5ldyBWZWMyKHBvc1gsIHBvc1kpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG5leHRfcG9zaXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgaW50ZXJhY3QoKXtcclxuICAgICAgICB2YXIgbmV4dCA9IHRoaXMubmV4dHBvc2l0aW9uKCk7XHJcbiAgICAgICAgdGhpcy5lbWl0dGVyLmZpcmVFdmVudChDVENldmVudC5JTlRFUkFDVF9FTEVNRU5ULCB7XCJwb3NpdGlvblhcIjogbmV4dC54LCBcInBvc2l0aW9uWVwiOiBuZXh0LnksIFwiZGlyZWN0aW9uXCI6IHRoaXMuZmFjaW5nX2RpcmVjdGlvbn0pO1xyXG4gICAgfVxyXG4gICAgcGxhY2luZ19lbGVtZW50KCl7XHJcbiAgICAgICAgdmFyIG5leHQgPSB0aGlzLm5leHRwb3NpdGlvbigpO1xyXG4gICAgICAgIHRoaXMuZW1pdHRlci5maXJlRXZlbnQoQ1RDZXZlbnQuUExBQ0VfRUxFTUVOVCwge1wicG9zaXRpb25YXCI6IG5leHQueCwgXCJwb3NpdGlvbllcIjogbmV4dC55LCBcInR5cGVcIjogdGhpcy5zZWxlY3RlZEVsZW1lbnR9KTtcclxuICAgIH1cclxuXHJcbn0iLCJleHBvcnQgZW51bSBQbGF5ZXJfZW51bXMge1xyXG4gICAgRkFDSU5HX0RPV04gPSBcImRvd25cIixcclxuICAgIEZBQ0lOR19MRUZUID0gXCJsZWZ0XCIsXHJcbiAgICBGQUNJTkdfVVAgPSBcInVwXCIsXHJcbiAgICBGQUNJTkdfUklHSFQgPSBcInJpZ2h0XCIsXHJcbn0iLCJleHBvcnQgZW51bSBDVENldmVudHtcclxuICAgIFBMQUNFX0VMRU1FTlQgPSBcInBsYWNlX2VsZW1lbnRcIixcclxuICAgIElOVEVSQUNUX0VMRU1FTlQgPSBcImludGVyYWN0X2VsZW1lbnRcIixcclxuICAgIFBMQVlFUl9NT1ZFX1JFUVVFU1QgPSBcInBsYXllcl9tb3ZlX3JlcXVlc3RcIixcclxuICAgIFBMQVlFUl9NT1ZFID0gXCJwbGF5ZXJfbW92ZVwiLFxyXG4gICAgRUxFTUVOVF9CUkVBSyA9IFwiZWxlbWVudF9kZXN0cm95XCIsXHJcbiAgICBFTkRfTEVWRUwgPSBcImVuZF9sZXZlbFwiLFxyXG4gICAgQ0hBTkdFX0VMRU1FTlQgPSBcImNoYW5nZV9lbGVtZW50XCJcclxufSIsImltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9EYXRhVHlwZXMvVmVjMlwiO1xyXG5pbXBvcnQgeyBVSUVsZW1lbnRUeXBlIH0gZnJvbSBcIi4uLy4uL1dvbGZpZTJEL05vZGVzL1VJRWxlbWVudHMvVUlFbGVtZW50VHlwZXNcIjtcclxuaW1wb3J0IExheWVyIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9TY2VuZS9MYXllclwiO1xyXG5pbXBvcnQgU2NlbmUgZnJvbSBcIi4uLy4uL1dvbGZpZTJEL1NjZW5lL1NjZW5lXCI7XHJcbmltcG9ydCBDb2xvciBmcm9tIFwiLi4vLi4vV29sZmllMkQvVXRpbHMvQ29sb3JcIjtcclxuaW1wb3J0IExhYmVsIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9Ob2Rlcy9VSUVsZW1lbnRzL0xhYmVsXCI7XHJcbmltcG9ydCBPcnRob2dvbmFsVGlsZW1hcCBmcm9tIFwiLi4vLi4vV29sZmllMkQvTm9kZXMvVGlsZW1hcHMvT3J0aG9nb25hbFRpbGVtYXBcIjtcclxuaW1wb3J0IEFuaW1hdGVkU3ByaXRlIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9Ob2Rlcy9TcHJpdGVzL0FuaW1hdGVkU3ByaXRlXCI7XHJcbmltcG9ydCBBQUJCIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9EYXRhVHlwZXMvU2hhcGVzL0FBQkJcIjtcclxuaW1wb3J0IFBsYXllckNvbnRyb2xsZXIgZnJvbSBcIi4uL1BsYXllci9QbGF5ZXJDb250cm9sbGVyXCI7XHJcbmltcG9ydCBTcHJpdGUgZnJvbSBcIi4uLy4uL1dvbGZpZTJEL05vZGVzL1Nwcml0ZXMvU3ByaXRlXCI7XHJcbmltcG9ydCBHYW1lRXZlbnQgZnJvbSBcIi4uLy4uL1dvbGZpZTJEL0V2ZW50cy9HYW1lRXZlbnRcIjtcclxuaW1wb3J0IHsgQ1RDZXZlbnQgfSBmcm9tIFwiLi9DVENFdmVudFwiO1xyXG5pbXBvcnQgRWxlbWVudENvbnRyb2xsZXIgZnJvbSBcIi4uL0VsZW1lbnQvRWxlbWVudENvbnRyb2xsZXJcIjtcclxuaW1wb3J0IHsgUGxheWVyX2VudW1zIH0gZnJvbSBcIi4uL1BsYXllci9QbGF5ZXJfZW51bXNcIjtcclxuaW1wb3J0IHsgRWFzZUZ1bmN0aW9uVHlwZSB9IGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9VdGlscy9FYXNlRnVuY3Rpb25zXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFYXJ0aCBleHRlbmRzIFNjZW5lIHtcclxuICAgIHN0YXRpYyBwYXVzZWQ6IEJvb2xlYW47XHJcbiAgICBwcml2YXRlIHdhbGxzOiBPcnRob2dvbmFsVGlsZW1hcDtcclxuICAgIHByaXZhdGUgcGxheWVyOiBBbmltYXRlZFNwcml0ZTtcclxuICAgIHByb3RlY3RlZCBnYW1lYm9hcmQgOiBBcnJheTxBcnJheTxTcHJpdGU+PjtcclxuICAgIHByb3RlY3RlZCBlbmRwb3NpdGlvbiA6IFZlYzI7XHJcbiAgICBwcml2YXRlIHNraWxsVXNlZCA6IEFycmF5PEJvb2xlYW4+O1xyXG4gICAgcHJpdmF0ZSBlbGVtZW50R1VJIDogQW5pbWF0ZWRTcHJpdGU7XHJcbiAgICBwcml2YXRlIHBhdXNlR1VJOiBMYXllcjtcclxuXHJcbiAgICBsb2FkU2NlbmUoKXtcclxuICAgICAgICB0aGlzLmxvYWQuaW1hZ2UoXCJyb2NrX1NcIiwgXCJnYW1lX2Fzc2V0cy9zcHJpdGVzL3JvY2tfUy5wbmdcIik7XHJcbiAgICAgICAgdGhpcy5sb2FkLmltYWdlKFwicm9ja19NXCIsIFwiZ2FtZV9hc3NldHMvc3ByaXRlcy9yb2NrX00ucG5nXCIpO1xyXG4gICAgICAgIHRoaXMubG9hZC5pbWFnZShcInJvY2tfTFwiLCBcImdhbWVfYXNzZXRzL3Nwcml0ZXMvcm9ja19MLnBuZ1wiKTtcclxuICAgICAgICB0aGlzLmxvYWQuaW1hZ2UoXCJyb2NrX1BcIiwgXCJnYW1lX2Fzc2V0cy9zcHJpdGVzL3JvY2tfUC5wbmdcIik7XHJcbiAgICAgICAgdGhpcy5sb2FkLnNwcml0ZXNoZWV0KFwiZ29kXCIsIFwiZ2FtZV9hc3NldHMvc3ByaXRlc2hlZXRzL2dvZC5qc29uXCIpO1xyXG4gICAgICAgIHRoaXMubG9hZC5zcHJpdGVzaGVldChcImVsZW1lbnRfZXF1aXBwZWRcIiwgXCJnYW1lX2Fzc2V0cy9zcHJpdGVzaGVldHMvZWxlbWVudF9lcXVpcHBlZC5qc29uXCIpO1xyXG4gICAgICAgIHRoaXMubG9hZC50aWxlbWFwKFwibGV2ZWxcIiwgXCJnYW1lX2Fzc2V0cy90aWxlbWFwcy9lYXJ0aC5qc29uXCIpO1xyXG5cclxuICAgICAgICB0aGlzLmxvYWQub2JqZWN0KFwiYm9hcmRcIiwgXCJnYW1lX2Fzc2V0cy9kYXRhL2VhcnRoX2JvYXJkLmpzb25cIik7XHJcbiAgICAgICAgLy91bmxvY2sgYWxsIHBvd2VycyBmb3IgdGVzdGluZ1xyXG4gICAgICAgIHRoaXMubG9hZC5zcHJpdGVzaGVldChcIndoaXJsd2luZFwiLCBcImdhbWVfYXNzZXRzL3Nwcml0ZXNoZWV0cy93aGlybHdpbmQuanNvblwiKTtcclxuICAgICAgICB0aGlzLmxvYWQuaW1hZ2UoXCJndXN0XCIsIFwiZ2FtZV9hc3NldHMvc3ByaXRlcy9ndXN0LnBuZ1wiKTtcclxuICAgICAgICB0aGlzLmxvYWQuc3ByaXRlc2hlZXQoXCJhaXJzdHJlYW1cIiwgXCJnYW1lX2Fzc2V0cy9zcHJpdGVzaGVldHMvYWlyc3RyZWFtLmpzb25cIik7XHJcbiAgICAgICAgdGhpcy5sb2FkLmltYWdlKFwiYnViYmxlXCIsIFwiZ2FtZV9hc3NldHMvc3ByaXRlcy9idWJibGUucG5nXCIpO1xyXG4gICAgICAgIHRoaXMubG9hZC5pbWFnZShcInNoYWxsb3dfd2F0ZXJcIiwgXCJnYW1lX2Fzc2V0cy9zcHJpdGVzL3NoYWxsb3dfd2F0ZXIucG5nXCIpO1xyXG4gICAgICAgIHRoaXMubG9hZC5zcHJpdGVzaGVldChcImVtYmVyXCIsIFwiZ2FtZV9hc3NldHMvc3ByaXRlc2hlZXRzL2VtYmVyLmpzb25cIik7XHJcbiAgICAgICAgdGhpcy5sb2FkLmltYWdlKFwiZmxhbWVzXCIsIFwiZ2FtZV9hc3NldHMvc3ByaXRlcy9mbGFtZXMucG5nXCIpO1xyXG4gICAgICAgIHRoaXMubG9hZC5pbWFnZShcImlnbml0ZVwiLCBcImdhbWVfYXNzZXRzL3Nwcml0ZXMvaWduaXRlLnBuZ1wiKTtcclxuICAgICAgICB0aGlzLmxvYWQuaW1hZ2UoXCJpY2VfY3ViZVwiLCBcImdhbWVfYXNzZXRzL3Nwcml0ZXMvaWNlX2N1YmUucG5nXCIpO1xyXG4gICAgICAgIHRoaXMubG9hZC5zcHJpdGVzaGVldChcInRvcmNoXCIsIFwiZ2FtZV9hc3NldHMvc3ByaXRlc2hlZXRzL3RvcmNoLmpzb25cIik7XHJcbiAgICAgICAgdGhpcy5sb2FkLnNwcml0ZXNoZWV0KFwiY3Vyc29yXCIsIFwiZ2FtZV9hc3NldHMvc3ByaXRlc2hlZXRzL2N1cnNvci5qc29uXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXJ0U2NlbmUoKXtcclxuICAgICAgICAvLyBBZGQgaW4gdGhlIHRpbGVtYXBcclxuICAgICAgICBsZXQgdGlsZW1hcExheWVycyA9IHRoaXMuYWRkLnRpbGVtYXAoXCJsZXZlbFwiKTtcclxuXHJcbiAgICAgICAgIC8vIEdldCB0aGUgd2FsbCBsYXllciBcclxuICAgICAgICB0aGlzLndhbGxzID0gPE9ydGhvZ29uYWxUaWxlbWFwPnRpbGVtYXBMYXllcnNbMV0uZ2V0SXRlbXMoKVswXTtcclxuXHJcbiAgICAgICAgLy8gU2V0IHRoZSB2aWV3cG9ydCBib3VuZHMgdG8gdGhlIHRpbGVtYXBcclxuICAgICAgICBsZXQgdGlsZW1hcFNpemU6IFZlYzIgPSB0aGlzLndhbGxzLnNpemU7XHJcblxyXG4gICAgICAgIHRoaXMuZ2FtZWJvYXJkID0gbmV3IEFycmF5KHRoaXMud2FsbHMuZ2V0RGltZW5zaW9ucygpLnkpO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy53YWxscy5nZXREaW1lbnNpb25zKCkueTsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZ2FtZWJvYXJkW2ldID0gbmV3IEFycmF5KHRoaXMud2FsbHMuZ2V0RGltZW5zaW9ucygpLngpLmZpbGwobnVsbCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnZpZXdwb3J0LnNldEJvdW5kcygwLCAwLCB0aWxlbWFwU2l6ZS54LCB0aWxlbWFwU2l6ZS55KTtcclxuXHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy5hZGRMYXllcihcInByaW1hcnlcIiwgMTApO1xyXG4gICAgICAgIHRoaXMuZWxlbWVudEdVSSA9IHRoaXMuYWRkLmFuaW1hdGVkU3ByaXRlKFwiZWxlbWVudF9lcXVpcHBlZFwiLCBcInByaW1hcnlcIik7XHJcbiAgICAgICAgdGhpcy5lbGVtZW50R1VJLmFuaW1hdGlvbi5wbGF5KFwibm9uZV9lcXVpcHBlZFwiKTtcclxuICAgICAgICB0aGlzLmVsZW1lbnRHVUkucG9zaXRpb24uc2V0KDMqMTYrNCwgMTkqMTYpO1xyXG5cclxuICAgICAgICB0aGlzLnBhdXNlR1VJID0gdGhpcy5hZGRVSUxheWVyKFwicGF1c2VNZW51XCIpO1xyXG4gICAgICAgIHRoaXMucGF1c2VHVUkuc2V0SGlkZGVuKHRydWUpO1xyXG4gICAgICAgIGxldCBwYXVzZVRleHQgPSA8TGFiZWw+dGhpcy5hZGQudWlFbGVtZW50KFVJRWxlbWVudFR5cGUuTEFCRUwsIFwicGF1c2VNZW51XCIsIHtwb3NpdGlvbjogbmV3IFZlYzIoNSoxNiwgMTYpLCB0ZXh0OiBcIlBBVVNFRCAoV29yayBJbiBQcm9ncmVzcylcIn0pO1xyXG4gICAgICAgIHBhdXNlVGV4dC50ZXh0Q29sb3IgPSBDb2xvci5XSElURTtcclxuXHJcbiAgICAgICAgdGhpcy5pbml0aWFsaXplR2FtZWJvYXJkKCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy5pbml0aWFsaXplUGxheWVyKCk7XHJcblxyXG4gICAgICAgIHRoaXMuc2tpbGxVc2VkID0gW2ZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZV07XHJcblxyXG4gICAgICAgIC8vIFpvb20gaW4gdG8gYSByZWFzb25hYmxlIGxldmVsXHJcbiAgICAgICAgdGhpcy52aWV3cG9ydC5lbmFibGVab29tKCk7XHJcbiAgICAgICAgdGhpcy52aWV3cG9ydC5zZXRab29tTGV2ZWwoMi41KTtcclxuXHJcbiAgICAgICAgLy90aGlzLnZpZXdwb3J0LmZvbGxvdyh0aGlzLnBsYXllcik7XHJcblxyXG4gICAgICAgIHRoaXMucmVjZWl2ZXIuc3Vic2NyaWJlKFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDVENldmVudC5JTlRFUkFDVF9FTEVNRU5ULCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDVENldmVudC5QTEFDRV9FTEVNRU5ULFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENUQ2V2ZW50LlBMQVlFUl9NT1ZFX1JFUVVFU1QsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ1RDZXZlbnQuQ0hBTkdFX0VMRU1FTlRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ1RDIFRPRE86IHN1YnNjcmliZSB0byBDVENldmVudC5MRVZFTF9FTkQgZXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKTtcclxuICAgICAgICBcclxuICAgICAgIFxyXG4gICAgfVxyXG5cclxuICAgIHVwZGF0ZVNjZW5lKCl7XHJcbiAgICAgICAgaWYgKCFFYXJ0aC5wYXVzZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5wYXVzZUdVSS5zZXRIaWRkZW4odHJ1ZSk7XHJcbiAgICAgICAgICAgIHdoaWxlKHRoaXMucmVjZWl2ZXIuaGFzTmV4dEV2ZW50KCkpe1xyXG4gICAgICAgICAgICAgICAgbGV0IGV2ZW50ID0gdGhpcy5yZWNlaXZlci5nZXROZXh0RXZlbnQoKTtcclxuXHJcbiAgICAgICAgICAgICAgICBzd2l0Y2goZXZlbnQudHlwZSl7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ1RDIFRPRE86IGludGVyYWN0aW5nIGFuZCBwbGFjaW5nIChpZiBwbGFjaW5nIHRoZW4gaGF2ZSB0byBhY2NvdW50IGZvciB0aGUgd2FsbHMgc28geW91IGNhbnQgcGxhY2UgdGhlcmUpXHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBDVENldmVudC5JTlRFUkFDVF9FTEVNRU5UOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImludGVyYWN0IGhhcHBlbmVkXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhldmVudC5kYXRhLmdldChcInBvc2l0aW9uWFwiKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGV2ZW50LmRhdGEuZ2V0KFwicG9zaXRpb25ZXCIpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRhcmdldHBvc1ggPSBldmVudC5kYXRhLmdldChcInBvc2l0aW9uWFwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRhcmdldHBvc1kgPSBldmVudC5kYXRhLmdldChcInBvc2l0aW9uWVwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRpcmVjdGlvbiA9IGV2ZW50LmRhdGEuZ2V0KFwiZGlyZWN0aW9uXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpcy5nYW1lYm9hcmRbdGFyZ2V0cG9zWF1bdGFyZ2V0cG9zWV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHRhcmdldCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdGl2YXRlRWxlbWVudCh0YXJnZXQsIHRhcmdldHBvc1gsIHRhcmdldHBvc1ksIGRpcmVjdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBDVENldmVudC5QTEFDRV9FTEVNRU5UOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcGxhY2VYID0gZXZlbnQuZGF0YS5nZXQoXCJwb3NpdGlvblhcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwbGFjZVkgPSBldmVudC5kYXRhLmdldChcInBvc2l0aW9uWVwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEocGxhY2VYIDwgMiB8fCBwbGFjZVggPj0gdGhpcy53YWxscy5nZXREaW1lbnNpb25zKCkueSAtIDIgfHwgcGxhY2VZIDwgMiB8fCBwbGFjZVkgPj0gdGhpcy53YWxscy5nZXREaW1lbnNpb25zKCkueCAtIDIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5nYW1lYm9hcmRbcGxhY2VYXVtwbGFjZVldID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2goZXZlbnQuZGF0YS5nZXQoXCJ0eXBlXCIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHRoaXMuc2tpbGxVc2VkWzBdKSBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2tpbGxVc2VkWzBdID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwbGFjZV9yb2NrID0gdGhpcy5hZGQuc3ByaXRlKFwicm9ja19QXCIsIFwicHJpbWFyeVwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlX3JvY2sucG9zaXRpb24uc2V0KHBsYWNlWCoxNis4LCBwbGFjZVkqMTYrOCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZV9yb2NrLmFkZFBoeXNpY3MobmV3IEFBQkIoVmVjMi5aRVJPLCBuZXcgVmVjMig4LDgpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZV9yb2NrLmFkZEFJKEVsZW1lbnRDb250cm9sbGVyLCB7fSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdhbWVib2FyZFtwbGFjZVhdW3BsYWNlWV0gPSBwbGFjZV9yb2NrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHRoaXMuc2tpbGxVc2VkWzFdKSBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2tpbGxVc2VkWzFdID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwbGFjZV93aW5kID0gdGhpcy5hZGQuYW5pbWF0ZWRTcHJpdGUoXCJ3aGlybHdpbmRcIiwgXCJwcmltYXJ5XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2Vfd2luZC5wb3NpdGlvbi5zZXQocGxhY2VYKjE2ICsgOCwgcGxhY2VZKjE2ICsgOCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZV93aW5kLmFuaW1hdGlvbi5wbGF5KFwiaWRsZVwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlX3dpbmQuYWRkUGh5c2ljcyhuZXcgQUFCQihWZWMyLlpFUk8sIG5ldyBWZWMyKDgsIDgpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZV93aW5kLmFkZEFJKEVsZW1lbnRDb250cm9sbGVyLCB7fSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdhbWVib2FyZFtwbGFjZVhdW3BsYWNlWV0gPSBwbGFjZV93aW5kO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHRoaXMuc2tpbGxVc2VkWzJdKSBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2tpbGxVc2VkWzJdID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwbGFjZV93YXRlciA9IHRoaXMuYWRkLnNwcml0ZShcImJ1YmJsZVwiLCBcInByaW1hcnlcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZV93YXRlci5wb3NpdGlvbi5zZXQocGxhY2VYKjE2KzgsIHBsYWNlWSoxNis4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlX3dhdGVyLmFkZFBoeXNpY3MobmV3IEFBQkIoVmVjMi5aRVJPLCBuZXcgVmVjMig4LDgpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZV93YXRlci5hZGRBSShFbGVtZW50Q29udHJvbGxlciwge30pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nYW1lYm9hcmRbcGxhY2VYXVtwbGFjZVldID0gcGxhY2Vfd2F0ZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYodGhpcy5za2lsbFVzZWRbM10pIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5za2lsbFVzZWRbM10gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHBsYWNlX2ZpcmUgPSB0aGlzLmFkZC5hbmltYXRlZFNwcml0ZShcImVtYmVyXCIsIFwicHJpbWFyeVwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlX2ZpcmUucG9zaXRpb24uc2V0KHBsYWNlWCoxNiArIDgsIHBsYWNlWSoxNiArIDgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2VfZmlyZS5hbmltYXRpb24ucGxheShcImlkbGVcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZV9maXJlLmFkZFBoeXNpY3MobmV3IEFBQkIoVmVjMi5aRVJPLCBuZXcgVmVjMig4LCA4KSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2VfZmlyZS5hZGRBSShFbGVtZW50Q29udHJvbGxlciwge30pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nYW1lYm9hcmRbcGxhY2VYXVtwbGFjZVldID0gcGxhY2VfZmlyZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDU6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZih0aGlzLnNraWxsVXNlZFs0XSkgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNraWxsVXNlZFs0XSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgcGxhY2VfaWNlID0gdGhpcy5hZGQuc3ByaXRlKFwiaWNlX2N1YmVcIiwgXCJwcmltYXJ5XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2VfaWNlLnBvc2l0aW9uLnNldChwbGFjZVgqMTYrOCwgcGxhY2VZKjE2KzgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2VfaWNlLmFkZFBoeXNpY3MobmV3IEFBQkIoVmVjMi5aRVJPLCBuZXcgVmVjMig4LDgpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZV9pY2UuYWRkQUkoRWxlbWVudENvbnRyb2xsZXIsIHt9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ2FtZWJvYXJkW3BsYWNlWF1bcGxhY2VZXSA9IHBsYWNlX2ljZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoKGV2ZW50LmRhdGEuZ2V0KFwidHlwZVwiKSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHRoaXMuZ2FtZWJvYXJkW3BsYWNlWF1bcGxhY2VZXS5pbWFnZUlkID09IFwicm9ja19QXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3ByaXRlID0gdGhpcy5nYW1lYm9hcmRbcGxhY2VYXVtwbGFjZVldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwcml0ZS5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nYW1lYm9hcmRbcGxhY2VYXVtwbGFjZVldID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNraWxsVXNlZFswXSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHRoaXMuZ2FtZWJvYXJkW3BsYWNlWF1bcGxhY2VZXS5pbWFnZUlkPT0gXCJ3aGlybHdpbmRcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzcHJpdGUgPSB0aGlzLmdhbWVib2FyZFtwbGFjZVhdW3BsYWNlWV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ByaXRlLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdhbWVib2FyZFtwbGFjZVhdW3BsYWNlWV0gPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2tpbGxVc2VkWzFdID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYodGhpcy5nYW1lYm9hcmRbcGxhY2VYXVtwbGFjZVldLmltYWdlSWQgPT0gXCJidWJibGVcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzcHJpdGUgPSB0aGlzLmdhbWVib2FyZFtwbGFjZVhdW3BsYWNlWV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ByaXRlLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdhbWVib2FyZFtwbGFjZVhdW3BsYWNlWV0gPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2tpbGxVc2VkWzJdID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYodGhpcy5nYW1lYm9hcmRbcGxhY2VYXVtwbGFjZVldLmltYWdlSWQgPT0gXCJlbWJlclwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHNwcml0ZSA9IHRoaXMuZ2FtZWJvYXJkW3BsYWNlWF1bcGxhY2VZXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcHJpdGUuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ2FtZWJvYXJkW3BsYWNlWF1bcGxhY2VZXSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5za2lsbFVzZWRbM10gPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDU6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZih0aGlzLmdhbWVib2FyZFtwbGFjZVhdW3BsYWNlWV0uaW1hZ2VJZCA9PSBcImljZV9jdWJlXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3ByaXRlID0gdGhpcy5nYW1lYm9hcmRbcGxhY2VYXVtwbGFjZVldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwcml0ZS5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nYW1lYm9hcmRbcGxhY2VYXVtwbGFjZVldID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNraWxsVXNlZFs0XSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgQ1RDZXZlbnQuUExBWUVSX01PVkVfUkVRVUVTVDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5leHQgPSBldmVudC5kYXRhLmdldChcIm5leHRcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHRoaXMuZ2FtZWJvYXJkW25leHQueF1bbmV4dC55XSA9PSBudWxsIHx8IHRoaXMuZW5kcG9zaXRpb24gPT0gbmV4dCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXR0ZXIuZmlyZUV2ZW50KENUQ2V2ZW50LlBMQVlFUl9NT1ZFKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHRoaXMuZW5kcG9zaXRpb24gPT0gbmV4dCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0dGVyLmZpcmVFdmVudChDVENldmVudC5FTkRfTEVWRUwsIHtcIm5leHRsZXZlbFwiIDogXCJlYXJ0aF9ib3NzXCJ9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIENUQ2V2ZW50LkNIQU5HRV9FTEVNRU5UOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2goZXZlbnQuZGF0YS5nZXQoXCJlbFwiKSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50R1VJLmFuaW1hdGlvbi5wbGF5KFwiZWFydGhfZXF1aXBwZWRcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50R1VJLmFuaW1hdGlvbi5wbGF5KFwid2luZF9lcXVpcHBlZFwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnRHVUkuYW5pbWF0aW9uLnBsYXkoXCJ3YXRlcl9lcXVpcHBlZFwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnRHVUkuYW5pbWF0aW9uLnBsYXkoXCJmaXJlX2VxdWlwcGVkXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudEdVSS5hbmltYXRpb24ucGxheShcImljZV9lcXVpcHBlZFwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSAgICBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5wYXVzZUdVSS5zZXRIaWRkZW4oZmFsc2UpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgYWN0aXZhdGVFbGVtZW50KHRhcmdldDogU3ByaXRlLCB0YXJnZXRwb3NYOiBudW1iZXIsIHRhcmdldHBvc1k6IG51bWJlciwgZGlyZWN0aW9uOiBQbGF5ZXJfZW51bXMpIDogdm9pZCB7XHJcbiAgICAgICAgdmFyIFZlbCA9IG5ldyBWZWMyKDAsMCk7IC8vIHZlbG9jaXR5IG9mIHNwcml0ZSAoaWYgd2UgbWFrZSBtb3Zpbmcgcm9jayBzb290aGx5LilcclxuICAgICAgICB2YXIgZGVzdCA9IG5ldyBWZWMyKHRhcmdldHBvc1gsIHRhcmdldHBvc1kpOyAvL2Rlc3RpbmF0aW9uIHRoYXQgcm9jayB3aWxsIGdvLiAoSW5kZXgpXHJcbiAgICAgICAgdmFyIGRpcjtcclxuICAgICAgICBzd2l0Y2goZGlyZWN0aW9uKXtcclxuICAgICAgICAgICAgY2FzZSBQbGF5ZXJfZW51bXMuRkFDSU5HX1VQOlxyXG4gICAgICAgICAgICAgICAgZGlyID0gbmV3IFZlYzIoMCwgLTEpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgUGxheWVyX2VudW1zLkZBQ0lOR19ET1dOOlxyXG4gICAgICAgICAgICAgICAgZGlyID0gbmV3IFZlYzIoMCwgMSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBQbGF5ZXJfZW51bXMuRkFDSU5HX0xFRlQ6XHJcbiAgICAgICAgICAgICAgICBkaXIgPSBuZXcgVmVjMigtMSwgMCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBQbGF5ZXJfZW51bXMuRkFDSU5HX1JJR0hUOlxyXG4gICAgICAgICAgICAgICAgZGlyID0gbmV3IFZlYzIoMSwgMCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgc3dpdGNoKHRhcmdldC5pbWFnZUlkKXtcclxuICAgICAgICAgICAgY2FzZSBcInJvY2tfUFwiOlxyXG4gICAgICAgICAgICBjYXNlIFwicm9ja19TXCI6XHJcbiAgICAgICAgICAgICAgICBpZihkZXN0LngrZGlyLng8MiB8fCBkZXN0LnkrZGlyLnk8MiB8fCBkZXN0LngrZGlyLng+MTcgfHwgZGVzdC55K2Rpci55PjE3IHx8dGhpcy5nYW1lYm9hcmRbZGVzdC54K2Rpci54XVtkZXN0LnkrZGlyLnldICE9IG51bGwpIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgZGVzdC5hZGQoZGlyKTtcclxuICAgICAgICAgICAgY2FzZSBcInJvY2tfTVwiOlxyXG4gICAgICAgICAgICAgICAgaWYoZGVzdC54K2Rpci54PDIgfHwgZGVzdC55K2Rpci55PDIgfHwgZGVzdC54K2Rpci54PjE3IHx8IGRlc3QueStkaXIueT4xNyB8fCB0aGlzLmdhbWVib2FyZFtkZXN0LngrZGlyLnhdW2Rlc3QueStkaXIueV0gIT0gbnVsbCkgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBkZXN0LmFkZChkaXIpO1xyXG4gICAgICAgICAgICBjYXNlIFwicm9ja19MXCI6XHJcbiAgICAgICAgICAgICAgICBpZihkZXN0LngrZGlyLng8MiB8fCBkZXN0LnkrZGlyLnk8MiB8fCBkZXN0LngrZGlyLng+MTcgfHwgZGVzdC55K2Rpci55PjE3IHx8IHRoaXMuZ2FtZWJvYXJkW2Rlc3QueCtkaXIueF1bZGVzdC55K2Rpci55XSAhPSBudWxsKSBicmVhaztcclxuICAgICAgICAgICAgICAgIGRlc3QuYWRkKGRpcik7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXQucG9zaXRpb24uc2V0KGRlc3QueCoxNiArIDgsIGRlc3QueSoxNiArIDgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5nYW1lYm9hcmRbdGFyZ2V0cG9zWF1bdGFyZ2V0cG9zWV0gPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5nYW1lYm9hcmRbZGVzdC54XVtkZXN0LnldID0gdGFyZ2V0O1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJ3aGlybHdpbmRcIjpcclxuICAgICAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgICAgICB0aGlzLnBsYXllci50d2VlbnMuYWRkKFwiZmx5XCIsIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGFydERlbGF5OiAwLFxyXG4gICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uOiA1MDAsXHJcbiAgICAgICAgICAgICAgICAgICAgZWZmZWN0czogW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eTogdGhpcy5wbGF5ZXIucG9zaXRpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogdGhpcy5wbGF5ZXIucG9zaXRpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IGRlc3QsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlYXNlOiBFYXNlRnVuY3Rpb25UeXBlLklOX09VVF9RVUFEXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBdXHJcbiAgICAgICAgICAgICAgICB9KTsqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5nYW1lYm9hcmRbdGFyZ2V0cG9zWF1bdGFyZ2V0cG9zWV0gPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0LmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2tpbGxVc2VkWzFdID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBpZihkZXN0LngrZGlyLnNjYWxlZCgzKS54ID49IDIgJiYgZGVzdC55K2Rpci5zY2FsZWQoMykueSA+PSAyICYmIGRlc3QueCtkaXIuc2NhbGVkKDMpLnggPD0gMTcgJiYgZGVzdC55K2Rpci5zY2FsZWQoMykueSA8PSAxNykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmdhbWVib2FyZFtkZXN0LngrZGlyLnNjYWxlZCgzKS54XVtkZXN0LnkrZGlyLnNjYWxlZCgzKS55XSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vZGVzdC5hZGQoZGlyLnNjYWxlZCgzKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vdGhpcy5wbGF5ZXIudHdlZW5zLnBsYXkoXCJmbHlcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGk8MzsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXN0LmFkZChkaXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0dGVyLmZpcmVFdmVudChDVENldmVudC5QTEFZRVJfTU9WRV9SRVFVRVNULCB7XCJuZXh0XCI6IGRlc3R9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYoZGVzdC54K2Rpci5zY2FsZWQoMikueCA+PSAyICYmIGRlc3QueStkaXIuc2NhbGVkKDIpLnkgPj0gMiAmJiBkZXN0LngrZGlyLnNjYWxlZCgyKS54IDw9IDE3ICYmIGRlc3QueStkaXIuc2NhbGVkKDIpLnkgPD0gMTcpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5nYW1lYm9hcmRbZGVzdC54K2Rpci5zY2FsZWQoMikueF1bZGVzdC55K2Rpci5zY2FsZWQoMikueV0gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2Rlc3QuYWRkKGRpci5zY2FsZWQoMikpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3RoaXMucGxheWVyLnR3ZWVucy5wbGF5KFwiZmx5XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpPDI7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVzdC5hZGQoZGlyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdHRlci5maXJlRXZlbnQoQ1RDZXZlbnQuUExBWUVSX01PVkVfUkVRVUVTVCwge1wibmV4dFwiOiBkZXN0fSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcImJ1YmJsZVwiOlxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJlbWJlclwiOlxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJpY2VfY3ViZVwiOlxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvLyBDVEMgVE9ETzogaWYgbGV2ZWwtZW5kIHBvcnRhbCBpcyBhIHNwcml0ZSwgdGhlbiByaWdodCBoZXJlIHlvdSBjb3VsZCBtYWtlIHRoaXMucG9ydGFsIChhIFNwcml0ZSBmaWVsZCkgYW5kIHRlc3QgdGhpcy5wbGF5ZXIucG9zaXRpb24gPT09IHRoaXMucG9ydGFsLnBvc2l0aW9uIHRvIGZpcmUgTEVWRUxfRU5EIGV2ZW50LiBJbiB0aGlzIGNhc2UgeW91IGNvdWxkIHJlZmVyIHRvIHRoZSBmb2xsb3dpbmcgdG8gaW5pdGlhbGl6ZSB0aGUgcG9ydGFsIChhZGQgdGhpcyBjb2RlIGluIGl0cyBvd24gZnVuY3Rpb24gb3IgbWF5YmUgcmlnaHQgYXQgdGhlIGVuZCBvZiBpbml0aWFsaXplUGxheWVyIGZ1bmN0aW9uPyk6XHJcbiAgICAgICAgLypcclxuICAgICAgICB0aGlzLnBvcnRhbCA9IHRoaXMuYWRkLnNwcml0ZShcInBvcnRhbFwiLCBcInByaW1hcnlcIik7ICoqSEFWRSBUTyBMT0FEIFBPUlRBTCBBUyBJTUFHRSBJTiBMT0FEU0NFTkUgRlVOQ1RJT05cclxuICAgICAgICB0aGlzLnBsYXllci5wb3NpdGlvbi5zZXQoMyoxNiArIDgsIDMqMTYgKyA4KTsgKipDSEFOR0UgVEhFIDNzIFRPIEJFIFNPTUUgT1RIRVIgVElMRSBQT1NJVElPTlxyXG4gICAgICAgIHRoaXMucG9ydGFsLmFkZFBoeXNpY3MobmV3IEFBQkIoVmVjMi5aRVJPLCBuZXcgVmVjMig4LCA4KSkpO1xyXG4gICAgICAgIHRoaXMucG9ydGFsLmFkZEFJKEVsZW1lbnRDb250cm9sbGVyLCB7fSk7XHJcblxyXG4gICAgICAgIGlmIHRoZSBzcHJpdGUgaXMgYW5pbWF0ZWQgdGhlbiB5b3UncmUgb24geW91ciBvd24gdGJoIGxvbCwgdGhpcyBzaG91bGQgd29yayBmb3IgYSBub24tYW5pbWF0ZWQgc3ByaXRlIGkgaG9wZVxyXG4gICAgICAgICovXHJcblxyXG5cclxuICAgIGluaXRpYWxpemVQbGF5ZXIoKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5wbGF5ZXIgPSB0aGlzLmFkZC5hbmltYXRlZFNwcml0ZShcImdvZFwiLCBcInByaW1hcnlcIik7XHJcbiAgICAgICAgdGhpcy5wbGF5ZXIuYW5pbWF0aW9uLnBsYXkoXCJpZGxlXCIpO1xyXG4gICAgICAgIHRoaXMucGxheWVyLnBvc2l0aW9uLnNldCgzKjE2ICsgOCwgMyoxNiArIDgpO1xyXG4gICAgICAgIC8vIENUQyBUT0RPOiByZW1vdmUgdGhpcyB0b2RvLCBqdXN0IG5vdGUgdGhhdCBpIGRpZCBub3QgaW5jbHVkZSBwbGF5ZXIgc3ByaXRlIGluIHRoZSBnYW1lYm9hcmQgYXJyYXkgYmVjYXVzZSB0aGF0cyB0b28gbXVjaCB3b3JrIHRvIHVwZGF0ZSBpdCBsb2xcclxuICAgICAgICB0aGlzLnBsYXllci5hZGRQaHlzaWNzKG5ldyBBQUJCKFZlYzIuWkVSTywgbmV3IFZlYzIoOCwgOCkpKTtcclxuICAgICAgICB0aGlzLnBsYXllci5hZGRBSShQbGF5ZXJDb250cm9sbGVyLCB7dGlsZW1hcDogXCJNYWluXCJ9KTtcclxuICAgIH1cclxuXHJcbiAgICBpbml0aWFsaXplR2FtZWJvYXJkKCk6IHZvaWQge1xyXG4gICAgICAgIGxldCBib2FyZERhdGEgPSB0aGlzLmxvYWQuZ2V0T2JqZWN0KFwiYm9hcmRcIik7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBib2FyZERhdGEubnVtRWxlbWVudHM7IGkrKykge1xyXG4gICAgICAgICAgICBsZXQgZWxlbWVudCA9IGJvYXJkRGF0YS5lbGVtZW50c1tpXTtcclxuICAgICAgICAgICAgbGV0IHNwcml0ZSA9IHRoaXMuYWRkLnNwcml0ZShlbGVtZW50LnR5cGUsIFwicHJpbWFyeVwiKTtcclxuICAgICAgICAgICAgc3ByaXRlLnBvc2l0aW9uLnNldChlbGVtZW50LnBvc2l0aW9uWzBdKjE2ICsgOCwgZWxlbWVudC5wb3NpdGlvblsxXSoxNiArIDgpO1xyXG4gICAgICAgICAgICBzcHJpdGUuYWRkUGh5c2ljcyhuZXcgQUFCQihWZWMyLlpFUk8sIG5ldyBWZWMyKDgsIDgpKSk7XHJcbiAgICAgICAgICAgIHNwcml0ZS5hZGRBSShFbGVtZW50Q29udHJvbGxlciwge30pO1xyXG4gICAgICAgICAgICB0aGlzLmdhbWVib2FyZFtlbGVtZW50LnBvc2l0aW9uWzBdXVtlbGVtZW50LnBvc2l0aW9uWzFdXSA9IHNwcml0ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy9zZXQgcG9ydGFsIFxyXG4gICAgICAgIC8vdGhpcy5nYW1lYm9hcmRbdGhpcy5lbmRwb3NpdGlvbi54XVt0aGlzLmVuZHBvc2l0aW9uLnldID0gXHJcbiAgICB9XHJcbn0iLCJpbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vV29sZmllMkQvRGF0YVR5cGVzL1ZlYzJcIjtcclxuaW1wb3J0IHsgVUlFbGVtZW50VHlwZSB9IGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9Ob2Rlcy9VSUVsZW1lbnRzL1VJRWxlbWVudFR5cGVzXCI7XHJcbmltcG9ydCBMYXllciBmcm9tIFwiLi4vLi4vV29sZmllMkQvU2NlbmUvTGF5ZXJcIjtcclxuaW1wb3J0IFNjZW5lIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9TY2VuZS9TY2VuZVwiO1xyXG5pbXBvcnQgQ29sb3IgZnJvbSBcIi4uLy4uL1dvbGZpZTJEL1V0aWxzL0NvbG9yXCI7XHJcbmltcG9ydCBMYWJlbCBmcm9tIFwiLi4vLi4vV29sZmllMkQvTm9kZXMvVUlFbGVtZW50cy9MYWJlbFwiO1xyXG5pbXBvcnQgQnV0dG9uIGZyb20gXCIuLi8uLi9Xb2xmaWUyZC9Ob2Rlcy9VSUVsZW1lbnRzL0J1dHRvblwiO1xyXG5pbXBvcnQgTWFpbk1lbnUgZnJvbSBcIi4vTWFpbk1lbnVcIjtcclxuaW1wb3J0IElucHV0IGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9JbnB1dC9JbnB1dFwiO1xyXG5pbXBvcnQgRWFydGggZnJvbSBcIi4vRWFydGhcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExldmVsU2VsZWN0aW9uIGV4dGVuZHMgU2NlbmUge1xyXG4gICAgcHJpdmF0ZSBsZXZlbHM6IExheWVyO1xyXG5cclxuICAgIGxvYWRTY2VuZSgpe31cclxuXHJcbiAgICBzdGFydFNjZW5lKCl7XHJcbiAgICAgICAgY29uc3QgY2VudGVyID0gdGhpcy52aWV3cG9ydC5nZXRDZW50ZXIoKTtcclxuXHJcbiAgICAgICAgLy8gVGhlIG1haW4gbWVudVxyXG4gICAgICAgIHRoaXMubGV2ZWxzID0gdGhpcy5hZGRVSUxheWVyKFwibGV2ZWxzXCIpO1xyXG5cclxuICAgICAgICBjb25zdCBsZXZlbHNIZWFkZXIgPSA8TGFiZWw+dGhpcy5hZGQudWlFbGVtZW50KFVJRWxlbWVudFR5cGUuTEFCRUwsIFwibGV2ZWxzXCIsIHtwb3NpdGlvbjogbmV3IFZlYzIoY2VudGVyLngsIGNlbnRlci55IC0gMjUwKSwgdGV4dDogXCJMZXZlbCBTZWxlY3RcIn0pO1xyXG4gICAgICAgIGxldmVsc0hlYWRlci5mb250U2l6ZSA9IDUwO1xyXG5cclxuICAgICAgICAvKiBFQVJUSCBST1cgKi9cclxuICAgICAgICBjb25zdCBlYXJ0aEhlYWRlciA9IDxMYWJlbD50aGlzLmFkZC51aUVsZW1lbnQoVUlFbGVtZW50VHlwZS5MQUJFTCwgXCJsZXZlbHNcIiwge3Bvc2l0aW9uOiBuZXcgVmVjMihjZW50ZXIueCAtIDIyNSwgY2VudGVyLnkgLSAxNTApLCB0ZXh0OiBcIkVBUlRIXCJ9KTs7XHJcblxyXG4gICAgICAgIGNvbnN0IGVhcnRoID0gPEJ1dHRvbj50aGlzLmFkZC51aUVsZW1lbnQoVUlFbGVtZW50VHlwZS5CVVRUT04sIFwibGV2ZWxzXCIsIHtwb3NpdGlvbjogbmV3IFZlYzIoY2VudGVyLngsIGNlbnRlci55IC0gMTUwKSwgdGV4dDogXCJQdXp6bGUgU3RhZ2VcIn0pO1xyXG4gICAgICAgIGVhcnRoLnNpemUuc2V0KDIwMCwgNTApO1xyXG4gICAgICAgIGVhcnRoLmJvcmRlcldpZHRoID0gMjtcclxuICAgICAgICBlYXJ0aC5ib3JkZXJDb2xvciA9IENvbG9yLkJMQUNLO1xyXG4gICAgICAgIGVhcnRoLmJhY2tncm91bmRDb2xvciA9IG5ldyBDb2xvcigwLDI1NSwyMTMpO1xyXG4gICAgICAgIGVhcnRoLnRleHRDb2xvciA9IENvbG9yLkJMQUNLO1xyXG4gICAgICAgIGVhcnRoLm9uQ2xpY2tFdmVudElkID0gXCJwbGF5LWVhcnRoXCI7XHJcblxyXG4gICAgICAgIGNvbnN0IGVhcnRoQiA9IDxCdXR0b24+dGhpcy5hZGQudWlFbGVtZW50KFVJRWxlbWVudFR5cGUuQlVUVE9OLCBcImxldmVsc1wiLCB7cG9zaXRpb246IG5ldyBWZWMyKGNlbnRlci54ICsgMjUwLCBjZW50ZXIueSAtIDE1MCksIHRleHQ6IFwiQm9zcyBTdGFnZVwifSk7XHJcbiAgICAgICAgZWFydGhCLmNsb25lKGVhcnRoLCBcInBsYXktZWFydGgtYm9zc1wiKTtcclxuXHJcbiAgICAgICAgLyogV0lORCBST1cgKi9cclxuICAgICAgICBjb25zdCB3aW5kSGVhZGVyID0gPExhYmVsPnRoaXMuYWRkLnVpRWxlbWVudChVSUVsZW1lbnRUeXBlLkxBQkVMLCBcImxldmVsc1wiLCB7cG9zaXRpb246IG5ldyBWZWMyKGNlbnRlci54IC0gMjI1LCBjZW50ZXIueSAtIDc1KSwgdGV4dDogXCJXSU5EXCJ9KTs7XHJcblxyXG4gICAgICAgIGNvbnN0IHdpbmQgPSA8QnV0dG9uPnRoaXMuYWRkLnVpRWxlbWVudChVSUVsZW1lbnRUeXBlLkJVVFRPTiwgXCJsZXZlbHNcIiwge3Bvc2l0aW9uOiBuZXcgVmVjMihjZW50ZXIueCwgY2VudGVyLnkgLSA3NSksIHRleHQ6IFwiUHV6emxlIFN0YWdlXCJ9KTtcclxuICAgICAgICB3aW5kLmNsb25lKGVhcnRoLCBcInBsYXktd2luZFwiKTtcclxuXHJcbiAgICAgICAgY29uc3Qgd2luZEIgPSA8QnV0dG9uPnRoaXMuYWRkLnVpRWxlbWVudChVSUVsZW1lbnRUeXBlLkJVVFRPTiwgXCJsZXZlbHNcIiwge3Bvc2l0aW9uOiBuZXcgVmVjMihjZW50ZXIueCArIDI1MCwgY2VudGVyLnkgLSA3NSksIHRleHQ6IFwiQm9zcyBTdGFnZVwifSk7XHJcbiAgICAgICAgd2luZEIuY2xvbmUoZWFydGgsIFwicGxheS13aW5kLWJvc3NcIik7XHJcblxyXG4gICAgICAgIC8qIFdBVEVSIFJPVyAqL1xyXG4gICAgICAgIGNvbnN0IHdhdGVySGVhZGVyID0gPExhYmVsPnRoaXMuYWRkLnVpRWxlbWVudChVSUVsZW1lbnRUeXBlLkxBQkVMLCBcImxldmVsc1wiLCB7cG9zaXRpb246IG5ldyBWZWMyKGNlbnRlci54IC0gMjI1LCBjZW50ZXIueSksIHRleHQ6IFwiV0FURVJcIn0pOztcclxuXHJcbiAgICAgICAgY29uc3Qgd2F0ZXIgPSA8QnV0dG9uPnRoaXMuYWRkLnVpRWxlbWVudChVSUVsZW1lbnRUeXBlLkJVVFRPTiwgXCJsZXZlbHNcIiwge3Bvc2l0aW9uOiBuZXcgVmVjMihjZW50ZXIueCwgY2VudGVyLnkpLCB0ZXh0OiBcIlB1enpsZSBTdGFnZVwifSk7XHJcbiAgICAgICAgd2F0ZXIuY2xvbmUoZWFydGgsIFwicGxheS13YXRlclwiKTtcclxuXHJcbiAgICAgICAgY29uc3Qgd2F0ZXJCID0gPEJ1dHRvbj50aGlzLmFkZC51aUVsZW1lbnQoVUlFbGVtZW50VHlwZS5CVVRUT04sIFwibGV2ZWxzXCIsIHtwb3NpdGlvbjogbmV3IFZlYzIoY2VudGVyLnggKyAyNTAsIGNlbnRlci55KSwgdGV4dDogXCJCb3NzIFN0YWdlXCJ9KTtcclxuICAgICAgICB3YXRlckIuY2xvbmUoZWFydGgsIFwicGxheS13YXRlci1ib3NzXCIpO1xyXG5cclxuICAgICAgICAvKiBGSVJFIFJPVyAqL1xyXG4gICAgICAgIGNvbnN0IGZpcmVIZWFkZXIgPSA8TGFiZWw+dGhpcy5hZGQudWlFbGVtZW50KFVJRWxlbWVudFR5cGUuTEFCRUwsIFwibGV2ZWxzXCIsIHtwb3NpdGlvbjogbmV3IFZlYzIoY2VudGVyLnggLSAyMjUsIGNlbnRlci55ICsgNzUpLCB0ZXh0OiBcIkZJUkVcIn0pOztcclxuXHJcbiAgICAgICAgY29uc3QgZmlyZSA9IDxCdXR0b24+dGhpcy5hZGQudWlFbGVtZW50KFVJRWxlbWVudFR5cGUuQlVUVE9OLCBcImxldmVsc1wiLCB7cG9zaXRpb246IG5ldyBWZWMyKGNlbnRlci54LCBjZW50ZXIueSArIDc1KSwgdGV4dDogXCJQdXp6bGUgU3RhZ2VcIn0pO1xyXG4gICAgICAgIGZpcmUuY2xvbmUoZWFydGgsIFwicGxheS1maXJlXCIpO1xyXG5cclxuICAgICAgICBjb25zdCBmaXJlQiA9IDxCdXR0b24+dGhpcy5hZGQudWlFbGVtZW50KFVJRWxlbWVudFR5cGUuQlVUVE9OLCBcImxldmVsc1wiLCB7cG9zaXRpb246IG5ldyBWZWMyKGNlbnRlci54ICsgMjUwLCBjZW50ZXIueSArIDc1KSwgdGV4dDogXCJCb3NzIFN0YWdlXCJ9KTtcclxuICAgICAgICBmaXJlQi5jbG9uZShlYXJ0aCwgXCJwbGF5LWZpcmUtYm9zc1wiKTtcclxuXHJcbiAgICAgICAgLyogSUNFIFJPVyAqL1xyXG4gICAgICAgIGNvbnN0IGljZUhlYWRlciA9IDxMYWJlbD50aGlzLmFkZC51aUVsZW1lbnQoVUlFbGVtZW50VHlwZS5MQUJFTCwgXCJsZXZlbHNcIiwge3Bvc2l0aW9uOiBuZXcgVmVjMihjZW50ZXIueCAtIDIyNSwgY2VudGVyLnkgKyAxNTApLCB0ZXh0OiBcIklDRVwifSk7O1xyXG5cclxuICAgICAgICBjb25zdCBpY2UgPSA8QnV0dG9uPnRoaXMuYWRkLnVpRWxlbWVudChVSUVsZW1lbnRUeXBlLkJVVFRPTiwgXCJsZXZlbHNcIiwge3Bvc2l0aW9uOiBuZXcgVmVjMihjZW50ZXIueCwgY2VudGVyLnkgKyAxNTApLCB0ZXh0OiBcIlB1enpsZSBTdGFnZVwifSk7XHJcbiAgICAgICAgaWNlLmNsb25lKGVhcnRoLCBcInBsYXktaWNlXCIpO1xyXG5cclxuICAgICAgICBjb25zdCBpY2VCID0gPEJ1dHRvbj50aGlzLmFkZC51aUVsZW1lbnQoVUlFbGVtZW50VHlwZS5CVVRUT04sIFwibGV2ZWxzXCIsIHtwb3NpdGlvbjogbmV3IFZlYzIoY2VudGVyLnggKyAyNTAsIGNlbnRlci55ICsgMTUwKSwgdGV4dDogXCJCb3NzIFN0YWdlXCJ9KTtcclxuICAgICAgICBpY2VCLmNsb25lKGVhcnRoLCBcInBsYXktaWNlLWJvc3NcIik7XHJcblxyXG4gICAgICAgIC8qIEJBQ0sgQlVUVE9OICovXHJcbiAgICAgICAgY29uc3QgYmFjayA9IDxCdXR0b24+dGhpcy5hZGQudWlFbGVtZW50KFVJRWxlbWVudFR5cGUuQlVUVE9OLCBcImxldmVsc1wiLCB7cG9zaXRpb246IG5ldyBWZWMyKGNlbnRlci54LCBjZW50ZXIueSArIDMwMCksIHRleHQ6IFwiQmFja1wifSk7XHJcbiAgICAgICAgYmFjay5jbG9uZShlYXJ0aCwgXCJiYWNrXCIpO1xyXG5cclxuICAgICAgICB0aGlzLnJlY2VpdmVyLnN1YnNjcmliZShcInBsYXktZWFydGhcIik7XHJcbiAgICAgICAgdGhpcy5yZWNlaXZlci5zdWJzY3JpYmUoXCJiYWNrXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIHVwZGF0ZVNjZW5lKCl7XHJcbiAgICAgICAgLy8gQ1RDIFRPRE86IEFERCBUSEUgQ0hFQVRTXHJcbiAgICAgICAgaWYgKElucHV0LmlzS2V5SnVzdFByZXNzZWQoXCJ5XCIpKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiQ0hFQVQ6IFVOTE9DSyBBTEwgTEVWRUxTXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoSW5wdXQuaXNLZXlKdXN0UHJlc3NlZChcInVcIikpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJDSEVBVDogVU5MT0NLIEFMTCBFTEVNRU5UQUwgU0tJTFNcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHdoaWxlKHRoaXMucmVjZWl2ZXIuaGFzTmV4dEV2ZW50KCkpe1xyXG4gICAgICAgICAgICBsZXQgZXZlbnQgPSB0aGlzLnJlY2VpdmVyLmdldE5leHRFdmVudCgpO1xyXG5cclxuICAgICAgICAgICAgY29uc29sZS5sb2coZXZlbnQpO1xyXG5cclxuICAgICAgICAgICAgaWYoZXZlbnQudHlwZSA9PT0gXCJwbGF5LWVhcnRoXCIpe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zY2VuZU1hbmFnZXIuY2hhbmdlVG9TY2VuZShFYXJ0aCwge30pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBDVEMgVE9ETzogQUREIFRIRSBPVEhFUiBMRVZFTFMgQU5EIFNVQlNDUklCRSBUTyBUSEUgRVZFTlRTXHJcblxyXG4gICAgICAgICAgICBpZihldmVudC50eXBlID09PSBcImJhY2tcIil7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNjZW5lTWFuYWdlci5jaGFuZ2VUb1NjZW5lKE1haW5NZW51LCB7fSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0iLCJpbXBvcnQgVmVjMiBmcm9tIFwiLi4vLi4vV29sZmllMkQvRGF0YVR5cGVzL1ZlYzJcIjtcclxuaW1wb3J0IHsgVUlFbGVtZW50VHlwZSB9IGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9Ob2Rlcy9VSUVsZW1lbnRzL1VJRWxlbWVudFR5cGVzXCI7XHJcbmltcG9ydCBMYXllciBmcm9tIFwiLi4vLi4vV29sZmllMkQvU2NlbmUvTGF5ZXJcIjtcclxuaW1wb3J0IFNjZW5lIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9TY2VuZS9TY2VuZVwiO1xyXG5pbXBvcnQgQ29sb3IgZnJvbSBcIi4uLy4uL1dvbGZpZTJEL1V0aWxzL0NvbG9yXCI7XHJcbmltcG9ydCBMYWJlbCBmcm9tIFwiLi4vLi4vV29sZmllMkQvTm9kZXMvVUlFbGVtZW50cy9MYWJlbFwiO1xyXG5pbXBvcnQgQnV0dG9uIGZyb20gXCIuLi8uLi9Xb2xmaWUyZC9Ob2Rlcy9VSUVsZW1lbnRzL0J1dHRvblwiO1xyXG5pbXBvcnQgTGV2ZWxTZWxlY3Rpb24gZnJvbSBcIi4vTGV2ZWxTZWxlY3Rpb25cIjtcclxuaW1wb3J0IElucHV0IGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9JbnB1dC9JbnB1dFwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWFpbk1lbnUgZXh0ZW5kcyBTY2VuZSB7XHJcbiAgICAvLyBMYXllcnMsIGZvciBtdWx0aXBsZSBtYWluIG1lbnUgc2NyZWVuc1xyXG4gICAgcHJpdmF0ZSBtYWluTWVudTogTGF5ZXI7XHJcbiAgICBwcml2YXRlIGFib3V0OiBMYXllcjtcclxuICAgIHByaXZhdGUgY29udHJvbDogTGF5ZXI7XHJcbiAgICBwcml2YXRlIGNyZWRpdHM6IExheWVyO1xyXG5cclxuICAgIGxvYWRTY2VuZSgpe31cclxuXHJcbiAgICBzdGFydFNjZW5lKCl7XHJcbiAgICAgICAgY29uc3QgY2VudGVyID0gdGhpcy52aWV3cG9ydC5nZXRDZW50ZXIoKTtcclxuXHJcbiAgICAgICAgLy8gVGhlIG1haW4gbWVudVxyXG4gICAgICAgIHRoaXMubWFpbk1lbnUgPSB0aGlzLmFkZFVJTGF5ZXIoXCJtYWluTWVudVwiKTtcclxuXHJcbiAgICAgICAgY29uc3QgbWFpbk1lbnVIZWFkZXIgPSA8TGFiZWw+dGhpcy5hZGQudWlFbGVtZW50KFVJRWxlbWVudFR5cGUuTEFCRUwsIFwibWFpbk1lbnVcIiwge3Bvc2l0aW9uOiBuZXcgVmVjMihjZW50ZXIueCwgY2VudGVyLnkgLSAyNTApLCB0ZXh0OiBcIkNhbG0gVGhlIENhbGFtaXRpZXNcIn0pO1xyXG4gICAgICAgIG1haW5NZW51SGVhZGVyLnRleHRDb2xvciA9IENvbG9yLkJMQUNLO1xyXG4gICAgICAgIG1haW5NZW51SGVhZGVyLmZvbnRTaXplID0gNTA7XHJcblxyXG4gICAgICAgIC8vIEFkZCBwbGF5IGJ1dHRvbiwgYW5kIGdpdmUgaXQgYW4gZXZlbnQgdG8gZW1pdCBvbiBwcmVzc1xyXG4gICAgICAgIGNvbnN0IHBsYXkgPSA8QnV0dG9uPnRoaXMuYWRkLnVpRWxlbWVudChVSUVsZW1lbnRUeXBlLkJVVFRPTiwgXCJtYWluTWVudVwiLCB7cG9zaXRpb246IG5ldyBWZWMyKGNlbnRlci54LCBjZW50ZXIueSAtIDEwMCksIHRleHQ6IFwiU3RhcnRcIn0pO1xyXG4gICAgICAgIHBsYXkuc2l6ZS5zZXQoMjAwLCA1MCk7XHJcbiAgICAgICAgcGxheS5ib3JkZXJXaWR0aCA9IDI7XHJcbiAgICAgICAgcGxheS5ib3JkZXJDb2xvciA9IENvbG9yLkJMQUNLO1xyXG4gICAgICAgIHBsYXkuYmFja2dyb3VuZENvbG9yID0gbmV3IENvbG9yKDAsMjU1LDIxMyk7XHJcbiAgICAgICAgcGxheS50ZXh0Q29sb3IgPSBDb2xvci5CTEFDSztcclxuICAgICAgICBwbGF5Lm9uQ2xpY2tFdmVudElkID0gXCJwbGF5XCI7XHJcblxyXG4gICAgICAgIC8vIEFkZCBhYm91dCBidXR0b25cclxuICAgICAgICBjb25zdCBhYm91dCA9IDxCdXR0b24+dGhpcy5hZGQudWlFbGVtZW50KFVJRWxlbWVudFR5cGUuQlVUVE9OLCBcIm1haW5NZW51XCIsIHtwb3NpdGlvbjogbmV3IFZlYzIoY2VudGVyLngsIGNlbnRlci55ICsgMTAwKSwgdGV4dDogXCJIZWxwXCJ9KTtcclxuICAgICAgICBhYm91dC5zaXplLnNldCgyMDAsIDUwKTtcclxuICAgICAgICBhYm91dC5ib3JkZXJXaWR0aCA9IDI7XHJcbiAgICAgICAgYWJvdXQuYm9yZGVyQ29sb3IgPSBDb2xvci5CTEFDSztcclxuICAgICAgICBhYm91dC5iYWNrZ3JvdW5kQ29sb3IgPSBuZXcgQ29sb3IoMCwyNTUsMjEzKTtcclxuICAgICAgICBhYm91dC50ZXh0Q29sb3IgPSBDb2xvci5CTEFDSztcclxuICAgICAgICBhYm91dC5vbkNsaWNrRXZlbnRJZCA9IFwiYWJvdXRcIjtcclxuXHJcbiAgICAgICAgLy8gQWRkIGNvbnRyb2xzIGJ1dHRvblxyXG4gICAgICAgIGNvbnN0IGNvbnRyb2wgPSA8QnV0dG9uPnRoaXMuYWRkLnVpRWxlbWVudChVSUVsZW1lbnRUeXBlLkJVVFRPTiwgXCJtYWluTWVudVwiLCB7cG9zaXRpb246IG5ldyBWZWMyKGNlbnRlci54LCBjZW50ZXIueSksIHRleHQ6IFwiQ29udHJvbHNcIn0pO1xyXG4gICAgICAgIGNvbnRyb2wuc2l6ZS5zZXQoMjAwLCA1MCk7XHJcbiAgICAgICAgY29udHJvbC5ib3JkZXJXaWR0aCA9IDI7XHJcbiAgICAgICAgY29udHJvbC5ib3JkZXJDb2xvciA9IENvbG9yLkJMQUNLO1xyXG4gICAgICAgIGNvbnRyb2wuYmFja2dyb3VuZENvbG9yID0gbmV3IENvbG9yKDAsMjU1LDIxMyk7XHJcbiAgICAgICAgY29udHJvbC50ZXh0Q29sb3IgPSBDb2xvci5CTEFDSztcclxuICAgICAgICBjb250cm9sLm9uQ2xpY2tFdmVudElkID0gXCJjb250cm9sXCI7XHJcblxyXG4gICAgICAgIGNvbnN0IGNyZWRpdHMgPSA8QnV0dG9uPnRoaXMuYWRkLnVpRWxlbWVudChVSUVsZW1lbnRUeXBlLkJVVFRPTiwgXCJtYWluTWVudVwiLCB7cG9zaXRpb246IG5ldyBWZWMyKGNlbnRlci54LCBjZW50ZXIueSArIDIwMCksIHRleHQ6IFwiQ3JlZGl0c1wifSk7XHJcbiAgICAgICAgY3JlZGl0cy5zaXplLnNldCgyMDAsIDUwKTtcclxuICAgICAgICBjcmVkaXRzLmJvcmRlcldpZHRoID0gMjtcclxuICAgICAgICBjcmVkaXRzLmJvcmRlckNvbG9yID0gQ29sb3IuQkxBQ0s7XHJcbiAgICAgICAgY3JlZGl0cy5iYWNrZ3JvdW5kQ29sb3IgPSBuZXcgQ29sb3IoMCwyNTUsMjEzKTtcclxuICAgICAgICBjcmVkaXRzLnRleHRDb2xvciA9IENvbG9yLkJMQUNLO1xyXG4gICAgICAgIGNyZWRpdHMub25DbGlja0V2ZW50SWQgPSBcImNyZWRpdHNcIjtcclxuXHJcbiAgICAgICAgLyogIyMjIyMjIyMjIyBBQk9VVCBTQ1JFRU4gIyMjIyMjIyMjIyAqL1xyXG4gICAgICAgIHRoaXMuYWJvdXQgPSB0aGlzLmFkZFVJTGF5ZXIoXCJhYm91dFwiKTtcclxuICAgICAgICB0aGlzLmFib3V0LnNldEhpZGRlbih0cnVlKTtcclxuXHJcbiAgICAgICAgY29uc3QgYWJvdXRIZWFkZXIgPSA8TGFiZWw+dGhpcy5hZGQudWlFbGVtZW50KFVJRWxlbWVudFR5cGUuTEFCRUwsIFwiYWJvdXRcIiwge3Bvc2l0aW9uOiBuZXcgVmVjMihjZW50ZXIueCwgY2VudGVyLnkgLSAyNTApLCB0ZXh0OiBcIkhlbHBcIn0pO1xyXG4gICAgICAgIGFib3V0SGVhZGVyLnRleHRDb2xvciA9IENvbG9yLkJMQUNLO1xyXG4gICAgICAgIGFib3V0SGVhZGVyLmZvbnRTaXplID0gNTA7XHJcblxyXG4gICAgICAgIGNvbnN0IHRleHQxID0gXCJZb3UgYXJlIGEgeW91bmcgZ29kIHdobyBqdXN0IGZpbmlzaGVkIGNyZWF0aW5nIHlvdXIgZmlyc3RcIjtcclxuICAgICAgICBjb25zdCB0ZXh0MiA9IFwid29ybGQuIFlvdSBmZWVsIHRpcmVkIGFmdGVyIG1ha2luZyB0aGUgd29ybGQgc28geW91IGRlY2lkZWRcIjtcclxuICAgICAgICBjb25zdCB0ZXh0MyA9IFwidG8gdGFrZSBhIG5hcC4gVGhlIG5hcCB0dXJucyBpbnRvIGEgbWlsbGVubml1bSBsb25nIHNsdW1iZXIuXCI7XHJcbiAgICAgICAgY29uc3QgdGV4dDQgPSBcIldoaWxlIHlvdSB3ZXJlIGFzbGVlcCwgeW91ciBwb3dlcnMgbGVha2VkIG91dCBmcm9tIHlvdXJcIjtcclxuICAgICAgICBjb25zdCB0ZXh0NSA9IFwiYm9keSBpbnRvIHlvdXIgd29ybGQuIFRoZXkgdG9vayB0aGUgc2hhcGUgb2YgdmlvbGVudCBzcGlyaXRzLFwiO1xyXG4gICAgICAgIGNvbnN0IHRleHQ2ID0gXCJjcmVhdGluZyBhbGwga2luZHMgb2YgbmF0dXJhbCBkaXNhc3RlcnMgdGhyb3VnaG91dCB5b3VyIHdvcmxkLlwiXHJcbiAgICAgICAgY29uc3QgdGV4dDcgPSBcIkNIRUFUUyAoVXNlIG9uIE1haW4gTWVudS9MZXZlbCBTZWxlY3QpOlwiO1xyXG4gICAgICAgIGNvbnN0IHRleHQ4ID0gXCJZIC0gVW5sb2NrIEFsbCBMZXZlbHNcIjtcclxuICAgICAgICBjb25zdCB0ZXh0OSA9IFwiVSAtIFVubG9jayBBbGwgRWxlbWVudGFsIFNraWxsc1wiO1xyXG5cclxuICAgICAgICBjb25zdCBsaW5lMSA9IDxMYWJlbD50aGlzLmFkZC51aUVsZW1lbnQoVUlFbGVtZW50VHlwZS5MQUJFTCwgXCJhYm91dFwiLCB7cG9zaXRpb246IG5ldyBWZWMyKGNlbnRlci54LCBjZW50ZXIueSAtIDE1MCksIHRleHQ6IHRleHQxfSk7XHJcbiAgICAgICAgY29uc3QgbGluZTIgPSA8TGFiZWw+dGhpcy5hZGQudWlFbGVtZW50KFVJRWxlbWVudFR5cGUuTEFCRUwsIFwiYWJvdXRcIiwge3Bvc2l0aW9uOiBuZXcgVmVjMihjZW50ZXIueCwgY2VudGVyLnkgLSAxMDApLCB0ZXh0OiB0ZXh0Mn0pO1xyXG4gICAgICAgIGNvbnN0IGxpbmUzID0gPExhYmVsPnRoaXMuYWRkLnVpRWxlbWVudChVSUVsZW1lbnRUeXBlLkxBQkVMLCBcImFib3V0XCIsIHtwb3NpdGlvbjogbmV3IFZlYzIoY2VudGVyLngsIGNlbnRlci55IC0gNTApLCB0ZXh0OiB0ZXh0M30pO1xyXG4gICAgICAgIGNvbnN0IGxpbmU0ID0gPExhYmVsPnRoaXMuYWRkLnVpRWxlbWVudChVSUVsZW1lbnRUeXBlLkxBQkVMLCBcImFib3V0XCIsIHtwb3NpdGlvbjogbmV3IFZlYzIoY2VudGVyLngsIGNlbnRlci55KSwgdGV4dDogdGV4dDR9KTtcclxuICAgICAgICBjb25zdCBsaW5lNSA9IDxMYWJlbD50aGlzLmFkZC51aUVsZW1lbnQoVUlFbGVtZW50VHlwZS5MQUJFTCwgXCJhYm91dFwiLCB7cG9zaXRpb246IG5ldyBWZWMyKGNlbnRlci54LCBjZW50ZXIueSArIDUwKSwgdGV4dDogdGV4dDV9KTtcclxuICAgICAgICBjb25zdCBsaW5lNiA9IDxMYWJlbD50aGlzLmFkZC51aUVsZW1lbnQoVUlFbGVtZW50VHlwZS5MQUJFTCwgXCJhYm91dFwiLCB7cG9zaXRpb246IG5ldyBWZWMyKGNlbnRlci54LCBjZW50ZXIueSArIDEwMCksIHRleHQ6IHRleHQ2fSk7XHJcbiAgICAgICAgY29uc3QgbGluZTcgPSA8TGFiZWw+dGhpcy5hZGQudWlFbGVtZW50KFVJRWxlbWVudFR5cGUuTEFCRUwsIFwiYWJvdXRcIiwge3Bvc2l0aW9uOiBuZXcgVmVjMihjZW50ZXIueCAtIDEwMCwgY2VudGVyLnkgKyAxNTApLCB0ZXh0OiB0ZXh0N30pO1xyXG4gICAgICAgIGNvbnN0IGxpbmU4ID0gPExhYmVsPnRoaXMuYWRkLnVpRWxlbWVudChVSUVsZW1lbnRUeXBlLkxBQkVMLCBcImFib3V0XCIsIHtwb3NpdGlvbjogbmV3IFZlYzIoY2VudGVyLnggKyAxNTAsIGNlbnRlci55ICsgMjAwKSwgdGV4dDogdGV4dDh9KTtcclxuICAgICAgICBjb25zdCBsaW5lOSA9IDxMYWJlbD50aGlzLmFkZC51aUVsZW1lbnQoVUlFbGVtZW50VHlwZS5MQUJFTCwgXCJhYm91dFwiLCB7cG9zaXRpb246IG5ldyBWZWMyKGNlbnRlci54ICsgMjAwLCBjZW50ZXIueSArIDI1MCksIHRleHQ6IHRleHQ5fSk7XHJcblxyXG4gICAgICAgIGxpbmUxLnRleHRDb2xvciA9IENvbG9yLkJMQUNLO1xyXG4gICAgICAgIGxpbmUyLnRleHRDb2xvciA9IENvbG9yLkJMQUNLO1xyXG4gICAgICAgIGxpbmUzLnRleHRDb2xvciA9IENvbG9yLkJMQUNLO1xyXG5cclxuICAgICAgICBjb25zdCBhYm91dEJhY2sgPSA8QnV0dG9uPnRoaXMuYWRkLnVpRWxlbWVudChVSUVsZW1lbnRUeXBlLkJVVFRPTiwgXCJhYm91dFwiLCB7cG9zaXRpb246IG5ldyBWZWMyKGNlbnRlci54LCBjZW50ZXIueSArIDMwMCksIHRleHQ6IFwiQmFja1wifSk7XHJcbiAgICAgICAgYWJvdXRCYWNrLnNpemUuc2V0KDIwMCwgNTApO1xyXG4gICAgICAgIGFib3V0QmFjay5ib3JkZXJXaWR0aCA9IDI7XHJcbiAgICAgICAgYWJvdXRCYWNrLmJvcmRlckNvbG9yID0gQ29sb3IuQkxBQ0s7XHJcbiAgICAgICAgYWJvdXRCYWNrLmJhY2tncm91bmRDb2xvciA9IG5ldyBDb2xvcigwLDI1NSwyMTMpO1xyXG4gICAgICAgIGFib3V0QmFjay50ZXh0Q29sb3IgPSBDb2xvci5CTEFDSztcclxuICAgICAgICBhYm91dEJhY2sub25DbGlja0V2ZW50SWQgPSBcIm1lbnVcIjtcclxuXHJcbiAgICAgICAgLyogIyMjIyMjIyMjIyBDT05UUk9MUyBTQ1JFRU4gIyMjIyMjIyMjIyAqL1xyXG4gICAgICAgIHRoaXMuY29udHJvbCA9IHRoaXMuYWRkVUlMYXllcihcImNvbnRyb2xcIik7XHJcbiAgICAgICAgdGhpcy5jb250cm9sLnNldEhpZGRlbih0cnVlKTtcclxuXHJcbiAgICAgICAgY29uc3QgY29udHJvbEhlYWRlciA9IDxMYWJlbD50aGlzLmFkZC51aUVsZW1lbnQoVUlFbGVtZW50VHlwZS5MQUJFTCwgXCJjb250cm9sXCIsIHtwb3NpdGlvbjogbmV3IFZlYzIoY2VudGVyLngsIGNlbnRlci55IC0gMjUwKSwgdGV4dDogXCJDb250cm9sc1wifSk7XHJcbiAgICAgICAgY29udHJvbEhlYWRlci50ZXh0Q29sb3IgPSBDb2xvci5CTEFDSztcclxuICAgICAgICBjb250cm9sSGVhZGVyLmZvbnRTaXplID0gNTA7XHJcblxyXG4gICAgICAgIGNvbnN0IGN0ZXh0MSA9IFwiVyAtIE1vdmUgVXBcIjtcclxuICAgICAgICBjb25zdCBjdGV4dDIgPSBcIkEgLSBNb3ZlIExlZnRcIjtcclxuICAgICAgICBjb25zdCBjdGV4dDMgPSBcIlMgLSBNb3ZlIERvd25cIjtcclxuICAgICAgICBjb25zdCBjdGV4dDQgPSBcIkQgLSBNb3ZlIFJpZ2h0XCI7XHJcbiAgICAgICAgY29uc3QgY3RleHQ1ID0gXCIxLDIsMyw0LDUgLSBTd2l0Y2ggdG8gRWxlbWVudCAxLTVcIjtcclxuICAgICAgICBjb25zdCBjdGV4dDYgPSBcIkogLSBJbnRlcmFjdCBXaXRoIEVsZW1lbnRcIjtcclxuICAgICAgICBjb25zdCBjdGV4dDcgPSBcIksgLSBQbGFjZS9SZW1vdmUgRWxlbWVudFwiO1xyXG4gICAgICAgIGNvbnN0IGN0ZXh0OCA9IFwiRVNDQVBFIC0gUGF1c2VcIjtcclxuXHJcbiAgICAgICAgY29uc3QgY2xpbmUxID0gPExhYmVsPnRoaXMuYWRkLnVpRWxlbWVudChVSUVsZW1lbnRUeXBlLkxBQkVMLCBcImNvbnRyb2xcIiwge3Bvc2l0aW9uOiBuZXcgVmVjMihjZW50ZXIueCwgY2VudGVyLnkgLSAxNTApLCB0ZXh0OiBjdGV4dDF9KTtcclxuICAgICAgICBjb25zdCBjbGluZTIgPSA8TGFiZWw+dGhpcy5hZGQudWlFbGVtZW50KFVJRWxlbWVudFR5cGUuTEFCRUwsIFwiY29udHJvbFwiLCB7cG9zaXRpb246IG5ldyBWZWMyKGNlbnRlci54LCBjZW50ZXIueSAtIDEwMCksIHRleHQ6IGN0ZXh0Mn0pO1xyXG4gICAgICAgIGNvbnN0IGNsaW5lMyA9IDxMYWJlbD50aGlzLmFkZC51aUVsZW1lbnQoVUlFbGVtZW50VHlwZS5MQUJFTCwgXCJjb250cm9sXCIsIHtwb3NpdGlvbjogbmV3IFZlYzIoY2VudGVyLngsIGNlbnRlci55IC0gNTApLCB0ZXh0OiBjdGV4dDN9KTtcclxuICAgICAgICBjb25zdCBjbGluZTQgPSA8TGFiZWw+dGhpcy5hZGQudWlFbGVtZW50KFVJRWxlbWVudFR5cGUuTEFCRUwsIFwiY29udHJvbFwiLCB7cG9zaXRpb246IG5ldyBWZWMyKGNlbnRlci54LCBjZW50ZXIueSksIHRleHQ6IGN0ZXh0NH0pO1xyXG4gICAgICAgIGNvbnN0IGNsaW5lNSA9IDxMYWJlbD50aGlzLmFkZC51aUVsZW1lbnQoVUlFbGVtZW50VHlwZS5MQUJFTCwgXCJjb250cm9sXCIsIHtwb3NpdGlvbjogbmV3IFZlYzIoY2VudGVyLngsIGNlbnRlci55ICsgNTApLCB0ZXh0OiBjdGV4dDV9KTtcclxuICAgICAgICBjb25zdCBjbGluZTYgPSA8TGFiZWw+dGhpcy5hZGQudWlFbGVtZW50KFVJRWxlbWVudFR5cGUuTEFCRUwsIFwiY29udHJvbFwiLCB7cG9zaXRpb246IG5ldyBWZWMyKGNlbnRlci54LCBjZW50ZXIueSArIDEwMCksIHRleHQ6IGN0ZXh0Nn0pO1xyXG4gICAgICAgIGNvbnN0IGNsaW5lNyA9IDxMYWJlbD50aGlzLmFkZC51aUVsZW1lbnQoVUlFbGVtZW50VHlwZS5MQUJFTCwgXCJjb250cm9sXCIsIHtwb3NpdGlvbjogbmV3IFZlYzIoY2VudGVyLngsIGNlbnRlci55ICsgMTUwKSwgdGV4dDogY3RleHQ3fSk7XHJcbiAgICAgICAgY29uc3QgY2xpbmU4ID0gPExhYmVsPnRoaXMuYWRkLnVpRWxlbWVudChVSUVsZW1lbnRUeXBlLkxBQkVMLCBcImNvbnRyb2xcIiwge3Bvc2l0aW9uOiBuZXcgVmVjMihjZW50ZXIueCwgY2VudGVyLnkgKyAyMDApLCB0ZXh0OiBjdGV4dDh9KTtcclxuXHJcbiAgICAgICAgY29uc3QgY29udHJvbEJhY2sgPSA8QnV0dG9uPnRoaXMuYWRkLnVpRWxlbWVudChVSUVsZW1lbnRUeXBlLkJVVFRPTiwgXCJjb250cm9sXCIsIHtwb3NpdGlvbjogbmV3IFZlYzIoY2VudGVyLngsIGNlbnRlci55ICsgMzAwKSwgdGV4dDogXCJCYWNrXCJ9KTtcclxuICAgICAgICBjb250cm9sQmFjay5zaXplLnNldCgyMDAsIDUwKTtcclxuICAgICAgICBjb250cm9sQmFjay5ib3JkZXJXaWR0aCA9IDI7XHJcbiAgICAgICAgY29udHJvbEJhY2suYm9yZGVyQ29sb3IgPSBDb2xvci5CTEFDSztcclxuICAgICAgICBjb250cm9sQmFjay5iYWNrZ3JvdW5kQ29sb3IgPSBuZXcgQ29sb3IoMCwyNTUsMjEzKTtcclxuICAgICAgICBjb250cm9sQmFjay50ZXh0Q29sb3IgPSBDb2xvci5CTEFDSztcclxuICAgICAgICBjb250cm9sQmFjay5vbkNsaWNrRXZlbnRJZCA9IFwibWVudVwiO1xyXG5cclxuICAgICAgICAvKiAjIyMjIyMjIyMjIENSRURJVFMgU0NSRUVOICMjIyMjIyMjIyMgKi9cclxuICAgICAgICB0aGlzLmNyZWRpdHMgPSB0aGlzLmFkZFVJTGF5ZXIoXCJjcmVkaXRzXCIpO1xyXG4gICAgICAgIHRoaXMuY3JlZGl0cy5zZXRIaWRkZW4odHJ1ZSk7XHJcblxyXG4gICAgICAgIGNvbnN0IGNyZWRpdHNIZWFkZXIgPSA8TGFiZWw+dGhpcy5hZGQudWlFbGVtZW50KFVJRWxlbWVudFR5cGUuTEFCRUwsIFwiY3JlZGl0c1wiLCB7cG9zaXRpb246IG5ldyBWZWMyKGNlbnRlci54LCBjZW50ZXIueSAtIDI1MCksIHRleHQ6IFwiQ3JlZGl0c1wifSk7XHJcbiAgICAgICAgY3JlZGl0c0hlYWRlci50ZXh0Q29sb3IgPSBDb2xvci5CTEFDSztcclxuICAgICAgICBjcmVkaXRzSGVhZGVyLmZvbnRTaXplID0gNTA7XHJcblxyXG4gICAgICAgIGNvbnN0IGNydGV4dDEgPSBcIlRoaXMgZ2FtZSB3YXMgbWFkZSBieTpcIjtcclxuICAgICAgICBjb25zdCBjcnRleHQyID0gXCJEYXZpZCBTaWx2ZXJtYW5cIjtcclxuICAgICAgICBjb25zdCBjcnRleHQzID0gXCJXZWkgSGFuZyBIb25nXCI7XHJcbiAgICAgICAgY29uc3QgY3J0ZXh0NCA9IFwiSml3b24gSmFuZ1wiO1xyXG5cclxuICAgICAgICBjb25zdCBjcmxpbmUxID0gPExhYmVsPnRoaXMuYWRkLnVpRWxlbWVudChVSUVsZW1lbnRUeXBlLkxBQkVMLCBcImNyZWRpdHNcIiwge3Bvc2l0aW9uOiBuZXcgVmVjMihjZW50ZXIueCwgY2VudGVyLnkgLSAxMDApLCB0ZXh0OiBjcnRleHQxfSk7XHJcbiAgICAgICAgY29uc3QgY3JsaW5lMiA9IDxMYWJlbD50aGlzLmFkZC51aUVsZW1lbnQoVUlFbGVtZW50VHlwZS5MQUJFTCwgXCJjcmVkaXRzXCIsIHtwb3NpdGlvbjogbmV3IFZlYzIoY2VudGVyLngsIGNlbnRlci55KSwgdGV4dDogY3J0ZXh0Mn0pO1xyXG4gICAgICAgIGNvbnN0IGNybGluZTMgPSA8TGFiZWw+dGhpcy5hZGQudWlFbGVtZW50KFVJRWxlbWVudFR5cGUuTEFCRUwsIFwiY3JlZGl0c1wiLCB7cG9zaXRpb246IG5ldyBWZWMyKGNlbnRlci54LCBjZW50ZXIueSArIDUwKSwgdGV4dDogY3J0ZXh0M30pO1xyXG4gICAgICAgIGNvbnN0IGNybGluZTQgPSA8TGFiZWw+dGhpcy5hZGQudWlFbGVtZW50KFVJRWxlbWVudFR5cGUuTEFCRUwsIFwiY3JlZGl0c1wiLCB7cG9zaXRpb246IG5ldyBWZWMyKGNlbnRlci54LCBjZW50ZXIueSArIDEwMCksIHRleHQ6IGNydGV4dDR9KTtcclxuXHJcbiAgICAgICAgY3JsaW5lMS50ZXh0Q29sb3IgPSBDb2xvci5CTEFDSztcclxuICAgICAgICBjcmxpbmUyLnRleHRDb2xvciA9IENvbG9yLkJMQUNLO1xyXG4gICAgICAgIGNybGluZTMudGV4dENvbG9yID0gQ29sb3IuQkxBQ0s7XHJcbiAgICAgICAgY3JsaW5lNC50ZXh0Q29sb3IgPSBDb2xvci5CTEFDSztcclxuXHJcbiAgICAgICAgY29uc3QgY3JlZGl0c0JhY2sgPSA8QnV0dG9uPnRoaXMuYWRkLnVpRWxlbWVudChVSUVsZW1lbnRUeXBlLkJVVFRPTiwgXCJjcmVkaXRzXCIsIHtwb3NpdGlvbjogbmV3IFZlYzIoY2VudGVyLngsIGNlbnRlci55ICsgMzAwKSwgdGV4dDogXCJCYWNrXCJ9KTtcclxuICAgICAgICBjcmVkaXRzQmFjay5zaXplLnNldCgyMDAsIDUwKTtcclxuICAgICAgICBjcmVkaXRzQmFjay5ib3JkZXJXaWR0aCA9IDI7XHJcbiAgICAgICAgY3JlZGl0c0JhY2suYm9yZGVyQ29sb3IgPSBDb2xvci5CTEFDSztcclxuICAgICAgICBjcmVkaXRzQmFjay5iYWNrZ3JvdW5kQ29sb3IgPSBuZXcgQ29sb3IoMCwyNTUsMjEzKTtcclxuICAgICAgICBjcmVkaXRzQmFjay50ZXh0Q29sb3IgPSBDb2xvci5CTEFDSztcclxuICAgICAgICBjcmVkaXRzQmFjay5vbkNsaWNrRXZlbnRJZCA9IFwibWVudVwiO1xyXG5cclxuICAgICAgICAvLyBTdWJzY3JpYmUgdG8gdGhlIGJ1dHRvbiBldmVudHNcclxuICAgICAgICB0aGlzLnJlY2VpdmVyLnN1YnNjcmliZShcInBsYXlcIik7XHJcbiAgICAgICAgdGhpcy5yZWNlaXZlci5zdWJzY3JpYmUoXCJhYm91dFwiKTtcclxuICAgICAgICB0aGlzLnJlY2VpdmVyLnN1YnNjcmliZShcIm1lbnVcIik7XHJcbiAgICAgICAgdGhpcy5yZWNlaXZlci5zdWJzY3JpYmUoXCJjb250cm9sXCIpO1xyXG4gICAgICAgIHRoaXMucmVjZWl2ZXIuc3Vic2NyaWJlKFwiY3JlZGl0c1wiKTtcclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGVTY2VuZSgpe1xyXG4gICAgICAgIC8vIENUQyBUT0RPOiBBREQgVEhFIENIRUFUU1xyXG4gICAgICAgIGlmIChJbnB1dC5pc0tleUp1c3RQcmVzc2VkKFwieVwiKSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIkNIRUFUOiBVTkxPQ0sgQUxMIExFVkVMU1wiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKElucHV0LmlzS2V5SnVzdFByZXNzZWQoXCJ1XCIpKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiQ0hFQVQ6IFVOTE9DSyBBTEwgRUxFTUVOVEFMIFNLSUxTXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB3aGlsZSh0aGlzLnJlY2VpdmVyLmhhc05leHRFdmVudCgpKXtcclxuICAgICAgICAgICAgbGV0IGV2ZW50ID0gdGhpcy5yZWNlaXZlci5nZXROZXh0RXZlbnQoKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGV2ZW50KTtcclxuXHJcbiAgICAgICAgICAgIGlmKGV2ZW50LnR5cGUgPT09IFwicGxheVwiKXtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2NlbmVNYW5hZ2VyLmNoYW5nZVRvU2NlbmUoTGV2ZWxTZWxlY3Rpb24sIHt9KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYoZXZlbnQudHlwZSA9PT0gXCJhYm91dFwiKXtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWJvdXQuc2V0SGlkZGVuKGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMubWFpbk1lbnUuc2V0SGlkZGVuKHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZihldmVudC50eXBlID09PSBcIm1lbnVcIil7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1haW5NZW51LnNldEhpZGRlbihmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFib3V0LnNldEhpZGRlbih0cnVlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29udHJvbC5zZXRIaWRkZW4odHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNyZWRpdHMuc2V0SGlkZGVuKHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmKGV2ZW50LnR5cGUgPT09IFwiY29udHJvbFwiKXtcclxuICAgICAgICAgICAgICAgIHRoaXMubWFpbk1lbnUuc2V0SGlkZGVuKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb250cm9sLnNldEhpZGRlbihmYWxzZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChldmVudC50eXBlID09PSBcImNyZWRpdHNcIikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tYWluTWVudS5zZXRIaWRkZW4odHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNyZWRpdHMuc2V0SGlkZGVuKGZhbHNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufSIsImltcG9ydCBWZWMyIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9EYXRhVHlwZXMvVmVjMlwiO1xyXG5pbXBvcnQgeyBVSUVsZW1lbnRUeXBlIH0gZnJvbSBcIi4uLy4uL1dvbGZpZTJEL05vZGVzL1VJRWxlbWVudHMvVUlFbGVtZW50VHlwZXNcIjtcclxuaW1wb3J0IExheWVyIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9TY2VuZS9MYXllclwiO1xyXG5pbXBvcnQgU2NlbmUgZnJvbSBcIi4uLy4uL1dvbGZpZTJEL1NjZW5lL1NjZW5lXCI7XHJcbmltcG9ydCBDb2xvciBmcm9tIFwiLi4vLi4vV29sZmllMkQvVXRpbHMvQ29sb3JcIjtcclxuaW1wb3J0IExhYmVsIGZyb20gXCIuLi8uLi9Xb2xmaWUyRC9Ob2Rlcy9VSUVsZW1lbnRzL0xhYmVsXCI7XHJcbmltcG9ydCBNYWluTWVudSBmcm9tIFwiLi9NYWluTWVudVwiO1xyXG5pbXBvcnQgeyBUd2VlbmFibGVQcm9wZXJ0aWVzIH0gZnJvbSBcIi4uLy4uL1dvbGZpZTJEL05vZGVzL0dhbWVOb2RlXCI7XHJcbmltcG9ydCB7IEVhc2VGdW5jdGlvblR5cGUgfSBmcm9tIFwiLi4vLi4vV29sZmllMkQvVXRpbHMvRWFzZUZ1bmN0aW9uc1wiO1xyXG5pbXBvcnQgSW5wdXQgZnJvbSBcIi4uLy4uL1dvbGZpZTJEL0lucHV0L0lucHV0XCI7XHJcbmltcG9ydCBTcHJpdGUgZnJvbSBcIi4uLy4uL1dvbGZpZTJEL05vZGVzL1Nwcml0ZXMvU3ByaXRlXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTcGxhc2hTY3JlZW4gZXh0ZW5kcyBTY2VuZSB7XHJcbiAgICBwcml2YXRlIHNwbGFzaDogTGF5ZXI7XHJcbiAgICBwcml2YXRlIGxvZ286IFNwcml0ZTtcclxuXHJcbiAgICBsb2FkU2NlbmUoKXtcclxuICAgICAgICB0aGlzLmxvYWQuaW1hZ2UoXCJsb2dvXCIsIFwiZ2FtZV9hc3NldHMvc3ByaXRlcy9sb2dvLnBuZ1wiKTtcclxuICAgIH1cclxuXHJcbiAgICBzdGFydFNjZW5lKCl7XHJcbiAgICAgICAgY29uc3QgY2VudGVyID0gdGhpcy52aWV3cG9ydC5nZXRDZW50ZXIoKTtcclxuXHJcbiAgICAgICAgdGhpcy5zcGxhc2ggPSB0aGlzLmFkZFVJTGF5ZXIoXCJzcGxhc2hcIik7XHJcblxyXG4gICAgICAgIC8qIEdhbWUgbG9nbyAqL1xyXG4gICAgICAgIHRoaXMubG9nbyA9IHRoaXMuYWRkLnNwcml0ZShcImxvZ29cIiwgXCJzcGxhc2hcIik7XHJcbiAgICAgICAgdGhpcy5sb2dvLnNjYWxlLnNldCgyLCAyKTtcclxuICAgICAgICB0aGlzLmxvZ28uYWxwaGEgPSAwO1xyXG5cdFx0dGhpcy5sb2dvLnBvc2l0aW9uID0gbmV3IFZlYzIoY2VudGVyLngsIGNlbnRlci55IC0gMTAwKTtcclxuICAgICAgICB0aGlzLmxvZ28udHdlZW5zLmFkZChcImZhZGVJblwiLCB7XHJcbiAgICAgICAgICAgIHN0YXJ0RGVsYXk6IDEwMDAsXHJcbiAgICAgICAgICAgIGR1cmF0aW9uOiAxMDAwLFxyXG4gICAgICAgICAgICBlZmZlY3RzOiBbXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydHk6IFR3ZWVuYWJsZVByb3BlcnRpZXMuYWxwaGEsXHJcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgZW5kOiAxLFxyXG4gICAgICAgICAgICAgICAgICAgIGVhc2U6IEVhc2VGdW5jdGlvblR5cGUuT1VUX1NJTkVcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvKiBDbGljayBhbnl3aGVyZSB0ZXh0ICovXHJcbiAgICAgICAgY29uc3QgY2xpY2tUZXh0ID0gXCJDbGljayBBbnl3aGVyZSBUbyBDb250aW51ZVwiO1xyXG4gICAgICAgIGNvbnN0IGNsaWNrTGFiZWwgPSA8TGFiZWw+dGhpcy5hZGQudWlFbGVtZW50KFVJRWxlbWVudFR5cGUuTEFCRUwsIFwic3BsYXNoXCIsIHtwb3NpdGlvbjogbmV3IFZlYzIoY2VudGVyLngsIGNlbnRlci55ICsgMjUwKSwgdGV4dDogY2xpY2tUZXh0fSk7XHJcbiAgICAgICAgY2xpY2tMYWJlbC50ZXh0Q29sb3IgPSBuZXcgQ29sb3IoMCwgMCwgMCwgMCk7XHJcbiAgICAgICAgY2xpY2tMYWJlbC5mb250U2l6ZSA9IDUwO1xyXG4gICAgICAgIGNsaWNrTGFiZWwudHdlZW5zLmFkZChcImZhZGVJblwiLCB7XHJcbiAgICAgICAgICAgIHN0YXJ0RGVsYXk6IDIwMDAsXHJcbiAgICAgICAgICAgIGR1cmF0aW9uOiAxMDAwLFxyXG4gICAgICAgICAgICBlZmZlY3RzOiBbXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydHk6IFwidGV4dEFscGhhXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgZW5kOiAxLFxyXG4gICAgICAgICAgICAgICAgICAgIGVhc2U6IEVhc2VGdW5jdGlvblR5cGUuT1VUX1NJTkVcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB0aGlzLmxvZ28udHdlZW5zLnBsYXkoXCJmYWRlSW5cIik7XHJcbiAgICAgICAgY2xpY2tMYWJlbC50d2VlbnMucGxheShcImZhZGVJblwiKTtcclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGVTY2VuZSgpe1xyXG4gICAgICAgIGlmIChJbnB1dC5pc01vdXNlSnVzdFByZXNzZWQoKSkge1xyXG4gICAgICAgICAgICB0aGlzLnNjZW5lTWFuYWdlci5jaGFuZ2VUb1NjZW5lKE1haW5NZW51LCB7fSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59IiwiaW1wb3J0IEdhbWUgZnJvbSBcIi4vV29sZmllMkQvTG9vcC9HYW1lXCI7XHJcbmltcG9ydCBTcGxhc2hTY3JlZW4gZnJvbSBcIi4vZ2FtZS9TY2VuZXMvU3BsYXNoU2NyZWVuXCI7XHJcblxyXG4vLyBUaGUgbWFpbiBmdW5jdGlvbiBpcyB5b3VyIGVudHJ5cG9pbnQgaW50byBXb2xmaWUyRC4gU3BlY2lmeSB5b3VyIGZpcnN0IHNjZW5lIGFuZCBhbnkgb3B0aW9ucyBoZXJlLlxyXG4oZnVuY3Rpb24gbWFpbigpe1xyXG4gICAgLy8gUnVuIGFueSB0ZXN0c1xyXG4gICAgcnVuVGVzdHMoKTtcclxuXHJcbiAgICAvLyBTZXQgdXAgb3B0aW9ucyBmb3Igb3VyIGdhbWVcclxuICAgIGxldCBvcHRpb25zID0ge1xyXG4gICAgICAgIGNhbnZhc1NpemU6IHt4OiA4MDAsIHk6IDgwMH0sICAgICAgICAgIC8vIFRoZSBzaXplIG9mIHRoZSBnYW1lXHJcbiAgICAgICAgY2xlYXJDb2xvcjoge3I6IDIxNCwgZzogMTc5LCBiOiAxNzl9LCAgIC8vIFRoZSBjb2xvciB0aGUgZ2FtZSBjbGVhcnMgdG9cclxuICAgICAgICBpbnB1dHM6IFtcclxuICAgICAgICAgICAge25hbWU6IFwidXBcIiwga2V5czogW1wid1wiXX0sXHJcbiAgICAgICAgICAgIHtuYW1lOiBcImRvd25cIiwga2V5czogW1wic1wiXX0sXHJcbiAgICAgICAgICAgIHtuYW1lOiBcImxlZnRcIiwga2V5czogW1wiYVwiXX0sXHJcbiAgICAgICAgICAgIHtuYW1lOiBcInJpZ2h0XCIsIGtleXM6IFtcImRcIl19LFxyXG4gICAgICAgICAgICB7bmFtZTogXCJpbnRlcmFjdFwiLCBrZXlzOiBbXCJqXCJdfSxcclxuICAgICAgICAgICAge25hbWU6IFwicGxhY2VcIiwga2V5czogW1wia1wiXX0sXHJcbiAgICAgICAgICAgIHtuYW1lOiBcImVsMVwiLCBrZXlzOiBbXCIxXCJdfSxcclxuICAgICAgICAgICAge25hbWU6IFwiZWwyXCIsIGtleXM6IFtcIjJcIl19LFxyXG4gICAgICAgICAgICB7bmFtZTogXCJlbDNcIiwga2V5czogW1wiM1wiXX0sXHJcbiAgICAgICAgICAgIHtuYW1lOiBcImVsNFwiLCBrZXlzOiBbXCI0XCJdfSxcclxuICAgICAgICAgICAge25hbWU6IFwiZWw1XCIsIGtleXM6IFtcIjVcIl19LFxyXG4gICAgICAgICAgICB7bmFtZTogXCJlc2NcIiwga2V5czogW1wiZXNjYXBlXCJdfVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgdXNlV2ViR0w6IGZhbHNlLCAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRlbGwgdGhlIGdhbWUgd2Ugd2FudCB0byB1c2Ugd2ViZ2xcclxuICAgICAgICBzaG93RGVidWc6IGZhbHNlXHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ3JlYXRlIGEgZ2FtZSB3aXRoIHRoZSBvcHRpb25zIHNwZWNpZmllZFxyXG4gICAgY29uc3QgZ2FtZSA9IG5ldyBHYW1lKG9wdGlvbnMpO1xyXG5cclxuICAgIC8vIFN0YXJ0IG91ciBnYW1lXHJcbiAgICBnYW1lLnN0YXJ0KFNwbGFzaFNjcmVlbiwge30pO1xyXG59KSgpO1xyXG5cclxuZnVuY3Rpb24gcnVuVGVzdHMoKXt9OyJdfQ==
